
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>MDAnalysis.core.topologyattrs &#8212; MDAnalysis 0.20.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.20.1 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.core.topologyattrs</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1"># doi: 10.25080/majora-629e541a-00e</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">Topology attribute objects --- :mod:`MDAnalysis.core.topologyattrs`</span>
<span class="sd">===================================================================</span>

<span class="sd">Common :class:`TopologyAttr` instances that are used by most topology</span>
<span class="sd">parsers.</span>

<span class="sd">TopologyAttrs are used to contain attributes such as atom names or resids.</span>
<span class="sd">These are usually read by the TopologyParser.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">zip</span><span class="p">,</span> <span class="nb">range</span>

<span class="kn">import</span> <span class="nn">Bio.Seq</span>
<span class="kn">import</span> <span class="nn">Bio.SeqRecord</span>
<span class="kn">import</span> <span class="nn">Bio.Alphabet</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">numpy.lib.utils</span> <span class="kn">import</span> <span class="n">deprecate</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">flags</span>
<span class="kn">from</span> <span class="nn">..lib.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">cached</span><span class="p">,</span> <span class="n">convert_aa_code</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">warn_if_not_unique</span><span class="p">,</span>
                        <span class="n">unique_int_1d</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">transformations</span><span class="p">,</span> <span class="n">mdamath</span>
<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="kn">import</span> <span class="n">NoDataError</span><span class="p">,</span> <span class="n">SelectionError</span>
<span class="kn">from</span> <span class="nn">.topologyobjects</span> <span class="kn">import</span> <span class="n">TopologyGroup</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">selection</span>
<span class="kn">from</span> <span class="nn">.groups</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ComponentBase</span><span class="p">,</span> <span class="n">GroupBase</span><span class="p">,</span>
                     <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">,</span>
                     <span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span>
                     <span class="n">check_pbc_and_unwrap</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">_TOPOLOGY_ATTRS</span>


<span class="k">def</span> <span class="nf">_check_length</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper which checks the length of inputs to set_X</span>

<span class="sd">    Eg:</span>

<span class="sd">    @_check_length</span>
<span class="sd">    def set_X(self, group, values):</span>

<span class="sd">    Will check the length of *values* compared to *group* before proceeding with</span>
<span class="sd">    anything in the *set_X* method.</span>

<span class="sd">    Pseudo code for the check:</span>

<span class="sd">    if group in (Atom, Residue, Segment):</span>
<span class="sd">        values must be single values, ie int, float or string</span>
<span class="sd">    else:</span>
<span class="sd">        values must be single value OR same length as group</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_SINGLE_VALUE_ERROR</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Setting </span><span class="si">{cls}</span><span class="s2"> </span><span class="si">{attrname}</span><span class="s2"> with wrong sized input. &quot;</span>
                           <span class="s2">&quot;Must use single value, length of supplied values: </span><span class="si">{lenvalues}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="c1"># Eg &quot;Setting Residue resid with wrong sized input. Must use single value, length of supplied</span>
    <span class="c1"># values: 2.&quot;</span>

    <span class="n">_GROUP_VALUE_ERROR</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Setting </span><span class="si">{group}</span><span class="s2"> </span><span class="si">{attrname}</span><span class="s2"> with wrong sized array. &quot;</span>
                          <span class="s2">&quot;Length </span><span class="si">{group}</span><span class="s2">: </span><span class="si">{lengroup}</span><span class="s2">, length of supplied values: </span><span class="si">{lenvalues}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="c1"># Eg &quot;Setting AtomGroup masses with wrong sized array. Length AtomGroup: 100, length of</span>
    <span class="c1"># supplied values: 50.&quot;</span>

    <span class="k">def</span> <span class="nf">_attr_len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="c1"># quasi len measurement</span>
        <span class="c1"># strings, floats, ints are len 0, ie not iterable</span>
        <span class="c1"># other iterables are just len&#39;d</span>
        <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>  <span class="c1"># special case</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">val_len</span> <span class="o">=</span> <span class="n">_attr_len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">ComponentBase</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">val_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_SINGLE_VALUE_ERROR</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">cls</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attrname</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">singular</span><span class="p">,</span>
                    <span class="n">lenvalues</span><span class="o">=</span><span class="n">val_len</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">val_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">val_len</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_GROUP_VALUE_ERROR</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attrname</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">attrname</span><span class="p">,</span>
                    <span class="n">lengroup</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="n">lenvalues</span><span class="o">=</span><span class="n">val_len</span><span class="p">))</span>
        <span class="c1"># if everything went OK, continue with the function</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_wronglevel_error</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate an error for setting attr at wrong level</span>

<span class="sd">    attr : TopologyAttr that was accessed</span>
<span class="sd">    group : Offending Component/Group</span>

<span class="sd">    Eg:</span>
<span class="sd">    setting mass of residue, gets called with attr=Masses, group=residue</span>

<span class="sd">    raises a NotImplementedError with:</span>
<span class="sd">    &#39;Cannot set masses from Residue.  Use &#39;Residue.atoms.masses&#39;</span>

<span class="sd">    Mainly used to ensure consistent and helpful error messages</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
        <span class="n">group_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Residue</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">)):</span>
        <span class="n">group_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)):</span>
        <span class="n">group_level</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="c1"># What level to go to before trying to set this attr</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">AtomAttr</span><span class="p">):</span>
        <span class="n">corr_classes</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;atoms&#39;</span><span class="p">,</span> <span class="s1">&#39;atom&#39;</span><span class="p">)</span>
        <span class="n">attr_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">ResidueAttr</span><span class="p">):</span>
        <span class="n">corr_classes</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;residues&#39;</span><span class="p">,</span> <span class="s1">&#39;residue&#39;</span><span class="p">)</span>
        <span class="n">attr_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">SegmentAttr</span><span class="p">):</span>
        <span class="n">corr_classes</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;segments&#39;</span><span class="p">,</span> <span class="s1">&#39;segment&#39;</span><span class="p">)</span>
        <span class="n">attr_level</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">ComponentBase</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">attr_level</span> <span class="o">&gt;</span> <span class="n">group_level</span><span class="p">):</span>
        <span class="c1"># ie going downards use plurals, going upwards use singulars</span>
        <span class="c1"># Residue.atom!s!.mass!es! but Atom.segment!!.segid!!</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="n">corr_classes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">attrname</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">singular</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="n">corr_classes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">attrname</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">attrname</span>

    <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot set </span><span class="si">{attr}</span><span class="s2"> from </span><span class="si">{cls}</span><span class="s2">. Use &#39;</span><span class="si">{cls}</span><span class="s2">.</span><span class="si">{correct}</span><span class="s2">.</span><span class="si">{attr}</span><span class="s2"> = &#39;&quot;</span>
    <span class="c1"># eg &quot;Cannot set masses from Residue.  &#39;Use Residue.atoms.masses = &#39;&quot;</span>

    <span class="k">return</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">attr</span><span class="o">=</span><span class="n">attrname</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">correct</span><span class="o">=</span><span class="n">correct</span><span class="p">,</span>
    <span class="p">))</span>


<span class="k">class</span> <span class="nc">_TopologyAttrMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="c1"># register TopologyAttrs</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">classdict</span><span class="p">):</span>
        <span class="nb">type</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">classdict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;attrname&#39;</span><span class="p">,</span> <span class="s1">&#39;singular&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">attrname</span> <span class="o">=</span> <span class="n">classdict</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_TOPOLOGY_ATTRS</span><span class="p">[</span><span class="n">attrname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>


<div class="viewcode-block" id="TopologyAttr"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr">[docs]</a><span class="k">class</span> <span class="nc">TopologyAttr</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">_TopologyAttrMeta</span><span class="p">,</span> <span class="nb">object</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Base class for Topology attributes.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This class is intended to be subclassed, and mostly amounts to</span>
<span class="sd">    a skeleton. The methods here should be present in all</span>
<span class="sd">    :class:`TopologyAttr` child classes, but by default they raise</span>
<span class="sd">    appropriate exceptions.</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    attrname : str</span>
<span class="sd">        the name used for the attribute when attached to a ``Topology`` object</span>
<span class="sd">    singular : str</span>
<span class="sd">        name for the attribute on a singular object (Atom/Residue/Segment)</span>
<span class="sd">    per_object : str</span>
<span class="sd">        If there is a strict mapping between Component and Attribute</span>
<span class="sd">    dtype : int/float/object</span>
<span class="sd">        Type to coerce this attribute to be.  For string use &#39;object&#39;</span>
<span class="sd">    top : Topology</span>
<span class="sd">        handle for the Topology object TopologyAttr is associated with</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;topologyattrs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;topologyattr&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># ie Resids per_object = &#39;residue&#39;</span>
    <span class="n">top</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># pointer to Topology object</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">groupdoc</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">singledoc</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">guessed</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">n_residues</span><span class="p">,</span> <span class="n">n_segments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Populate an initial empty data structure for this Attribute</span>

<span class="sd">        The only provided parameters are the &quot;shape&quot; of the Universe</span>

<span class="sd">        Eg for charges, provide np.zeros(n_atoms)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;No default values&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyAttr.from_blank"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.from_blank">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_blank</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_residues</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a blank version of this TopologyAttribute</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_atoms : int, optional</span>
<span class="sd">          Size of the TopologyAttribute atoms</span>
<span class="sd">        n_residues: int, optional</span>
<span class="sd">          Size of the TopologyAttribute residues</span>
<span class="sd">        n_segments : int, optional</span>
<span class="sd">          Size of the TopologyAttribute segments</span>
<span class="sd">        values : optional</span>
<span class="sd">          Initial values for the TopologyAttribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_gen_initial_values</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">n_residues</span><span class="p">,</span> <span class="n">n_segments</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">cls</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if supplied starting values and statically typed</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopologyAttr.copy"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deepcopy of this attribute&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">guessed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Length of the TopologyAttr at its intrinsic level.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Accepts an AtomGroup, ResidueGroup or SegmentGroup&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Residue</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_residues</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segments</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_atoms</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Residue</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_residues</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_guessed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bool of if the source of this information is a guess&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span>

<div class="viewcode-block" id="TopologyAttr.get_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.get_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get atom attributes for a given AtomGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">NoDataError</span></div>

<div class="viewcode-block" id="TopologyAttr.set_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.set_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set atom attributes for a given AtomGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="TopologyAttr.get_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.get_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get residue attributes for a given ResidueGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">NoDataError</span></div>

<div class="viewcode-block" id="TopologyAttr.set_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.set_residues">[docs]</a>    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set residue attributes for a given ResidueGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="TopologyAttr.get_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get segment attributes for a given SegmentGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">NoDataError</span></div>

<div class="viewcode-block" id="TopologyAttr.set_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.set_segments">[docs]</a>    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set segmentattributes for a given SegmentGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div></div>


<span class="c1"># core attributes</span>

<div class="viewcode-block" id="Atomindices"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomindices">[docs]</a><span class="k">class</span> <span class="nc">Atomindices</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Globally unique indices for each atom in the group.</span>

<span class="sd">    If the group is an AtomGroup, then this gives the index for each atom in</span>
<span class="sd">    the group. This is the unambiguous identifier for each atom in the</span>
<span class="sd">    topology, and it is not alterable.</span>

<span class="sd">    If the group is a ResidueGroup or SegmentGroup, then this gives the indices</span>
<span class="sd">    of each atom represented in the group in a 1-D array, in the order of the</span>
<span class="sd">    elements in that group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;indices&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;index&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Atomindices.set_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomindices.set_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Atom indices are fixed; they cannot be reset&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atomindices.get_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomindices.get_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ag</span><span class="o">.</span><span class="n">ix</span></div>

<div class="viewcode-block" id="Atomindices.get_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomindices.get_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_2d</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">))</span></div>

<div class="viewcode-block" id="Atomindices.get_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomindices.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="Resindices"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resindices">[docs]</a><span class="k">class</span> <span class="nc">Resindices</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Globally unique resindices for each residue in the group.</span>

<span class="sd">    If the group is an AtomGroup, then this gives the resindex for each atom in</span>
<span class="sd">    the group. This unambiguously determines each atom&#39;s residue membership.</span>
<span class="sd">    Resetting these values changes the residue membership of the atoms.</span>

<span class="sd">    If the group is a ResidueGroup or SegmentGroup, then this gives the</span>
<span class="sd">    resindices of each residue represented in the group in a 1-D array, in the</span>
<span class="sd">    order of the elements in that group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;resindices&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;resindex&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Resindices.get_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resindices.get_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">atoms2residues</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span></div>

<div class="viewcode-block" id="Resindices.get_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resindices.get_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">rg</span><span class="o">.</span><span class="n">ix</span></div>

<div class="viewcode-block" id="Resindices.set_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resindices.set_residues">[docs]</a>    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Residue indices are fixed; they cannot be reset&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Resindices.get_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resindices.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2residues_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="Segindices"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segindices">[docs]</a><span class="k">class</span> <span class="nc">Segindices</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Globally unique segindices for each segment in the group.</span>

<span class="sd">    If the group is an AtomGroup, then this gives the segindex for each atom in</span>
<span class="sd">    the group. This unambiguously determines each atom&#39;s segment membership.</span>
<span class="sd">    It is not possible to set these, since membership in a segment is an</span>
<span class="sd">    attribute of each atom&#39;s residue.</span>

<span class="sd">    If the group is a ResidueGroup or SegmentGroup, then this gives the</span>
<span class="sd">    segindices of each segment represented in the group in a 1-D array, in the</span>
<span class="sd">    order of the elements in that group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;segindices&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;segindex&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span>
                      <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Segindices.get_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segindices.get_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">atoms2segments</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span></div>

<div class="viewcode-block" id="Segindices.get_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segindices.get_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2segments</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span></div>

<div class="viewcode-block" id="Segindices.get_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segindices.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sg</span><span class="o">.</span><span class="n">ix</span></div>

<div class="viewcode-block" id="Segindices.set_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segindices.set_segments">[docs]</a>    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Segment indices are fixed; they cannot be reset&quot;</span><span class="p">)</span></div></div>


<span class="c1"># atom attributes</span>

<div class="viewcode-block" id="AtomAttr"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr">[docs]</a><span class="k">class</span> <span class="nc">AtomAttr</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for atom attributes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;atomattrs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;atomattr&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">]</span>

<div class="viewcode-block" id="AtomAttr.get_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.get_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span></div>

<div class="viewcode-block" id="AtomAttr.set_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.set_atoms">[docs]</a>    <span class="nd">@_check_length</span>
    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span></div>

<div class="viewcode-block" id="AtomAttr.get_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.get_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;By default, the values for each atom present in the set of residues</span>
<span class="sd">        are returned in a single array. This behavior can be overriden in child</span>
<span class="sd">        attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aixs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_2d</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">aix</span><span class="p">]</span> <span class="k">for</span> <span class="n">aix</span> <span class="ow">in</span> <span class="n">aixs</span><span class="p">]</span></div>

<div class="viewcode-block" id="AtomAttr.set_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.set_residues">[docs]</a>    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">)</span></div>

<div class="viewcode-block" id="AtomAttr.get_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;By default, the values for each atom present in the set of residues</span>
<span class="sd">        are returned in a single array. This behavior can be overriden in child</span>
<span class="sd">        attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aixs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">aix</span><span class="p">]</span> <span class="k">for</span> <span class="n">aix</span> <span class="ow">in</span> <span class="n">aixs</span><span class="p">]</span></div>

<div class="viewcode-block" id="AtomAttr.set_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.set_segments">[docs]</a>    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">)</span></div></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Atomids"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomids">[docs]</a><span class="k">class</span> <span class="nc">Atomids</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;ID for each atom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;ids&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;id&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">na</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Atomnames"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames">[docs]</a><span class="k">class</span> <span class="nc">Atomnames</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Name for each atom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;names&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;name&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getattr__</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">_get_named_atom</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{0}</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">{1}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">atomgroup</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_named_atom</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all atoms with name *name* in the current AtomGroup.</span>

<span class="sd">        For more than one atom it returns a list of :class:`Atom`</span>
<span class="sd">        instance. A single :class:`Atom` is returned just as such. If</span>
<span class="sd">        no atoms are found, a :exc:`SelectionError` is raised.</span>

<span class="sd">        .. versionadded:: 0.9.2</span>

<span class="sd">        .. deprecated:: 0.16.2</span>
<span class="sd">           *Instant selectors* will be removed in the 1.0 release.</span>
<span class="sd">           Use ``AtomGroup.select_atoms(&#39;name &lt;name&gt;&#39;)`` instead.</span>
<span class="sd">           See issue `#1377</span>
<span class="sd">           &lt;https://github.com/MDAnalysis/mdanalysis/issues/1377&gt;`_ for</span>
<span class="sd">           more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># There can be more than one atom with the same name</span>
        <span class="n">atomlist</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">unique</span><span class="p">[</span><span class="n">group</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">unique</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">(</span>
                <span class="s2">&quot;No atoms with name &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># XXX: keep this, makes more sense for names</span>
            <span class="n">atomlist</span> <span class="o">=</span> <span class="n">atomlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Instant selector AtomGroup[&#39;&lt;name&gt;&#39;] or AtomGroup.&lt;name&gt; &quot;</span>
                      <span class="s2">&quot;is deprecated and will be removed in 1.0. &quot;</span>
                      <span class="s2">&quot;Use AtomGroup.select_atoms(&#39;name &lt;name&gt;&#39;) instead.&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">atomlist</span>

    <span class="c1"># AtomGroup already has a getattr</span>
<span class="c1">#    transplants[AtomGroup].append(</span>
<span class="c1">#        (&#39;__getattr__&#39;, getattr__))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;__getattr__&#39;</span><span class="p">,</span> <span class="n">getattr__</span><span class="p">))</span>

    <span class="c1"># this is also getitem for a residue</span>
    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;__getitem__&#39;</span><span class="p">,</span> <span class="n">getattr__</span><span class="p">))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">AtomGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;_get_named_atom&#39;</span><span class="p">,</span> <span class="n">_get_named_atom</span><span class="p">))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;_get_named_atom&#39;</span><span class="p">,</span> <span class="n">_get_named_atom</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.phi_selection"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.phi_selection">[docs]</a>    <span class="k">def</span> <span class="nf">phi_selection</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the phi protein backbone dihedral</span>
<span class="sd">        C&#39;-N-CA-C.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomGroup</span>
<span class="sd">            4-atom selection in the correct order. If no C&#39; found in the</span>
<span class="sd">            previous residue (by resid) then this method returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: maybe this can be reformulated into one selection string without</span>
        <span class="c1"># the additions later</span>
        <span class="n">sel_str</span> <span class="o">=</span> <span class="s2">&quot;segid </span><span class="si">{}</span><span class="s2"> and resid </span><span class="si">{}</span><span class="s2"> and name C&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">residue</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span> <span class="n">residue</span><span class="o">.</span><span class="n">resid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel_str</span><span class="p">)</span> <span class="o">+</span>
               <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;name N&#39;</span><span class="p">,</span> <span class="s1">&#39;name CA&#39;</span><span class="p">,</span> <span class="s1">&#39;name C&#39;</span><span class="p">))</span>

        <span class="c1"># select_atoms doesnt raise errors if nothing found, so check size</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;phi_selection&#39;</span><span class="p">,</span> <span class="n">phi_selection</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.psi_selection"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.psi_selection">[docs]</a>    <span class="k">def</span> <span class="nf">psi_selection</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the psi protein backbone dihedral</span>
<span class="sd">        N-CA-C-N&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomGroup</span>
<span class="sd">            4-atom selection in the correct order. If no N&#39; found in the</span>
<span class="sd">            following residue (by resid) then this method returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sel_str</span> <span class="o">=</span> <span class="s2">&quot;segid </span><span class="si">{}</span><span class="s2"> and resid </span><span class="si">{}</span><span class="s2"> and name N&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">residue</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span> <span class="n">residue</span><span class="o">.</span><span class="n">resid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">sel</span> <span class="o">=</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;name N&#39;</span><span class="p">,</span> <span class="s1">&#39;name CA&#39;</span><span class="p">,</span> <span class="s1">&#39;name C&#39;</span><span class="p">)</span> <span class="o">+</span>
               <span class="n">residue</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel_str</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;psi_selection&#39;</span><span class="p">,</span> <span class="n">psi_selection</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.omega_selection"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.omega_selection">[docs]</a>    <span class="k">def</span> <span class="nf">omega_selection</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the omega protein backbone dihedral</span>
<span class="sd">        CA-C-N&#39;-CA&#39;.</span>

<span class="sd">        omega describes the -C-N- peptide bond. Typically, it is trans (180</span>
<span class="sd">        degrees) although cis-bonds (0 degrees) are also occasionally observed</span>
<span class="sd">        (especially near Proline).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomGroup</span>
<span class="sd">            4-atom selection in the correct order. If no C&#39; found in the</span>
<span class="sd">            previous residue (by resid) then this method returns ``None``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nextres</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">resid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">segid</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">segid</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;name CA&#39;</span><span class="p">,</span> <span class="s1">&#39;name C&#39;</span><span class="p">)</span> <span class="o">+</span>
               <span class="n">residue</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                   <span class="s1">&#39;segid </span><span class="si">{}</span><span class="s1"> and resid </span><span class="si">{}</span><span class="s1"> and name N&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">segid</span><span class="p">,</span> <span class="n">nextres</span><span class="p">),</span>
                   <span class="s1">&#39;segid </span><span class="si">{}</span><span class="s1"> and resid </span><span class="si">{}</span><span class="s1"> and name CA&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">segid</span><span class="p">,</span> <span class="n">nextres</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;omega_selection&#39;</span><span class="p">,</span> <span class="n">omega_selection</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.chi1_selection"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.chi1_selection">[docs]</a>    <span class="k">def</span> <span class="nf">chi1_selection</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the chi1 sidechain dihedral N-CA-CB-CG.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomGroup</span>
<span class="sd">            4-atom selection in the correct order. If no CB and/or CG is found</span>
<span class="sd">            then this method returns ``None``.</span>

<span class="sd">        .. versionadded:: 0.7.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ag</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;name N&#39;</span><span class="p">,</span> <span class="s1">&#39;name CA&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;name CB&#39;</span><span class="p">,</span> <span class="s1">&#39;name CG&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;chi1_selection&#39;</span><span class="p">,</span> <span class="n">chi1_selection</span><span class="p">))</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Atomtypes"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomtypes">[docs]</a><span class="k">class</span> <span class="nc">Atomtypes</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Type for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;types&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;type&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Elements"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Elements">[docs]</a><span class="k">class</span> <span class="nc">Elements</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Element for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;elements&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;element&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Radii"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Radii">[docs]</a><span class="k">class</span> <span class="nc">Radii</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Radii for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;radii&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;radius&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>


<div class="viewcode-block" id="RecordTypes"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.RecordTypes">[docs]</a><span class="k">class</span> <span class="nc">RecordTypes</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;For PDB-like formats, indicates if ATOM or HETATM</span>

<span class="sd">    Defaults to &#39;ATOM&#39;</span>

<span class="sd">    .. versionchanged:: 0.20.0</span>
<span class="sd">       Now stores array of dtype object rather than boolean mapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;record_types&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;record_type&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ATOM&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChainIDs"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ChainIDs">[docs]</a><span class="k">class</span> <span class="nc">ChainIDs</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;ChainID per atom</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This is an attribute of the Atom, not Residue or Segment</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;chainIDs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;chainID&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tempfactors"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Tempfactors">[docs]</a><span class="k">class</span> <span class="nc">Tempfactors</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tempfactor for atoms&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;tempfactors&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;tempfactor&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>


<div class="viewcode-block" id="Masses"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses">[docs]</a><span class="k">class</span> <span class="nc">Masses</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;masses&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;mass&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span>
                      <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="n">groupdoc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Mass of each component in the Group.</span>

<span class="s2">    If the Group is an AtomGroup, then the masses are for each atom. If the</span>
<span class="s2">    Group is a ResidueGroup or SegmentGroup, the masses are for each residue or</span>
<span class="s2">    segment, respectively. These are obtained by summation of the member atoms</span>
<span class="s2">    for each component.</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="n">singledoc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Mass of the component.&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span>

<div class="viewcode-block" id="Masses.get_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.get_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="n">resatoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_2d</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># for a single residue</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">resatoms</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for a residuegroup</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rg</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">resatoms</span><span class="p">):</span>
                <span class="n">masses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">masses</span></div>

<div class="viewcode-block" id="Masses.get_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="n">segatoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># for a single segment</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">segatoms</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for a segmentgroup</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">segatoms</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">masses</span></div>

<div class="viewcode-block" id="Masses.center_of_mass"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.center_of_mass">[docs]</a>    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@check_pbc_and_unwrap</span>
    <span class="k">def</span> <span class="nf">center_of_mass</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Center of mass of (compounds of) the group.</span>

<span class="sd">        Computes the center of mass of :class:`Atoms&lt;Atom&gt;` in the group.</span>
<span class="sd">        Centers of mass per :class:`Residue`, :class:`Segment`, molecule, or</span>
<span class="sd">        fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly. If the masses of a compound sum up to zero, the</span>
<span class="sd">        center of mass coordinates of that compound will be ``nan`` (not a</span>
<span class="sd">        number).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True`` and `compound` is ``&#39;group&#39;``, move all atoms to the</span>
<span class="sd">            primary unit cell before calculation.</span>
<span class="sd">            If ``True`` and `compound` is ``&#39;segments&#39;`` or ``&#39;residues&#39;``, the</span>
<span class="sd">            centers of mass of each compound will be calculated without moving</span>
<span class="sd">            any atoms to keep the compounds intact. Instead, the resulting</span>
<span class="sd">            center-of-mass position vectors will be moved to the primary unit</span>
<span class="sd">            cell after calculation.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;},\</span>
<span class="sd">                   optional</span>
<span class="sd">            If ``&#39;group&#39;``, the center of mass of all atoms in the group will</span>
<span class="sd">            be returned as a single position vector. Otherwise, the centers of</span>
<span class="sd">            mass of each :class:`Segment`, :class:`Residue`, molecule, or</span>
<span class="sd">            fragment will be returned as an array of position vectors, i.e. a 2d</span>
<span class="sd">            array.</span>
<span class="sd">            Note that, in any case, *only* the positions of :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">            *belonging to the group* will be taken into account.</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their centers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        center : numpy.ndarray</span>
<span class="sd">            Position vector(s) of the center(s) of mass of the group.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            position vector.</span>
<span class="sd">            If `compound` was set to ``&#39;segments&#39;`` or ``&#39;residues&#39;``, the</span>
<span class="sd">            output will be a 2d coordinate array of shape ``(n, 3)`` where ``n``</span>
<span class="sd">            is the number of compounds.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        * This method can only be accessed if the underlying topology has</span>
<span class="sd">          information about atomic masses.</span>
<span class="sd">        * The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">          ``True`` allows the *pbc* flag to be used by default.</span>


<span class="sd">        .. versionchanged:: 0.8 Added `pbc` parameter</span>
<span class="sd">        .. versionchanged:: 0.19.0 Added `compound` parameter</span>
<span class="sd">        .. versionchanged:: 0.20.0 Added ``&#39;molecules&#39;`` and ``&#39;fragments&#39;``</span>
<span class="sd">            compounds</span>
<span class="sd">        .. versionchanged:: 0.20.0 Added `unwrap` parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">return</span> <span class="n">atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">masses</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">)</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;center_of_mass&#39;</span><span class="p">,</span> <span class="n">center_of_mass</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.total_mass"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.total_mass">[docs]</a>    <span class="nd">@warn_if_not_unique</span>
    <span class="k">def</span> <span class="nf">total_mass</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total mass of (compounds of) the group.</span>

<span class="sd">        Computes the total mass of :class:`Atoms&lt;Atom&gt;` in the group.</span>
<span class="sd">        Total masses per :class:`Residue`, :class:`Segment`, molecule, or</span>
<span class="sd">        fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;},\</span>
<span class="sd">                   optional</span>
<span class="sd">            If ``&#39;group&#39;``, the total mass of all atoms in the group will be</span>
<span class="sd">            returned as a single value. Otherwise, the total masses per</span>
<span class="sd">            :class:`Segment`, :class:`Residue`, molecule, or fragment will be</span>
<span class="sd">            returned as a 1d array.</span>
<span class="sd">            Note that, in any case, *only* the masses of :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">            *belonging to the group* will be taken into account.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or numpy.ndarray</span>
<span class="sd">            Total mass of (compounds of) the group.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            value. Otherwise, the output will be a 1d array of shape ``(n,)``</span>
<span class="sd">            where ``n`` is the number of compounds.</span>


<span class="sd">        .. versionchanged:: 0.20.0 Added `compound` parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="s2">&quot;masses&quot;</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;total_mass&#39;</span><span class="p">,</span> <span class="n">total_mass</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.moment_of_inertia"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.moment_of_inertia">[docs]</a>    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@check_pbc_and_unwrap</span>
    <span class="k">def</span> <span class="nf">moment_of_inertia</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tensor moment of inertia relative to center of mass as 3x3 numpy</span>
<span class="sd">        array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">        ``True`` allows the *pbc* flag to be used by default.</span>


<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        .. versionchanged:: 0.20.0 Added `unwrap` parameter</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="n">unwrap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;unwrap&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">compound</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;compound&#39;</span><span class="p">,</span> <span class="s1">&#39;group&#39;</span><span class="p">)</span>

        <span class="n">com</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
            <span class="n">com</span> <span class="o">=</span> <span class="p">(</span><span class="n">com</span> <span class="o">*</span> <span class="n">group</span><span class="o">.</span><span class="n">masses</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">group</span><span class="o">.</span><span class="n">masses</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span>
        <span class="k">elif</span> <span class="n">unwrap</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">com</span>

        <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>
        <span class="c1"># Create the inertia tensor</span>
        <span class="c1"># m_i = mass of atom i</span>
        <span class="c1"># (x_i, y_i, z_i) = pos of atom i</span>
        <span class="c1"># Ixx = sum(m_i*(y_i^2+z_i^2));</span>
        <span class="c1"># Iyy = sum(m_i*(x_i^2+z_i^2));</span>
        <span class="c1"># Izz = sum(m_i*(x_i^2+y_i^2))</span>
        <span class="c1"># Ixy = Iyx = -1*sum(m_i*x_i*y_i)</span>
        <span class="c1"># Ixz = Izx = -1*sum(m_i*x_i*z_i)</span>
        <span class="c1"># Iyz = Izy = -1*sum(m_i*y_i*z_i)</span>
        <span class="n">tens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># xx</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># xy &amp; yx</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># xz &amp; zx</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># yy</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># yz + zy</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># zz</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">tens</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;moment_of_inertia&#39;</span><span class="p">,</span> <span class="n">moment_of_inertia</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.radius_of_gyration"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.radius_of_gyration">[docs]</a>    <span class="nd">@warn_if_not_unique</span>
    <span class="k">def</span> <span class="nf">radius_of_gyration</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Radius of gyration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">        ``True`` allows the *pbc* flag to be used by default.</span>


<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>

        <span class="n">com</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">com</span>

        <span class="n">rog_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">recenteredpos</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">total_mass</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rog_sq</span><span class="p">)</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;radius_of_gyration&#39;</span><span class="p">,</span> <span class="n">radius_of_gyration</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.shape_parameter"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.shape_parameter">[docs]</a>    <span class="nd">@warn_if_not_unique</span>
    <span class="k">def</span> <span class="nf">shape_parameter</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shape parameter.</span>

<span class="sd">        See [Dima2004a]_ for background information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">        ``True`` allows the *pbc* flag to be used by default.</span>


<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [Dima2004a] Dima, R. I., &amp; Thirumalai, D. (2004). Asymmetry</span>
<span class="sd">           in the shapes of folded and denatured states of</span>
<span class="sd">           proteins. *J Phys Chem B*, 108(21),</span>
<span class="sd">           6564-6570. doi:`10.1021/jp037128y</span>
<span class="sd">           &lt;https://doi.org/10.1021/jp037128y&gt;`_</span>


<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>

        <span class="n">com</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">com</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">recenteredpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">tensor</span> <span class="o">+=</span> <span class="n">masses</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">:],</span>
                                           <span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">tensor</span> <span class="o">/=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">total_mass</span><span class="p">()</span>
        <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="mf">27.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">eig_vals</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">shape</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;shape_parameter&#39;</span><span class="p">,</span> <span class="n">shape_parameter</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.asphericity"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.asphericity">[docs]</a>    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@check_pbc_and_unwrap</span>
    <span class="k">def</span> <span class="nf">asphericity</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Asphericity.</span>

<span class="sd">        See [Dima2004b]_ for background information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. If ``None`` use value defined in</span>
<span class="sd">            MDAnalysis.core.flags[&#39;use_pbc&#39;]</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their centers.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;}, optional</span>
<span class="sd">            Which type of component to keep together during unwrapping.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">        ``True`` allows the *pbc* flag to be used by default.</span>


<span class="sd">        References</span>
<span class="sd">        ----------</span>

<span class="sd">        .. [Dima2004b] Dima, R. I., &amp; Thirumalai, D. (2004). Asymmetry</span>
<span class="sd">           in the shapes of folded and denatured states of</span>
<span class="sd">           proteins. *J Phys Chem B*, 108(21),</span>
<span class="sd">           6564-6570. doi:`10.1021/jp037128y</span>
<span class="sd">           &lt;https://doi.org/10.1021/jp037128y&gt;`_</span>



<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        .. versionchanged:: 0.20.0 Added *unwrap* and *compound* parameter</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">if</span> <span class="n">pbc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pbc</span> <span class="o">=</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">]</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>

        <span class="n">com</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
            <span class="n">com</span> <span class="o">=</span> <span class="p">(</span><span class="n">com</span> <span class="o">*</span> <span class="n">group</span><span class="o">.</span><span class="n">masses</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">group</span><span class="o">.</span><span class="n">masses</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">unwrap</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">com</span><span class="p">)</span>

        <span class="n">tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">recenteredpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">tensor</span> <span class="o">+=</span> <span class="n">masses</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                           <span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

        <span class="n">tensor</span> <span class="o">/=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">total_mass</span><span class="p">()</span>
        <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">eig_vals</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">shape</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;asphericity&#39;</span><span class="p">,</span> <span class="n">asphericity</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.principal_axes"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.principal_axes">[docs]</a>    <span class="nd">@warn_if_not_unique</span>
    <span class="k">def</span> <span class="nf">principal_axes</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the principal axes from the moment of inertia.</span>

<span class="sd">        e1,e2,e3 = AtomGroup.principal_axes()</span>

<span class="sd">        The eigenvectors are sorted by eigenvalue, i.e. the first one</span>
<span class="sd">        corresponds to the highest eigenvalue and is thus the first principal</span>
<span class="sd">        axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. If ``None`` use value defined in setup flags.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        axis_vectors : array</span>
<span class="sd">            3 x 3 array with ``v[0]`` as first, ``v[1]`` as second, and</span>
<span class="sd">            ``v[2]`` as third eigenvector.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">        ``True`` allows the *pbc* flag to be used by default.</span>


<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">if</span> <span class="n">pbc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pbc</span> <span class="o">=</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">]</span>
        <span class="n">e_val</span><span class="p">,</span> <span class="n">e_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">moment_of_inertia</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">))</span>

        <span class="c1"># Sort</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">e_val</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Return transposed in more logical form. See Issue 33.</span>
        <span class="k">return</span> <span class="n">e_vec</span><span class="p">[:,</span> <span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">T</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;principal_axes&#39;</span><span class="p">,</span> <span class="n">principal_axes</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.align_principal_axis"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.align_principal_axis">[docs]</a>    <span class="k">def</span> <span class="nf">align_principal_axis</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Align principal axis with index `axis` with `vector`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0, 1, 2}</span>
<span class="sd">            Index of the principal axis (0, 1, or 2), as produced by</span>
<span class="sd">            :meth:`~principal_axes`.</span>
<span class="sd">        vector : array_like</span>
<span class="sd">            Vector to align principal axis with.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To align the long axis of a channel (the first principal axis, i.e.</span>
<span class="sd">        *axis* = 0) with the z-axis::</span>

<span class="sd">          u.atoms.align_principal_axis(0, [0,0,1])</span>
<span class="sd">          u.atoms.write(&quot;aligned.pdb&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">principal_axes</span><span class="p">()[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">mdamath</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">vector</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">transformations</span><span class="o">.</span><span class="n">rotaxis</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
        <span class="c1"># print &quot;principal[%d] = %r&quot; % (axis, p)</span>
        <span class="c1"># print &quot;axis = %r, angle = %f deg&quot; % (ax, angle)</span>
        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">rotateby</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;align_principal_axis&#39;</span><span class="p">,</span> <span class="n">align_principal_axis</span><span class="p">))</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Charges"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges">[docs]</a><span class="k">class</span> <span class="nc">Charges</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;charges&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;charge&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span>
                      <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span>

<div class="viewcode-block" id="Charges.get_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges.get_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="n">resatoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_2d</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">resatoms</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rg</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">resatoms</span><span class="p">):</span>
                <span class="n">charges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">charges</span></div>

<div class="viewcode-block" id="Charges.get_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="n">segatoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># for a single segment</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">segatoms</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for a segmentgroup</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">segatoms</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">charges</span></div>

<div class="viewcode-block" id="Charges.total_charge"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges.total_charge">[docs]</a>    <span class="nd">@warn_if_not_unique</span>
    <span class="k">def</span> <span class="nf">total_charge</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total charge of (compounds of) the group.</span>

<span class="sd">        Computes the total charge of :class:`Atoms&lt;Atom&gt;` in the group.</span>
<span class="sd">        Total charges per :class:`Residue`, :class:`Segment`, molecule, or</span>
<span class="sd">        fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;},\</span>
<span class="sd">                   optional</span>
<span class="sd">            If &#39;group&#39;, the total charge of all atoms in the group will</span>
<span class="sd">            be returned as a single value. Otherwise, the total charges per</span>
<span class="sd">            :class:`Segment`, :class:`Residue`, molecule, or fragment</span>
<span class="sd">            will be returned as a 1d array.</span>
<span class="sd">            Note that, in any case, *only* the charges of :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">            *belonging to the group* will be taken into account.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or numpy.ndarray</span>
<span class="sd">            Total charge of (compounds of) the group.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            value. Otherwise, the output will be a 1d array of shape ``(n,)``</span>
<span class="sd">            where ``n`` is the number of compounds.</span>


<span class="sd">        .. versionchanged:: 0.20.0 Added `compound` parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="s2">&quot;charges&quot;</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;total_charge&#39;</span><span class="p">,</span> <span class="n">total_charge</span><span class="p">))</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Bfactors"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bfactors">[docs]</a><span class="k">class</span> <span class="nc">Bfactors</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Crystallographic B-factors in A**2 for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;bfactors&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;bfactor&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Occupancies"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Occupancies">[docs]</a><span class="k">class</span> <span class="nc">Occupancies</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;occupancies&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;occupancy&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="AltLocs"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AltLocs">[docs]</a><span class="k">class</span> <span class="nc">AltLocs</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;AltLocs for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;altLocs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;altLoc&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>


<div class="viewcode-block" id="ResidueAttr"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr">[docs]</a><span class="k">class</span> <span class="nc">ResidueAttr</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;residueattrs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;residueattr&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;residue&#39;</span>

<div class="viewcode-block" id="ResidueAttr.get_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.get_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="n">rix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">atoms2residues</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">rix</span><span class="p">]</span></div>

<div class="viewcode-block" id="ResidueAttr.set_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.set_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span></div>

<div class="viewcode-block" id="ResidueAttr.get_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.get_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span></div>

<div class="viewcode-block" id="ResidueAttr.set_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.set_residues">[docs]</a>    <span class="nd">@_check_length</span>
    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span></div>

<div class="viewcode-block" id="ResidueAttr.get_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;By default, the values for each residue present in the set of</span>
<span class="sd">        segments are returned in a single array. This behavior can be overriden</span>
<span class="sd">        in child attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rixs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2residues_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">rix</span><span class="p">]</span> <span class="k">for</span> <span class="n">rix</span> <span class="ow">in</span> <span class="n">rixs</span><span class="p">]</span></div>

<div class="viewcode-block" id="ResidueAttr.set_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.set_segments">[docs]</a>    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">)</span></div></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Resids"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resids">[docs]</a><span class="k">class</span> <span class="nc">Resids</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Residue ID&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;resids&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;resid&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Resnames"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resnames">[docs]</a><span class="k">class</span> <span class="nc">Resnames</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;resnames&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;resname&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getattr__</span><span class="p">(</span><span class="n">residuegroup</span><span class="p">,</span> <span class="n">resname</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">residuegroup</span><span class="o">.</span><span class="n">_get_named_residue</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{0}</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">{1}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">residuegroup</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">resname</span><span class="p">))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;__getattr__&#39;</span><span class="p">,</span> <span class="n">getattr__</span><span class="p">))</span>
    <span class="c1"># This transplant is hardcoded for now to allow for multiple getattr things</span>
    <span class="c1">#transplants[Segment].append((&#39;__getattr__&#39;, getattr__))</span>

    <span class="k">def</span> <span class="nf">_get_named_residue</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">resname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all residues with name *resname* in the current ResidueGroup</span>
<span class="sd">        or Segment.</span>

<span class="sd">        For more than one residue it returns a</span>
<span class="sd">        :class:`MDAnalysis.core.groups.ResidueGroup` instance. A single</span>
<span class="sd">        :class:`MDAnalysis.core.group.Residue` is returned for a single match.</span>
<span class="sd">        If no residues are found, a :exc:`SelectionError` is raised.</span>

<span class="sd">        .. versionadded:: 0.9.2</span>

<span class="sd">        .. deprecated:: 0.16.2</span>
<span class="sd">           *Instant selectors* will be removed in the 1.0 release.</span>
<span class="sd">           Use ``ResidueGroup[ResidueGroup.resnames == &#39;&lt;name&gt;&#39;]``</span>
<span class="sd">           or ``Segment.residues[Segment.residues == &#39;&lt;name&gt;&#39;]``</span>
<span class="sd">           instead.</span>
<span class="sd">           See issue `#1377</span>
<span class="sd">           &lt;https://github.com/MDAnalysis/mdanalysis/issues/1377&gt;`_ for</span>
<span class="sd">           more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># There can be more than one residue with the same name</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">unique</span><span class="p">[</span>
                <span class="n">group</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">unique</span><span class="o">.</span><span class="n">resnames</span> <span class="o">==</span> <span class="n">resname</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">(</span>
                <span class="s2">&quot;No residues with resname &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">resname</span><span class="p">))</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Instant selector ResidueGroup.&lt;name&gt; &quot;</span>
                      <span class="s2">&quot;or Segment.&lt;name&gt; &quot;</span>
                      <span class="s2">&quot;is deprecated and will be removed in 1.0. &quot;</span>
                      <span class="s2">&quot;Use ResidueGroup[ResidueGroup.resnames == &#39;&lt;name&gt;&#39;] &quot;</span>
                      <span class="s2">&quot;or Segment.residues[Segment.residues == &#39;&lt;name&gt;&#39;] &quot;</span>
                      <span class="s2">&quot;instead.&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># XXX: keep this, makes more sense for names</span>
            <span class="k">return</span> <span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># XXX: but inconsistent (see residues and Issue 47)</span>
            <span class="k">return</span> <span class="n">residues</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;_get_named_residue&#39;</span><span class="p">,</span> <span class="n">_get_named_residue</span><span class="p">))</span>

<div class="viewcode-block" id="Resnames.sequence"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resnames.sequence">[docs]</a>    <span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the amino acid sequence.</span>

<span class="sd">        The format of the sequence is selected with the keyword *format*:</span>

<span class="sd">        ============== ============================================</span>
<span class="sd">        *format*       description</span>
<span class="sd">        ============== ============================================</span>
<span class="sd">        &#39;SeqRecord&#39;    :class:`Bio.SeqRecord.SeqRecord` (default)</span>
<span class="sd">        &#39;Seq&#39;          :class:`Bio.Seq.Seq`</span>
<span class="sd">        &#39;string&#39;       string</span>
<span class="sd">        ============== ============================================</span>

<span class="sd">        The sequence is returned by default (keyword ``format = &#39;SeqRecord&#39;``)</span>
<span class="sd">        as a :class:`Bio.SeqRecord.SeqRecord` instance, which can then be</span>
<span class="sd">        further processed. In this case, all keyword arguments (such as the</span>
<span class="sd">        *id* string or the *name* or the *description*) are directly passed to</span>
<span class="sd">        :class:`Bio.SeqRecord.SeqRecord`.</span>

<span class="sd">        If the keyword *format* is set to ``&#39;Seq&#39;``, all *kwargs* are ignored</span>
<span class="sd">        and a :class:`Bio.Seq.Seq` instance is returned. The difference to the</span>
<span class="sd">        record is that the record also contains metadata and can be directly</span>
<span class="sd">        used as an input for other functions in :mod:`Bio`.</span>

<span class="sd">        If the keyword *format* is set to ``&#39;string&#39;``, all *kwargs* are</span>
<span class="sd">        ignored and a Python string is returned.</span>

<span class="sd">        .. rubric:: Example: Write FASTA file</span>

<span class="sd">        Use :func:`Bio.SeqIO.write`, which takes sequence records::</span>

<span class="sd">           import Bio.SeqIO</span>

<span class="sd">           # get the sequence record of a protein component of a Universe</span>
<span class="sd">           protein = u.select_atoms(&quot;protein&quot;)</span>
<span class="sd">           record = protein.sequence(id=&quot;myseq1&quot;, name=&quot;myprotein&quot;)</span>

<span class="sd">           Bio.SeqIO.write(record, &quot;single.fasta&quot;, &quot;fasta&quot;)</span>

<span class="sd">        A FASTA file with multiple entries can be written with ::</span>

<span class="sd">           Bio.SeqIO.write([record1, record2, ...], &quot;multi.fasta&quot;, &quot;fasta&quot;)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        format : string, optional</span>
<span class="sd">           - ``&quot;string&quot;``: return sequence as a string of 1-letter codes</span>
<span class="sd">           - ``&quot;Seq&quot;``: return a :class:`Bio.Seq.Seq` instance</span>
<span class="sd">           - ``&quot;SeqRecord&quot;``: return a :class:`Bio.SeqRecord.SeqRecord`</span>
<span class="sd">             instance</span>

<span class="sd">            Default is ``&quot;SeqRecord&quot;``</span>
<span class="sd">        id : optional</span>
<span class="sd">           Sequence ID for SeqRecord (should be different for different</span>
<span class="sd">           sequences)</span>
<span class="sd">        name : optional</span>
<span class="sd">           Name of the protein.</span>
<span class="sd">        description : optional</span>
<span class="sd">           Short description of the sequence.</span>
<span class="sd">        kwargs : optional</span>
<span class="sd">           Any other keyword arguments that are understood by</span>
<span class="sd">           class:`Bio.SeqRecord.SeqRecord`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        :exc:`ValueError` if a residue name cannot be converted to a</span>
<span class="sd">        1-letter IUPAC protein amino acid code; make sure to only</span>
<span class="sd">        select protein residues.</span>

<span class="sd">        :exc:`TypeError` if an unknown *format* is selected.</span>


<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">formats</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="s1">&#39;Seq&#39;</span><span class="p">,</span> <span class="s1">&#39;SeqRecord&#39;</span><span class="p">)</span>

        <span class="nb">format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;SeqRecord&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">formats</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown format=&#39;</span><span class="si">{0}</span><span class="s2">&#39;: must be one of: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">format</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formats</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">convert_aa_code</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">resnames</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;AtomGroup contains a residue name &#39;</span><span class="si">{0}</span><span class="s2">&#39; that &quot;</span>
                             <span class="s2">&quot;does not have a IUPAC protein 1-letter &quot;</span>
                             <span class="s2">&quot;character&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">message</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sequence</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">Seq</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="n">Bio</span><span class="o">.</span><span class="n">Alphabet</span><span class="o">.</span><span class="n">IUPAC</span><span class="o">.</span><span class="n">protein</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;Seq&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">seq</span>
        <span class="k">return</span> <span class="n">Bio</span><span class="o">.</span><span class="n">SeqRecord</span><span class="o">.</span><span class="n">SeqRecord</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;sequence&#39;</span><span class="p">,</span> <span class="n">sequence</span><span class="p">))</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Resnums"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resnums">[docs]</a><span class="k">class</span> <span class="nc">Resnums</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;resnums&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;resnum&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="ICodes"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ICodes">[docs]</a><span class="k">class</span> <span class="nc">ICodes</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Insertion code for Atoms&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;icodes&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;icode&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>


<div class="viewcode-block" id="Moltypes"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Moltypes">[docs]</a><span class="k">class</span> <span class="nc">Moltypes</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Name of the molecule type</span>

<span class="sd">    Two molecules that share a molecule type share a common template topology.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;moltypes&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;moltype&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span></div>


<div class="viewcode-block" id="Molnums"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Molnums">[docs]</a><span class="k">class</span> <span class="nc">Molnums</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Name of the molecule type</span>

<span class="sd">    Two molecules that share a molecule type share a common template topology.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;molnums&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;molnum&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span></div>

<span class="c1"># segment attributes</span>

<div class="viewcode-block" id="SegmentAttr"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr">[docs]</a><span class="k">class</span> <span class="nc">SegmentAttr</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for segment attributes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;segmentattrs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;segmentattr&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;segment&#39;</span>

<div class="viewcode-block" id="SegmentAttr.get_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr.get_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="n">six</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">atoms2segments</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">six</span><span class="p">]</span></div>

<div class="viewcode-block" id="SegmentAttr.set_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr.set_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span></div>

<div class="viewcode-block" id="SegmentAttr.get_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr.get_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="n">six</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2segments</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">six</span><span class="p">]</span></div>

<div class="viewcode-block" id="SegmentAttr.set_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr.set_residues">[docs]</a>    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">)</span></div>

<div class="viewcode-block" id="SegmentAttr.get_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span></div>

<div class="viewcode-block" id="SegmentAttr.set_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr.set_segments">[docs]</a>    <span class="nd">@_check_length</span>
    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span></div></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Segids"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segids">[docs]</a><span class="k">class</span> <span class="nc">Segids</span><span class="p">(</span><span class="n">SegmentAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;segids&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;segid&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span>
                      <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getattr__</span><span class="p">(</span><span class="n">segmentgroup</span><span class="p">,</span> <span class="n">segid</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">segmentgroup</span><span class="o">.</span><span class="n">_get_named_segment</span><span class="p">(</span><span class="n">segid</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{0}</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">{1}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">segmentgroup</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">segid</span><span class="p">))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">SegmentGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;__getattr__&#39;</span><span class="p">,</span> <span class="n">getattr__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_named_segment</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">segid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all segments with name *segid* in the current SegmentGroup.</span>

<span class="sd">        For more than one residue it returns a</span>
<span class="sd">        :class:`MDAnalysis.core.groups.SegmentGroup` instance. A single</span>
<span class="sd">        :class:`MDAnalysis.core.group.Segment` is returned for a single match.</span>
<span class="sd">        If no residues are found, a :exc:`SelectionError` is raised.</span>

<span class="sd">        .. versionadded:: 0.9.2</span>

<span class="sd">        .. deprecated:: 0.16.2</span>
<span class="sd">           *Instant selectors* will be removed in the 1.0 release.</span>
<span class="sd">           Use ``SegmentGroup[SegmentGroup.segids == &#39;&lt;name&gt;&#39;]`` instead.</span>
<span class="sd">           See issue `#1377</span>
<span class="sd">           &lt;https://github.com/MDAnalysis/mdanalysis/issues/1377&gt;`_ for</span>
<span class="sd">           more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Undo adding &#39;s&#39; if segid started with digit</span>
        <span class="k">if</span> <span class="n">segid</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">segid</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">segid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">segid</span> <span class="o">=</span> <span class="n">segid</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># There can be more than one segment with the same name</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">segments</span><span class="o">.</span><span class="n">unique</span><span class="p">[</span>
                <span class="n">group</span><span class="o">.</span><span class="n">segments</span><span class="o">.</span><span class="n">unique</span><span class="o">.</span><span class="n">segids</span> <span class="o">==</span> <span class="n">segid</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">(</span>
                <span class="s2">&quot;No segments with segid &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">segid</span><span class="p">))</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Instant selector SegmentGroup.&lt;name&gt; &quot;</span>
                      <span class="s2">&quot;is deprecated and will be removed in 1.0. &quot;</span>
                      <span class="s2">&quot;Use SegmentGroup[SegmentGroup.segids == &#39;&lt;name&gt;&#39;] &quot;</span>
                      <span class="s2">&quot;instead.&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># XXX: keep this, makes more sense for names</span>
            <span class="k">return</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># XXX: but inconsistent (see residues and Issue 47)</span>
            <span class="k">return</span> <span class="n">segments</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">SegmentGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;_get_named_segment&#39;</span><span class="p">,</span> <span class="n">_get_named_segment</span><span class="p">))</span></div>


<span class="k">class</span> <span class="nc">_Connection</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for connectivity between atoms&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">types</span>
        <span class="k">if</span> <span class="n">guessed</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># if single value passed, multiply this across</span>
            <span class="c1"># all bonds</span>
            <span class="n">guessed</span> <span class="o">=</span> <span class="p">[</span><span class="n">guessed</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">guessed</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deepcopy of this attribute&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                              <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">),</span>
                              <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">),</span>
                              <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondDict</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;bd&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_bondDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lazily built mapping of atoms:bonds&quot;&quot;&quot;</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">):</span>
            <span class="c1"># We always want the first index</span>
            <span class="c1"># to be less than the last</span>
            <span class="c1"># eg (0, 1) not (1, 0)</span>
            <span class="c1"># and (4, 10, 8) not (8, 10, 4)</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">bd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">bd</span>

    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot set bond information&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">unique_bonds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondDict</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># maybe we got passed an Atom</span>
            <span class="n">unique_bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondDict</span><span class="p">[</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span>
        <span class="n">bond_idx</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">guessed</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">unique_bonds</span><span class="p">)),</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">bond_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bond_idx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">types</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">guessed</span> <span class="o">=</span> <span class="n">guessed</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">bond_idx</span><span class="p">,</span> <span class="n">ag</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">singular</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">types</span><span class="p">,</span>
                             <span class="n">guessed</span><span class="p">,</span>
                             <span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="kc">None</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">guessed</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">guessed</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="n">guessed</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="kc">None</span><span class="p">,))</span>

        <span class="n">existing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">guessed</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="c1"># kill the old cache of bond Dict</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;bd&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>


<div class="viewcode-block" id="Bonds"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds">[docs]</a><span class="k">class</span> <span class="nc">Bonds</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bonds between two atoms</span>

<span class="sd">    Must be initialised by a list of zero based tuples.</span>
<span class="sd">    These indices refer to the atom indices.</span>
<span class="sd">    E.g., ` [(0, 1), (1, 2), (2, 3)]`</span>

<span class="sd">    Also adds the `bonded_atoms`, `fragment` and `fragments`</span>
<span class="sd">    attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;bonds&#39;</span>
    <span class="c1"># Singular is the same because one Atom might have</span>
    <span class="c1"># many bonds, so still asks for &quot;bonds&quot; in the plural</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;bonds&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<div class="viewcode-block" id="Bonds.bonded_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.bonded_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">bonded_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An :class:`~MDAnalysis.core.groups.AtomGroup` of all</span>
<span class="sd">        :class:`Atoms&lt;MDAnalysis.core.groups.Atom&gt;` bonded to this</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.Atom`.&quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;bonded_atoms&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">bonded_atoms</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">bonded_atoms</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

<div class="viewcode-block" id="Bonds.fragindex"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.fragindex">[docs]</a>    <span class="k">def</span> <span class="nf">fragindex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The index (ID) of the</span>
<span class="sd">        :class:`~MDAnalysis.core.topologyattrs.Bonds.fragment` this</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.Atom` is part of.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This property is only accessible if the underlying topology contains</span>
<span class="sd">        bond information.</span>


<span class="sd">        .. versionadded:: 0.20.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_fragdict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">ix</span></div>

<div class="viewcode-block" id="Bonds.fragindices"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.fragindices">[docs]</a>    <span class="k">def</span> <span class="nf">fragindices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The</span>
<span class="sd">        :class:`fragment indices&lt;MDAnalysis.core.topologyattrs.Bonds.fragindex&gt;`</span>
<span class="sd">        of all :class:`Atoms&lt;MDAnalysis.core.groups.Atom&gt;` in this</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.AtomGroup`.</span>

<span class="sd">        A :class:`numpy.ndarray` with</span>
<span class="sd">        :attr:`~numpy.ndarray.shape`\ ``=(``\ :attr:`~AtomGroup.n_atoms`\ ``,)``</span>
<span class="sd">        and :attr:`~numpy.ndarray.dtype`\ ``=numpy.int64``.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This property is only accessible if the underlying topology contains</span>
<span class="sd">        bond information.</span>


<span class="sd">        .. versionadded:: 0.20.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fragdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_fragdict</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fragdict</span><span class="p">[</span><span class="n">aix</span><span class="p">]</span><span class="o">.</span><span class="n">ix</span> <span class="k">for</span> <span class="n">aix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span></div>

<div class="viewcode-block" id="Bonds.fragment"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.fragment">[docs]</a>    <span class="k">def</span> <span class="nf">fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An :class:`~MDAnalysis.core.groups.AtomGroup` representing the</span>
<span class="sd">        fragment this :class:`~MDAnalysis.core.groups.Atom` is part of.</span>

<span class="sd">        A fragment is a</span>
<span class="sd">        :class:`group of atoms&lt;MDAnalysis.core.groups.AtomGroup&gt;` which are</span>
<span class="sd">        interconnected by :class:`~MDAnalysis.core.topologyattrs.Bonds`, i.e.,</span>
<span class="sd">        there exists a path along one</span>
<span class="sd">        or more :class:`~MDAnalysis.core.topologyattrs.Bonds` between any pair</span>
<span class="sd">        of :class:`Atoms&lt;MDAnalysis.core.groups.Atom&gt;`</span>
<span class="sd">        within a fragment. Thus, a fragment typically corresponds to a molecule.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This property is only accessible if the underlying topology contains</span>
<span class="sd">        bond information.</span>


<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_fragdict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">fragment</span></div>

<div class="viewcode-block" id="Bonds.fragments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.fragments">[docs]</a>    <span class="k">def</span> <span class="nf">fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read-only :class:`tuple` of</span>
<span class="sd">        :class:`fragments&lt;MDAnalysis.core.topologyattrs.Bonds.fragment&gt;`.</span>

<span class="sd">        Contains all fragments that</span>
<span class="sd">        any :class:`~MDAnalysis.core.groups.Atom` in this</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.AtomGroup` is part of.</span>

<span class="sd">        A fragment is a</span>
<span class="sd">        :class:`group of atoms&lt;MDAnalysis.core.groups.AtomGroup&gt;` which are</span>
<span class="sd">        interconnected by :class:`~MDAnalysis.core.topologyattrs.Bonds`, i.e.,</span>
<span class="sd">        there exists a path along one</span>
<span class="sd">        or more :class:`~MDAnalysis.core.topologyattrs.Bonds` between any pair</span>
<span class="sd">        of :class:`Atoms&lt;MDAnalysis.core.groups.Atom&gt;`</span>
<span class="sd">        within a fragment. Thus, a fragment typically corresponds to a molecule.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        * This property is only accessible if the underlying topology contains</span>
<span class="sd">          bond information.</span>
<span class="sd">        * The contents of the fragments may extend beyond the contents of this</span>
<span class="sd">          :class:`~MDAnalysis.core.groups.AtomGroup`.</span>


<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fragdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_fragdict</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">fragdict</span><span class="p">[</span><span class="n">aix</span><span class="p">]</span><span class="o">.</span><span class="n">fragment</span> <span class="k">for</span> <span class="n">aix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">),</span>
                            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ix</span><span class="p">))</span></div>

<div class="viewcode-block" id="Bonds.n_fragments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.n_fragments">[docs]</a>    <span class="k">def</span> <span class="nf">n_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of unique</span>
<span class="sd">        :class:`~MDAnalysis.core.topologyattrs.Bonds.fragments` the</span>
<span class="sd">        :class:`Atoms&lt;MDAnalysis.core.groups.Atom&gt;` of this</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.AtomGroup` are part of.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This property is only accessible if the underlying topology contains</span>
<span class="sd">        bond information.</span>


<span class="sd">        .. versionadded:: 0.20.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_int_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragindices</span><span class="p">))</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;fragment&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">fragment</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;fragindex&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">fragindex</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">fragindex</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">AtomGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;fragments&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">fragments</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">fragments</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">AtomGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;fragindices&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">fragindices</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">fragindices</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">AtomGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;n_fragments&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">n_fragments</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">n_fragments</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span></div>


<div class="viewcode-block" id="Angles"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Angles">[docs]</a><span class="k">class</span> <span class="nc">Angles</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Angles between three atoms</span>

<span class="sd">    Initialise with a list of 3 long tuples</span>
<span class="sd">    E.g.,  `[(0, 1, 2), (1, 2, 3), (2, 3, 4)]`</span>

<span class="sd">    These indices refer to the atom indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;angles&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;angles&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dihedrals"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Dihedrals">[docs]</a><span class="k">class</span> <span class="nc">Dihedrals</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A connection between four sequential atoms&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;dihedrals&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;dihedrals&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span></div>


<div class="viewcode-block" id="Impropers"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Impropers">[docs]</a><span class="k">class</span> <span class="nc">Impropers</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An imaginary dihedral between four atoms&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;impropers&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;impropers&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logos/mdanalysis-logo-200x150.png" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=MDAnalysis&repo=mdanalysis&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/trajectory_transformations.html">7. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections_modules.html">8. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/auxiliary_modules.html">9. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/core_modules.html">10. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/visualization_modules.html">11. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/lib_modules.html">12. Library functions — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/version.html">13. Version information for MDAnalysis - <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/units.html">14. Constants and unit conversion — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/exceptions.html">15. Custom exceptions and warnings — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/references.html">16. References</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2005-2017, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Shobhit Agarwal, Irfan Alibay, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Jonathan Barnoud, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Wouter Boomsma, Jose Borreguero, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, David Caplan, Matthieu Chavent, Kathleen Clark, Ruggero Cortini, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Ali Ehlen, Shujie Fan, Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Benjamin Hall, Eugen Hruska, Kyle J. Huston, Joe Jordan, Jon Kapla, Navya Khare, Andrew William King, Abhishek A. Kognole, Max Linke, Philip Loche, Jinju Lu, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Rocco Meli, Manuel Nuno Melo, Dominik 'Rathann' Mierzejewski, Henry Mull, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Danny Parton, Joshua L. Phillips, Kashish Punjani, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Carlos Yanez S., Utkarsh Saxena, Sean L. Seyler, Paul Smith, Andy Somogyi, Caio S. Souza, Shantanu Srivastava, Lukas Stelzl, Gorman Stock, Fenil Suchak, Ayush Suhane, Xiki Tempula, Matthew W. Thompson, Matteo Tiberti, Isaac Virshup, Lily Wang, Nestor Wendt, Zhiyi Wu, Zhuyi Xue, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, and Oliver Beckstein.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/MDAnalysis/mdanalysis" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>