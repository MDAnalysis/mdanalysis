


  
    
  




<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="shortcut icon" href="../../../_static/logo/mda_favicon.ico">
</head>

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MDAnalysis.lib.transformations &mdash; MDAnalysis 2.7.0-dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/site.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=542471e5"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/js/versions.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 2.7.0-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >




  




<a href="../../../index.html">
  
    <img src="../../../_static/logo/mda_logo.png" class="logo" alt="Logo"/>
</a>


  
  
  
    <div class="version">
      2.7.0-dev0
    </div>
  



<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>
<div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
    <!-- <p class="caption" role="heading"></p> -->
    <ul>
        
        <li class="toctree-l1"><a class="reference internal" href="http://mdanalysis.org">MDAnalysis</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="http://userguide.mdanalysis.org">User guide</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="https://mdakits.mdanalysis.org/">MDAKits</a></li>
        
    </ul>
    
        <p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/converters.html">7. Converter modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/trajectory_transformations.html">8. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections_modules.html">9. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/auxiliary_modules.html">10. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/core_modules.html">11. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/visualization_modules.html">12. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/lib_modules.html">13. Library functions — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/version.html">14. Version information for MDAnalysis - <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/units.html">15. Constants and unit conversion — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/exceptions.html">16. Custom exceptions and warnings — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/references.html">17. References</a></li>
</ul>

</div>

      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MDAnalysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">MDAnalysis.lib.transformations</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MDAnalysis.lib.transformations</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding: utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>

<span class="c1"># transformations.py</span>

<span class="c1"># Copyright (c) 2006, Christoph Gohlke</span>
<span class="c1"># Copyright (c) 2006-2010, The Regents of the University of California</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># * Redistributions of source code must retain the above copyright</span>
<span class="c1"># notice, this list of conditions and the following disclaimer.</span>
<span class="c1"># * Redistributions in binary form must reproduce the above copyright</span>
<span class="c1">#   notice, this list of conditions and the following disclaimer in the</span>
<span class="c1">#   documentation and/or other materials provided with the distribution.</span>
<span class="c1"># * Neither the name of the copyright holders nor the names of any</span>
<span class="c1">#   contributors may be used to endorse or promote products derived</span>
<span class="c1">#   from this software without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="c1"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c1"># POSSIBILITY OF SUCH DAMAGE.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Homogeneous Transformation Matrices and Quaternions --- :mod:`MDAnalysis.lib.transformations`</span>
<span class="sd">==============================================================================================</span>

<span class="sd">A library for calculating 4x4 matrices for translating, rotating, reflecting,</span>
<span class="sd">scaling, shearing, projecting, orthogonalizing, and superimposing arrays of</span>
<span class="sd">3D homogeneous coordinates as well as for converting between rotation matrices,</span>
<span class="sd">Euler angles, and quaternions. Also includes an Arcball control object and</span>
<span class="sd">functions to decompose transformation matrices.</span>

<span class="sd">:Authors:</span>
<span class="sd">  `Christoph Gohlke &lt;http://www.lfd.uci.edu/~gohlke/&gt;`__,</span>
<span class="sd">  Laboratory for Fluorescence Dynamics, University of California, Irvine</span>
<span class="sd">:Version: 2010.05.10</span>
<span class="sd">:Licence: BSD 3-clause</span>

<span class="sd">Requirements</span>
<span class="sd">------------</span>

<span class="sd">* `Python 2.6 or 3.1 &lt;http://www.python.org&gt;`__</span>
<span class="sd">* `Numpy 1.4 &lt;http://numpy.scipy.org&gt;`__</span>
<span class="sd">* `transformations.c 2010.04.10 &lt;http://www.lfd.uci.edu/~gohlke/&gt;`__</span>
<span class="sd">  (optional implementation of some functions in C)</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>

<span class="sd">The API is not stable yet and is expected to change between revisions.</span>

<span class="sd">This Python code is not optimized for speed. Refer to the transformations.c</span>
<span class="sd">module for a faster implementation of some functions.</span>

<span class="sd">Documentation in HTML format can be generated with epydoc.</span>

<span class="sd">Matrices (M) can be inverted using ``numpy.linalg.inv(M)``, concatenated using</span>
<span class="sd">``numpy.dot(M0, M1)``, or used to transform homogeneous coordinates (v) using</span>
<span class="sd">``numpy.dot(M, v)`` for shape ``(4, *)`` &quot;point of arrays&quot;, respectively</span>
<span class="sd">``numpy.dot(v, M.T)`` for shape ``(*, 4)`` &quot;array of points&quot;.</span>

<span class="sd">Use the transpose of transformation matrices for OpenGL ``glMultMatrixd()``.</span>

<span class="sd">Calculations are carried out with ``numpy.float64`` precision.</span>

<span class="sd">Vector, point, quaternion, and matrix function arguments are expected to be</span>
<span class="sd">&quot;array like&quot;, i.e. tuple, list, or numpy arrays.</span>

<span class="sd">Return types are numpy arrays unless specified otherwise.</span>

<span class="sd">Angles are in radians unless specified otherwise.</span>

<span class="sd">Quaternions w+ix+jy+kz are represented as ``[w, x, y, z]``.</span>

<span class="sd">A triple of Euler angles can be applied/interpreted in 24 ways, which can</span>
<span class="sd">be specified using a 4 character string or encoded 4-tuple:</span>

<span class="sd">  - *Axes 4-string*: e.g. &#39;sxyz&#39; or &#39;ryxy&#39;</span>

<span class="sd">    - first character : rotations are applied to &#39;s&#39;tatic or &#39;r&#39;otating frame</span>
<span class="sd">    - remaining characters : successive rotation axis &#39;x&#39;, &#39;y&#39;, or &#39;z&#39;</span>

<span class="sd">  - *Axes 4-tuple*: e.g. (0, 0, 0, 0) or (1, 1, 1, 1)</span>

<span class="sd">    - inner axis: code of axis (&#39;x&#39;:0, &#39;y&#39;:1, &#39;z&#39;:2) of rightmost matrix.</span>
<span class="sd">    - parity : even (0) if inner axis &#39;x&#39; is followed by &#39;y&#39;, &#39;y&#39; is followed</span>
<span class="sd">      by &#39;z&#39;, or &#39;z&#39; is followed by &#39;x&#39;. Otherwise odd (1).</span>
<span class="sd">    - repetition : first and last axis are same (1) or different (0).</span>
<span class="sd">    - frame : rotations are applied to static (0) or rotating (1) frame.</span>

<span class="sd">.. rubric:: References</span>

<span class="sd">.. footbibliography::</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>

<span class="sd">&gt;&gt;&gt; from MDAnalysis.lib.transformations import *</span>
<span class="sd">&gt;&gt;&gt; import numpy as np</span>
<span class="sd">&gt;&gt;&gt; alpha, beta, gamma = 0.123, -1.234, 2.345</span>
<span class="sd">&gt;&gt;&gt; origin, xaxis, yaxis, zaxis = (0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)</span>
<span class="sd">&gt;&gt;&gt; I = identity_matrix()</span>
<span class="sd">&gt;&gt;&gt; Rx = rotation_matrix(alpha, xaxis)</span>
<span class="sd">&gt;&gt;&gt; Ry = rotation_matrix(beta, yaxis)</span>
<span class="sd">&gt;&gt;&gt; Rz = rotation_matrix(gamma, zaxis)</span>
<span class="sd">&gt;&gt;&gt; R = concatenate_matrices(Rx, Ry, Rz)</span>
<span class="sd">&gt;&gt;&gt; euler = euler_from_matrix(R, &#39;rxyz&#39;)</span>
<span class="sd">&gt;&gt;&gt; np.allclose([alpha, beta, gamma], euler)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; Re = euler_matrix(alpha, beta, gamma, &#39;rxyz&#39;)</span>
<span class="sd">&gt;&gt;&gt; is_same_transform(R, Re)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; al, be, ga = euler_from_matrix(Re, &#39;rxyz&#39;)</span>
<span class="sd">&gt;&gt;&gt; is_same_transform(Re, euler_matrix(al, be, ga, &#39;rxyz&#39;))</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; qx = quaternion_about_axis(alpha, xaxis)</span>
<span class="sd">&gt;&gt;&gt; qy = quaternion_about_axis(beta, yaxis)</span>
<span class="sd">&gt;&gt;&gt; qz = quaternion_about_axis(gamma, zaxis)</span>
<span class="sd">&gt;&gt;&gt; q = quaternion_multiply(qx, qy)</span>
<span class="sd">&gt;&gt;&gt; q = quaternion_multiply(q, qz)</span>
<span class="sd">&gt;&gt;&gt; Rq = quaternion_matrix(q)</span>
<span class="sd">&gt;&gt;&gt; is_same_transform(R, Rq)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; S = scale_matrix(1.23, origin)</span>
<span class="sd">&gt;&gt;&gt; T = translation_matrix((1, 2, 3))</span>
<span class="sd">&gt;&gt;&gt; Z = shear_matrix(beta, xaxis, origin, zaxis)</span>
<span class="sd">&gt;&gt;&gt; R = random_rotation_matrix(np.random.rand(3))</span>
<span class="sd">&gt;&gt;&gt; M = concatenate_matrices(T, R, Z, S)</span>
<span class="sd">&gt;&gt;&gt; scale, shear, angles, trans, persp = decompose_matrix(M)</span>
<span class="sd">&gt;&gt;&gt; np.allclose(scale, 1.23)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; np.allclose(trans, (1, 2, 3))</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; np.allclose(shear, (0, math.tan(beta), 0))</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; is_same_transform(R, euler_matrix(axes=&#39;sxyz&#39;, *angles))</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; M1 = compose_matrix(scale, shear, angles, trans, persp)</span>
<span class="sd">&gt;&gt;&gt; is_same_transform(M, M1)</span>
<span class="sd">True</span>

<span class="sd">Functions</span>
<span class="sd">---------</span>

<span class="sd">.. See `help(MDAnalysis.lib.transformations)` for a listing of functions or</span>
<span class="sd">.. the online help.</span>


<span class="sd">.. versionchanged:: 0.11.0</span>
<span class="sd">   Transformations library moved from MDAnalysis.core.transformations to</span>
<span class="sd">   MDAnalysis.lib.transformations</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>

<span class="kn">from</span> <span class="nn">.mdamath</span> <span class="kn">import</span> <span class="n">angle</span> <span class="k">as</span> <span class="n">vecangle</span>

<span class="k">def</span> <span class="nf">identity_matrix</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return 4x4 identity/unit matrix.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import identity_matrix</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; I = identity_matrix()</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(I, np.dot(I, I))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.sum(I), np.trace(I)</span>
<span class="sd">    (4.0, 4.0)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(I, np.identity(4, dtype=np.float64))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">translation_matrix</span><span class="p">(</span><span class="n">direction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to translate by direction vector.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import translation_matrix</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; v = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v, translation_matrix(v)[:3, 3])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">direction</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">M</span>


<div class="viewcode-block" id="translation_from_matrix">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.translation_from_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">translation_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return translation vector from translation matrix.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (translation_matrix,</span>
<span class="sd">    ...     translation_from_matrix)</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; v0 = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; v1 = translation_from_matrix(translation_matrix(v0))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v0, v1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>



<span class="k">def</span> <span class="nf">reflection_matrix</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to mirror at plane defined by point and normal vector.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import reflection_matrix</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; v0 = np.random.random(4) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; v0[3] = 1.0</span>
<span class="sd">    &gt;&gt;&gt; v1 = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; R = reflection_matrix(v0, v1)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(2., np.trace(R))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v0, np.dot(R, v0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v2 = v0.copy()</span>
<span class="sd">    &gt;&gt;&gt; v2[:3] += v1</span>
<span class="sd">    &gt;&gt;&gt; v3 = v0.copy()</span>
<span class="sd">    &gt;&gt;&gt; v2[:3] -= v1</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v2, np.dot(R, v3))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">normal</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">normal</span><span class="p">))</span> <span class="o">*</span> <span class="n">normal</span>
    <span class="k">return</span> <span class="n">M</span>


<div class="viewcode-block" id="reflection_from_matrix">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.reflection_from_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">reflection_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return mirror plane point and normal vector from reflection matrix.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (reflection_matrix,</span>
<span class="sd">    ...     reflection_from_matrix, is_same_transform)</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; v0 = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; v1 = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; M0 = reflection_matrix(v0, v1)</span>
<span class="sd">    &gt;&gt;&gt; point, normal = reflection_from_matrix(M0)</span>
<span class="sd">    &gt;&gt;&gt; M1 = reflection_matrix(point, normal)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(M0, M1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># normal: unit eigenvector corresponding to eigenvalue -1</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no unit eigenvector corresponding to eigenvalue -1&quot;</span><span class="p">)</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="c1"># point: any unit eigenvector corresponding to eigenvalue 1</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no unit eigenvector corresponding to eigenvalue 1&quot;</span><span class="p">)</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">point</span> <span class="o">/=</span> <span class="n">point</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">point</span><span class="p">,</span> <span class="n">normal</span></div>



<span class="k">def</span> <span class="nf">rotation_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to rotate about axis defined by point and direction.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (rotation_matrix,</span>
<span class="sd">    ...     is_same_transform)</span>
<span class="sd">    &gt;&gt;&gt; import random, math</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; R = rotation_matrix(math.pi/2.0, [0, 0, 1], [1, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.dot(R, [0, 0, 0, 1]), [ 1., -1.,  0.,  1.])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; angle = (random.random() - 0.5) * (2*math.pi)</span>
<span class="sd">    &gt;&gt;&gt; direc = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; point = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; R0 = rotation_matrix(angle, direc, point)</span>
<span class="sd">    &gt;&gt;&gt; R1 = rotation_matrix(angle-2*math.pi, direc, point)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(R0, R1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R0 = rotation_matrix(angle, direc, point)</span>
<span class="sd">    &gt;&gt;&gt; R1 = rotation_matrix(-angle, -direc, point)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(R0, R1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; I = np.identity(4, np.float64)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(I, rotation_matrix(math.pi*2, direc))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(2., np.trace(rotation_matrix(math.pi/2,</span>
<span class="sd">    ...                                                direc, point)))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sina</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">cosa</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">direction</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="c1"># rotation matrix around unit vector</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">cosa</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cosa</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">cosa</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cosa</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">*=</span> <span class="n">sina</span>
    <span class="n">R</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">(</span><span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="p">(</span><span class="o">-</span><span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span>
    <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># rotation not around origin</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">M</span>


<div class="viewcode-block" id="rotation_from_matrix">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.rotation_from_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">rotation_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return rotation angle and axis from rotation matrix.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (rotation_matrix,</span>
<span class="sd">    ...     is_same_transform, rotation_from_matrix)</span>
<span class="sd">    &gt;&gt;&gt; import random, math</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; angle = (random.random() - 0.5) * (2*math.pi)</span>
<span class="sd">    &gt;&gt;&gt; direc = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; point = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; R0 = rotation_matrix(angle, direc, point)</span>
<span class="sd">    &gt;&gt;&gt; angle, direc, point = rotation_from_matrix(R0)</span>
<span class="sd">    &gt;&gt;&gt; R1 = rotation_matrix(angle, direc, point)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(R0, R1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">R33</span> <span class="o">=</span> <span class="n">R</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="c1"># direction: unit eigenvector of R33 corresponding to eigenvalue of 1</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">R33</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no unit eigenvector corresponding to eigenvalue 1&quot;</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">W</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="c1"># point: unit eigenvector of R33 corresponding to eigenvalue of 1</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no unit eigenvector corresponding to eigenvalue 1&quot;</span><span class="p">)</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Q</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">point</span> <span class="o">/=</span> <span class="n">point</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="c1"># rotation angle depending on direction</span>
    <span class="n">cosa</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">R33</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1e-8</span><span class="p">:</span>
        <span class="n">sina</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">cosa</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1e-8</span><span class="p">:</span>
        <span class="n">sina</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">cosa</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sina</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">cosa</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">sina</span><span class="p">,</span> <span class="n">cosa</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">angle</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">point</span></div>



<span class="k">def</span> <span class="nf">scale_matrix</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to scale by factor around origin in direction.</span>

<span class="sd">    Use factor -1 for point symmetry.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import scale_matrix</span>
<span class="sd">    &gt;&gt;&gt; import random</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; v = (np.random.rand(4, 5) - 0.5) * 20.0</span>
<span class="sd">    &gt;&gt;&gt; v[3] = 1.0</span>
<span class="sd">    &gt;&gt;&gt; S = scale_matrix(-1.234)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.dot(S, v)[:3], -1.234*v[:3])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; factor = random.random() * 10 - 5</span>
<span class="sd">    &gt;&gt;&gt; origin = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; direct = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; S = scale_matrix(factor, origin)</span>
<span class="sd">    &gt;&gt;&gt; S = scale_matrix(factor, origin, direct)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># uniform scaling</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">((</span><span class="n">factor</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">origin</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">factor</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># nonuniform scaling</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">direction</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">factor</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">origin</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="p">))</span> <span class="o">*</span> <span class="n">direction</span>
    <span class="k">return</span> <span class="n">M</span>


<div class="viewcode-block" id="scale_from_matrix">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.scale_from_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">scale_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return scaling factor, origin and direction from scaling matrix.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (scale_matrix,</span>
<span class="sd">    ...      scale_from_matrix, is_same_transform)</span>
<span class="sd">    &gt;&gt;&gt; import random</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; factor = random.random() * 10 - 5</span>
<span class="sd">    &gt;&gt;&gt; origin = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; direct = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; S0 = scale_matrix(factor, origin)</span>
<span class="sd">    &gt;&gt;&gt; factor, origin, direction = scale_from_matrix(S0)</span>
<span class="sd">    &gt;&gt;&gt; S1 = scale_matrix(factor, origin, direction)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(S0, S1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; S0 = scale_matrix(factor, origin, direct)</span>
<span class="sd">    &gt;&gt;&gt; factor, origin, direction = scale_from_matrix(S0)</span>
<span class="sd">    &gt;&gt;&gt; S1 = scale_matrix(factor, origin, direction)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(S0, S1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">M33</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">M33</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># direction: unit eigenvector corresponding to eigenvalue factor</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M33</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">factor</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">direction</span> <span class="o">/=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="c1"># uniform scaling</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># origin: any eigenvector corresponding to eigenvalue 1</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no eigenvector corresponding to eigenvalue 1&quot;</span><span class="p">)</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">origin</span> <span class="o">/=</span> <span class="n">origin</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">direction</span></div>



<span class="k">def</span> <span class="nf">projection_matrix</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">perspective</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pseudo</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to project onto plane defined by point and normal.</span>

<span class="sd">    Using either perspective point, projection direction, or none of both.</span>

<span class="sd">    If pseudo is True, perspective projections will preserve relative depth</span>
<span class="sd">    such that Perspective = dot(Orthogonal, PseudoPerspective).</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (projection_matrix,</span>
<span class="sd">    ...     is_same_transform)</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; P = projection_matrix((0, 0, 0), (1, 0, 0))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(P[1:, 1:], np.identity(4)[1:, 1:])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; point = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; normal = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; direct = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; persp = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; P0 = projection_matrix(point, normal)</span>
<span class="sd">    &gt;&gt;&gt; P1 = projection_matrix(point, normal, direction=direct)</span>
<span class="sd">    &gt;&gt;&gt; P2 = projection_matrix(point, normal, perspective=persp)</span>
<span class="sd">    &gt;&gt;&gt; P3 = projection_matrix(point, normal, perspective=persp, pseudo=True)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(P2, np.dot(P0, P3))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; P = projection_matrix((3, 0, 0), (1, 1, 0), (1, 0, 0))</span>
<span class="sd">    &gt;&gt;&gt; v0 = (np.random.rand(4, 5) - 0.5) * 20.0</span>
<span class="sd">    &gt;&gt;&gt; v0[3] = 1.0</span>
<span class="sd">    &gt;&gt;&gt; v1 = np.dot(P, v0)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v1[1], v0[1])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v1[0], 3.0-v1[1])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">normal</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">perspective</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># perspective projection</span>
        <span class="n">perspective</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">perspective</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                                  <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">perspective</span> <span class="o">-</span> <span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">perspective</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pseudo</span><span class="p">:</span>
            <span class="c1"># preserve relative depth</span>
            <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
            <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">perspective</span> <span class="o">+</span> <span class="n">normal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="n">perspective</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">normal</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">perspective</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># parallel projection</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">direction</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">direction</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># orthogonal projection</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="n">normal</span>
    <span class="k">return</span> <span class="n">M</span>


<div class="viewcode-block" id="projection_from_matrix">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.projection_from_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">projection_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">pseudo</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return projection plane and perspective point from projection matrix.</span>

<span class="sd">    Return values are same as arguments for projection_matrix function:</span>
<span class="sd">    point, normal, direction, perspective, and pseudo.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (projection_matrix,</span>
<span class="sd">    ...     projection_from_matrix, is_same_transform)</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; point = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; normal = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; direct = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; persp = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; P0 = projection_matrix(point, normal)</span>
<span class="sd">    &gt;&gt;&gt; result = projection_from_matrix(P0)</span>
<span class="sd">    &gt;&gt;&gt; P1 = projection_matrix(*result)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(P0, P1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; P0 = projection_matrix(point, normal, direct)</span>
<span class="sd">    &gt;&gt;&gt; result = projection_from_matrix(P0)</span>
<span class="sd">    &gt;&gt;&gt; P1 = projection_matrix(*result)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(P0, P1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; P0 = projection_matrix(point, normal, perspective=persp, pseudo=False)</span>
<span class="sd">    &gt;&gt;&gt; result = projection_from_matrix(P0, pseudo=False)</span>
<span class="sd">    &gt;&gt;&gt; P1 = projection_matrix(*result)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(P0, P1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; P0 = projection_matrix(point, normal, perspective=persp, pseudo=True)</span>
<span class="sd">    &gt;&gt;&gt; result = projection_from_matrix(P0, pseudo=True)</span>
<span class="sd">    &gt;&gt;&gt; P1 = projection_matrix(*result)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(P0, P1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">M33</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pseudo</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="c1"># point: any eigenvector corresponding to eigenvalue 1</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">point</span> <span class="o">/=</span> <span class="n">point</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1"># direction: unit eigenvector corresponding to eigenvalue 0</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M33</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no eigenvector corresponding to eigenvalue 0&quot;</span><span class="p">)</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">direction</span> <span class="o">/=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
        <span class="c1"># normal: unit eigenvector of M33.T corresponding to eigenvalue 0</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M33</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="c1"># parallel projection</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">normal</span> <span class="o">/=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># orthogonal projection, where normal equals direction vector</span>
            <span class="k">return</span> <span class="n">point</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># perspective projection</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;no eigenvector not corresponding to eigenvalue 0&quot;</span><span class="p">)</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">point</span> <span class="o">/=</span> <span class="n">point</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">perspective</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">normal</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pseudo</span><span class="p">:</span>
            <span class="n">perspective</span> <span class="o">-=</span> <span class="n">normal</span>
        <span class="k">return</span> <span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">perspective</span><span class="p">,</span> <span class="n">pseudo</span></div>



<span class="k">def</span> <span class="nf">clip_matrix</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">near</span><span class="p">,</span> <span class="n">far</span><span class="p">,</span> <span class="n">perspective</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to obtain normalized device coordinates from frustrum.</span>

<span class="sd">    The frustrum bounds are axis-aligned along x (left, right),</span>
<span class="sd">    y (bottom, top) and z (near, far).</span>

<span class="sd">    Normalized device coordinates are in range [-1, 1] if coordinates are</span>
<span class="sd">    inside the frustrum.</span>

<span class="sd">    If perspective is True the frustrum is a truncated pyramid with the</span>
<span class="sd">    perspective point at origin and direction along z axis, otherwise an</span>
<span class="sd">    orthographic canonical view volume (a box).</span>

<span class="sd">    Homogeneous coordinates transformed by the perspective clip matrix</span>
<span class="sd">    need to be dehomogenized (devided by w coordinate).</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import clip_matrix</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; frustrum = np.random.rand(6)</span>
<span class="sd">    &gt;&gt;&gt; frustrum[1] += frustrum[0]</span>
<span class="sd">    &gt;&gt;&gt; frustrum[3] += frustrum[2]</span>
<span class="sd">    &gt;&gt;&gt; frustrum[5] += frustrum[4]</span>
<span class="sd">    &gt;&gt;&gt; M = clip_matrix(perspective=False, *frustrum)</span>
<span class="sd">    &gt;&gt;&gt; np.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0])</span>
<span class="sd">    array([-1., -1., -1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; np.dot(M, [frustrum[1], frustrum[3], frustrum[5], 1.0])</span>
<span class="sd">    array([1., 1., 1., 1.])</span>
<span class="sd">    &gt;&gt;&gt; M = clip_matrix(perspective=True, *frustrum)</span>
<span class="sd">    &gt;&gt;&gt; v = np.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0])</span>
<span class="sd">    &gt;&gt;&gt; v / v[3]</span>
<span class="sd">    array([-1., -1., -1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; v = np.dot(M, [frustrum[1], frustrum[3], frustrum[4], 1.0])</span>
<span class="sd">    &gt;&gt;&gt; v / v[3]</span>
<span class="sd">    array([ 1.,  1., -1.,  1.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span> <span class="ow">or</span> <span class="n">bottom</span> <span class="o">&gt;=</span> <span class="n">top</span> <span class="ow">or</span> <span class="n">near</span> <span class="o">&gt;=</span> <span class="n">far</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid frustrum&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">perspective</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">near</span> <span class="o">&lt;=</span> <span class="n">_EPS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid frustrum: near &lt;= 0&quot;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">near</span>
        <span class="n">M</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">right</span> <span class="o">+</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span><span class="p">),</span> <span class="p">(</span><span class="n">top</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">far</span> <span class="o">+</span> <span class="n">near</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">far</span> <span class="o">-</span> <span class="n">near</span><span class="p">),</span> <span class="n">t</span> <span class="o">*</span> <span class="n">far</span> <span class="o">/</span> <span class="p">(</span><span class="n">far</span> <span class="o">-</span> <span class="n">near</span><span class="p">)),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">right</span> <span class="o">+</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">)),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">top</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">top</span><span class="p">)),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">far</span> <span class="o">-</span> <span class="n">near</span><span class="p">),</span> <span class="p">(</span><span class="n">far</span> <span class="o">+</span> <span class="n">near</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">near</span> <span class="o">-</span> <span class="n">far</span><span class="p">)),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">shear_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to shear by angle along direction vector on shear plane.</span>

<span class="sd">    The shear plane is defined by a point and normal vector. The direction</span>
<span class="sd">    vector must be orthogonal to the plane&#39;s normal vector.</span>

<span class="sd">    A point P is transformed by the shear matrix into P&quot; such that</span>
<span class="sd">    the vector P-P&quot; is parallel to the direction vector and its extent is</span>
<span class="sd">    given by the angle of P-P&#39;-P&quot;, where P&#39; is the orthogonal projection</span>
<span class="sd">    of P onto the shear plane.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import shear_matrix</span>
<span class="sd">    &gt;&gt;&gt; import random, math</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; angle = (random.random() - 0.5) * 4*math.pi</span>
<span class="sd">    &gt;&gt;&gt; direct = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; point = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; normal = np.cross(direct, np.random.random(3))</span>
<span class="sd">    &gt;&gt;&gt; S = shear_matrix(angle, direct, point, normal)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(1.0, np.linalg.det(S))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">normal</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">direction</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">direction</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;direction and normal vectors are not orthogonal&quot;</span><span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="n">direction</span>
    <span class="k">return</span> <span class="n">M</span>


<div class="viewcode-block" id="shear_from_matrix">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.shear_from_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">shear_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return shear angle, direction and plane from shear matrix.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (shear_matrix,</span>
<span class="sd">    ...     shear_from_matrix, is_same_transform)</span>
<span class="sd">    &gt;&gt;&gt; import random, math</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; angle = (random.random() - 0.5) * 4*math.pi</span>
<span class="sd">    &gt;&gt;&gt; direct = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; point = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; normal = np.cross(direct, np.random.random(3))</span>
<span class="sd">    &gt;&gt;&gt; S0 = shear_matrix(angle, direct, point, normal)</span>
<span class="sd">    &gt;&gt;&gt; angle, direct, point, normal = shear_from_matrix(S0)</span>
<span class="sd">    &gt;&gt;&gt; S1 = shear_matrix(angle, direct, point, normal)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(S0, S1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">M33</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="c1"># normal: cross independent eigenvectors corresponding to the eigenvalue 1</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M33</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-4</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no two linear independent eigenvectors found </span><span class="si">{0!s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
    <span class="n">lenorm</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">for</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i0</span><span class="p">],</span> <span class="n">V</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">lenorm</span><span class="p">:</span>
            <span class="n">lenorm</span> <span class="o">=</span> <span class="n">l</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">normal</span> <span class="o">/=</span> <span class="n">lenorm</span>
    <span class="c1"># direction and angle</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M33</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">normal</span><span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">/=</span> <span class="n">angle</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="c1"># point: eigenvector corresponding to eigenvalue 1</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no eigenvector corresponding to eigenvalue 1&quot;</span><span class="p">)</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">point</span> <span class="o">/=</span> <span class="n">point</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">angle</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">normal</span></div>



<div class="viewcode-block" id="decompose_matrix">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.decompose_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">decompose_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return sequence of transformations from transformation matrix.</span>

<span class="sd">    matrix : array_like</span>
<span class="sd">        Non-degenerative homogeneous transformation matrix</span>

<span class="sd">    Return tuple of:</span>
<span class="sd">        scale : vector of 3 scaling factors</span>
<span class="sd">        shear : list of shear factors for x-y, x-z, y-z axes</span>
<span class="sd">        angles : list of Euler angles about static x, y, z axes</span>
<span class="sd">        translate : translation vector along x, y, z axes</span>
<span class="sd">        perspective : perspective partition of matrix</span>

<span class="sd">    Raise ValueError if matrix is of wrong type or degenerative.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (translation_matrix,</span>
<span class="sd">    ...     decompose_matrix, scale_matrix, euler_matrix)</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; T0 = translation_matrix((1, 2, 3))</span>
<span class="sd">    &gt;&gt;&gt; scale, shear, angles, trans, persp = decompose_matrix(T0)</span>
<span class="sd">    &gt;&gt;&gt; T1 = translation_matrix(trans)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(T0, T1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; S = scale_matrix(0.123)</span>
<span class="sd">    &gt;&gt;&gt; scale, shear, angles, trans, persp = decompose_matrix(S)</span>
<span class="sd">    &gt;&gt;&gt; scale[0]</span>
<span class="sd">    0.123</span>
<span class="sd">    &gt;&gt;&gt; R0 = euler_matrix(1, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; scale, shear, angles, trans, persp = decompose_matrix(R0)</span>
<span class="sd">    &gt;&gt;&gt; R1 = euler_matrix(*angles)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(R0, R1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=unsubscriptable-object</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">_EPS</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;M[3, 3] is zero&quot;</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">/=</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">P</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matrix is singular&quot;</span><span class="p">)</span>

    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">shear</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">_EPS</span><span class="p">):</span>
        <span class="n">perspective</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="n">M</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">perspective</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">translate</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">row</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">shear</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shear</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">shear</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">shear</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">shear</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">scale</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">row</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="o">-</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">angles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#angles[0] = math.atan2(row[1, 0], row[1, 1])</span>
        <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">angles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">return</span> <span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">translate</span><span class="p">,</span> <span class="n">perspective</span></div>



<div class="viewcode-block" id="compose_matrix">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.compose_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">compose_matrix</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shear</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">translate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">perspective</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return transformation matrix from sequence of transformations.</span>

<span class="sd">    This is the inverse of the decompose_matrix function.</span>

<span class="sd">    Sequence of transformations:</span>
<span class="sd">        scale : vector of 3 scaling factors</span>
<span class="sd">        shear : list of shear factors for x-y, x-z, y-z axes</span>
<span class="sd">        angles : list of Euler angles about static x, y, z axes</span>
<span class="sd">        translate : translation vector along x, y, z axes</span>
<span class="sd">        perspective : perspective partition of matrix</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (compose_matrix,</span>
<span class="sd">    ...     decompose_matrix, is_same_transform)</span>
<span class="sd">    &gt;&gt;&gt; import math</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; scale = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; shear = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; angles = (np.random.random(3) - 0.5) * (2*math.pi)</span>
<span class="sd">    &gt;&gt;&gt; trans = np.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; persp = np.random.random(4) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; M0 = compose_matrix(scale, shear, angles, trans, persp)</span>
<span class="sd">    &gt;&gt;&gt; result = decompose_matrix(M0)</span>
<span class="sd">    &gt;&gt;&gt; M1 = compose_matrix(*result)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(M0, M1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">perspective</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">P</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">perspective</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">translate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">T</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">translate</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angles</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">angles</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;sxyz&#39;</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shear</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">Z</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">shear</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">shear</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">/=</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">M</span></div>



<span class="k">def</span> <span class="nf">orthogonalization_matrix</span><span class="p">(</span><span class="n">lengths</span><span class="p">,</span> <span class="n">angles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return orthogonalization matrix for crystallographic cell coordinates.</span>

<span class="sd">    Angles are expected in degrees.</span>

<span class="sd">    The de-orthogonalization matrix is the inverse.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import orthogonalization_matrix</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; O = orthogonalization_matrix((10., 10., 10.), (90., 90., 90.))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(O[:3, :3], np.identity(3, float) * 10)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; O = orthogonalization_matrix([9.8, 12.0, 15.5], [87.2, 80.7, 69.7])</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.sum(O), 43.063229)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">lengths</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">sina</span><span class="p">,</span> <span class="n">sinb</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">cosa</span><span class="p">,</span> <span class="n">cosb</span><span class="p">,</span> <span class="n">cosg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">co</span> <span class="o">=</span> <span class="p">(</span><span class="n">cosa</span> <span class="o">*</span> <span class="n">cosb</span> <span class="o">-</span> <span class="n">cosg</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sina</span> <span class="o">*</span> <span class="n">sinb</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">sinb</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">co</span> <span class="o">*</span> <span class="n">co</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="o">-</span><span class="n">a</span> <span class="o">*</span> <span class="n">sinb</span> <span class="o">*</span> <span class="n">co</span><span class="p">,</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sina</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">cosb</span><span class="p">,</span> <span class="n">b</span> <span class="o">*</span> <span class="n">cosa</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">superimposition_matrix</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">usesvd</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to transform given vector set into second vector set.</span>

<span class="sd">    `v0` and `v1` are shape `(3, *)` or `(4, *)` arrays of at least 3 vectors.</span>

<span class="sd">    If `usesvd` is ``True``, the weighted sum of squared deviations (RMSD) is</span>
<span class="sd">    minimized according to the algorithm by W. Kabsch [8]. Otherwise the</span>
<span class="sd">    quaternion based algorithm by B. Horn [9] is used (slower when using</span>
<span class="sd">    this Python implementation).</span>

<span class="sd">    The returned matrix performs rotation, translation and uniform scaling</span>
<span class="sd">    (if specified).</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (superimposition_matrix,</span>
<span class="sd">    ... random_rotation_matrix, scale_matrix, translation_matrix,</span>
<span class="sd">    ... concatenate_matrices)</span>
<span class="sd">    &gt;&gt;&gt; import random</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; v0 = np.random.rand(3, 10)</span>
<span class="sd">    &gt;&gt;&gt; M = superimposition_matrix(v0, v0)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(M, np.identity(4))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R = random_rotation_matrix(np.random.random(3))</span>
<span class="sd">    &gt;&gt;&gt; v0 = ((1,0,0), (0,1,0), (0,0,1), (1,1,1))</span>
<span class="sd">    &gt;&gt;&gt; v1 = np.dot(R, v0)</span>
<span class="sd">    &gt;&gt;&gt; M = superimposition_matrix(v0, v1)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v1, np.dot(M, v0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v0 = (np.random.rand(4, 100) - 0.5) * 20.0</span>
<span class="sd">    &gt;&gt;&gt; v0[3] = 1.0</span>
<span class="sd">    &gt;&gt;&gt; v1 = np.dot(R, v0)</span>
<span class="sd">    &gt;&gt;&gt; M = superimposition_matrix(v0, v1)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v1, np.dot(M, v0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; S = scale_matrix(random.random())</span>
<span class="sd">    &gt;&gt;&gt; T = translation_matrix(np.random.random(3)-0.5)</span>
<span class="sd">    &gt;&gt;&gt; M = concatenate_matrices(T, R, S)</span>
<span class="sd">    &gt;&gt;&gt; v1 = np.dot(M, v0)</span>
<span class="sd">    &gt;&gt;&gt; v0[:3] += np.random.normal(0.0, 1e-9, 300).reshape(3, -1)</span>
<span class="sd">    &gt;&gt;&gt; M = superimposition_matrix(v0, v1, scaling=True)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v1, np.dot(M, v0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; M = superimposition_matrix(v0, v1, scaling=True, usesvd=False)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v1, np.dot(M, v0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v = np.empty((4, 100, 3), dtype=np.float64)</span>
<span class="sd">    &gt;&gt;&gt; v[:, :, 0] = v0</span>
<span class="sd">    &gt;&gt;&gt; M = superimposition_matrix(v0, v1, scaling=True, usesvd=False)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v1, np.dot(M, v[:, :, 0]))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">v1</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;vector sets are of wrong shape or type&quot;</span><span class="p">)</span>

    <span class="c1"># move centroids to origin</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">v0</span> <span class="o">-</span> <span class="n">t0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">-</span> <span class="n">t1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">usesvd</span><span class="p">:</span>
        <span class="c1"># Singular Value Decomposition of covariance matrix</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="c1"># rotation matrix from SVD orthonormal bases</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">vh</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="c1"># R does not constitute right handed system</span>
            <span class="n">R</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">vh</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="c1"># homogeneous transformation matrix</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># compute symmetric matrix N</span>
        <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">zz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">v0</span> <span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
        <span class="n">xy</span><span class="p">,</span> <span class="n">yz</span><span class="p">,</span> <span class="n">zx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">xz</span><span class="p">,</span> <span class="n">yx</span><span class="p">,</span> <span class="n">zy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">N</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">xx</span> <span class="o">+</span> <span class="n">yy</span> <span class="o">+</span> <span class="n">zz</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">yz</span> <span class="o">-</span> <span class="n">zy</span><span class="p">,</span> <span class="n">xx</span> <span class="o">-</span> <span class="n">yy</span> <span class="o">-</span> <span class="n">zz</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">zx</span> <span class="o">-</span> <span class="n">xz</span><span class="p">,</span> <span class="n">xy</span> <span class="o">+</span> <span class="n">yx</span><span class="p">,</span> <span class="o">-</span><span class="n">xx</span> <span class="o">+</span> <span class="n">yy</span> <span class="o">-</span> <span class="n">zz</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">xy</span> <span class="o">-</span> <span class="n">yx</span><span class="p">,</span> <span class="n">zx</span> <span class="o">+</span> <span class="n">xz</span><span class="p">,</span> <span class="n">yz</span> <span class="o">+</span> <span class="n">zy</span><span class="p">,</span> <span class="o">-</span><span class="n">xx</span> <span class="o">-</span> <span class="n">yy</span> <span class="o">+</span> <span class="n">zz</span><span class="p">))</span>
        <span class="c1"># quaternion: eigenvector corresponding to most positive eigenvalue</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>
        <span class="n">q</span> <span class="o">/=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>  <span class="c1"># unit quaternion</span>
        <span class="c1"># homogeneous transformation matrix</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">quaternion_matrix</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

    <span class="c1"># scale: ratio of rms deviations from centroid</span>
    <span class="k">if</span> <span class="n">scaling</span><span class="p">:</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;&#39;</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v1</span><span class="p">)</span> <span class="o">/</span> 
                                <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;&#39;</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">v0</span><span class="p">))</span>


    <span class="c1"># translation</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">T</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">t0</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">euler_matrix</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span> <span class="n">aj</span><span class="p">,</span> <span class="n">ak</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;sxyz&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return homogeneous rotation matrix from Euler angles and axis sequence.</span>

<span class="sd">    ai, aj, ak : Euler&#39;s roll, pitch and yaw angles</span>
<span class="sd">    axes : One of 24 axis sequences as string or encoded tuple</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (euler_matrix,</span>
<span class="sd">    ... _AXES2TUPLE, _TUPLE2AXES)</span>
<span class="sd">    &gt;&gt;&gt; import math</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; R = euler_matrix(1, 2, 3, &#39;syxz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.sum(R[0]), -1.34786452)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R = euler_matrix(1, 2, 3, (0, 1, 0, 1))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.sum(R[0]), -0.383436184)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ai, aj, ak = (4.0*math.pi) * (np.random.random(3) - 0.5)</span>
<span class="sd">    &gt;&gt;&gt; for axes in _AXES2TUPLE.keys():</span>
<span class="sd">    ...    R = euler_matrix(ai, aj, ak, axes)</span>
<span class="sd">    &gt;&gt;&gt; for axes in _TUPLE2AXES.keys():</span>
<span class="sd">    ...    R = euler_matrix(ai, aj, ak, axes)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">firstaxis</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">repetition</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">_AXES2TUPLE</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">_TUPLE2AXES</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span>
        <span class="n">firstaxis</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">repetition</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">axes</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">firstaxis</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">_NEXT_AXIS</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">parity</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">_NEXT_AXIS</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">parity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">frame</span><span class="p">:</span>
        <span class="n">ai</span><span class="p">,</span> <span class="n">ak</span> <span class="o">=</span> <span class="n">ak</span><span class="p">,</span> <span class="n">ai</span>
    <span class="k">if</span> <span class="n">parity</span><span class="p">:</span>
        <span class="n">ai</span><span class="p">,</span> <span class="n">aj</span><span class="p">,</span> <span class="n">ak</span> <span class="o">=</span> <span class="o">-</span><span class="n">ai</span><span class="p">,</span> <span class="o">-</span><span class="n">aj</span><span class="p">,</span> <span class="o">-</span><span class="n">ak</span>

    <span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">,</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">aj</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ak</span><span class="p">)</span>
    <span class="n">ci</span><span class="p">,</span> <span class="n">cj</span><span class="p">,</span> <span class="n">ck</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">aj</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ak</span><span class="p">)</span>
    <span class="n">cc</span><span class="p">,</span> <span class="n">cs</span> <span class="o">=</span> <span class="n">ci</span> <span class="o">*</span> <span class="n">ck</span><span class="p">,</span> <span class="n">ci</span> <span class="o">*</span> <span class="n">sk</span>
    <span class="n">sc</span><span class="p">,</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">si</span> <span class="o">*</span> <span class="n">ck</span><span class="p">,</span> <span class="n">si</span> <span class="o">*</span> <span class="n">sk</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">repetition</span><span class="p">:</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">si</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">ci</span>
        <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">sk</span>
        <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">cj</span> <span class="o">*</span> <span class="n">ss</span> <span class="o">+</span> <span class="n">cc</span>
        <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">cj</span> <span class="o">*</span> <span class="n">cs</span> <span class="o">-</span> <span class="n">sc</span>
        <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sj</span> <span class="o">*</span> <span class="n">ck</span>
        <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">sc</span> <span class="o">+</span> <span class="n">cs</span>
        <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">cc</span> <span class="o">-</span> <span class="n">ss</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">ck</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">sc</span> <span class="o">-</span> <span class="n">cs</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">cc</span> <span class="o">+</span> <span class="n">ss</span>
        <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">sk</span>
        <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">ss</span> <span class="o">+</span> <span class="n">cc</span>
        <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">cs</span> <span class="o">-</span> <span class="n">sc</span>
        <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sj</span>
        <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">si</span>
        <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">ci</span>
    <span class="k">return</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">euler_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;sxyz&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return Euler angles from rotation matrix for specified axis sequence.</span>

<span class="sd">    axes : One of 24 axis sequences as string or encoded tuple</span>

<span class="sd">    Note that many Euler angle triplets can describe one matrix.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (euler_matrix,</span>
<span class="sd">    ... euler_from_matrix, _AXES2TUPLE)</span>
<span class="sd">    &gt;&gt;&gt; import math</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; R0 = euler_matrix(1, 2, 3, &#39;syxz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; al, be, ga = euler_from_matrix(R0, &#39;syxz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; R1 = euler_matrix(al, be, ga, &#39;syxz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(R0, R1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; angles = (4.0*math.pi) * (np.random.random(3) - 0.5)</span>
<span class="sd">    &gt;&gt;&gt; for axes in _AXES2TUPLE.keys():</span>
<span class="sd">    ...    R0 = euler_matrix(axes=axes, *angles)</span>
<span class="sd">    ...    R1 = euler_matrix(axes=axes, *euler_from_matrix(R0, axes))</span>
<span class="sd">    ...    if not np.allclose(R0, R1): print(axes, &quot;failed&quot;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">firstaxis</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">repetition</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">_AXES2TUPLE</span><span class="p">[</span><span class="n">axes</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">_TUPLE2AXES</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span>
        <span class="n">firstaxis</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">repetition</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">axes</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">firstaxis</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">_NEXT_AXIS</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">parity</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">_NEXT_AXIS</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">parity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">repetition</span><span class="p">:</span>
        <span class="n">sy</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sy</span> <span class="o">&gt;</span> <span class="n">_EPS</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span>
            <span class="n">ay</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">sy</span><span class="p">,</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">az</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">ay</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">sy</span><span class="p">,</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">az</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cy</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cy</span> <span class="o">&gt;</span> <span class="n">_EPS</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span>
            <span class="n">ay</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">cy</span><span class="p">)</span>
            <span class="n">az</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">ay</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">cy</span><span class="p">)</span>
            <span class="n">az</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">if</span> <span class="n">parity</span><span class="p">:</span>
        <span class="n">ax</span><span class="p">,</span> <span class="n">ay</span><span class="p">,</span> <span class="n">az</span> <span class="o">=</span> <span class="o">-</span><span class="n">ax</span><span class="p">,</span> <span class="o">-</span><span class="n">ay</span><span class="p">,</span> <span class="o">-</span><span class="n">az</span>
    <span class="k">if</span> <span class="n">frame</span><span class="p">:</span>
        <span class="n">ax</span><span class="p">,</span> <span class="n">az</span> <span class="o">=</span> <span class="n">az</span><span class="p">,</span> <span class="n">ax</span>
    <span class="k">return</span> <span class="n">ax</span><span class="p">,</span> <span class="n">ay</span><span class="p">,</span> <span class="n">az</span>


<div class="viewcode-block" id="euler_from_quaternion">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.euler_from_quaternion">[docs]</a>
<span class="k">def</span> <span class="nf">euler_from_quaternion</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;sxyz&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return Euler angles from quaternion for specified axis sequence.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import euler_from_quaternion</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; angles = euler_from_quaternion([0.99810947, 0.06146124, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(angles, [0.123, 0, 0])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">euler_from_matrix</span><span class="p">(</span><span class="n">quaternion_matrix</span><span class="p">(</span><span class="n">quaternion</span><span class="p">),</span> <span class="n">axes</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">quaternion_from_euler</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span> <span class="n">aj</span><span class="p">,</span> <span class="n">ak</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;sxyz&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return quaternion from Euler angles and axis sequence.</span>

<span class="sd">    ai, aj, ak : Euler&#39;s roll, pitch and yaw angles</span>
<span class="sd">    axes : One of 24 axis sequences as string or encoded tuple</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import quaternion_from_euler</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_from_euler(1, 2, 3, &#39;ryxz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(q, [0.435953, 0.310622, -0.718287, 0.444435])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">firstaxis</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">repetition</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">_AXES2TUPLE</span><span class="p">[</span><span class="n">axes</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">_TUPLE2AXES</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span>
        <span class="n">firstaxis</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">repetition</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">axes</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">firstaxis</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">_NEXT_AXIS</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">parity</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">_NEXT_AXIS</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">parity</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">frame</span><span class="p">:</span>
        <span class="n">ai</span><span class="p">,</span> <span class="n">ak</span> <span class="o">=</span> <span class="n">ak</span><span class="p">,</span> <span class="n">ai</span>
    <span class="k">if</span> <span class="n">parity</span><span class="p">:</span>
        <span class="n">aj</span> <span class="o">=</span> <span class="o">-</span><span class="n">aj</span>

    <span class="n">ai</span> <span class="o">/=</span> <span class="mf">2.0</span>
    <span class="n">aj</span> <span class="o">/=</span> <span class="mf">2.0</span>
    <span class="n">ak</span> <span class="o">/=</span> <span class="mf">2.0</span>
    <span class="n">ci</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
    <span class="n">si</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
    <span class="n">cj</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span>
    <span class="n">sj</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span>
    <span class="n">ck</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ak</span><span class="p">)</span>
    <span class="n">sk</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ak</span><span class="p">)</span>
    <span class="n">cc</span> <span class="o">=</span> <span class="n">ci</span> <span class="o">*</span> <span class="n">ck</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">ci</span> <span class="o">*</span> <span class="n">sk</span>
    <span class="n">sc</span> <span class="o">=</span> <span class="n">si</span> <span class="o">*</span> <span class="n">ck</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">si</span> <span class="o">*</span> <span class="n">sk</span>

    <span class="n">quaternion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">repetition</span><span class="p">:</span>
        <span class="n">quaternion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="p">(</span><span class="n">cc</span> <span class="o">-</span> <span class="n">ss</span><span class="p">)</span>
        <span class="n">quaternion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="p">(</span><span class="n">cs</span> <span class="o">+</span> <span class="n">sc</span><span class="p">)</span>
        <span class="n">quaternion</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="p">(</span><span class="n">cc</span> <span class="o">+</span> <span class="n">ss</span><span class="p">)</span>
        <span class="n">quaternion</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="p">(</span><span class="n">cs</span> <span class="o">-</span> <span class="n">sc</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">quaternion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">cc</span> <span class="o">+</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">ss</span>
        <span class="n">quaternion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">sc</span> <span class="o">-</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">cs</span>
        <span class="n">quaternion</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">ss</span> <span class="o">+</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">cc</span>
        <span class="n">quaternion</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">cs</span> <span class="o">-</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">sc</span>
    <span class="k">if</span> <span class="n">parity</span><span class="p">:</span>
        <span class="n">quaternion</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">quaternion</span>


<span class="k">def</span> <span class="nf">quaternion_about_axis</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return quaternion for rotation about axis.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import quaternion_about_axis</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_about_axis(0.123, (1, 0, 0))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(q, [0.99810947, 0.06146124, 0, 0])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">quaternion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">quaternion</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">quaternion</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">quaternion</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">qlen</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">quaternion</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">qlen</span> <span class="o">&gt;</span> <span class="n">_EPS</span><span class="p">:</span>
        <span class="n">quaternion</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">qlen</span>
    <span class="n">quaternion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quaternion</span>


<span class="k">def</span> <span class="nf">quaternion_matrix</span><span class="p">(</span><span class="n">quaternion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return homogeneous rotation matrix from quaternion.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (identity_matrix,</span>
<span class="sd">    ...     quaternion_matrix, rotation_matrix)</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; M = quaternion_matrix([0.99810947, 0.06146124, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(M, rotation_matrix(0.123, (1, 0, 0)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; M = quaternion_matrix([1, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(M, identity_matrix())</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; M = quaternion_matrix([0, 1, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(M, np.diag([1, -1, -1, 1]))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quaternion</span><span class="p">[:</span><span class="mi">4</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nq</span> <span class="o">&lt;</span> <span class="n">_EPS</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="n">nq</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">quaternion_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">isprecise</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return quaternion from rotation matrix.</span>

<span class="sd">    If isprecise=True, the input matrix is assumed to be a precise rotation</span>
<span class="sd">    matrix and a faster algorithm is used.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (identity_matrix,</span>
<span class="sd">    ...     quaternion_from_matrix, rotation_matrix, random_rotation_matrix,</span>
<span class="sd">    ...     is_same_transform, quaternion_matrix)</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_from_matrix(identity_matrix(), True)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(q, [1., 0., 0., 0.])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_from_matrix(np.diag([1., -1., -1., 1.]))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(q, [0, 1, 0, 0]) or np.allclose(q, [0, -1, 0, 0])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R = rotation_matrix(0.123, (1, 2, 3))</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_from_matrix(R, True)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(q, [0.9981095, 0.0164262, 0.0328524, 0.0492786])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R = [[-0.545, 0.797, 0.260, 0], [0.733, 0.603, -0.313, 0],</span>
<span class="sd">    ...      [-0.407, 0.021, -0.913, 0], [0, 0, 0, 1]]</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_from_matrix(R)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(q, [0.19069, 0.43736, 0.87485, -0.083611])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R = [[0.395, 0.362, 0.843, 0], [-0.626, 0.796, -0.056, 0],</span>
<span class="sd">    ...      [-0.677, -0.498, 0.529, 0], [0, 0, 0, 1]]</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_from_matrix(R)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(q, [0.82336615, -0.13610694, 0.46344705, -0.29792603])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R = random_rotation_matrix()</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_from_matrix(R)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(R, quaternion_matrix(q))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">isprecise</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
            <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
            <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">q</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
        <span class="n">q</span> <span class="o">*=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m00</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">m01</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">m02</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">m10</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">m11</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">m12</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">m20</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">m21</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">m22</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="c1"># symmetric matrix K</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span>
            <span class="p">(</span><span class="n">m00</span> <span class="o">-</span> <span class="n">m11</span> <span class="o">-</span> <span class="n">m22</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">m01</span> <span class="o">+</span> <span class="n">m10</span><span class="p">,</span> <span class="n">m11</span> <span class="o">-</span> <span class="n">m00</span> <span class="o">-</span> <span class="n">m22</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">m02</span> <span class="o">+</span> <span class="n">m20</span><span class="p">,</span> <span class="n">m12</span> <span class="o">+</span> <span class="n">m21</span><span class="p">,</span> <span class="n">m22</span> <span class="o">-</span> <span class="n">m00</span> <span class="o">-</span> <span class="n">m11</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">m21</span> <span class="o">-</span> <span class="n">m12</span><span class="p">,</span> <span class="n">m02</span> <span class="o">-</span> <span class="n">m20</span><span class="p">,</span> <span class="n">m10</span> <span class="o">-</span> <span class="n">m01</span><span class="p">,</span> <span class="n">m00</span> <span class="o">+</span> <span class="n">m11</span> <span class="o">+</span> <span class="n">m22</span><span class="p">)))</span>
        <span class="n">K</span> <span class="o">/=</span> <span class="mf">3.0</span>
        <span class="c1"># quaternion is eigenvector of K that corresponds to largest eigenvalue</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">V</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">q</span>


<span class="k">def</span> <span class="nf">quaternion_multiply</span><span class="p">(</span><span class="n">quaternion1</span><span class="p">,</span> <span class="n">quaternion0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return multiplication of two quaternions.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import quaternion_multiply</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_multiply([4, 1, -2, 3], [8, -5, 6, 7])</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(q, [28, -44, -14, 48])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span> <span class="o">=</span> <span class="n">quaternion0</span>
    <span class="n">w1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span> <span class="o">=</span> <span class="n">quaternion1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="o">-</span><span class="n">x1</span> <span class="o">*</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">y1</span> <span class="o">*</span> <span class="n">y0</span> <span class="o">-</span> <span class="n">z1</span> <span class="o">*</span> <span class="n">z0</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">w0</span><span class="p">,</span>
            <span class="n">x1</span> <span class="o">*</span> <span class="n">w0</span> <span class="o">+</span> <span class="n">y1</span> <span class="o">*</span> <span class="n">z0</span> <span class="o">-</span> <span class="n">z1</span> <span class="o">*</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">x0</span><span class="p">,</span>
            <span class="o">-</span><span class="n">x1</span> <span class="o">*</span> <span class="n">z0</span> <span class="o">+</span> <span class="n">y1</span> <span class="o">*</span> <span class="n">w0</span> <span class="o">+</span> <span class="n">z1</span> <span class="o">*</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">y0</span><span class="p">,</span>
            <span class="n">x1</span> <span class="o">*</span> <span class="n">y0</span> <span class="o">-</span> <span class="n">y1</span> <span class="o">*</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">z1</span> <span class="o">*</span> <span class="n">w0</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">z0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">quaternion_conjugate</span><span class="p">(</span><span class="n">quaternion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return conjugate of quaternion.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (random_quaternion,</span>
<span class="sd">    ...     quaternion_conjugate)</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; q0 = random_quaternion()</span>
<span class="sd">    &gt;&gt;&gt; q1 = quaternion_conjugate(q0)</span>
<span class="sd">    &gt;&gt;&gt; q1[0] == q0[0] and all(q1[1:] == -q0[1:])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">quaternion</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">quaternion</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="o">-</span><span class="n">quaternion</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="n">quaternion</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">quaternion_inverse</span><span class="p">(</span><span class="n">quaternion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return inverse of quaternion.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (random_quaternion,</span>
<span class="sd">    ...     quaternion_inverse)</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; q0 = random_quaternion()</span>
<span class="sd">    &gt;&gt;&gt; q1 = quaternion_inverse(q0)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(quaternion_multiply(q0, q1), [1, 0, 0, 0])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">quaternion_conjugate</span><span class="p">(</span><span class="n">quaternion</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">quaternion</span><span class="p">)</span>


<div class="viewcode-block" id="quaternion_real">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.quaternion_real">[docs]</a>
<span class="k">def</span> <span class="nf">quaternion_real</span><span class="p">(</span><span class="n">quaternion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return real part of quaternion.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import quaternion_real</span>
<span class="sd">    &gt;&gt;&gt; quaternion_real([3.0, 0.0, 1.0, 2.0])</span>
<span class="sd">    3.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">quaternion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>



<div class="viewcode-block" id="quaternion_imag">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.quaternion_imag">[docs]</a>
<span class="k">def</span> <span class="nf">quaternion_imag</span><span class="p">(</span><span class="n">quaternion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return imaginary part of quaternion.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import quaternion_imag</span>
<span class="sd">    &gt;&gt;&gt; quaternion_imag([3.0, 0.0, 1.0, 2.0])</span>
<span class="sd">    [0.0, 1.0, 2.0]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">quaternion</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span></div>



<span class="k">def</span> <span class="nf">quaternion_slerp</span><span class="p">(</span><span class="n">quat0</span><span class="p">,</span> <span class="n">quat1</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shortestpath</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return spherical linear interpolation between two quaternions.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (random_quaternion,</span>
<span class="sd">    ...     quaternion_slerp)</span>
<span class="sd">    &gt;&gt;&gt; import math</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; q0 = random_quaternion()</span>
<span class="sd">    &gt;&gt;&gt; q1 = random_quaternion()</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_slerp(q0, q1, 0.0)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(q, q0)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_slerp(q0, q1, 1.0, 1)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(q, q1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_slerp(q0, q1, 0.5)</span>
<span class="sd">    &gt;&gt;&gt; angle = math.acos(np.dot(q0, q))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(2.0, math.acos(np.dot(q0, q1)) / angle) or \</span>
<span class="sd">    ... np.allclose(2.0, math.acos(-np.dot(q0, q1)) / angle)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q0</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">quat0</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">quat1</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">fraction</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q0</span>
    <span class="k">elif</span> <span class="n">fraction</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q1</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_EPS</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q0</span>
    <span class="k">if</span> <span class="n">shortestpath</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="c1"># invert rotation</span>
        <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span>
        <span class="n">q1</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">spin</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_EPS</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q0</span>
    <span class="n">isin</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">q0</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">fraction</span><span class="p">)</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">isin</span>
    <span class="n">q1</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">fraction</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">isin</span>
    <span class="n">q0</span> <span class="o">+=</span> <span class="n">q1</span>
    <span class="k">return</span> <span class="n">q0</span>


<span class="k">def</span> <span class="nf">random_quaternion</span><span class="p">(</span><span class="n">rand</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return uniform random unit quaternion.</span>

<span class="sd">    rand: array like or None</span>
<span class="sd">        Three independent random variables that are uniformly distributed</span>
<span class="sd">        between 0 and 1.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (random_quaternion,</span>
<span class="sd">    ...     vector_norm)</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; q = random_quaternion()</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(1.0, vector_norm(q))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; q = random_quaternion(np.random.random(3))</span>
<span class="sd">    &gt;&gt;&gt; len(q.shape), q.shape[0]==4</span>
<span class="sd">    (1, True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rand</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rand</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rand</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rand</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">pi2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">2.0</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">pi2</span> <span class="o">*</span> <span class="n">rand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">pi2</span> <span class="o">*</span> <span class="n">rand</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">*</span> <span class="n">r2</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r1</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r1</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">*</span> <span class="n">r2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">random_rotation_matrix</span><span class="p">(</span><span class="n">rand</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return uniform random rotation matrix.</span>

<span class="sd">    rnd: array like</span>
<span class="sd">        Three independent random variables that are uniformly distributed</span>
<span class="sd">        between 0 and 1 for each returned quaternion.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import random_rotation_matrix</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; R = random_rotation_matrix()</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.dot(R.T, R), np.identity(4))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">quaternion_matrix</span><span class="p">(</span><span class="n">random_quaternion</span><span class="p">(</span><span class="n">rand</span><span class="p">))</span>


<div class="viewcode-block" id="Arcball">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.Arcball">[docs]</a>
<span class="k">class</span> <span class="nc">Arcball</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Virtual Trackball Control.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import Arcball</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; ball = Arcball()</span>
<span class="sd">    &gt;&gt;&gt; ball = Arcball(initial=np.identity(4))</span>
<span class="sd">    &gt;&gt;&gt; ball.place([320, 320], 320)</span>
<span class="sd">    &gt;&gt;&gt; ball.down([500, 250])</span>
<span class="sd">    &gt;&gt;&gt; ball.drag([475, 275])</span>
<span class="sd">    &gt;&gt;&gt; R = ball.matrix()</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.sum(R), 3.90583455)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ball = Arcball(initial=[1, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; ball.place([320, 320], 320)</span>
<span class="sd">    &gt;&gt;&gt; ball.setaxes([1,1,0], [-1, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; ball.setconstrain(True)</span>
<span class="sd">    &gt;&gt;&gt; ball.down([400, 200])</span>
<span class="sd">    &gt;&gt;&gt; ball.drag([200, 400])</span>
<span class="sd">    &gt;&gt;&gt; R = ball.matrix()</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.sum(R), 0.2055924)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ball.next()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize virtual trackball control.</span>

<span class="sd">        initial : quaternion or rotation matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constrain</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span> <span class="o">=</span> <span class="n">quaternion_from_matrix</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">initial</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">):</span>
                <span class="n">initial</span> <span class="o">/=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span> <span class="o">=</span> <span class="n">initial</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;initial not a quaternion or matrix&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qpre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span>

<div class="viewcode-block" id="Arcball.place">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.Arcball.place">[docs]</a>
    <span class="k">def</span> <span class="nf">place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Place Arcball, e.g. when window size changes.</span>

<span class="sd">        center : sequence[2]</span>
<span class="sd">            Window coordinates of trackball center.</span>
<span class="sd">        radius : float</span>
<span class="sd">            Radius of trackball in window coordinates.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="Arcball.setaxes">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.Arcball.setaxes">[docs]</a>
    <span class="k">def</span> <span class="nf">setaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">axes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set axes to constrain rotations.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span></div>


<div class="viewcode-block" id="Arcball.setconstrain">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.Arcball.setconstrain">[docs]</a>
    <span class="k">def</span> <span class="nf">setconstrain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constrain</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set state of constrain to axis mode.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constrain</span> <span class="o">=</span> <span class="n">constrain</span> <span class="ow">is</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Arcball.getconstrain">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.Arcball.getconstrain">[docs]</a>
    <span class="k">def</span> <span class="nf">getconstrain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return state of constrain to axis mode.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constrain</span></div>


<div class="viewcode-block" id="Arcball.down">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.Arcball.down">[docs]</a>
    <span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set initial cursor window coordinates and pick constrain-axis.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span> <span class="o">=</span> <span class="n">arcball_map_to_sphere</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qpre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constrain</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="o">=</span> <span class="n">arcball_nearest_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span> <span class="o">=</span> <span class="n">arcball_constrain_to_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Arcball.drag">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.Arcball.drag">[docs]</a>
    <span class="k">def</span> <span class="nf">drag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update current cursor window coordinates.&quot;&quot;&quot;</span>
        <span class="n">vnow</span> <span class="o">=</span> <span class="n">arcball_map_to_sphere</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vnow</span> <span class="o">=</span> <span class="n">arcball_constrain_to_axis</span><span class="p">(</span><span class="n">vnow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_qpre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span><span class="p">,</span> <span class="n">vnow</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_EPS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span><span class="p">,</span> <span class="n">vnow</span><span class="p">),</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span> <span class="o">=</span> <span class="n">quaternion_multiply</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span><span class="p">)</span></div>


<div class="viewcode-block" id="Arcball.next">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.Arcball.next">[docs]</a>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">acceleration</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Continue rotation in direction of last drag.&quot;&quot;&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">quaternion_slerp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qpre</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">acceleration</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qpre</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span><span class="p">,</span> <span class="n">q</span></div>


<div class="viewcode-block" id="Arcball.matrix">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.Arcball.matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return homogeneous rotation matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">quaternion_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span><span class="p">)</span></div>
</div>



<span class="k">def</span> <span class="nf">arcball_map_to_sphere</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return unit sphere coordinates from window coordinates.&quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">radius</span><span class="p">,</span>
            <span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">radius</span><span class="p">,</span>
            <span class="mf">0.0</span>
        <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
    <span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">/=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># position outside of sphere</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span>


<span class="k">def</span> <span class="nf">arcball_constrain_to_axis</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return sphere point perpendicular to axis.&quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">-=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>  <span class="c1"># on plane</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">_EPS</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="n">v</span> <span class="o">/=</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">v</span>
    <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unit_vector</span><span class="p">([</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>


<div class="viewcode-block" id="arcball_nearest_axis">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.arcball_nearest_axis">[docs]</a>
<span class="k">def</span> <span class="nf">arcball_nearest_axis</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return axis, which arc is nearest to point.&quot;&quot;&quot;</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">nearest</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mx</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">arcball_constrain_to_axis</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">point</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">mx</span><span class="p">:</span>
            <span class="n">nearest</span> <span class="o">=</span> <span class="n">axis</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="n">t</span>
    <span class="k">return</span> <span class="n">nearest</span></div>



<span class="c1"># epsilon for testing whether a number is close to zero</span>
<span class="n">_EPS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="mf">4.0</span>

<span class="c1"># axis sequences for Euler angles</span>
<span class="n">_NEXT_AXIS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="c1"># map axes strings to/from tuples of inner axis, parity, repetition, frame</span>
<span class="n">_AXES2TUPLE</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;sxyz&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;sxyx&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;sxzy&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s1">&#39;sxzx&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;syzx&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;syzy&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s1">&#39;syxz&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;syxy&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;szxy&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s1">&#39;szxz&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;szyx&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;szyz&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s1">&#39;rzyx&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;rxyx&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;ryzx&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s1">&#39;rxzx&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;rxzy&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;ryzy&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s1">&#39;rzxy&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;ryxy&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;ryxz&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s1">&#39;rzxz&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;rzyz&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>

<span class="n">_TUPLE2AXES</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_AXES2TUPLE</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">vector_norm</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return length, i.e. eucledian norm, of ndarray along axis.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import vector_norm</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; v = np.random.random(3)</span>
<span class="sd">    &gt;&gt;&gt; n = vector_norm(v)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(n, np.linalg.norm(v))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v = np.random.rand(6, 5, 3)</span>
<span class="sd">    &gt;&gt;&gt; n = vector_norm(v, axis=-1)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(n, np.sqrt(np.sum(v*v, axis=2)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; n = vector_norm(v, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(n, np.sqrt(np.sum(v*v, axis=1)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v = np.random.rand(5, 4, 3)</span>
<span class="sd">    &gt;&gt;&gt; n = np.empty((5, 3), dtype=np.float64)</span>
<span class="sd">    &gt;&gt;&gt; vector_norm(v, axis=1, out=n)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(n, np.sqrt(np.sum(v*v, axis=1)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; vector_norm([])</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; vector_norm([1.0])</span>
<span class="sd">    1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">*=</span> <span class="n">data</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">*=</span> <span class="n">data</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unit_vector</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return ndarray normalized by length, i.e. eucledian norm, along axis.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import unit_vector</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; v0 = np.random.random(3)</span>
<span class="sd">    &gt;&gt;&gt; v1 = unit_vector(v0)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v1, v0 / np.linalg.norm(v0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v0 = np.random.rand(5, 4, 3)</span>
<span class="sd">    &gt;&gt;&gt; v1 = unit_vector(v0, axis=-1)</span>
<span class="sd">    &gt;&gt;&gt; v2 = v0 / np.expand_dims(np.sqrt(np.sum(v0*v0, axis=2)), 2)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v1, v2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v1 = unit_vector(v0, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; v2 = v0 / np.expand_dims(np.sqrt(np.sum(v0*v0, axis=1)), 1)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v1, v2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v1 = np.empty((5, 4, 3), dtype=np.float64)</span>
<span class="sd">    &gt;&gt;&gt; unit_vector(v0, axis=1, out=v1)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(v1, v2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; list(unit_vector([]))</span>
<span class="sd">    []</span>
<span class="sd">    &gt;&gt;&gt; list(unit_vector([1.0]))</span>
<span class="sd">    [1.0]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">/=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">out</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>
    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">/=</span> <span class="n">length</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">random_vector</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return array of random doubles in the half-open interval [0.0, 1.0).</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import random_vector</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; v = random_vector(10000)</span>
<span class="sd">    &gt;&gt;&gt; np.all(v &gt;= 0.0) and np.all(v &lt; 1.0)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v0 = random_vector(10)</span>
<span class="sd">    &gt;&gt;&gt; v1 = random_vector(10)</span>
<span class="sd">    &gt;&gt;&gt; np.any(v0 == v1)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">inverse_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return inverse of square transformation matrix.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (random_rotation_matrix,</span>
<span class="sd">    ...     inverse_matrix)</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; M0 = random_rotation_matrix()</span>
<span class="sd">    &gt;&gt;&gt; M1 = inverse_matrix(M0.T)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(M1, np.linalg.inv(M0.T))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; for size in range(1, 7):</span>
<span class="sd">    ...     M0 = np.random.rand(size, size)</span>
<span class="sd">    ...     M1 = inverse_matrix(M0)</span>
<span class="sd">    ...     if not np.allclose(M1, np.linalg.inv(M0)): print(size)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>


<div class="viewcode-block" id="concatenate_matrices">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.concatenate_matrices">[docs]</a>
<span class="k">def</span> <span class="nf">concatenate_matrices</span><span class="p">(</span><span class="o">*</span><span class="n">matrices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return concatenation of series of transformation matrices.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import concatenate_matrices</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; M = np.random.rand(16).reshape((4, 4)) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(M, concatenate_matrices(M))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.dot(M, M.T), concatenate_matrices(M, M.T))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">M</span></div>



<span class="k">def</span> <span class="nf">is_same_transform</span><span class="p">(</span><span class="n">matrix0</span><span class="p">,</span> <span class="n">matrix1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return True if two matrices perform same transformation.</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.transformations import (is_same_transform,</span>
<span class="sd">    ...     random_rotation_matrix)</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(np.identity(4), np.identity(4))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(np.identity(4), random_rotation_matrix())</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">matrix0</span> <span class="o">/=</span> <span class="n">matrix0</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">matrix1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">matrix1</span> <span class="o">/=</span> <span class="n">matrix1</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">matrix0</span><span class="p">,</span> <span class="n">matrix1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_import_module</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;_py_&#39;</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Try import all public attributes from module into global namespace.</span>

<span class="sd">    Existing attributes with name clashes are renamed with prefix.</span>
<span class="sd">    Attributes starting with underscore are ignored by default.</span>

<span class="sd">    Return True on successful import.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">module</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="n">module_name</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">warn</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;failed to import module &quot;</span> <span class="o">+</span> <span class="n">module_name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ignore</span> <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ignore</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">prefix</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">():</span>
                    <span class="nb">globals</span><span class="p">()[</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">attr</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">warn</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;no Python implementation of &quot;</span> <span class="o">+</span> <span class="n">attr</span><span class="p">)</span>
            <span class="nb">globals</span><span class="p">()[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="c1"># orbeckst --- some simple geometry</span>

<div class="viewcode-block" id="rotaxis">
<a class="viewcode-back" href="../../../documentation_pages/lib/transformations.html#MDAnalysis.lib.transformations.rotaxis">[docs]</a>
<span class="k">def</span> <span class="nf">rotaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the rotation axis to rotate vector a into b.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array_like</span>
<span class="sd">        two vectors</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    c : np.ndarray</span>
<span class="sd">        vector to rotate a into b</span>


<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    If a == b this will always return [1, 0, 0]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>



<span class="n">_import_module</span><span class="p">(</span><span class="s1">&#39;_transformations&#39;</span><span class="p">)</span>

<span class="c1"># Documentation in HTML format can be generated with Epydoc</span>
<span class="n">__docformat__</span> <span class="o">=</span> <span class="s2">&quot;restructuredtext en&quot;</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2023, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Henok Ademtew, Shobhit Agarwal, Aya M. Alaa, Irfan Alibay, Kazi Shudipto Amin, Anshul Angaria, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Patricio Barletta, Leonardo Barneschi, Jonathan Barnoud, Estefania Barreto-Ojeda, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Kavya Bisht, Wouter Boomsma, Jose Borreguero, Cédric Bouysset, Kevin Boyd, Meet Brijwani, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, Yantong Cai, David Caplan, Yuanyu Chang, Pratham Chauhan, Matthieu Chavent, Haochuan Chen, Xu Hong Chen, Kathleen Clark, Jennifer A Clark, Orion Cohen, Charlie Cook, Ruggero Cortini, Nicholas Craven, Ramon Crehuet, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Mark D. Driver, Ali Ehlen, Daniel J. Evans, Shujie Fan, Bjarne Feddersen, Lennard van der Feltz, Jake Fennick, Philip Fowler, Guillaume Fraux, Anirvinya G, Michael Gecht, Ahmed Salah Ghoneim, Mikhail Glagolev, William Glass, Joseph Goose, Alexander Gorfer, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Pratik Gupta, Sumit Gupta, Benjamin Hall, Ameya Harmalkar, Ivan Hristov, Eugen Hruska, Kyle J. Huston, Siddharth Jain, Edis Jakupovic, Joe Jordan, Henrik Jäger, Uma D Kadam, Aditya Kamath, Jon Kapla, Ian M. Kenney, Haleema Khan, Navya Khare, Utsav Khatu, Andrew William King, Henry Kobin, Abhishek A. Kognole, Kosuke Kudo, Atharva Kulkarni, Manish Kumar, Mohit Kumar, Shubham Kumar, Alia Lescoulie, Max Linke, Philip Loche, Jinju Lu, Hugo MacDermott-Opeskin, Shaivi Malik, Egor Marin, Domenico Marson, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Rocco Meli, Manuel Nuno Melo, Marcelo C. R. Melo, Dominik &#39;Rathann&#39; Mierzejewski, Geongi Moon, Henry Mull, Morgan L. Nance, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Meghan Osato, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Dimitrios Papageorgiou, Rafael R. Pappalardo, Vishal Parmar, Danny Parton, Shakul Pathak, Christian Pfaendner, Joshua L. Phillips, Marcelo D. Poleto, Hannah Pollak, Kashish Punjani, Michael Quevillon, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Andrea Rizzi, Xiaoxu Ruan, Carlos Yanez S., Utkarsh Saxena, Moritz Schaeffler, Alexander Schlaich, Marcello Sega, Ricky Sexton, Sean L. Seyler, Faraaz Shah, Sulay Shah, Abhishek Shandilya, Shubham Sharma, Rishabh Shukla, Karthikeyan Singaravelan, Tamandeep Singh, Brigitta Sipőcz, Paul Smith, Andy Somogyi, Caio S. Souza, David van der Spoel, Shantanu Srivastava, Lukas Stelzl, Jan Stevens, Gorman Stock, Fenil Suchak, Ayush Suhane, Filip T. Szczypiński, Sukeerti T, Matthijs Tadema, Joao Miguel Correia Teixeira, Paarth Thadani, Matthew W. Thompson, Hao Tian, Matteo Tiberti, Zaheer Timol, Wiep van der Toorn, Mieczyslaw Torchala, Aditi Tripathi, Heet Vekariya, Mark Verma, Josh Vermaas, Isaac Virshup, Lily Wang, Nestor Wendt, Zhiyi Wu, Tengyu Xie, Zhuyi Xue, Mingyi Xue, Alexander Yang, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, Raymond Zhao, Yuxuan Zhuang, and Oliver Beckstein.</p>
  </div>

  

<div class="footer"><p>Please see
    our <a href="https://www.mdanalysis.org/pages/privacy/">Privacy Policy</a>
    to learn how <a href="https://www.mdanalysis.org">MDAnalysis</a> collects data.</p>
    <script data-goatcounter="https://mdanalysis.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</div>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
    var versions_json_url = 'https://docs.mdanalysis.org/versions.json'
</script>

<div class="rst-versions" data-toggle="rst-versions" role="note"
     aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
        2.7.0-dev0
      <span class="fa fa-caret-down"></span>
    </span>

    <div class="rst-other-versions">
        <dl id="versionselector">
            <dt>Other Versions</dt>
        </dl>

    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>