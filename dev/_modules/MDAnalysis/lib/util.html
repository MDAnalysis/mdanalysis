


  
    
  




<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="shortcut icon" href="../../../_static/logo/mda_favicon.ico">
</head>

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MDAnalysis.lib.util &mdash; MDAnalysis 2.8.0-dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/site.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=a9b57af3"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/js/versions.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 2.8.0-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >




  




<a href="../../../index.html">
  
    <img src="../../../_static/logo/mda_logo.png" class="logo" alt="Logo"/>
</a>


  
  
  
    <div class="version">
      2.8.0-dev0
    </div>
  



<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>
<div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
    <!-- <p class="caption" role="heading"></p> -->
    <ul>
        
        <li class="toctree-l1"><a class="reference internal" href="http://mdanalysis.org">MDAnalysis</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="http://userguide.mdanalysis.org">User guide</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="https://mdakits.mdanalysis.org/">MDAKits</a></li>
        
    </ul>
    
        <p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/converters.html">7. Converter modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/trajectory_transformations.html">8. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections_modules.html">9. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/auxiliary_modules.html">10. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/core_modules.html">11. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/visualization_modules.html">12. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/lib_modules.html">13. Library functions — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/version.html">14. Version information for MDAnalysis - <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/units.html">15. Constants and unit conversion — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/exceptions.html">16. Custom exceptions and warnings — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/references.html">17. References</a></li>
</ul>

</div>

      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MDAnalysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">MDAnalysis.lib.util</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MDAnalysis.lib.util</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1"># doi: 10.25080/majora-629e541a-00e</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Helper functions --- :mod:`MDAnalysis.lib.util`</span>
<span class="sd">====================================================</span>

<span class="sd">Small helper functions that don&#39;t fit anywhere else.</span>

<span class="sd">.. versionchanged:: 0.11.0</span>
<span class="sd">   Moved mathematical functions into lib.mdamath</span>

<span class="sd">.. versionchanged::2.0.0</span>
<span class="sd">   The following aliases, that existed for compatibility with python versions</span>
<span class="sd">   older than 3.6, were removed: `callable` for the built-in of the same name,</span>
<span class="sd">   `PathLike` for :class:`os.PathLike`, and `bz_open` for :func:`bz2.open`.</span>


<span class="sd">Files and directories</span>
<span class="sd">---------------------</span>

<span class="sd">.. autofunction:: filename</span>
<span class="sd">.. autofunction:: openany</span>
<span class="sd">.. autofunction:: anyopen</span>
<span class="sd">.. autofunction:: greedy_splitext</span>
<span class="sd">.. autofunction:: which</span>
<span class="sd">.. autofunction:: realpath</span>
<span class="sd">.. autofunction:: get_ext</span>
<span class="sd">.. autofunction:: check_compressed_format</span>
<span class="sd">.. autofunction:: format_from_filename_extension</span>
<span class="sd">.. autofunction:: guess_format</span>

<span class="sd">Streams</span>
<span class="sd">-------</span>

<span class="sd">Many of the readers are not restricted to just reading files. They can</span>
<span class="sd">also use gzip-compressed or bzip2-compressed files (through the</span>
<span class="sd">internal use of :func:`openany`). It is also possible to provide more</span>
<span class="sd">general streams as inputs, such as a :class:`io.StringIO`</span>
<span class="sd">instances (essentially, a memory buffer) by wrapping these instances</span>
<span class="sd">into a :class:`NamedStream`. This :class:`NamedStream` can then be</span>
<span class="sd">used in place of an ordinary file name (typically, with a</span>
<span class="sd">class:`~MDAnalysis.core.universe.Universe` but it is also possible to</span>
<span class="sd">*write* to such a stream using :func:`MDAnalysis.Writer`).</span>

<span class="sd">.. rubric: Examples</span>

<span class="sd">In the following example, we use a PDB stored as a string ``pdb_s``::</span>

<span class="sd">   import MDAnalysis</span>
<span class="sd">   from MDAnalysis.lib.util import NamedStream</span>
<span class="sd">   from io import StringIO</span>

<span class="sd">   pdb_s = &quot;TITLE     Lonely Ion\\nATOM      1  NA  NA+     1      81.260  64.982  10.926  1.00  0.00\\n&quot;</span>
<span class="sd">   u = MDAnalysis.Universe(NamedStream(StringIO(pdb_s), &quot;ion.pdb&quot;))</span>
<span class="sd">   print(u)</span>
<span class="sd">   #  &lt;Universe with 1 atoms&gt;</span>
<span class="sd">   print(u.atoms.positions)</span>
<span class="sd">   # [[ 81.26000214  64.98200226  10.92599964]]</span>

<span class="sd">It is important to provide a proper pseudo file name with the correct extension</span>
<span class="sd">(&quot;.pdb&quot;) to :class:`NamedStream` because the file type recognition uses the</span>
<span class="sd">extension of the file name to determine the file format or alternatively</span>
<span class="sd">provide the ``format=&quot;pdb&quot;`` keyword argument to the</span>
<span class="sd">:class:`~MDAnalysis.core.universe.Universe`.</span>

<span class="sd">The use of streams becomes more interesting when MDAnalysis is used as glue</span>
<span class="sd">between different analysis packages and when one can arrange things so that</span>
<span class="sd">intermediate frames (typically in the PDB format) are not written to disk but</span>
<span class="sd">remain in memory via e.g. :class:`io.StringIO` buffers.</span>


<span class="sd">.. The following does *not* work because most readers need to</span>
<span class="sd">.. reopen files, which is not possible with http streams. Might</span>
<span class="sd">.. need to implement a buffer.</span>
<span class="sd">..</span>
<span class="sd">.. Read a test LAMMPS data file from the MDAnalysis repository::</span>
<span class="sd">..</span>
<span class="sd">..   import MDAnalysis</span>
<span class="sd">..   from MDAnalysis.lib.util import NamedStream</span>
<span class="sd">..   import urllib2</span>
<span class="sd">..   URI = &quot;https://mdanalysis.googlecode.com/git-history/develop/testsuite/MDAnalysisTests/data/mini.data&quot;</span>
<span class="sd">..   urldata = NamedStream(urllib2.urlopen(URI), &quot;mini.data&quot;)</span>
<span class="sd">..   u = MDAnalysis.Universe(urldata)</span>

<span class="sd">.. Note::  A remote connection created by :func:`urllib2.urlopen` is not seekable</span>
<span class="sd">           and therefore will often not work as an input. But try it...</span>

<span class="sd">.. autoclass:: NamedStream</span>
<span class="sd">   :members:</span>

<span class="sd">.. autofunction:: isstream</span>

<span class="sd">Containers and lists</span>
<span class="sd">--------------------</span>

<span class="sd">.. autofunction:: iterable</span>
<span class="sd">.. autofunction:: asiterable</span>
<span class="sd">.. autofunction:: hasmethod</span>
<span class="sd">.. autoclass:: Namespace</span>

<span class="sd">Arrays</span>
<span class="sd">------</span>

<span class="sd">.. autofunction:: unique_int_1d(values)</span>
<span class="sd">.. autofunction:: unique_rows</span>
<span class="sd">.. autofunction:: blocks_of</span>
<span class="sd">.. autofunction:: group_same_or_consecutive_integers</span>

<span class="sd">File parsing</span>
<span class="sd">------------</span>

<span class="sd">.. autoclass:: FORTRANReader</span>
<span class="sd">   :members:</span>
<span class="sd">.. autodata:: FORTRAN_format_regex</span>

<span class="sd">Data manipulation and handling</span>
<span class="sd">------------------------------</span>

<span class="sd">.. autofunction:: fixedwidth_bins</span>
<span class="sd">.. autofunction:: get_weights</span>
<span class="sd">.. autofunction:: ltruncate_int</span>
<span class="sd">.. autofunction:: flatten_dict</span>

<span class="sd">Strings</span>
<span class="sd">-------</span>

<span class="sd">.. autofunction:: convert_aa_code</span>
<span class="sd">.. autofunction:: parse_residue</span>
<span class="sd">.. autofunction:: conv_float</span>

<span class="sd">Class decorators</span>
<span class="sd">----------------</span>

<span class="sd">.. autofunction:: cached</span>
<span class="sd">.. autofunction:: store_init_arguments</span>

<span class="sd">Function decorators</span>
<span class="sd">-------------------</span>

<span class="sd">.. autofunction:: static_variables</span>
<span class="sd">.. autofunction:: warn_if_not_unique</span>
<span class="sd">.. autofunction:: check_coords</span>
<span class="sd">.. autofunction:: check_atomgroup_not_empty</span>

<span class="sd">Code management</span>
<span class="sd">---------------</span>

<span class="sd">.. autofunction:: deprecate</span>
<span class="sd">.. autoclass:: _Deprecate</span>
<span class="sd">.. autofunction:: dedent_docstring</span>

<span class="sd">Data format checks</span>
<span class="sd">------------------</span>

<span class="sd">.. autofunction:: check_box</span>

<span class="sd">.. Rubric:: Footnotes</span>

<span class="sd">.. [#NamedStreamClose] The reason why :meth:`NamedStream.close` does</span>
<span class="sd">   not close a stream by default (but just rewinds it to the</span>
<span class="sd">   beginning) is so that one can use the class :class:`NamedStream` as</span>
<span class="sd">   a drop-in replacement for file names, which are often re-opened</span>
<span class="sd">   (e.g. when the same file is used as a topology and coordinate file</span>
<span class="sd">   or when repeatedly iterating through a trajectory in some</span>
<span class="sd">   implementations). The ``close=True`` keyword can be supplied in</span>
<span class="sd">   order to make :meth:`NamedStream.close` actually close the</span>
<span class="sd">   underlying stream and ``NamedStream.close(force=True)`` will also</span>
<span class="sd">   close it.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s2">&quot;restructuredtext en&quot;</span>


<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">import</span> <span class="nn">bz2</span>
<span class="kn">import</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">import</span> <span class="nn">mmtf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">numpy.testing</span> <span class="kn">import</span> <span class="n">assert_equal</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">.picklable_file_io</span> <span class="kn">import</span> <span class="n">pickle_open</span><span class="p">,</span> <span class="n">bz2_pickle_open</span><span class="p">,</span> <span class="n">gzip_pickle_open</span>

<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="kn">import</span> <span class="n">StreamWarning</span><span class="p">,</span> <span class="n">DuplicateWarning</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">._cutil</span> <span class="kn">import</span> <span class="n">unique_int_1d</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;MDAnalysis not installed properly. &quot;</span>
                      <span class="s2">&quot;This can happen if your C extensions &quot;</span>
                      <span class="s2">&quot;have not been built.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">int_array_is_sorted</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="c1"># Empty arrays are sorted, I guess...</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">unique_int_1d_unsorted</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="n">values</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">indices</span><span class="p">)]</span>


<div class="viewcode-block" id="filename">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.filename">[docs]</a>
<span class="k">def</span> <span class="nf">filename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a new name that has suffix attached; replaces other extensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str or NamedStream</span>
<span class="sd">        filename; extension is replaced unless ``keep=True``;</span>
<span class="sd">        `name` can also be a :class:`NamedStream` (and its</span>
<span class="sd">        :attr:`NamedStream.name` will be changed accordingly)</span>
<span class="sd">    ext : None or str</span>
<span class="sd">        extension to use in the new filename</span>
<span class="sd">    keep : bool</span>
<span class="sd">        - ``False``: replace existing extension with `ext`;</span>
<span class="sd">        - ``True``: keep old extension if one existed</span>


<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Also permits :class:`NamedStream` to pass through.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ext</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">extsep</span><span class="p">):</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">extsep</span> <span class="o">+</span> <span class="n">ext</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">origext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">origext</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">newname</span> <span class="o">=</span> <span class="n">root</span> <span class="o">+</span> <span class="n">ext</span>
            <span class="k">if</span> <span class="n">isstream</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="n">name</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">newname</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">newname</span>
    <span class="k">return</span> <span class="n">name</span> <span class="k">if</span> <span class="n">isstream</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>



<div class="viewcode-block" id="openany">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.openany">[docs]</a>
<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">openany</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context manager for :func:`anyopen`.</span>

<span class="sd">    Open the `datasource` and close it when the context of the :keyword:`with`</span>
<span class="sd">    statement exits.</span>

<span class="sd">    `datasource` can be a filename or a stream (see :func:`isstream`). A stream</span>
<span class="sd">    is reset to its start if possible (via :meth:`~io.IOBase.seek` or</span>
<span class="sd">    :meth:`~cString.StringIO.reset`).</span>

<span class="sd">    The advantage of this function is that very different input sources</span>
<span class="sd">    (&quot;streams&quot;) can be used for a &quot;file&quot;, ranging from files on disk (including</span>
<span class="sd">    compressed files) to open file objects to sockets and strings---as long as</span>
<span class="sd">    they have a file-like interface.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    datasource : a file or a stream</span>
<span class="sd">    mode : {&#39;r&#39;, &#39;w&#39;} (optional)</span>
<span class="sd">        open in r(ead) or w(rite) mode</span>
<span class="sd">    reset : bool (optional)</span>
<span class="sd">        try to read (`mode` &#39;r&#39;) the stream from the start [``True``]</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Open a gzipped file and process it line by line::</span>

<span class="sd">        with openany(&quot;input.pdb.gz&quot;) as pdb:</span>
<span class="sd">            for line in pdb:</span>
<span class="sd">                if line.startswith(&#39;ATOM&#39;):</span>
<span class="sd">                    print(line)</span>

<span class="sd">    Open a URL and read it::</span>

<span class="sd">       import urllib2</span>
<span class="sd">       with openany(urllib2.urlopen(&quot;https://www.mdanalysis.org/&quot;)) as html:</span>
<span class="sd">           print(html.read())</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`anyopen`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">anyopen</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="n">reset</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">stream</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>



<div class="viewcode-block" id="anyopen">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.anyopen">[docs]</a>
<span class="k">def</span> <span class="nf">anyopen</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Open datasource (gzipped, bzipped, uncompressed) and return a stream.</span>

<span class="sd">    `datasource` can be a filename or a stream (see :func:`isstream`). By</span>
<span class="sd">    default, a stream is reset to its start if possible (via</span>
<span class="sd">    :meth:`~io.IOBase.seek` or :meth:`~cString.StringIO.reset`).</span>

<span class="sd">    If possible, the attribute ``stream.name`` is set to the filename or</span>
<span class="sd">    &quot;&lt;stream&gt;&quot; if no filename could be associated with the *datasource*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    datasource</span>
<span class="sd">        a file (from :class:`file` or :func:`open`) or a stream (e.g. from</span>
<span class="sd">        :func:`urllib2.urlopen` or :class:`io.StringIO`)</span>
<span class="sd">    mode: {&#39;r&#39;, &#39;w&#39;, &#39;a&#39;} (optional)</span>
<span class="sd">        Open in r(ead), w(rite) or a(ppend) mode. This string is directly</span>
<span class="sd">        passed to the file opening handler (either Python&#39;s openfe, bz2, or</span>
<span class="sd">        gzip). More complex modes are supported if the file opening handler</span>
<span class="sd">        supports it.</span>
<span class="sd">    reset: bool (optional)</span>
<span class="sd">        try to read (`mode` &#39;r&#39;) the stream from the start</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    file-like object</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`openany`</span>
<span class="sd">      to be used with the :keyword:`with` statement.</span>


<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Only returns the ``stream`` and tries to set ``stream.name = filename`` instead of the previous</span>
<span class="sd">       behavior to return a tuple ``(stream, filename)``.</span>

<span class="sd">    .. versionchanged:: 2.0.0</span>
<span class="sd">       New read handlers support pickle functionality</span>
<span class="sd">       if `datasource` is a filename.</span>
<span class="sd">       They return a custom picklable file stream in</span>
<span class="sd">       :class:`MDAnalysis.lib.picklable_file_io`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">read_handlers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bz2&#39;</span><span class="p">:</span> <span class="n">bz2_pickle_open</span><span class="p">,</span>
                     <span class="s1">&#39;gz&#39;</span><span class="p">:</span> <span class="n">gzip_pickle_open</span><span class="p">,</span>
                     <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="n">pickle_open</span><span class="p">}</span>
    <span class="n">write_handlers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bz2&#39;</span><span class="p">:</span> <span class="n">bz2</span><span class="o">.</span><span class="n">open</span><span class="p">,</span>
                      <span class="s1">&#39;gz&#39;</span><span class="p">:</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">,</span>
                      <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="nb">open</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">isstream</span><span class="p">(</span><span class="n">datasource</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">datasource</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># maybe that does not always work?</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;&lt;stream&gt;&quot;</span>
            <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">stream</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Stream </span><span class="si">{0}</span><span class="s2">: not guaranteed to be at the beginning.&quot;</span>
                                      <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span>
                                      <span class="n">category</span><span class="o">=</span><span class="n">StreamWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">datasource</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;bz2&#39;</span><span class="p">,</span> <span class="s1">&#39;gz&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>  <span class="c1"># file == &#39;&#39; should be last</span>
                <span class="n">openfunc</span> <span class="o">=</span> <span class="n">read_handlers</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="n">_get_stream</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">openfunc</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stream</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">stream</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EIO</span><span class="p">,</span> <span class="s2">&quot;Cannot open file or stream in mode=</span><span class="si">{mode!r}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">):</span>  <span class="c1"># append &#39;a&#39; not tested...</span>
        <span class="k">if</span> <span class="n">isstream</span><span class="p">(</span><span class="n">datasource</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">datasource</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># maybe that does not always work?</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;&lt;stream&gt;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">datasource</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">):</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;bz2&#39;</span><span class="p">,</span> <span class="s1">&#39;gz&#39;</span><span class="p">):</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># anything else but bz2 or gz is just a normal file</span>
            <span class="n">openfunc</span> <span class="o">=</span> <span class="n">write_handlers</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">openfunc</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stream</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EIO</span><span class="p">,</span> <span class="s2">&quot;Cannot open file or stream in mode=</span><span class="si">{mode!r}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Sorry, mode=</span><span class="si">{mode!r}</span><span class="s2"> is not implemented for </span><span class="si">{datasource!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">filename</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">pass</span>  <span class="c1"># can&#39;t set name (e.g. io.StringIO)</span>
    <span class="k">return</span> <span class="n">stream</span></div>



<span class="k">def</span> <span class="nf">_get_stream</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">openfunction</span><span class="o">=</span><span class="nb">open</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return open stream if *filename* can be opened with *openfunction* or else ``None``.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">openfunction</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="c1"># An exception might be raised due to two reasons, first the openfunction is unable to open the file, in this</span>
        <span class="c1"># case we have to ignore the error and return None. Second is when openfunction can&#39;t open the file because</span>
        <span class="c1"># either the file isn&#39;t there or the permissions don&#39;t allow access.</span>
        <span class="k">if</span> <span class="n">errno</span><span class="o">.</span><span class="n">errorcode</span><span class="p">[</span><span class="n">err</span><span class="o">.</span><span class="n">errno</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ENOENT&#39;</span><span class="p">,</span> <span class="s1">&#39;EACCES&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
        <span class="c1"># additional check for reading (eg can we uncompress) --- is this needed?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">openfunction</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stream</span>


<div class="viewcode-block" id="greedy_splitext">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.greedy_splitext">[docs]</a>
<span class="k">def</span> <span class="nf">greedy_splitext</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split extension in path *p* at the left-most separator.</span>

<span class="sd">    Extensions are taken to be separated from the filename with the</span>
<span class="sd">    separator :data:`os.extsep` (as used by :func:`os.path.splitext`).</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    p : str</span>
<span class="sd">       path</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (root, extension) : tuple</span>
<span class="sd">          where ``root`` is the full path and filename with all</span>
<span class="sd">          extensions removed whereas ``extension`` is the string of</span>
<span class="sd">          all extensions.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.util import greedy_splitext</span>
<span class="sd">    &gt;&gt;&gt; greedy_splitext(&quot;/home/joe/protein.pdb.bz2&quot;)</span>
<span class="sd">    (&#39;/home/joe/protein&#39;, &#39;.pdb.bz2&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span><span class="p">,</span> <span class="n">root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">extension</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">extension</span> <span class="o">=</span> <span class="n">ext</span> <span class="o">+</span> <span class="n">extension</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">root</span><span class="p">),</span> <span class="n">extension</span></div>



<div class="viewcode-block" id="hasmethod">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.hasmethod">[docs]</a>
<span class="k">def</span> <span class="nf">hasmethod</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return ``True`` if object *obj* contains the method *m*.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span></div>



<div class="viewcode-block" id="isstream">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.isstream">[docs]</a>
<span class="k">def</span> <span class="nf">isstream</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Detect if `obj` is a stream.</span>

<span class="sd">    We consider anything a stream that has the methods</span>

<span class="sd">    - ``close()``</span>

<span class="sd">    and either set of the following</span>

<span class="sd">    - ``read()``, ``readline()``, ``readlines()``</span>
<span class="sd">    - ``write()``, ``writeline()``, ``writelines()``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : stream or str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        ``True`` if `obj` is a stream, ``False`` otherwise</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :mod:`io`</span>


<span class="sd">    .. versionadded:: 0.9.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature_methods</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;close&quot;</span><span class="p">,)</span>
    <span class="n">alternative_methods</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="s2">&quot;read&quot;</span><span class="p">,</span> <span class="s2">&quot;readline&quot;</span><span class="p">,</span> <span class="s2">&quot;readlines&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;write&quot;</span><span class="p">,</span> <span class="s2">&quot;writeline&quot;</span><span class="p">,</span> <span class="s2">&quot;writelines&quot;</span><span class="p">))</span>

    <span class="c1"># Must have ALL the signature methods</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">signature_methods</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hasmethod</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># Must have at least one complete set of alternative_methods</span>
    <span class="n">alternative_results</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">hasmethod</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">alternatives</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">alternatives</span> <span class="ow">in</span> <span class="n">alternative_methods</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">alternative_results</span><span class="p">)</span></div>



<div class="viewcode-block" id="which">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.which">[docs]</a>
<span class="k">def</span> <span class="nf">which</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine full path of executable `program` on :envvar:`PATH`.</span>

<span class="sd">    (Jay at http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    programe : str</span>
<span class="sd">       name of the executable</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    path : str or None</span>
<span class="sd">       absolute path to the executable if it can be found, else ``None``</span>


<span class="sd">    .. deprecated:: 2.7.0</span>
<span class="sd">       This method is deprecated and will be removed in version 3.0.0.</span>
<span class="sd">       Please use shutil.which instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Can&#39;t use decorator because it&#39;s declared after this method</span>
    <span class="n">wmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;This method is deprecated as of MDAnalysis version 2.7.0 &quot;</span>
            <span class="s2">&quot;and will be removed in version 3.0.0. Please use shutil.which &quot;</span>
            <span class="s2">&quot;instead.&quot;</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">wmsg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_exe</span><span class="p">(</span><span class="n">fpath</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">X_OK</span><span class="p">)</span>

    <span class="n">fpath</span><span class="p">,</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fpath</span><span class="p">:</span>
        <span class="n">real_program</span> <span class="o">=</span> <span class="n">realpath</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_exe</span><span class="p">(</span><span class="n">real_program</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">real_program</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;PATH&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">pathsep</span><span class="p">):</span>
            <span class="n">exe_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">program</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_exe</span><span class="p">(</span><span class="n">exe_file</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exe_file</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="NamedStream">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream">[docs]</a>
<span class="nd">@functools</span><span class="o">.</span><span class="n">total_ordering</span>
<span class="k">class</span> <span class="nc">NamedStream</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">IOBase</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Stream that also provides a (fake) name.</span>

<span class="sd">    By wrapping a stream `stream` in this class, it can be passed to</span>
<span class="sd">    code that uses inspection of the filename to make decisions. For</span>
<span class="sd">    instance. :func:`os.path.split` will work correctly on a</span>
<span class="sd">    :class:`NamedStream`.</span>

<span class="sd">    The class can be used as a context manager.</span>

<span class="sd">    :class:`NamedStream` is derived from :class:`io.IOBase` (to indicate that</span>
<span class="sd">    it is a stream). Many operations that normally expect a string will also</span>
<span class="sd">    work with a :class:`NamedStream`; for instance, most of the functions in</span>
<span class="sd">    :mod:`os.path` will work with the exception of :func:`os.path.expandvars`</span>
<span class="sd">    and :func:`os.path.expanduser`, which will return the :class:`NamedStream`</span>
<span class="sd">    itself instead of a string if no substitutions were made.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Wrap a :class:`io.StringIO` instance to write to::</span>

<span class="sd">      from io import StringIO</span>
<span class="sd">      import os.path</span>
<span class="sd">      stream = StringIO()</span>
<span class="sd">      f = NamedStream(stream, &quot;output.pdb&quot;)</span>
<span class="sd">      print(os.path.splitext(f))</span>

<span class="sd">    Wrap a :class:`file` instance to read from::</span>

<span class="sd">      stream = open(&quot;input.pdb&quot;)</span>
<span class="sd">      f = NamedStream(stream, stream.name)</span>

<span class="sd">    Use as a context manager (closes stream automatically when the</span>
<span class="sd">    :keyword:`with` block is left)::</span>

<span class="sd">      with NamedStream(open(&quot;input.pdb&quot;), &quot;input.pdb&quot;) as f:</span>
<span class="sd">         # use f</span>
<span class="sd">         print f.closed  # --&gt; False</span>
<span class="sd">         # ...</span>
<span class="sd">      print f.closed     # --&gt; True</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This class uses its own :meth:`__getitem__` method so if `stream`</span>
<span class="sd">    implements :meth:`stream.__getitem__` then that will be masked and</span>
<span class="sd">    this class should not be used.</span>

<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    By default, :meth:`NamedStream.close` will **not close the</span>
<span class="sd">    stream** but instead :meth:`~NamedStream.reset` it to the</span>
<span class="sd">    beginning. [#NamedStreamClose]_ Provide the ``force=True`` keyword</span>
<span class="sd">    to :meth:`NamedStream.close` to always close the stream.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">close</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the :class:`NamedStream` from a `stream` and give it a `name`.</span>

<span class="sd">        The constructor attempts to rewind the stream to the beginning unless</span>
<span class="sd">        the keyword `reset` is set to ``False``. If rewinding fails, a</span>
<span class="sd">        :class:`MDAnalysis.StreamWarning` is issued.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : stream</span>
<span class="sd">            an open stream (e.g. :class:`file` or :class:`io.StringIO`)</span>
<span class="sd">        filename : str</span>
<span class="sd">            the filename that should be associated with the stream</span>
<span class="sd">        reset : bool (optional)</span>
<span class="sd">            start the stream from the beginning (either :meth:`reset` or :meth:`seek`)</span>
<span class="sd">            when the class instance is constructed</span>
<span class="sd">        close : bool (optional)</span>
<span class="sd">            close the stream when a :keyword:`with` block exits or when</span>
<span class="sd">            :meth:`close` is called; note that the default is **not to close</span>
<span class="sd">            the stream**</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        By default, this stream will *not* be closed by :keyword:`with` and</span>
<span class="sd">        :meth:`close` (see there) unless the `close` keyword is set to</span>
<span class="sd">        ``True``.</span>


<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># constructing the class from an instance of itself has weird behavior</span>
        <span class="c1"># on __del__ and super on python 3. Let&#39;s warn the user and ensure the</span>
        <span class="c1"># class works normally.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">NamedStream</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Constructed NamedStream from a NamedStream&quot;</span><span class="p">,</span>
                          <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">stream</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_stream</span> <span class="o">=</span> <span class="n">close</span>
        <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

<div class="viewcode-block" id="NamedStream.reset">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.reset">[docs]</a>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move to the beginning of the stream&quot;&quot;&quot;</span>
        <span class="c1"># try to rewind</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>  <span class="c1"># e.g. StreamIO</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># typical file objects</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;NamedStream </span><span class="si">{0}</span><span class="s2">: not guaranteed to be at the beginning.&quot;</span>
                              <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                              <span class="n">category</span><span class="o">=</span><span class="n">StreamWarning</span><span class="p">)</span></div>


    <span class="c1"># access the stream</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># do not call the stream&#39;s __enter__ because the stream is already open</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c1"># NOTE: By default (close=False) we only reset the stream and NOT close it; this makes</span>
        <span class="c1">#       it easier to use it as a drop-in replacement for a filename that might</span>
        <span class="c1">#       be opened repeatedly (at least in MDAnalysis)</span>
        <span class="c1">#try:</span>
        <span class="c1">#    return self.stream.__exit__(*args)</span>
        <span class="c1">#except AttributeError:</span>
        <span class="c1">#    super(NamedStream, self).__exit__(*args)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__fspath__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="c1"># override more IOBase methods, as these are provided by IOBase and are not</span>
    <span class="c1"># caught with __getattr__ (ugly...)</span>
<div class="viewcode-block" id="NamedStream.close">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.close">[docs]</a>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset or close the stream.</span>

<span class="sd">        If :attr:`NamedStream.close_stream` is set to ``False`` (the default)</span>
<span class="sd">        then this method will *not close the stream* and only :meth:`reset` it.</span>

<span class="sd">        If the *force* = ``True`` keyword is provided, the stream will be</span>
<span class="sd">        closed.</span>

<span class="sd">        .. Note:: This ``close()`` method is non-standard. ``del NamedStream``</span>
<span class="sd">                  always closes the underlying stream.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">close_stream</span> <span class="ow">or</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Always closes the stream.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;``True`` if stream is closed.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">closed</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">closed</span>

<div class="viewcode-block" id="NamedStream.seek">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.seek">[docs]</a>
    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">SEEK_SET</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change the stream position to the given byte `offset` .</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset : int</span>
<span class="sd">             `offset` is interpreted relative to the position</span>
<span class="sd">             indicated by `whence`.</span>
<span class="sd">        whence : {0, 1, 2} (optional)</span>
<span class="sd">             Values for `whence` are:</span>

<span class="sd">               - :data:`io.SEEK_SET` or 0 – start of the stream (the default); `offset`</span>
<span class="sd">                 should be zero or positive</span>
<span class="sd">               - :data:`io.SEEK_CUR` or 1 – current stream position; `offset` may be</span>
<span class="sd">                 negative</span>
<span class="sd">               - :data:`io.SEEK_END` or 2 – end of the stream; `offset` is usually</span>
<span class="sd">                 negative</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            the new absolute position in bytes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>  <span class="c1"># file.seek: no kw</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span></div>


<div class="viewcode-block" id="NamedStream.tell">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.tell">[docs]</a>
    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the current stream position.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span></div>


<div class="viewcode-block" id="NamedStream.truncate">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.truncate">[docs]</a>
    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Truncate the stream&#39;s size to `size`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : int (optional)</span>
<span class="sd">             The `size` defaults to the current position (if no `size` argument</span>
<span class="sd">             is supplied). The current file position is not changed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="NamedStream.seekable">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.seekable">[docs]</a>
    <span class="k">def</span> <span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``True`` if the stream supports random access.</span>

<span class="sd">        If ``False``, :meth:`seek`, :meth:`tell` and :meth:`truncate` will</span>
<span class="sd">        raise :exc:`IOError`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seekable</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">seekable</span><span class="p">()</span></div>


<div class="viewcode-block" id="NamedStream.readable">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.readable">[docs]</a>
    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``True`` if the stream can be read from.</span>

<span class="sd">        If ``False``, :meth:`read` will raise :exc:`IOError`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">readable</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">readable</span><span class="p">()</span></div>


<div class="viewcode-block" id="NamedStream.writable">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.writable">[docs]</a>
    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``True`` if the stream can be written to.</span>

<span class="sd">        If ``False``, :meth:`write` will raise :exc:`IOError`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">writable</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">writable</span><span class="p">()</span></div>


<div class="viewcode-block" id="NamedStream.flush">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.flush">[docs]</a>
    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flush the write buffers of the stream if applicable.</span>

<span class="sd">        This does nothing for read-only and non-blocking streams. For file</span>
<span class="sd">        objects one also needs to call :func:`os.fsync` to write contents to</span>
<span class="sd">        disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></div>


<div class="viewcode-block" id="NamedStream.fileno">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.fileno">[docs]</a>
    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the underlying file descriptor (an integer) of the stream if it exists.</span>

<span class="sd">        An :exc:`IOError` is raised if the IO object does not use a file descriptor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># IOBase.fileno does not raise IOError as advertised so we do this here</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;This NamedStream does not use a file descriptor.&quot;</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="NamedStream.readline">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.readline">[docs]</a>
    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span></div>


    <span class="c1"># fake the important parts of the string API</span>
    <span class="c1"># (other methods such as rfind() are automatically dealt with via __getattr__)</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">x</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">x</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">x</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">x</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">*</span> <span class="n">x</span>

    <span class="fm">__rmul__</span> <span class="o">=</span> <span class="fm">__mul__</span>

    <span class="k">def</span> <span class="fm">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">format_spec</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;NamedStream(</span><span class="si">{0}</span><span class="s2">, </span><span class="si">{1}</span><span class="s2">)&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>



<div class="viewcode-block" id="realpath">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.realpath">[docs]</a>
<span class="k">def</span> <span class="nf">realpath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Join all args and return the real path, rooted at ``/``.</span>

<span class="sd">    Expands &#39;~&#39;, &#39;~user&#39;, and environment variables such as :envvar:`$HOME`.</span>

<span class="sd">    Returns ``None`` if any of the args is ``None``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expandvars</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))))</span></div>



<div class="viewcode-block" id="get_ext">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.get_ext">[docs]</a>
<span class="k">def</span> <span class="nf">get_ext</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the lower-cased extension of `filename` without a leading dot.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    root : str</span>
<span class="sd">    ext : str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">extsep</span><span class="p">):</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">return</span> <span class="n">root</span><span class="p">,</span> <span class="n">ext</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span></div>



<div class="viewcode-block" id="check_compressed_format">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.check_compressed_format">[docs]</a>
<span class="k">def</span> <span class="nf">check_compressed_format</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if this is a supported gzipped/bzip2ed file format and return UPPERCASE format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    root : str</span>
<span class="sd">       path of a file, without extension `ext`</span>
<span class="sd">    ext : str</span>
<span class="sd">       extension (currently only &quot;bz2&quot; and &quot;gz&quot; are recognized as compressed formats)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    format : str</span>
<span class="sd">       upper case format extension *if* the compression can be handled by</span>
<span class="sd">       :func:`openany`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    openany : function that is used to open and decompress formats on the fly; only</span>
<span class="sd">              compression formats implemented in :func:`openany` are recognized</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># XYZReader&amp;others are setup to handle both plain and compressed (bzip2, gz) files</span>
    <span class="c1"># ..so if the first file extension is bzip2 or gz, look at the one to the left of it</span>
    <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">,</span> <span class="s2">&quot;gz&quot;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">get_ext</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Cannot determine coordinate format for &#39;</span><span class="si">{</span><span class="n">root</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">ext</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span></div>



<div class="viewcode-block" id="format_from_filename_extension">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.format_from_filename_extension">[docs]</a>
<span class="k">def</span> <span class="nf">format_from_filename_extension</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Guess file format from the file extension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    format : str</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        if the file format cannot be determined</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">get_ext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot determine file format for file &#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&#39;.</span><span class="se">\n</span><span class="s2">&quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;           You can set the format explicitly with &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;&#39;Universe(..., format=FORMAT)&#39;.&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
    <span class="nb">format</span> <span class="o">=</span> <span class="n">check_compressed_format</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">format</span></div>



<div class="viewcode-block" id="guess_format">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.guess_format">[docs]</a>
<span class="k">def</span> <span class="nf">guess_format</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the format of `filename`</span>

<span class="sd">    The current heuristic simply looks at the filename extension and can work</span>
<span class="sd">    around compressed format extensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str or stream</span>
<span class="sd">        path to the file or a stream, in which case ``filename.name`` is looked</span>
<span class="sd">        at for a hint to the format</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    format : str</span>
<span class="sd">        format specifier (upper case)</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        if the heuristics are insufficient to guess a supported format</span>


<span class="sd">    .. versionadded:: 0.11.0</span>
<span class="sd">       Moved into lib.util</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">isstream</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="c1"># perhaps StringIO or open stream</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="n">format_from_filename_extension</span><span class="p">(</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># format is None so we need to complain:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;guess_format requires an explicit format specifier &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;for stream </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># iterator, list, filename: simple extension checking... something more</span>
        <span class="c1"># complicated is left for the ambitious.</span>
        <span class="c1"># Note: at the moment the upper-case extension *is* the format specifier</span>
        <span class="c1"># and list of filenames is handled by ChainReader</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="p">(</span><span class="n">format_from_filename_extension</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                  <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;CHAIN&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span></div>



<div class="viewcode-block" id="iterable">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.iterable">[docs]</a>
<span class="k">def</span> <span class="nf">iterable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns ``True`` if `obj` can be iterated over and is *not* a  string</span>
<span class="sd">    nor a :class:`NamedStream`&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">NamedStream</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># avoid iterating over characters of a string</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;next&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># any iterator will do</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c1"># anything else that might work</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="asiterable">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.asiterable">[docs]</a>
<span class="k">def</span> <span class="nf">asiterable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns `obj` so that it can be iterated over.</span>

<span class="sd">    A string is *not* detected as and iterable and is wrapped into a :class:`list`</span>
<span class="sd">    with a single element.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    iterable</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">obj</span></div>



<span class="c1">#: Regular expresssion (see :mod:`re`) to parse a simple `FORTRAN edit descriptor`_.</span>
<span class="c1">#: ``(?P&lt;repeat&gt;\d?)(?P&lt;format&gt;[IFELAX])(?P&lt;numfmt&gt;(?P&lt;length&gt;\d+)(\.(?P&lt;decimals&gt;\d+))?)?``</span>
<span class="c1">#:</span>
<span class="c1">#: .. _FORTRAN edit descriptor: http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/chap05/format.html</span>
<span class="n">FORTRAN_format_regex</span> <span class="o">=</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;repeat&gt;\d+?)(?P&lt;format&gt;[IFEAX])&quot;</span>
                        <span class="sa">r</span><span class="s2">&quot;(?P&lt;numfmt&gt;(?P&lt;length&gt;\d+)(\.(?P&lt;decimals&gt;\d+))?)?&quot;</span><span class="p">)</span>
<span class="n">_FORTRAN_format_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">FORTRAN_format_regex</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert `s` to a string and return it white-space stripped.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">FixedcolumnEntry</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represent an entry at specific fixed columns.</span>

<span class="sd">    Reads from line[start:stop] and converts according to</span>
<span class="sd">    typespecifier.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">convertors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">strip</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">typespecifier</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int</span>
<span class="sd">            first column</span>
<span class="sd">        stop : int</span>
<span class="sd">            last column + 1</span>
<span class="sd">        typespecifier : str</span>
<span class="sd">            &#39;I&#39;: int, &#39;F&#39;: float, &#39;E&#39;: float, &#39;A&#39;: stripped string</span>

<span class="sd">        The start/stop arguments follow standard Python convention in that</span>
<span class="sd">        they are 0-based and that the *stop* argument is not included.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typespecifier</span> <span class="o">=</span> <span class="n">typespecifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convertor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertors</span><span class="p">[</span><span class="n">typespecifier</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the entry from `line` and convert to appropriate type.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertor</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">: Failed to read&amp;convert &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">line</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Length of the field in columns (stop - start)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;FixedcolumnEntry(</span><span class="si">{0:d}</span><span class="s2">,</span><span class="si">{1:d}</span><span class="s2">,</span><span class="si">{2!r}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typespecifier</span><span class="p">)</span>


<div class="viewcode-block" id="FORTRANReader">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.FORTRANReader">[docs]</a>
<span class="k">class</span> <span class="nc">FORTRANReader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;FORTRANReader provides a method to parse FORTRAN formatted lines in a file.</span>

<span class="sd">    The contents of lines in a file can be parsed according to FORTRAN format</span>
<span class="sd">    edit descriptors (see `Fortran Formats`_ for the syntax).</span>

<span class="sd">    Only simple one-character specifiers supported here: *I F E A X* (see</span>
<span class="sd">    :data:`FORTRAN_format_regex`).</span>

<span class="sd">    Strings are stripped of leading and trailing white space.</span>

<span class="sd">    .. _`Fortran Formats`: http://www.webcitation.org/5xbaWMV2x</span>
<span class="sd">    .. _`Fortran Formats (URL)`:</span>
<span class="sd">       http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/chap05/format.html</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up the reader with the FORTRAN format string.</span>

<span class="sd">        The string `fmt` should look like &#39;2I10,2X,A8,2X,A8,3F20.10,2X,A8,2X,A8,F20.10&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fmt : str</span>
<span class="sd">           FORTRAN format edit descriptor for a line as described in `Fortran</span>
<span class="sd">           Formats`_</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        Parsing of a standard CRD file::</span>

<span class="sd">           atomformat = FORTRANReader(&#39;2I10,2X,A8,2X,A8,3F20.10,2X,A8,2X,A8,F20.10&#39;)</span>
<span class="sd">           for line in open(&#39;coordinates.crd&#39;):</span>
<span class="sd">               serial,TotRes,resName,name,x,y,z,chainID,resSeq,tempFactor = atomformat.read(line)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="n">descriptors</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_FORTRAN_format</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span> <span class="k">for</span> <span class="n">descriptor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">descriptors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;format&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;repeat&#39;</span><span class="p">]):</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FixedcolumnEntry</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;format&#39;</span><span class="p">]))</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;totallength&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="FORTRANReader.read">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.FORTRANReader.read">[docs]</a>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse `line` according to the format string and return list of values.</span>

<span class="sd">        Values are converted to Python types according to the format specifier.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        line : str</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of entries with appropriate types</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Any of the conversions cannot be made (e.g. space for an int)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`FORTRANReader.number_of_matches`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries</span><span class="p">]</span></div>


<div class="viewcode-block" id="FORTRANReader.number_of_matches">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.FORTRANReader.number_of_matches">[docs]</a>
    <span class="k">def</span> <span class="nf">number_of_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return how many format entries could be populated with legal values.&quot;&quot;&quot;</span>
        <span class="c1"># not optimal, I suppose...</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">matches</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">matches</span></div>


<div class="viewcode-block" id="FORTRANReader.parse_FORTRAN_format">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.FORTRANReader.parse_FORTRAN_format">[docs]</a>
    <span class="k">def</span> <span class="nf">parse_FORTRAN_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edit_descriptor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the descriptor.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edit_descriptor : str</span>
<span class="sd">            FORTRAN format edit descriptor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            dict with totallength (in chars), repeat, length, format, decimals</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            The `edit_descriptor` is not recognized and cannot be parsed</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Specifiers: *L ES EN T TL TR / r S SP SS BN BZ* are *not* supported,</span>
<span class="sd">        and neither are the scientific notation *Ew.dEe* forms.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">_FORTRAN_format_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">edit_descriptor</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">_FORTRAN_format_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;1&quot;</span> <span class="o">+</span> <span class="n">edit_descriptor</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>  <span class="c1"># really no idea what the descriptor is supposed to mean</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unrecognized FORTRAN format </span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edit_descriptor</span><span class="p">))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;repeat&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;repeat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;format&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;repeat&#39;</span><span class="p">,</span> <span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="s1">&#39;decimals&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># catches &#39;&#39;</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># keep None</span>
                <span class="k">pass</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;totallength&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;repeat&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span></div>


    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns number of entries.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entries</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span></div>



<div class="viewcode-block" id="fixedwidth_bins">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.fixedwidth_bins">[docs]</a>
<span class="k">def</span> <span class="nf">fixedwidth_bins</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return bins of width `delta` that cover `xmin`, `xmax` (or a larger range).</span>

<span class="sd">    The bin parameters are computed such that the bin size `delta` is</span>
<span class="sd">    guaranteed. In order to achieve this, the range `[xmin, xmax]` can be</span>
<span class="sd">    increased.</span>

<span class="sd">    Bins can be calculated for 1D data (then all parameters are simple floats)</span>
<span class="sd">    or nD data (then parameters are supplied as arrays, with each entry</span>
<span class="sd">    correpsonding to one dimension).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    delta : float or array_like</span>
<span class="sd">        desired spacing of the bins</span>
<span class="sd">    xmin : float or array_like</span>
<span class="sd">        lower bound (left boundary of first bin)</span>
<span class="sd">    xmax : float or array_like</span>
<span class="sd">        upper bound (right boundary of last bin)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        The dict contains &#39;Nbins&#39;, &#39;delta&#39;, &#39;min&#39;, and &#39;max&#39;; these are either</span>
<span class="sd">        floats or arrays, depending on the input.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Use with :func:`numpy.histogram`::</span>

<span class="sd">       B = fixedwidth_bins(delta, xmin, xmax)</span>
<span class="sd">       h, e = np.histogram(data, bins=B[&#39;Nbins&#39;], range=(B[&#39;min&#39;], B[&#39;max&#39;]))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">xmin</span> <span class="o">&lt;</span> <span class="n">xmax</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Boundaries are not sane: should be xmin &lt; xmax.&#39;</span><span class="p">)</span>
    <span class="n">_delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">_xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">_xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">_length</span> <span class="o">=</span> <span class="n">_xmax</span> <span class="o">-</span> <span class="n">_xmin</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">_length</span> <span class="o">/</span> <span class="n">_delta</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>  <span class="c1"># number of bins</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">_delta</span> <span class="o">-</span> <span class="n">_length</span><span class="p">)</span>  <span class="c1"># add half of the excess to each end</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;Nbins&#39;</span><span class="p">:</span> <span class="n">N</span><span class="p">,</span> <span class="s1">&#39;delta&#39;</span><span class="p">:</span> <span class="n">_delta</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="n">_xmin</span> <span class="o">-</span> <span class="n">dx</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="n">_xmax</span> <span class="o">+</span> <span class="n">dx</span><span class="p">}</span></div>


<div class="viewcode-block" id="get_weights">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.get_weights">[docs]</a>
<span class="k">def</span> <span class="nf">get_weights</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check that a `weights` argument is compatible with `atoms`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    atoms : AtomGroup or array_like</span>
<span class="sd">        The atoms that the `weights` should be applied to. Typically this</span>
<span class="sd">        is a :class:`AtomGroup` but because only the length is compared,</span>
<span class="sd">        any sequence for which ``len(atoms)`` is defined is acceptable.</span>
<span class="sd">    weights : {&quot;mass&quot;, None} or array_like</span>
<span class="sd">        All MDAnalysis functions or classes understand &quot;mass&quot; and will then</span>
<span class="sd">        use ``atoms.masses``. ``None`` indicates equal weights for all atoms.</span>
<span class="sd">        Using an ``array_like`` assigns a custom weight to each element of</span>
<span class="sd">        `atoms`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weights : array_like or None</span>
<span class="sd">         If &quot;mass&quot; was selected, ``atoms.masses`` is returned, otherwise the</span>
<span class="sd">         value of `weights` (which can be ``None``).</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If `weights` is not one of the allowed values or if &quot;mass&quot; is</span>
<span class="sd">        selected but ``atoms.masses`` is not available.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `weights` is not a 1D array with the same length as</span>
<span class="sd">        `atoms`, then the exception is raised.  :exc:`TypeError` is</span>
<span class="sd">        also raised if ``atoms.masses`` is not defined.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="ow">and</span> <span class="n">weights</span> <span class="o">==</span> <span class="s2">&quot;mass&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">masses</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;weights=&#39;mass&#39; selected but atoms.masses is missing&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weights must be a 1D array, not with shape &quot;</span>
                            <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span>
                             <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weights (length </span><span class="si">{0}</span><span class="s2">) must be of same length as &quot;</span>
                             <span class="s2">&quot;the atoms (</span><span class="si">{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                 <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weights must be {&#39;mass&#39;, None} or an iterable of the &quot;</span>
                         <span class="s2">&quot;same size as the atomgroup.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">weights</span></div>



<span class="c1"># String functions</span>
<span class="c1"># ----------------</span>

<span class="c1">#: translation table for 3-letter codes --&gt; 1-letter codes</span>
<span class="c1">#: .. SeeAlso:: :data:`alternative_inverse_aa_codes`</span>
<span class="n">canonical_inverse_aa_codes</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;ALA&#39;</span><span class="p">:</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;CYS&#39;</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;ASP&#39;</span><span class="p">:</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;GLU&#39;</span><span class="p">:</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span>
    <span class="s1">&#39;PHE&#39;</span><span class="p">:</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;GLY&#39;</span><span class="p">:</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;HIS&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;ILE&#39;</span><span class="p">:</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span>
    <span class="s1">&#39;LYS&#39;</span><span class="p">:</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;LEU&#39;</span><span class="p">:</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;MET&#39;</span><span class="p">:</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;ASN&#39;</span><span class="p">:</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span>
    <span class="s1">&#39;PRO&#39;</span><span class="p">:</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;GLN&#39;</span><span class="p">:</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="s1">&#39;ARG&#39;</span><span class="p">:</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;SER&#39;</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">,</span>
    <span class="s1">&#39;THR&#39;</span><span class="p">:</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;VAL&#39;</span><span class="p">:</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;TRP&#39;</span><span class="p">:</span> <span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="s1">&#39;TYR&#39;</span><span class="p">:</span> <span class="s1">&#39;Y&#39;</span><span class="p">}</span>
<span class="c1">#: translation table for 1-letter codes --&gt; *canonical* 3-letter codes.</span>
<span class="c1">#: The table is used for :func:`convert_aa_code`.</span>
<span class="n">amino_acid_codes</span> <span class="o">=</span> <span class="p">{</span><span class="n">one</span><span class="p">:</span> <span class="n">three</span> <span class="k">for</span> <span class="n">three</span><span class="p">,</span>
                    <span class="n">one</span> <span class="ow">in</span> <span class="n">canonical_inverse_aa_codes</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="c1">#: non-default charge state amino acids or special charge state descriptions</span>
<span class="c1">#: (Not fully synchronized with :class:`MDAnalysis.core.selection.ProteinSelection`.)</span>
<span class="n">alternative_inverse_aa_codes</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;HISA&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;HISB&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;HSE&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;HSD&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;HID&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;HIE&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;HIS1&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span>
    <span class="s1">&#39;HIS2&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ASPH&#39;</span><span class="p">:</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;ASH&#39;</span><span class="p">:</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span>
    <span class="s1">&#39;GLUH&#39;</span><span class="p">:</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;GLH&#39;</span><span class="p">:</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span>
    <span class="s1">&#39;LYSH&#39;</span><span class="p">:</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;LYN&#39;</span><span class="p">:</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ARGN&#39;</span><span class="p">:</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span>
    <span class="s1">&#39;CYSH&#39;</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;CYS1&#39;</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;CYS2&#39;</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">}</span>
<span class="c1">#: lookup table from 3/4 letter resnames to 1-letter codes. Note that non-standard residue names</span>
<span class="c1">#: for tautomers or different protonation states such as HSE are converted to canonical 1-letter codes (&quot;H&quot;).</span>
<span class="c1">#: The table is used for :func:`convert_aa_code`.</span>
<span class="c1">#: .. SeeAlso:: :data:`canonical_inverse_aa_codes` and :data:`alternative_inverse_aa_codes`</span>
<span class="n">inverse_aa_codes</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">inverse_aa_codes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">canonical_inverse_aa_codes</span><span class="p">)</span>
<span class="n">inverse_aa_codes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">alternative_inverse_aa_codes</span><span class="p">)</span>


<div class="viewcode-block" id="convert_aa_code">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.convert_aa_code">[docs]</a>
<span class="k">def</span> <span class="nf">convert_aa_code</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converts between 3-letter and 1-letter amino acid codes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : str</span>
<span class="sd">        1-letter or 3-letter amino acid code</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        3-letter or 1-letter amino acid code</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        No conversion can be made; the amino acid code is not defined.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Data are defined in :data:`amino_acid_codes` and :data:`inverse_aa_codes`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">amino_acid_codes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">inverse_aa_codes</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No conversion for </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> found (1 letter -&gt; 3 letter or 3/4 &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;letter -&gt; 1 letter)&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span></div>



<span class="c1">#: Regular expression to match and parse a residue-atom selection; will match</span>
<span class="c1">#: &quot;LYS300:HZ1&quot; or &quot;K300:HZ1&quot; or &quot;K300&quot; or &quot;4GB300:H6O&quot; or &quot;4GB300&quot; or &quot;YaA300&quot;.</span>
<span class="n">RESIDUE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                 (?P&lt;aa&gt;([ACDEFGHIKLMNPQRSTVWY])   # 1-letter amino acid</span>
<span class="s2">                        |                          #   or</span>
<span class="s2">                        ([0-9A-Z][a-zA-Z][A-Z][A-Z]?)    # 3-letter or 4-letter residue name</span>
<span class="s2">                 )</span>
<span class="s2">                 \s*                               # white space allowed</span>
<span class="s2">                 (?P&lt;resid&gt;\d+)                    # resid</span>
<span class="s2">                 \s*</span>
<span class="s2">                 (:                                # separator &#39;:&#39;</span>
<span class="s2">                   \s*</span>
<span class="s2">                   (?P&lt;atom&gt;\w+)                   # atom name</span>
<span class="s2">                 )?                                # possibly one</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>


<span class="c1"># from GromacsWrapper cbook.IndexBuilder</span>
<div class="viewcode-block" id="parse_residue">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.parse_residue">[docs]</a>
<span class="k">def</span> <span class="nf">parse_residue</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Process residue string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    residue: str</span>
<span class="sd">        The *residue* must contain a 1-letter or 3-letter or</span>
<span class="sd">        4-letter residue string, a number (the resid) and</span>
<span class="sd">        optionally an atom identifier, which must be separate</span>
<span class="sd">        from the residue with a colon (&quot;:&quot;). White space is</span>
<span class="sd">        allowed in between.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        `(3-letter aa string, resid, atomname)`; known 1-letter</span>
<span class="sd">        aa codes are converted to 3-letter codes</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">     - &quot;LYS300:HZ1&quot; --&gt; (&quot;LYS&quot;, 300, &quot;HZ1&quot;)</span>
<span class="sd">     - &quot;K300:HZ1&quot; --&gt; (&quot;LYS&quot;, 300, &quot;HZ1&quot;)</span>
<span class="sd">     - &quot;K300&quot; --&gt; (&quot;LYS&quot;, 300, None)</span>
<span class="sd">     - &quot;4GB300:H6O&quot; --&gt; (&quot;4GB&quot;, 300, &quot;H6O&quot;)</span>
<span class="sd">     - &quot;4GB300&quot; --&gt; (&quot;4GB&quot;, 300, None)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># XXX: use _translate_residue() ....</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">RESIDUE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">residue</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Selection </span><span class="si">{residue!r}</span><span class="s2"> is not valid (only 1/3/4 letter resnames, resid required).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()))</span>
    <span class="n">resid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;resid&#39;</span><span class="p">))</span>
    <span class="n">residue</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;aa&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">resname</span> <span class="o">=</span> <span class="n">convert_aa_code</span><span class="p">(</span><span class="n">residue</span><span class="p">)</span>  <span class="c1"># only works for AA</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">resname</span> <span class="o">=</span> <span class="n">residue</span>  <span class="c1"># use 3-letter for any resname</span>
    <span class="n">atomname</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;atom&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">resname</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">atomname</span><span class="p">)</span></div>



<div class="viewcode-block" id="conv_float">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.conv_float">[docs]</a>
<span class="k">def</span> <span class="nf">conv_float</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an object `s` to float if possible.</span>

<span class="sd">    Function to be passed into :func:`map` or a list comprehension. If</span>
<span class="sd">    the argument can be interpreted as a float it is converted,</span>
<span class="sd">    otherwise the original object is passed back.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span></div>



<span class="c1"># A dummy, empty, cheaply-hashable object class to use with weakref caching.</span>
<span class="c1"># (class object doesn&#39;t allow weakrefs to its instances, but user-defined</span>
<span class="c1">#  classes do)</span>
<span class="k">class</span> <span class="nc">_CacheKey</span><span class="p">:</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="cached">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.cached">[docs]</a>
<span class="k">def</span> <span class="nf">cached</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">universe_validation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cache a property within a class.</span>

<span class="sd">    Requires the Class to have a cache dict :attr:`_cache` and, with</span>
<span class="sd">    `universe_validation`, a :attr:`universe` with a cache dict :attr:`_cache`.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    How to add a cache for a variable to a class by using the `@cached`</span>
<span class="sd">    decorator::</span>

<span class="sd">       class A(object):</span>
<span class="sd">           def__init__(self):</span>
<span class="sd">               self._cache = dict()</span>

<span class="sd">           @property</span>
<span class="sd">           @cached(&#39;keyname&#39;)</span>
<span class="sd">           def size(self):</span>
<span class="sd">               # This code gets run only if the lookup of keyname fails</span>
<span class="sd">               # After this code has been run once, the result is stored in</span>
<span class="sd">               # _cache with the key: &#39;keyname&#39;</span>
<span class="sd">               return 10.0</span>

<span class="sd">           @property</span>
<span class="sd">           @cached(&#39;keyname&#39;, universe_validation=True)</span>
<span class="sd">           def othersize(self):</span>
<span class="sd">               # This code gets run only if the lookup</span>
<span class="sd">               # id(self) is not in the validation set under</span>
<span class="sd">               # self.universe._cache[&#39;_valid&#39;][&#39;keyname&#39;]</span>
<span class="sd">               # After this code has been run once, id(self) is added to that</span>
<span class="sd">               # set. The validation set can be centrally invalidated at the</span>
<span class="sd">               # universe level (say, if a topology change invalidates specific</span>
<span class="sd">               # caches).</span>
<span class="sd">               return 20.0</span>


<span class="sd">    .. versionadded:: 0.9.0</span>

<span class="sd">    .. versionchanged::2.0.0</span>
<span class="sd">        Added the `universe_validation` keyword.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">cached_lookup</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">universe_validation</span><span class="p">:</span>  <span class="c1"># Universe-level cache validation</span>
                    <span class="n">u_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;_valid&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
                    <span class="c1"># A WeakSet is used so that keys from out-of-scope/deleted</span>
                    <span class="c1"># objects don&#39;t clutter it.</span>
                    <span class="n">valid_caches</span> <span class="o">=</span> <span class="n">u_cache</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakSet</span><span class="p">())</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_caches</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">KeyError</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># No _cache_key yet</span>
                        <span class="c1"># Must create a reference key for the validation set.</span>
                        <span class="c1"># self could be used itself as a weakref but set()</span>
                        <span class="c1"># requires hashing it, which can be slow for AGs. Using</span>
                        <span class="c1"># id(self) fails because ints can&#39;t be weak-referenced.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_key</span> <span class="o">=</span> <span class="n">_CacheKey</span><span class="p">()</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">universe_validation</span><span class="p">:</span>
                    <span class="n">valid_caches</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache_key</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span>

        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="k">return</span> <span class="n">cached_lookup</span></div>



<div class="viewcode-block" id="unique_rows">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.unique_rows">[docs]</a>
<span class="k">def</span> <span class="nf">unique_rows</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the unique rows of an array.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    arr : numpy.ndarray</span>
<span class="sd">        Array of shape ``(n1, m)``.</span>
<span class="sd">    return_index : bool, optional</span>
<span class="sd">      If ``True``, returns indices of array that formed answer (see</span>
<span class="sd">      :func:`numpy.unique`)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unique_rows : numpy.ndarray</span>
<span class="sd">         Array of shape ``(n2, m)`` containing only the unique rows of `arr`.</span>
<span class="sd">    r_idx : numpy.ndarray (optional)</span>
<span class="sd">          Array containing the corresponding row indices (if `return_index`</span>
<span class="sd">          is ``True``).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Remove dupicate rows from an array:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.util import unique_rows</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[0, 1], [1, 2], [1, 2], [0, 1], [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; b = unique_rows(a)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [1, 2],</span>
<span class="sd">           [2, 3]])</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.unique</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># From here, but adapted to handle any size rows</span>
    <span class="c1"># https://mail.scipy.org/pipermail/scipy-user/2011-December/031200.html</span>

    <span class="c1"># This seems to fail if arr.flags[&#39;OWNDATA&#39;] is False</span>
    <span class="c1"># this can occur when second dimension was created through broadcasting</span>
    <span class="c1"># eg: idx = np.array([1, 2])[None, :]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;OWNDATA&#39;</span><span class="p">]:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_index</span><span class="p">:</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">r_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                                                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)])),</span>
                             <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">r_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)])</span>
        <span class="p">))</span>
        <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span></div>



<div class="viewcode-block" id="blocks_of">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.blocks_of">[docs]</a>
<span class="k">def</span> <span class="nf">blocks_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract a view of ``(n, m)`` blocks along the diagonal of the array `a`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : numpy.ndarray</span>
<span class="sd">        Input array, must be C contiguous and at least 2D.</span>
<span class="sd">    n : int</span>
<span class="sd">        Size of block in first dimension.</span>
<span class="sd">    m : int</span>
<span class="sd">        Size of block in second dimension.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    view : numpy.ndarray</span>
<span class="sd">        A view of the original array with shape ``(nblocks, n, m)``, where</span>
<span class="sd">        ``nblocks`` is the number of times the miniblocks of shape ``(n, m)``</span>
<span class="sd">        fit in the original.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the supplied `n` and `m` don&#39;t divide `a` into an integer number</span>
<span class="sd">        of blocks or if `a` is not C contiguous.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.util import blocks_of</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(16).reshape(4, 4)</span>
<span class="sd">    &gt;&gt;&gt; view = blocks_of(arr, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; view[:] = 100</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([[100, 100,   2,   3],</span>
<span class="sd">           [100, 100,   6,   7],</span>
<span class="sd">           [  8,   9, 100, 100],</span>
<span class="sd">           [ 12,  13, 100, 100]])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `n`, `m` must divide `a` into an identical integer number of blocks. Please</span>
<span class="sd">    note that if the block size is larger than the input array, this number will</span>
<span class="sd">    be zero, resulting in an empty view!</span>

<span class="sd">    Uses strides and therefore requires that the array is C contiguous.</span>

<span class="sd">    Returns a view, so editing this modifies the original array.</span>


<span class="sd">    .. versionadded:: 0.12.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># based on:</span>
    <span class="c1"># http://stackoverflow.com/a/10862636</span>
    <span class="c1"># but generalised to handle non square blocks.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input array is not C contiguous.&quot;</span><span class="p">)</span>

    <span class="n">nblocks</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">n</span>
    <span class="n">nblocks2</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">m</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">nblocks</span> <span class="o">==</span> <span class="n">nblocks2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must divide into same number of blocks in both&quot;</span>
                         <span class="s2">&quot; directions.  Got </span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">&quot;</span>
                         <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nblocks</span><span class="p">,</span> <span class="n">nblocks2</span><span class="p">))</span>

    <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nblocks</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">new_strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">,</span> <span class="n">new_strides</span><span class="p">)</span></div>



<div class="viewcode-block" id="group_same_or_consecutive_integers">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.group_same_or_consecutive_integers">[docs]</a>
<span class="k">def</span> <span class="nf">group_same_or_consecutive_integers</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split an array of integers into a list of same or consecutive</span>
<span class="sd">    sequences.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr: :class:`numpy.ndarray`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of :class:`numpy.ndarray`</span>

<span class="sd">    Examples</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array([ 2,  3,  4,  7,  8,  9, 10, 11, 15, 16])</span>
<span class="sd">    &gt;&gt;&gt; group_same_or_consecutive_integers(arr)</span>
<span class="sd">    [array([2, 3, 4]), array([ 7,  8,  9, 10, 11]), array([15, 16])]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="Namespace">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.Namespace">[docs]</a>
<span class="k">class</span> <span class="nc">Namespace</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to allow storing attributes in new namespace. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># a.this causes a __getattr__ call for key = &#39;this&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">&quot; is not known in the namespace.&#39;</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">dict</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">dict</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">&quot; is not known in the namespace.&#39;</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># this&#39;ll allow us to compare if we&#39;re storing arrays</span>
            <span class="n">assert_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="ltruncate_int">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.ltruncate_int">[docs]</a>
<span class="k">def</span> <span class="nf">ltruncate_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ndigits</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Truncate an integer, retaining least significant digits</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value : int</span>
<span class="sd">      value to truncate</span>
<span class="sd">    ndigits : int</span>
<span class="sd">      number of digits to keep</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    truncated : int</span>
<span class="sd">      only the `ndigits` least significant digits from `value`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.util import ltruncate_int</span>
<span class="sd">    &gt;&gt;&gt; ltruncate_int(123, 2)</span>
<span class="sd">    23</span>
<span class="sd">    &gt;&gt;&gt; ltruncate_int(1234, 5)</span>
<span class="sd">    1234</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)[</span><span class="o">-</span><span class="n">ndigits</span><span class="p">:])</span></div>



<div class="viewcode-block" id="flatten_dict">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.flatten_dict">[docs]</a>
<span class="k">def</span> <span class="nf">flatten_dict</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">parent_key</span><span class="o">=</span><span class="nb">tuple</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flatten a nested dict `d` into a shallow dict with tuples as keys.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : dict</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>

<span class="sd">    Note</span>
<span class="sd">    -----</span>
<span class="sd">    Based on https://stackoverflow.com/a/6027615/</span>
<span class="sd">    by user https://stackoverflow.com/users/1897/imran</span>

<span class="sd">    .. versionadded:: 0.18.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">new_key</span> <span class="o">=</span> <span class="n">parent_key</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_key</span> <span class="o">=</span> <span class="n">parent_key</span> <span class="o">+</span> <span class="n">k</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">flatten_dict</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">new_key</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_key</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">items</span><span class="p">)</span></div>



<div class="viewcode-block" id="static_variables">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.static_variables">[docs]</a>
<span class="k">def</span> <span class="nf">static_variables</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator equipping functions or methods with static variables.</span>

<span class="sd">    Static variables are declared and initialized by supplying keyword arguments</span>
<span class="sd">    and initial values to the decorator.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.util import static_variables</span>
<span class="sd">    &gt;&gt;&gt; @static_variables(msg=&#39;foo calls&#39;, calls=0)</span>
<span class="sd">    ... def foo():</span>
<span class="sd">    ...     foo.calls += 1</span>
<span class="sd">    ...     print(&quot;{}: {}&quot;.format(foo.msg, foo.calls))</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; foo()</span>
<span class="sd">    foo calls: 1</span>
<span class="sd">    &gt;&gt;&gt; foo()</span>
<span class="sd">    foo calls: 2</span>


<span class="sd">    .. note:: Based on https://stackoverflow.com/a/279586</span>
<span class="sd">        by `Claudiu &lt;https://stackoverflow.com/users/15055/claudiu&gt;`_</span>

<span class="sd">    .. versionadded:: 0.19.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">static_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">kwarg</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">kwarg</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">static_decorator</span></div>



<span class="c1"># In a lot of Atom/Residue/SegmentGroup methods such as center_of_geometry() and</span>
<span class="c1"># the like, results are biased if the calling group is not unique, i.e., if it</span>
<span class="c1"># contains duplicates.</span>
<span class="c1"># We therefore raise a `DuplicateWarning` whenever an affected method is called</span>
<span class="c1"># from a non-unique group. Since several of the affected methods involve calls</span>
<span class="c1"># to other affected methods, simply raising a warning in every affected method</span>
<span class="c1"># would potentially lead to a massive amount of warnings. This is exactly where</span>
<span class="c1"># the `warn_if_unique` decorator below comes into play. It ensures that a</span>
<span class="c1"># warning is only raised once for a method using this decorator, and suppresses</span>
<span class="c1"># all such warnings that would potentially be raised in methods called by that</span>
<span class="c1"># method. Of course, as it is generally the case with Python warnings, this is</span>
<span class="c1"># *not threadsafe*.</span>

<div class="viewcode-block" id="warn_if_not_unique">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.warn_if_not_unique">[docs]</a>
<span class="nd">@static_variables</span><span class="p">(</span><span class="n">warned</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">warn_if_not_unique</span><span class="p">(</span><span class="n">groupmethod</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator triggering a :class:`~MDAnalysis.exceptions.DuplicateWarning`</span>
<span class="sd">    if the underlying group is not unique.</span>

<span class="sd">    Assures that during execution of the decorated method only the first of</span>
<span class="sd">    potentially multiple warnings concerning the uniqueness of groups is shown.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    :class:`~MDAnalysis.exceptions.DuplicateWarning`</span>
<span class="sd">        If the :class:`~MDAnalysis.core.groups.AtomGroup`,</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.ResidueGroup`, or</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.SegmentGroup` of which the decorated</span>
<span class="sd">        method is a member contains duplicates.</span>


<span class="sd">    .. versionadded:: 0.19.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">groupmethod</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Proceed as usual if the calling group is unique or a DuplicateWarning</span>
        <span class="c1"># has already been thrown:</span>
        <span class="k">if</span> <span class="n">group</span><span class="o">.</span><span class="n">isunique</span> <span class="ow">or</span> <span class="n">warn_if_not_unique</span><span class="o">.</span><span class="n">warned</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">groupmethod</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Otherwise, throw a DuplicateWarning and execute the method.</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">groupmethod</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="c1"># Try to get the group&#39;s variable name(s):</span>
        <span class="n">caller_locals</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_back</span><span class="o">.</span><span class="n">f_locals</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="n">group_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">caller_locals</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">group</span><span class="p">:</span>
                    <span class="n">group_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">group_names</span><span class="p">:</span>
            <span class="n">group_name</span> <span class="o">=</span> <span class="s2">&quot;&#39;unnamed </span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">group_name</span> <span class="o">=</span> <span class="n">group_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">group_name</span> <span class="o">=</span> <span class="s2">&quot; a.k.a. &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">group_names</span><span class="p">))</span>
        <span class="n">group_repr</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(): </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> contains duplicates. Results might be biased!&quot;</span>
               <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">group_repr</span><span class="p">))</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">DuplicateWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">warn_if_not_unique</span><span class="o">.</span><span class="n">warned</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">groupmethod</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">warn_if_not_unique</span><span class="o">.</span><span class="n">warned</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapper</span></div>



<div class="viewcode-block" id="check_coords">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.check_coords">[docs]</a>
<span class="k">def</span> <span class="nf">check_coords</span><span class="p">(</span><span class="o">*</span><span class="n">coord_names</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator for automated coordinate array checking.</span>

<span class="sd">    This decorator is intended for use especially in</span>
<span class="sd">    :mod:`MDAnalysis.lib.distances`.</span>
<span class="sd">    It takes an arbitrary number of positional arguments which must correspond</span>
<span class="sd">    to names of positional arguments of the decorated function.</span>
<span class="sd">    It then checks if the corresponding values are valid coordinate arrays or</span>
<span class="sd">    an :class:`~MDAnalysis.core.groups.AtomGroup`.</span>
<span class="sd">    If the input is an array and all these arrays are single coordinates</span>
<span class="sd">    (i.e., their shape is ``(3,)``), the decorated function can optionally</span>
<span class="sd">    return a single coordinate (or angle) instead of an array of coordinates</span>
<span class="sd">    (or angles). This can be used to enable computations of single observables</span>
<span class="sd">    using functions originally designed to accept only 2-d coordinate arrays.</span>

<span class="sd">    If the input is an :class:`~MDAnalysis.core.groups.AtomGroup` it is</span>
<span class="sd">    converted into its corresponding position array via a call to</span>
<span class="sd">    `AtomGroup.positions`.</span>

<span class="sd">    The checks performed on each individual coordinate array are:</span>

<span class="sd">    * Check that coordinate arrays are of type :class:`numpy.ndarray`.</span>
<span class="sd">    * Check that coordinate arrays have a shape of ``(n, 3)`` (or ``(3,)`` if</span>
<span class="sd">      single coordinates are allowed; see keyword argument `allow_single`).</span>
<span class="sd">    * Automatic dtype conversion to ``numpy.float32``.</span>
<span class="sd">    * Optional replacement by a copy; see keyword argument `enforce_copy` .</span>
<span class="sd">    * If coordinate arrays aren&#39;t C-contiguous, they will be automatically</span>
<span class="sd">      replaced by a C-contiguous copy.</span>
<span class="sd">    * Optional check for equal length of all coordinate arrays; see optional</span>
<span class="sd">      keyword argument `check_lengths_match`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *coord_names : tuple</span>
<span class="sd">        Arbitrary number of strings corresponding to names of positional</span>
<span class="sd">        arguments of the decorated function.</span>
<span class="sd">    **options : dict, optional</span>
<span class="sd">        * **enforce_copy** (:class:`bool`, optional) -- Enforce working on a</span>
<span class="sd">          copy of the coordinate arrays. This is useful to ensure that the input</span>
<span class="sd">          arrays are left unchanged. Default: ``True``</span>
<span class="sd">        * **enforce_dtype** (:class:`bool`, optional) -- Enforce a conversion</span>
<span class="sd">          to float32.  Default: ``True``</span>
<span class="sd">        * **allow_single** (:class:`bool`, optional) -- Allow the input</span>
<span class="sd">          coordinate array to be a single coordinate with shape ``(3,)``.</span>
<span class="sd">        * **convert_single** (:class:`bool`, optional) -- If ``True``, single</span>
<span class="sd">          coordinate arrays will be converted to have a shape of ``(1, 3)``.</span>
<span class="sd">          Only has an effect if `allow_single` is ``True``. Default: ``True``</span>
<span class="sd">        * **reduce_result_if_single** (:class:`bool`, optional) -- If ``True``</span>
<span class="sd">          and *all* input coordinates are single, a decorated function ``func``</span>
<span class="sd">          will return ``func()[0]`` instead of ``func()``. Only has an effect if</span>
<span class="sd">          `allow_single` is ``True``. Default: ``True``</span>
<span class="sd">        * **check_lengths_match** (:class:`bool`, optional) -- If ``True``, a</span>
<span class="sd">          :class:`ValueError` is raised if not all coordinate arrays contain the</span>
<span class="sd">          same number of coordinates. Default: ``True``</span>
<span class="sd">        * **allow_atomgroup** (:class:`bool`, optional) -- If ``False``, a</span>
<span class="sd">          :class:`TypeError` is raised if an :class:`AtomGroup` is supplied</span>
<span class="sd">          Default: ``False``</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the decorator is used without positional arguments (for development</span>
<span class="sd">        purposes only).</span>

<span class="sd">        If any of the positional arguments supplied to the decorator doesn&#39;t</span>
<span class="sd">        correspond to a name of any of the decorated function&#39;s positional</span>
<span class="sd">        arguments.</span>

<span class="sd">        If any of the coordinate arrays has a wrong shape.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If any of the coordinate arrays is not a :class:`numpy.ndarray` or an</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.AtomGroup`.</span>

<span class="sd">        If the dtype of any of the coordinate arrays is not convertible to</span>
<span class="sd">          ``numpy.float32``.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import MDAnalysis as mda</span>
<span class="sd">    &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">    &gt;&gt;&gt; from MDAnalysis.lib.util import check_coords</span>
<span class="sd">    &gt;&gt;&gt; @check_coords(&#39;coords1&#39;, &#39;coords2&#39;, allow_atomgroup=True)</span>
<span class="sd">    ... def coordsum(coords1, coords2):</span>
<span class="sd">    ...     assert coords1.dtype == np.float32</span>
<span class="sd">    ...     assert coords2.flags[&#39;C_CONTIGUOUS&#39;]</span>
<span class="sd">    ...     return coords1 + coords2</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; # automatic dtype conversion:</span>
<span class="sd">    &gt;&gt;&gt; coordsum(np.zeros(3, dtype=np.int64), np.ones(3))</span>
<span class="sd">    array([1., 1., 1.], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # automatic handling of non-contiguous arrays:</span>
<span class="sd">    &gt;&gt;&gt; coordsum(np.zeros(3), np.ones(6)[::2])</span>
<span class="sd">    array([1., 1., 1.], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # automatic handling of AtomGroups</span>
<span class="sd">    &gt;&gt;&gt; u = mda.Universe(PSF, DCD)</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     coordsum(u.atoms, u.select_atoms(&quot;index 1 to 10&quot;))</span>
<span class="sd">    ... except ValueError as err:</span>
<span class="sd">    ...     err</span>
<span class="sd">    ValueError(&#39;coordsum(): coords1, coords2 must contain the same number of coordinates, got [3341, 10].&#39;)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # automatic shape checking:</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     coordsum(np.zeros(3), np.ones(6))</span>
<span class="sd">    ... except ValueError as err:</span>
<span class="sd">    ...     err</span>
<span class="sd">    ValueError(&#39;coordsum(): coords2.shape must be (3,) or (n, 3), got (6,)&#39;)</span>


<span class="sd">    .. versionadded:: 0.19.0</span>
<span class="sd">    .. versionchanged:: 2.3.0</span>
<span class="sd">       Can now accept an :class:`AtomGroup` as input, and added option</span>
<span class="sd">       allow_atomgroup with default False to retain old behaviour</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">enforce_copy</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;enforce_copy&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">enforce_dtype</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;enforce_dtype&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">allow_single</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;allow_single&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">convert_single</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;convert_single&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">reduce_result_if_single</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reduce_result_if_single&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">check_lengths_match</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;check_lengths_match&#39;</span><span class="p">,</span>
                                      <span class="nb">len</span><span class="p">(</span><span class="n">coord_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">allow_atomgroup</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;allow_atomgroup&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">coord_names</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Decorator check_coords() cannot be used without &quot;</span>
                         <span class="s2">&quot;positional arguments.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check_coords_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__code__</span>
        <span class="n">argnames</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">co_varnames</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">)</span>
        <span class="n">ndefaults</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">)</span> <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="vm">__defaults__</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="c1"># Create a tuple of positional argument names:</span>
        <span class="n">nposargs</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">co_argcount</span> <span class="o">-</span> <span class="n">ndefaults</span>
        <span class="n">posargnames</span> <span class="o">=</span> <span class="n">argnames</span><span class="p">[:</span><span class="n">nposargs</span><span class="p">]</span>
        <span class="c1"># The check_coords() decorator is designed to work only for positional</span>
        <span class="c1"># arguments:</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">posargnames</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;In decorator check_coords(): Name &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                                 <span class="s2">&quot;doesn&#39;t correspond to any positional &quot;</span>
                                 <span class="s2">&quot;argument of the decorated function </span><span class="si">{}</span><span class="s2">().&quot;</span>
                                 <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">_check_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">argname</span><span class="p">):</span>
            <span class="n">is_single</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">allow_single</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">):</span>
                        <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">(): </span><span class="si">{</span><span class="n">argname</span><span class="si">}</span><span class="s2">.shape must be (3,) or &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;(n, 3), got </span><span class="si">{</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">coords</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">is_single</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="n">convert_single</span><span class="p">:</span>
                            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">):</span>
                        <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">(): </span><span class="si">{</span><span class="n">argname</span><span class="si">}</span><span class="s2">.shape must be (n, 3) &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">enforce_dtype</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">enforce_copy</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">(): </span><span class="si">{</span><span class="n">argname</span><span class="si">}</span><span class="s2">.dtype must be&quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;convertible to float32, got&quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">coords</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
                <span class="c1"># coordinates should now be the right shape</span>
                <span class="n">ncoord</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">positions</span>  <span class="c1"># homogenise to a numpy array</span>
                    <span class="n">ncoord</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_atomgroup</span><span class="p">:</span>
                        <span class="n">err</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;AtomGroup or other class with a&quot;</span>
                                        <span class="s2">&quot;`.positions` method supplied as an&quot;</span>
                                        <span class="s2">&quot;argument, but allow_atomgroup is&quot;</span>
                                        <span class="s2">&quot; False&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">err</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">(): Parameter &#39;</span><span class="si">{</span><span class="n">argname</span><span class="si">}</span><span class="s2">&#39; must be&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot; a numpy.ndarray or an AtomGroup,&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot; got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">coords</span><span class="p">,</span> <span class="n">is_single</span><span class="p">,</span> <span class="n">ncoord</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># Check for invalid function call:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nposargs</span><span class="p">:</span>
                <span class="c1"># set marker for testing purposes:</span>
                <span class="n">wrapper</span><span class="o">.</span><span class="n">_invalid_call</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nargs</span><span class="p">:</span>
                    <span class="c1"># too many arguments, invoke call:</span>
                    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">posargnames</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)]:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="c1"># duplicate argument, invoke call:</span>
                        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">posargnames</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):]:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="c1"># missing argument, invoke call:</span>
                        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">argnames</span><span class="p">:</span>
                        <span class="c1"># unexpected kwarg, invoke call:</span>
                        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="c1"># call is valid, unset test marker:</span>
                <span class="n">wrapper</span><span class="o">.</span><span class="n">_invalid_call</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">ncoords</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">all_single</span> <span class="o">=</span> <span class="n">allow_single</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">coord_names</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">posargnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                    <span class="n">args</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">is_single</span><span class="p">,</span> <span class="n">ncoord</span> <span class="o">=</span> <span class="n">_check_coords</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                                 <span class="n">name</span><span class="p">)</span>
                    <span class="n">all_single</span> <span class="o">&amp;=</span> <span class="n">is_single</span>
                    <span class="n">ncoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ncoord</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">is_single</span><span class="p">,</span> <span class="n">ncoord</span> <span class="o">=</span> <span class="n">_check_coords</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">],</span>
                                                                    <span class="n">name</span><span class="p">)</span>
                    <span class="n">all_single</span> <span class="o">&amp;=</span> <span class="n">is_single</span>
                    <span class="n">ncoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ncoord</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check_lengths_match</span> <span class="ow">and</span> <span class="n">ncoords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ncoords</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ncoords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ncoords</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(): </span><span class="si">{}</span><span class="s2"> must contain the same number of &quot;</span>
                                     <span class="s2">&quot;coordinates, got </span><span class="si">{}</span><span class="s2">.&quot;</span>
                                     <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">coord_names</span><span class="p">),</span>
                                               <span class="n">ncoords</span><span class="p">))</span>
            <span class="c1"># If all input coordinate arrays were 1-d, so should be the output:</span>
            <span class="k">if</span> <span class="n">all_single</span> <span class="ow">and</span> <span class="n">reduce_result_if_single</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">check_coords_decorator</span></div>



<div class="viewcode-block" id="check_atomgroup_not_empty">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.check_atomgroup_not_empty">[docs]</a>
<span class="k">def</span> <span class="nf">check_atomgroup_not_empty</span><span class="p">(</span><span class="n">groupmethod</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator triggering a ``ValueError`` if the underlying group is empty.</span>

<span class="sd">    Avoids downstream errors in computing properties of empty atomgroups. </span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input :class:`~MDAnalysis.core.groups.AtomGroup`,</span>
<span class="sd">        of a decorated method is empty.</span>


<span class="sd">    .. versionadded:: 2.4.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">groupmethod</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Throw error if the group is empty.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;AtomGroup is empty.&quot;</span><span class="p">)</span>
        <span class="c1"># Proceed as usual if the calling group is not empty.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">groupmethod</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapper</span></div>



<span class="c1"># ------------------------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># our own deprecate function, derived from numpy (see</span>
<span class="c1"># https://github.com/MDAnalysis/mdanalysis/pull/1763#issuecomment-403231136)</span>
<span class="c1">#</span>
<span class="c1"># From numpy/lib/utils.py 1.14.5 (used under the BSD 3-clause licence,</span>
<span class="c1"># https://www.numpy.org/license.html#license) and modified</span>

<span class="k">def</span> <span class="nf">_set_function_name</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">func</span>


<div class="viewcode-block" id="_Deprecate">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util._Deprecate">[docs]</a>
<span class="k">class</span> <span class="nc">_Deprecate</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator class to deprecate old functions.</span>

<span class="sd">    Refer to `deprecate` for details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    deprecate</span>


<span class="sd">    .. versionadded:: 0.19.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">release</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">old_name</span> <span class="o">=</span> <span class="n">old_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_name</span> <span class="o">=</span> <span class="n">new_name</span>
        <span class="k">if</span> <span class="n">release</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;deprecate: provide release in which &quot;</span>
                             <span class="s2">&quot;feature was deprecated.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">release</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">remove</span><span class="p">)</span> <span class="k">if</span> <span class="n">remove</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">remove</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator call.  Refer to ``decorate``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_name</span>
        <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_name</span>
        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span>
        <span class="n">release</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">release</span>
        <span class="n">remove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span>

        <span class="k">if</span> <span class="n">old_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">old_name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">old_name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">depdoc</span> <span class="o">=</span> <span class="s2">&quot;`</span><span class="si">{0}</span><span class="s2">` is deprecated!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">old_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">depdoc</span> <span class="o">=</span> <span class="s2">&quot;`</span><span class="si">{0}</span><span class="s2">` is deprecated, use `</span><span class="si">{1}</span><span class="s2">` instead!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>

        <span class="n">warn_message</span> <span class="o">=</span> <span class="n">depdoc</span>

        <span class="n">remove_text</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">remove</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">remove_text</span> <span class="o">=</span> <span class="s2">&quot;`</span><span class="si">{0}</span><span class="s2">` will be removed in release </span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">old_name</span><span class="p">,</span> <span class="n">remove</span><span class="p">)</span>
            <span class="n">warn_message</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">remove_text</span>
        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warn_message</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">message</span>

        <span class="k">def</span> <span class="nf">newfunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;This function is deprecated.&quot;&quot;&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warn_message</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="n">newfunc</span> <span class="o">=</span> <span class="n">_set_function_name</span><span class="p">(</span><span class="n">newfunc</span><span class="p">,</span> <span class="n">old_name</span><span class="p">)</span>

        <span class="c1"># Build the doc string</span>
        <span class="c1"># First line: func is deprecated, use newfunc instead!</span>
        <span class="c1"># Normal docs follows.</span>
        <span class="c1"># Last: .. deprecated::</span>

        <span class="c1"># make sure that we do not mess up indentation, otherwise sphinx</span>
        <span class="c1"># docs do not build properly</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="n">dedent_docstring</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">deprecation_text</span> <span class="o">=</span> <span class="n">dedent_docstring</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\n\n</span>
<span class="s2">        .. deprecated:: </span><span class="si">{0}</span>
<span class="s2">           </span><span class="si">{1}</span>
<span class="s2">           </span><span class="si">{2}</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">release</span><span class="p">,</span>
                   <span class="n">message</span> <span class="k">if</span> <span class="n">message</span> <span class="k">else</span> <span class="n">depdoc</span><span class="p">,</span>
                   <span class="n">remove_text</span><span class="p">))</span>

        <span class="n">doc</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="se">\n\n</span><span class="si">{1}</span><span class="se">\n</span><span class="si">{2}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">depdoc</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">deprecation_text</span><span class="p">)</span>

        <span class="n">newfunc</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doc</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newfunc</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newfunc</span></div>



<div class="viewcode-block" id="deprecate">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.deprecate">[docs]</a>
<span class="k">def</span> <span class="nf">deprecate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Issues a DeprecationWarning, adds warning to `old_name`&#39;s</span>
<span class="sd">    docstring, rebinds ``old_name.__name__`` and returns the new</span>
<span class="sd">    function object.</span>

<span class="sd">    This function may also be used as a decorator.</span>

<span class="sd">    It adds a restructured text ``.. deprecated:: release`` block with</span>
<span class="sd">    the sphinx deprecated role to the end of the docs. The `message`</span>
<span class="sd">    is added under the deprecation block and contains the `release` in</span>
<span class="sd">    which the function was deprecated.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">        The function to be deprecated.</span>
<span class="sd">    old_name : str, optional</span>
<span class="sd">        The name of the function to be deprecated. Default is None, in</span>
<span class="sd">        which case the name of `func` is used.</span>
<span class="sd">    new_name : str, optional</span>
<span class="sd">        The new name for the function. Default is None, in which case the</span>
<span class="sd">        deprecation message is that `old_name` is deprecated. If given, the</span>
<span class="sd">        deprecation message is that `old_name` is deprecated and `new_name`</span>
<span class="sd">        should be used instead.</span>
<span class="sd">    release : str</span>
<span class="sd">        Release in which the function was deprecated. This is given as</span>
<span class="sd">        a keyword argument for technical reasons but is required; a</span>
<span class="sd">        :exc:`ValueError` is raised if it is missing.</span>
<span class="sd">    remove : str, optional</span>
<span class="sd">        Release for which removal of the feature is planned.</span>
<span class="sd">    message : str, optional</span>
<span class="sd">        Additional explanation of the deprecation.  Displayed in the</span>
<span class="sd">        docstring after the warning.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    old_func : function</span>
<span class="sd">        The deprecated function.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    When :func:`deprecate` is used as a function as in the following</span>
<span class="sd">    example,</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       oldfunc = deprecate(func, release=&quot;0.19.0&quot;, remove=&quot;1.0&quot;,</span>
<span class="sd">                           message=&quot;Do it yourself instead.&quot;)</span>

<span class="sd">    then ``oldfunc`` will return a value after printing</span>
<span class="sd">    :exc:`DeprecationWarning`; ``func`` is still available as it was</span>
<span class="sd">    before.</span>

<span class="sd">    When used as a decorator, ``func`` will be changed and issue the</span>
<span class="sd">    warning and contain the deprecation note in the do string.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       @deprecate(release=&quot;0.19.0&quot;, remove=&quot;1.0&quot;,</span>
<span class="sd">                  message=&quot;Do it yourself instead.&quot;)</span>
<span class="sd">       def func():</span>
<span class="sd">           \&quot;\&quot;\&quot;Just pass\&quot;\&quot;\&quot;</span>
<span class="sd">           pass</span>

<span class="sd">    The resulting doc string (``help(func)``) will look like:</span>

<span class="sd">    .. code-block:: reST</span>

<span class="sd">       `func` is deprecated!</span>

<span class="sd">       Just pass.</span>

<span class="sd">       .. deprecated:: 0.19.0</span>
<span class="sd">          Do it yourself instead.</span>
<span class="sd">          `func` will be removed in 1.0.</span>

<span class="sd">    (It is possible but confusing to change the name of ``func`` with</span>
<span class="sd">    the decorator so it is not recommended to use the `new_func`</span>
<span class="sd">    keyword argument with the decorator.)</span>

<span class="sd">    .. versionadded:: 0.19.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Deprecate may be run as a function or as a decorator</span>
    <span class="c1"># If run as a function, we initialise the decorator class</span>
    <span class="c1"># and execute its __call__ method.</span>

    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">_Deprecate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_Deprecate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="c1">#</span>
<span class="c1"># ------------------------------------------------------------------</span>


<div class="viewcode-block" id="dedent_docstring">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.dedent_docstring">[docs]</a>
<span class="k">def</span> <span class="nf">dedent_docstring</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dedent typical python doc string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    text : str</span>
<span class="sd">        string, typically something like ``func.__doc__``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        string with the leading common whitespace removed from each</span>
<span class="sd">        line</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    textwrap.dedent</span>


<span class="sd">    .. versionadded:: 0.19.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>

    <span class="c1"># treat first line as special (typically no leading whitespace!) which messes up dedent</span>
    <span class="k">return</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span></div>



<div class="viewcode-block" id="check_box">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.check_box">[docs]</a>
<span class="k">def</span> <span class="nf">check_box</span><span class="p">(</span><span class="n">box</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Take a box input and deduce what type of system it represents based on</span>
<span class="sd">    the shape of the array and whether all angles are 90 degrees.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    box : array_like</span>
<span class="sd">        The unitcell dimensions of the system, which can be orthogonal or</span>
<span class="sd">        triclinic and must be provided in the same format as returned by</span>
<span class="sd">        :attr:`MDAnalysis.coordinates.timestep.Timestep.dimensions`:</span>
<span class="sd">        ``[lx, ly, lz, alpha, beta, gamma]``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    boxtype : {``&#39;ortho&#39;``, ``&#39;tri_vecs&#39;``}</span>
<span class="sd">        String indicating the box type (orthogonal or triclinic).</span>
<span class="sd">    checked_box : numpy.ndarray</span>
<span class="sd">        Array of dtype ``numpy.float32`` containing box information:</span>
<span class="sd">          * If `boxtype` is ``&#39;ortho&#39;``, `cecked_box` will have the shape ``(3,)``</span>
<span class="sd">            containing the x-, y-, and z-dimensions of the orthogonal box.</span>
<span class="sd">          * If  `boxtype` is ``&#39;tri_vecs&#39;``, `cecked_box` will have the shape</span>
<span class="sd">            ``(3, 3)`` containing the triclinic box vectors in a lower triangular</span>
<span class="sd">            matrix as returned by</span>
<span class="sd">            :meth:`~MDAnalysis.lib.mdamath.triclinic_vectors`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `box` is not of the form ``[lx, ly, lz, alpha, beta, gamma]``</span>
<span class="sd">        or contains data that is not convertible to ``numpy.float32``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MDAnalysis.lib.mdamath.triclinic_vectors</span>


<span class="sd">    .. versionchanged: 0.19.0</span>
<span class="sd">       * Enforced correspondence of `box` with specified format.</span>
<span class="sd">       * Added automatic conversion of input to :class:`numpy.ndarray` with</span>
<span class="sd">         dtype ``numpy.float32``.</span>
<span class="sd">       * Now also returns the box in the format expected by low-level functions</span>
<span class="sd">         in :mod:`~MDAnalysis.lib.c_distances`.</span>
<span class="sd">       * Removed obsolete box types ``tri_box`` and ``tri_vecs_bad``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Box is None&quot;</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">.mdamath</span> <span class="kn">import</span> <span class="n">triclinic_vectors</span>  <span class="c1"># avoid circular import</span>
    <span class="n">box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">box</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid box information. Must be of the form &quot;</span>
                         <span class="s2">&quot;[lx, ly, lz, alpha, beta, gamma].&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="mf">90.</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;ortho&#39;</span><span class="p">,</span> <span class="n">box</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="s1">&#39;tri_vecs&#39;</span><span class="p">,</span> <span class="n">triclinic_vectors</span><span class="p">(</span><span class="n">box</span><span class="p">)</span></div>



<div class="viewcode-block" id="store_init_arguments">
<a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.store_init_arguments">[docs]</a>
<span class="k">def</span> <span class="nf">store_init_arguments</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to store arguments passed to the init method of a class.</span>

<span class="sd">    Arguments are stored as a dictionary in ``cls._kwargs``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * Only does a shallow copy, if the arguments are changed</span>
<span class="sd">      by the class after passing through the decorator this will be</span>
<span class="sd">      reflected in the stored arguments.</span>
<span class="sd">    * If not empty, ``args`` is not unpacked and stored as-is in the</span>
<span class="sd">      dictionary. If no ``args`` are passed, then no ``arg`` entry will be</span>
<span class="sd">      stored in the dictionary.</span>


<span class="sd">    .. versionadded:: 2.2.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_kwargs&quot;</span><span class="p">):</span>
            <span class="n">arg_values</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">arg_values</span><span class="o">.</span><span class="n">apply_defaults</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">arg_values</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;self&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;kwargs&quot;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;args&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2024, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Henok Ademtew, Shobhit Agarwal, Aya M. Alaa, Irfan Alibay, Kazi Shudipto Amin, Anshul Angaria, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Patricio Barletta, Leonardo Barneschi, Jonathan Barnoud, Estefania Barreto-Ojeda, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Kavya Bisht, Wouter Boomsma, Jose Borreguero, Cédric Bouysset, Kevin Boyd, Meet Brijwani, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, Yantong Cai, David Caplan, Yuanyu Chang, Pratham Chauhan, Matthieu Chavent, Haochuan Chen, Xu Hong Chen, Kathleen Clark, Jennifer A Clark, Orion Cohen, Charlie Cook, Ruggero Cortini, Nicholas Craven, Ramon Crehuet, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Bradley Dice, Jan Domanski, David L. Dotson, Mark D. Driver, Ali Ehlen, Daniel J. Evans, Shujie Fan, Bjarne Feddersen, Lennard van der Feltz, Jake Fennick, Philip Fowler, Guillaume Fraux, Anirvinya G, Michael Gecht, Ahmed Salah Ghoneim, Mikhail Glagolev, William Glass, Jenna M. Swarthout Goddard, Joseph Goose, Alexander Gorfer, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Pratik Gupta, Sumit Gupta, Benjamin Hall, Ameya Harmalkar, Ivan Hristov, Eugen Hruska, Kyle J. Huston, Siddharth Jain, Edis Jakupovic, Joe Jordan, Henrik Jäger, Uma D Kadam, Aditya Kamath, Jon Kapla, Ian M. Kenney, Haleema Khan, Navya Khare, Utsav Khatu, Andrew William King, Henry Kobin, Abhishek A. Kognole, Kosuke Kudo, Atharva Kulkarni, Manish Kumar, Mohit Kumar, Shubham Kumar, Alia Lescoulie, Zhenbo Li, Max Linke, Philip Loche, Jinju Lu, Hugo MacDermott-Opeskin, Shaivi Malik, Egor Marin, Domenico Marson, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Rocco Meli, Manuel Nuno Melo, Marcelo C. R. Melo, Dominik &#39;Rathann&#39; Mierzejewski, David Minh, Geongi Moon, Henry Mull, Morgan L. Nance, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Meghan Osato, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Dimitrios Papageorgiou, Rafael R. Pappalardo, Vishal Parmar, Danny Parton, Shakul Pathak, Christian Pfaendner, Joshua L. Phillips, Marcelo D. Poleto, Hannah Pollak, Kashish Punjani, Michael Quevillon, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Andrea Rizzi, Xiaoxu Ruan, Carlos Yanez S., Utkarsh Saxena, Moritz Schaeffler, Alexander Schlaich, Marcello Sega, Ricky Sexton, Sean L. Seyler, Faraaz Shah, Sulay Shah, Abhishek Shandilya, Shubham Sharma, Rishabh Shukla, Karthikeyan Singaravelan, Tamandeep Singh, Brigitta Sipőcz, Paul Smith, Andy Somogyi, Caio S. Souza, David van der Spoel, Shantanu Srivastava, Lukas Stelzl, Jan Stevens, Gorman Stock, Johannes Stöckelmaier, Fenil Suchak, Ayush Suhane, Filip T. Szczypiński, Sukeerti T, Matthijs Tadema, Joao Miguel Correia Teixeira, Paarth Thadani, Matthew W. Thompson, Hao Tian, Matteo Tiberti, Zaheer Timol, Wiep van der Toorn, Mieczyslaw Torchala, Aditi Tripathi, Heet Vekariya, Mark Verma, Josh Vermaas, Isaac Virshup, Lily Wang, Nestor Wendt, Lawson Woods, Zhiyi Wu, Tengyu Xie, Zhuyi Xue, Mingyi Xue, Alexander Yang, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, Raymond Zhao, Yuxuan Zhuang, and Oliver Beckstein.</p>
  </div>

  

<div class="footer"><p>Please see
    our <a href="https://www.mdanalysis.org/pages/privacy/">Privacy Policy</a>
    to learn how <a href="https://www.mdanalysis.org">MDAnalysis</a> collects data.</p>
    <script data-goatcounter="https://mdanalysis.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</div>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
    var versions_json_url = 'https://docs.mdanalysis.org/versions.json'
</script>

<div class="rst-versions" data-toggle="rst-versions" role="note"
     aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
        2.8.0-dev0
      <span class="fa fa-caret-down"></span>
    </span>

    <div class="rst-other-versions">
        <dl id="versionselector">
            <dt>Other Versions</dt>
        </dl>

    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>