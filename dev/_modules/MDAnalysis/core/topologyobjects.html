


  
    
  




<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="shortcut icon" href="../../../_static/logo/mda_favicon.ico">
</head>

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MDAnalysis.core.topologyobjects &mdash; MDAnalysis 2.7.0-dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/site.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=542471e5"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/js/versions.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 2.7.0-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >




  




<a href="../../../index.html">
  
    <img src="../../../_static/logo/mda_logo.png" class="logo" alt="Logo"/>
</a>


  
  
  
    <div class="version">
      2.7.0-dev0
    </div>
  



<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>
<div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
    <!-- <p class="caption" role="heading"></p> -->
    <ul>
        
        <li class="toctree-l1"><a class="reference internal" href="http://mdanalysis.org">MDAnalysis</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="http://userguide.mdanalysis.org">User guide</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="https://mdakits.mdanalysis.org/">MDAKits</a></li>
        
    </ul>
    
        <p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/converters.html">7. Converter modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/trajectory_transformations.html">8. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections_modules.html">9. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/auxiliary_modules.html">10. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/core_modules.html">11. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/visualization_modules.html">12. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/lib_modules.html">13. Library functions — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/version.html">14. Version information for MDAnalysis - <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/units.html">15. Constants and unit conversion — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/exceptions.html">16. Custom exceptions and warnings — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/references.html">17. References</a></li>
</ul>

</div>

      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MDAnalysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">MDAnalysis.core.topologyobjects</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MDAnalysis.core.topologyobjects</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1"># doi: 10.25080/majora-629e541a-00e</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Core Topology Objects --- :mod:`MDAnalysis.core.topologyobjects`</span>
<span class="sd">================================================================</span>

<span class="sd">The building blocks for MDAnalysis&#39; description of topology</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">mdamath</span>
<span class="kn">from</span> <span class="nn">..lib.util</span> <span class="kn">import</span> <span class="n">cached</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">distances</span>


<div class="viewcode-block" id="TopologyObject">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyObject">[docs]</a>
<span class="nd">@functools</span><span class="o">.</span><span class="n">total_ordering</span>
<span class="k">class</span> <span class="nc">TopologyObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for all Topology items.</span>

<span class="sd">    Defines the behaviour by which Bonds/Angles/etc in MDAnalysis should</span>
<span class="sd">    behave.</span>

<span class="sd">    .. versionadded:: 0.9.0</span>
<span class="sd">    .. versionchanged:: 0.10.0</span>
<span class="sd">       All TopologyObject now keep track of if they were guessed or not</span>
<span class="sd">       via the ``is_guessed`` managed property.</span>
<span class="sd">    .. versionadded:: 0.11.0</span>
<span class="sd">       Added the `value` method to return the size of the object</span>
<span class="sd">    .. versionchanged:: 2.6.0</span>
<span class="sd">       Updated Atom ID representation order to match that of AtomGroup indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_ix&quot;</span><span class="p">,</span> <span class="s2">&quot;_u&quot;</span><span class="p">,</span> <span class="s2">&quot;btype&quot;</span><span class="p">,</span> <span class="s2">&quot;_bondtype&quot;</span><span class="p">,</span> <span class="s2">&quot;_guessed&quot;</span><span class="p">,</span> <span class="s2">&quot;order&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a topology object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ix : numpy array</span>
<span class="sd">          indices of the Atoms</span>
<span class="sd">        universe : MDAnalysis.Universe</span>
<span class="sd">        type : optional</span>
<span class="sd">          Type of the bond</span>
<span class="sd">        guessed : optional</span>
<span class="sd">          If the Bond is guessed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span> <span class="o">=</span> <span class="n">ix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bondtype</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">guessed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Atoms within this Bond&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tuple of indices describing this object</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type of the bond as a tuple</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        When comparing types, it is important to consider the reverse</span>
<span class="sd">        of the type too, i.e.::</span>

<span class="sd">            a.type == b.type or a.type == b.type[::-1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">types</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_guessed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return representation in same order of AtomGroup indices&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{cname}</span><span class="s2"> between: </span><span class="si">{conts}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">cname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">conts</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
                <span class="s2">&quot;Atom </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">]))</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether an atom is in this :class:`TopologyObject`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether two bonds have identical contents&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">universe</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Can retrieve a given Atom from within&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span></div>



<div class="viewcode-block" id="Bond">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Bond">[docs]</a>
<span class="k">class</span> <span class="nc">Bond</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;A bond between two :class:`~MDAnalysis.core.groups.Atom` instances.</span>

<span class="sd">    Two :class:`Bond` instances can be compared with the ``==`` and</span>
<span class="sd">    ``!=`` operators. A bond is equal to another if the same atom</span>
<span class="sd">    numbers are connected and they have the same bond order. The</span>
<span class="sd">    ordering of the two atom numbers is ignored as is the fact that a</span>
<span class="sd">    bond was guessed.</span>

<span class="sd">    The presence of a particular atom can also be queried::</span>

<span class="sd">      &gt;&gt;&gt; Atom in Bond</span>

<span class="sd">    will return either ``True`` or ``False``.</span>

<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now a subclass of :class:`TopologyObject`. Changed class to use</span>
<span class="sd">       :attr:`__slots__` and stores atoms in :attr:`atoms` attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;bond&#39;</span>

<div class="viewcode-block" id="Bond.partner">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Bond.partner">[docs]</a>
    <span class="k">def</span> <span class="nf">partner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bond.partner(Atom)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        the other :class:`~MDAnalysis.core.groups.Atom` in this</span>
<span class="sd">        bond</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">atom</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognised Atom&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Bond.length">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Bond.length">[docs]</a>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Length of the bond.</span>

<span class="sd">        .. versionchanged:: 0.11.0</span>
<span class="sd">           Added pbc keyword</span>
<span class="sd">        .. versionchanged:: 0.19.0</span>
<span class="sd">           Changed default of pbc to True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span></div>


    <span class="n">value</span> <span class="o">=</span> <span class="n">length</span></div>



<div class="viewcode-block" id="Angle">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Angle">[docs]</a>
<span class="k">class</span> <span class="nc">Angle</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;An angle between three :class:`~MDAnalysis.core.groups.Atom` instances.</span>
<span class="sd">    Atom 2 is the apex of the angle</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now a subclass of :class:`TopologyObject`; now uses</span>
<span class="sd">       :attr:`__slots__` and stores atoms in :attr:`atoms` attribute</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;angle&#39;</span>

<div class="viewcode-block" id="Angle.angle">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Angle.angle">[docs]</a>
    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the angle in degrees of this Angle.</span>

<span class="sd">        Angle between atoms 0 and 2 with apex at 1::</span>

<span class="sd">              2</span>
<span class="sd">             /</span>
<span class="sd">            /</span>
<span class="sd">           1------0</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The numerical precision is typically not better than</span>
<span class="sd">        4 decimals (and is only tested to 3 decimals).</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.17.0</span>
<span class="sd">           Fixed angles close to 180 giving NaN</span>
<span class="sd">        .. versionchanged:: 0.19.0</span>
<span class="sd">           Added pbc keyword, default True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">box</span><span class="p">))</span></div>


    <span class="n">value</span> <span class="o">=</span> <span class="n">angle</span></div>



<div class="viewcode-block" id="Dihedral">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Dihedral">[docs]</a>
<span class="k">class</span> <span class="nc">Dihedral</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dihedral (dihedral angle) between four</span>
<span class="sd">    :class:`~MDAnalysis.core.groups.Atom` instances.</span>

<span class="sd">    The dihedral is defined as the angle between the planes formed by</span>
<span class="sd">    Atoms (1, 2, 3) and (2, 3, 4).</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now a subclass of :class:`TopologyObject`; now uses :attr:`__slots__`</span>
<span class="sd">       and stores atoms in :attr:`atoms` attribute.</span>
<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Renamed to Dihedral (was Torsion)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># http://cbio.bmt.tue.nl/pumma/uploads/Theory/dihedral.png</span>
    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;dihedral&#39;</span>

<div class="viewcode-block" id="Dihedral.dihedral">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Dihedral.dihedral">[docs]</a>
    <span class="k">def</span> <span class="nf">dihedral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the dihedral angle in degrees.</span>

<span class="sd">        Dihedral angle around axis connecting atoms 1 and 2 (i.e. the angle</span>
<span class="sd">        between the planes spanned by atoms (0,1,2) and (1,2,3))::</span>

<span class="sd">                  3</span>
<span class="sd">                  |</span>
<span class="sd">            1-----2</span>
<span class="sd">           /</span>
<span class="sd">          0</span>


<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The numerical precision is typically not better than</span>
<span class="sd">        4 decimals (and is only tested to 3 decimals).</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.19.0</span>
<span class="sd">           Added pbc keyword, default True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">calc_dihedrals</span><span class="p">(</span>
            <span class="n">A</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">box</span><span class="p">))</span></div>


    <span class="n">value</span> <span class="o">=</span> <span class="n">dihedral</span></div>



<span class="c1"># subclass Dihedral to inherit dihedral method</span>
<div class="viewcode-block" id="ImproperDihedral">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.ImproperDihedral">[docs]</a>
<span class="k">class</span> <span class="nc">ImproperDihedral</span><span class="p">(</span><span class="n">Dihedral</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Improper Dihedral (improper dihedral angle) between four</span>
<span class="sd">    :class:`~MDAnalysis.core.groups.Atom` instances.</span>

<span class="sd">    MDAnalysis treats the improper dihedral angle as the angle between</span>
<span class="sd">    the planes formed by Atoms (1, 2, 3) and (2, 3, 4).</span>

<span class="sd">    .. warning:: Definitions of Atom ordering in improper dihedrals</span>
<span class="sd">                 can change. Check the definitions here against</span>
<span class="sd">                 your software.</span>

<span class="sd">    .. versionadded:: 0.9.0</span>
<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Renamed to ImproperDihedral (was Improper_Torsion)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># http://cbio.bmt.tue.nl/pumma/uploads/Theory/improper.png</span>
    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;improper&#39;</span>

<div class="viewcode-block" id="ImproperDihedral.improper">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.ImproperDihedral.improper">[docs]</a>
    <span class="k">def</span> <span class="nf">improper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Improper dihedral angle in degrees.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The numerical precision is typically not better than</span>
<span class="sd">        4 decimals (and is only tested to 3 decimals).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="UreyBradley">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.UreyBradley">[docs]</a>
<span class="k">class</span> <span class="nc">UreyBradley</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Urey-Bradley angle between two :class:`~MDAnalysis.core.groups.Atom` instances.</span>
<span class="sd">    Two :class:`UreyBradley` instances can be compared with the ``==`` and</span>
<span class="sd">    ``!=`` operators. A UreyBradley angle is equal to another if the same atom</span>
<span class="sd">    numbers are involved.</span>

<span class="sd">    .. versionadded:: 1.0.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;ureybradley&#39;</span>

<div class="viewcode-block" id="UreyBradley.partner">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.UreyBradley.partner">[docs]</a>
    <span class="k">def</span> <span class="nf">partner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;UreyBradley.partner(Atom)</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        the other :class:`~MDAnalysis.core.groups.Atom` in this</span>
<span class="sd">        interaction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">atom</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognised Atom&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="UreyBradley.distance">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.UreyBradley.distance">[docs]</a>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Distance between the atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span></div>


    <span class="n">value</span> <span class="o">=</span> <span class="n">distance</span></div>



<div class="viewcode-block" id="CMap">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.CMap">[docs]</a>
<span class="k">class</span> <span class="nc">CMap</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coupled-torsion correction map term between five </span>
<span class="sd">    :class:`~MDAnalysis.core.groups.Atom` instances.</span>

<span class="sd">    .. versionadded:: 1.0.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;cmap&#39;</span></div>



<div class="viewcode-block" id="TopologyDict">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict">[docs]</a>
<span class="k">class</span> <span class="nc">TopologyDict</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;A customised dictionary designed for sorting the bonds, angles and</span>
<span class="sd">    dihedrals present in a group of atoms.</span>

<span class="sd">    Usage::</span>

<span class="sd">      topologydict = TopologyDict(members)</span>


<span class="sd">    TopologyDicts are also built lazily from a :class:`TopologyGroup.topDict`</span>
<span class="sd">    attribute.</span>

<span class="sd">    The :class:`TopologyDict` collects all the selected topology type from the</span>
<span class="sd">    atoms and categorises them according to the types of the atoms within. A</span>
<span class="sd">    :class:`TopologyGroup` containing all of a given bond type can be made by</span>
<span class="sd">    querying with the appropriate key. The keys to the :class:`TopologyDict`</span>
<span class="sd">    are a tuple of the atom types that the bond represents and can be viewed</span>
<span class="sd">    using the :meth:`keys` method.</span>

<span class="sd">    For example, from a system containing pure ethanol ::</span>

<span class="sd">      &gt;&gt;&gt; td = u.bonds.topDict</span>
<span class="sd">      &gt;&gt;&gt; td.keys()</span>
<span class="sd">      [(&#39;C&#39;, &#39;C&#39;),</span>
<span class="sd">       (&#39;C&#39;, &#39;H&#39;),</span>
<span class="sd">       (&#39;O&#39;, &#39;H&#39;),</span>
<span class="sd">       (&#39;C&#39;, &#39;O&#39;)]</span>
<span class="sd">      &gt;&gt;&gt; td[&#39;C&#39;, &#39;O&#39;]</span>
<span class="sd">      &lt; TopologyGroup containing 912 bonds &gt;</span>

<span class="sd">    .. Note::</span>

<span class="sd">       The key for a bond is taken from the type attribute of the atoms.</span>

<span class="sd">       Getting and setting types of bonds is done smartly, so a C-C-H</span>
<span class="sd">       angle is considered identical to a H-C-C angle.</span>

<span class="sd">    Duplicate entries are automatically removed upon creation and</span>
<span class="sd">    combination of different Dicts.  This means a bond between atoms</span>
<span class="sd">    1 and 2 will only ever appear once in a dict despite both atoms 1</span>
<span class="sd">    and 2 having the bond in their :attr:`bond` attribute.</span>

<span class="sd">    Two :class:`TopologyDict` instances can be combined using</span>
<span class="sd">    addition and it will not create any duplicate bonds in the process.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    members :</span>
<span class="sd">      A list of :class:`TopologyObject` instances</span>


<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Changed initialisation to use a list of :class:`TopologyObject`</span>
<span class="sd">       instances instead of list of atoms; now used from within</span>
<span class="sd">       :class:`TopologyGroup` instead of accessed from :class:`AtomGroup`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topologygroup</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topologygroup</span><span class="p">,</span> <span class="n">TopologyGroup</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only construct from TopologyGroup&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">topologygroup</span><span class="o">.</span><span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">=</span> <span class="n">topologygroup</span><span class="o">.</span><span class="n">btype</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">topologygroup</span><span class="p">:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">type</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">btype</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">btype</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>

        <span class="c1"># Some force field types define bonds with a type</span>
        <span class="c1"># (Ex. 1: 12 or 21), while others define with a tuple of atom types</span>
        <span class="c1"># (Ex. 2: (&quot;H&quot;, &quot;O&quot;)  or (&quot;O&quot;, &quot;H&quot;)). If the bond type is a tuple</span>
        <span class="c1"># then the bond types in our second example are equivalent and one</span>
        <span class="c1"># should be removed. If the bonds are defined as an integer then</span>
        <span class="c1"># our first example would also be combined if `_removeDupes()`</span>
        <span class="c1"># is run.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_removeDupes</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_removeDupes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sorts through contents and makes sure that there are</span>
<span class="sd">        no duplicate keys (through type reversal)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Go through all keys, if the reverse of the key exists add this to</span>
        <span class="c1"># that entry else make a new entry</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">newdict</span><span class="p">:</span>
                <span class="n">newdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newdict</span><span class="p">[</span><span class="n">k</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="o">=</span> <span class="n">newdict</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of types of bond in the topology dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<div class="viewcode-block" id="TopologyDict.keys">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict.keys">[docs]</a>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of the different types of available bonds&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator over keys in this dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;TopologyDict with </span><span class="si">{num}</span><span class="s2"> unique </span><span class="si">{type}</span><span class="s2">s&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">toptype</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a TopologyGroup matching the criteria if possible,</span>
<span class="sd">        otherwise returns ``None``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">bix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">indices</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">bix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">toptype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns boolean on whether a given type exists within this dictionary</span>

<span class="sd">        For topology groups the key (1,2,3) is considered the same as (3,2,1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="ow">or</span> <span class="n">other</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span></div>



<span class="n">_BTYPE_TO_SHAPE</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bond&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;ureybradley&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> 
                   <span class="s1">&#39;dihedral&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;improper&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;cmap&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>


<div class="viewcode-block" id="TopologyGroup">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup">[docs]</a>
<span class="k">class</span> <span class="nc">TopologyGroup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;A container for a groups of bonds.</span>

<span class="sd">    All bonds of a certain types can be retrieved from within the</span>
<span class="sd">    :class:`TopologyGroup` by querying with a tuple of types::</span>

<span class="sd">      tg2 = tg.select_bonds([key])</span>

<span class="sd">    Where *key* describes the desired bond as a tuple of the involved</span>
<span class="sd">    :class:`~MDAnalysis.core.groups.Atom` types, as defined by the .type Atom</span>
<span class="sd">    attribute). A list of available keys can be displayed using the</span>
<span class="sd">    :meth:`types` method.</span>

<span class="sd">    Alternatively, all the bonds which are in a given</span>
<span class="sd">    :class:`~MDAnalysis.core.groups.AtomGroup` can be extracted using</span>
<span class="sd">    :meth:`atomgroup_intersection`::</span>

<span class="sd">      tg2 = tg.atomgroup_intersection(ag)</span>

<span class="sd">    This allows the keyword *strict* to be given, which forces all members of</span>
<span class="sd">    all bonds to be inside the AtomGroup passed to it.</span>

<span class="sd">    Finally, a TopologyGroup can be sliced similarly to AtomGroups::</span>

<span class="sd">      tg2 = tg[5:10]</span>

<span class="sd">    The :meth:`bonds`, :meth:`angles` and :meth:`dihedrals` methods offer</span>
<span class="sd">    a &quot;shortcut&quot; to the Cython distance calculation functions in</span>
<span class="sd">    :class:`MDAnalysis.lib.distances`.</span>

<span class="sd">    TopologyGroups can be combined with TopologyGroups of the same bond</span>
<span class="sd">    type (ie can combine two angle containing TopologyGroups).</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Overhauled completely: (1) Added internal :class:`TopologyDict`</span>
<span class="sd">       accessible by the :attr:`topDict` attribute. (2)</span>
<span class="sd">       :meth:`selectBonds` allows the :attr:`topDict` to be queried</span>
<span class="sd">       with tuple of types. (3) Added :meth:`atomgroup_intersection`</span>
<span class="sd">       to allow bonds which are in a given :class:`AtomGroup` to be retrieved.</span>
<span class="sd">    .. versionchanged:: 0.10.0</span>
<span class="sd">       Added :func:`from_indices` constructor, allowing class to be created</span>
<span class="sd">       from indices.</span>
<span class="sd">       Can now create empty Group.</span>
<span class="sd">       Renamed :meth:`dump_contents` to :meth:`to_indices`</span>
<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Added `values` method to return the size of each object in this group</span>
<span class="sd">       Deprecated selectBonds method in favour of select_bonds</span>
<span class="sd">    .. versionchanged:: 0.19.0</span>
<span class="sd">       Empty TopologyGroup now returns correctly shaped empty array via</span>
<span class="sd">       indices property and to_indices()</span>
<span class="sd">    .. versionchanged::1.0.0</span>
<span class="sd">       ``type``, ``guessed``, and ``order`` are no longer reshaped to arrays</span>
<span class="sd">       with an extra dimension</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bondidx</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">btype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># guess what I am</span>
            <span class="c1"># difference between dihedral and improper</span>
            <span class="c1"># not really important</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;bond&#39;</span><span class="p">,</span>
                          <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;angle&#39;</span><span class="p">,</span>
                          <span class="mi">4</span><span class="p">:</span> <span class="s1">&#39;dihedral&#39;</span><span class="p">}[</span><span class="nb">len</span><span class="p">(</span><span class="n">bondidx</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="k">elif</span> <span class="n">btype</span> <span class="ow">in</span> <span class="n">_BTYPE_TO_SHAPE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">=</span> <span class="n">btype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported btype, use one of &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_BTYPE_TO_SHAPE</span><span class="p">)))</span>

        <span class="n">bondidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bondidx</span><span class="p">)</span>
        <span class="n">nbonds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bondidx</span><span class="p">)</span>
        <span class="c1"># remove duplicate bonds</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbonds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">guessed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">guessed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">nbonds</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">guessed</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">guessed</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">guessed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">guessed</span><span class="p">,</span> <span class="n">nbonds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">guessed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">guessed</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbonds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nbonds</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">uniq</span><span class="p">,</span> <span class="n">uniq_idx</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">unique_rows</span><span class="p">(</span><span class="n">bondidx</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_bix</span> <span class="o">=</span> <span class="n">uniq</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bondtypes</span> <span class="o">=</span> <span class="nb">type</span><span class="p">[</span><span class="n">uniq_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">guessed</span><span class="p">[</span><span class="n">uniq_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="n">uniq_idx</span><span class="p">]</span>

            <span class="c1"># Create vertical AtomGroups</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span> <span class="o">=</span> <span class="p">[</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_bix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]]</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Empty TopologyGroup</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bondtypes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">universe</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># used for topdict saving</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The Universe that we belong to&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span>

<div class="viewcode-block" id="TopologyGroup.select_bonds">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.select_bonds">[docs]</a>
    <span class="k">def</span> <span class="nf">select_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves a selection from this topology group based on types.</span>

<span class="sd">        .. seeAlso :meth:`types`</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">topDict</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span></div>


    <span class="n">selectBonds</span> <span class="o">=</span> <span class="n">select_bonds</span>

<div class="viewcode-block" id="TopologyGroup.types">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.types">[docs]</a>
    <span class="k">def</span> <span class="nf">types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of the bond types in this TopologyGroup</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topDict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;dict&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">topDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the TopologyDict for this topology group.</span>

<span class="sd">        This is used for the select_bonds method when fetching a certain type</span>
<span class="sd">        of bond.</span>

<span class="sd">        This is a cached property so will be generated the first time it is</span>
<span class="sd">        accessed.</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TopologyDict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyGroup.atomgroup_intersection">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.atomgroup_intersection">[docs]</a>
    <span class="k">def</span> <span class="nf">atomgroup_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve all bonds from within this TopologyGroup that are within</span>
<span class="sd">        the AtomGroup which is passed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ag : AtomGroup</span>
<span class="sd">            The `:class:~MDAnalysis.core.groups.AtomGroup` to intersect</span>
<span class="sd">            with.</span>
<span class="sd">        strict : bool</span>
<span class="sd">            Only retrieve bonds which are completely contained within the</span>
<span class="sd">            AtomGroup. [``False``]</span>


<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Issue #780 - if self is empty, return self to avoid invalid mask</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Strict requires all items in a row to be seen,</span>
        <span class="c1"># otherwise any item in a row</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span> <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;strict&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span>

        <span class="n">atom_idx</span> <span class="o">=</span> <span class="n">ag</span><span class="o">.</span><span class="n">indices</span>
        <span class="c1"># Create a list of boolean arrays,</span>
        <span class="c1"># each representing a column of bond indices.</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">atom_idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bix</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>

        <span class="c1"># Create final boolean mask by summing across rows</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">seen</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;all bond indices</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_indices : function that just returns `indices`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># empty TG</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">_BTYPE_TO_SHAPE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bix</span>

<div class="viewcode-block" id="TopologyGroup.to_indices">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.to_indices">[docs]</a>
    <span class="k">def</span> <span class="nf">to_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a data structure with atom indices describing the bonds.</span>

<span class="sd">        This format should be identical to the original contents of the</span>
<span class="sd">        entries in universe._topology.</span>
<span class="sd">        Note that because bonds are sorted as they are initialised, the order</span>
<span class="sd">        that atoms are defined in each entry might be reversed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        indices : tuple</span>
<span class="sd">            A tuple of tuples which define the contents of this</span>
<span class="sd">            TopologyGroup in terms of the atom numbers.  (0 based</span>
<span class="sd">            index within u.atoms)</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Renamed from &quot;dump_contents&quot; to &quot;to_indices&quot;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span></div>


    <span class="n">dump_contents</span> <span class="o">=</span> <span class="n">to_indices</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of bonds in the topology group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine two TopologyGroups together.</span>

<span class="sd">        Can combined two TopologyGroup of the same type, or add a single</span>
<span class="sd">        TopologyObject to a TopologyGroup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check addition is sane</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TopologyObject</span><span class="p">,</span> <span class="n">TopologyGroup</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only combine TopologyObject or &quot;</span>
                            <span class="s2">&quot;TopologyGroup to TopologyGroup, not </span><span class="si">{0}</span><span class="s2">&quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

        <span class="c1"># cases where either other or self is empty TG</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span>  <span class="c1"># adding empty TG to me</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TopologyObject</span><span class="p">):</span>
                <span class="c1"># Reshape indices to be 2d array</span>
                <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:],</span>
                                     <span class="n">other</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span>
                                     <span class="n">btype</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">btype</span><span class="p">,</span>
                                     <span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">_bondtype</span><span class="p">]),</span>
                                     <span class="n">guessed</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">is_guessed</span><span class="p">]),</span>
                                     <span class="n">order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">order</span><span class="p">]),</span>
                                     <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span>
                                     <span class="n">other</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span>
                                     <span class="n">btype</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">btype</span><span class="p">,</span>
                                     <span class="nb">type</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">,</span>
                                     <span class="n">guessed</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">_guessed</span><span class="p">,</span>
                                     <span class="n">order</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span>
                                     <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot add different types of &quot;</span>
                                <span class="s2">&quot;TopologyObjects together&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TopologyObject</span><span class="p">):</span>
                <span class="c1"># add TO to me</span>
                <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span>
                    <span class="n">btype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">,</span>
                    <span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">,</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">_bondtype</span><span class="p">])]),</span>
                    <span class="n">guessed</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">,</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">is_guessed</span><span class="p">])]),</span>
                    <span class="n">order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">order</span><span class="p">])]),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># add TG to me</span>
                <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span>
                    <span class="n">btype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">,</span>
                    <span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">]),</span>
                    <span class="n">guessed</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_guessed</span><span class="p">]),</span>
                    <span class="n">order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_order</span><span class="p">]),</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a particular bond as single object or a subset of</span>
<span class="sd">        this TopologyGroup as another TopologyGroup</span>

<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Allows indexing via boolean numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Grab a single Item, similar to Atom/AtomGroup relationship</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">outclass</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bond&#39;</span><span class="p">:</span> <span class="n">Bond</span><span class="p">,</span>
                        <span class="s1">&#39;angle&#39;</span><span class="p">:</span> <span class="n">Angle</span><span class="p">,</span>
                        <span class="s1">&#39;dihedral&#39;</span><span class="p">:</span> <span class="n">Dihedral</span><span class="p">,</span>
                        <span class="s1">&#39;improper&#39;</span><span class="p">:</span> <span class="n">ImproperDihedral</span><span class="p">,</span>
                        <span class="s1">&#39;ureybradley&#39;</span><span class="p">:</span> <span class="n">UreyBradley</span><span class="p">,</span>
                        <span class="s1">&#39;cmap&#39;</span><span class="p">:</span> <span class="n">CMap</span><span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">outclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bix</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">,</span>
                            <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
                            <span class="n">guessed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
                            <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Slice my index array with the item</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bix</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">,</span>
                                  <span class="n">btype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">,</span>
                                  <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
                                  <span class="n">guessed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
                                  <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">[</span><span class="n">item</span><span class="p">],)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tests if this TopologyGroup contains a bond&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">indices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bix</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;TopologyGroup containing </span><span class="si">{num}</span><span class="s2"> </span><span class="si">{type}</span><span class="s2">s&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test if contents of TopologyGroups are equal&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The first atom in each TopologyObject in this Group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The second atom in each TopologyObject in this Group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The third atom in each TopologyObject in this Group&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">nvert</span> <span class="o">=</span> <span class="n">_BTYPE_TO_SHAPE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">]</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TopologyGroup of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="si">}</span><span class="s2">s only has </span><span class="si">{</span><span class="n">nvert</span><span class="si">}</span><span class="s2"> &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;vertical AtomGroups&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom4</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The fourth atom in each TopologyObject in this Group&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">nvert</span> <span class="o">=</span> <span class="n">_BTYPE_TO_SHAPE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">]</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TopologyGroup of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="si">}</span><span class="s2">s only has </span><span class="si">{</span><span class="n">nvert</span><span class="si">}</span><span class="s2"> &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;vertical AtomGroups&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

    <span class="c1"># Distance calculation methods below</span>
    <span class="c1"># &quot;Slow&quot; versions exist as a way of testing the Cython implementations</span>
<div class="viewcode-block" id="TopologyGroup.values">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.values">[docs]</a>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the size of each object in this Group</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *pbc*</span>
<span class="sd">              apply periodic boundary conditions when calculating distance</span>
<span class="sd">              [``False``]</span>
<span class="sd">           *result*</span>
<span class="sd">              allows a predefined results array to be used,</span>
<span class="sd">              note that this will be overwritten</span>

<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;bond&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;dihedral&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;improper&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_calc_connection_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">btypes</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="n">btype</span> <span class="k">for</span> <span class="n">btype</span> <span class="ow">in</span> <span class="n">btypes</span><span class="p">):</span>
            <span class="n">strbtype</span> <span class="o">=</span> <span class="s2">&quot;&#39; or &#39;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">btypes</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TopologyGroup is not of type &#39;</span><span class="si">{</span><span class="n">strbtype</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">box</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">pbc</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">ag</span><span class="o">.</span><span class="n">positions</span> <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">positions</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyGroup.bonds">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.bonds">[docs]</a>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the distance between all bonds in this TopologyGroup</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *pbc*</span>
<span class="sd">              apply periodic boundary conditions when calculating distance</span>
<span class="sd">              [False]</span>
<span class="sd">           *result*</span>
<span class="sd">              allows a predefined results array to be used,</span>
<span class="sd">              note that this will be overwritten</span>

<span class="sd">        Uses cython implementation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_connection_values</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">calc_bonds</span><span class="p">,</span> <span class="s2">&quot;bond&quot;</span><span class="p">,</span>
                                            <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="TopologyGroup.angles">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.angles">[docs]</a>
    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the angle in radians formed between a bond</span>
<span class="sd">        between atoms 1 and 2 and a bond between atoms 2 &amp; 3</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        result : array_like</span>
<span class="sd">            allows a predefined results array to be used, note that this</span>
<span class="sd">            will be overwritten</span>
<span class="sd">        pbc : bool</span>
<span class="sd">            apply periodic boundary conditions when calculating angles</span>
<span class="sd">            [``False``] this is important when connecting vectors between</span>
<span class="sd">            atoms might require minimum image convention</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        angles : ndarray</span>

<span class="sd">        .. versionchanged :: 0.9.0</span>
<span class="sd">           Added *pbc* option (default ``False``)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_connection_values</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">,</span> <span class="s2">&quot;angle&quot;</span><span class="p">,</span>
                                            <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="TopologyGroup.dihedrals">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.dihedrals">[docs]</a>
    <span class="k">def</span> <span class="nf">dihedrals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the dihedral angle in radians for this topology</span>
<span class="sd">        group.</span>

<span class="sd">        Defined as the angle between a plane formed by atoms 1, 2 and</span>
<span class="sd">        3 and a plane formed by atoms 2, 3 and 4.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        result : array_like</span>
<span class="sd">            allows a predefined results array to be used, note that this</span>
<span class="sd">            will be overwritten</span>
<span class="sd">        pbc : bool</span>
<span class="sd">            apply periodic boundary conditions when calculating angles</span>
<span class="sd">            [``False``] this is important when connecting vectors between</span>
<span class="sd">            atoms might require minimum image convention</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        angles : ndarray</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Added *pbc* option (default ``False``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_connection_values</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">calc_dihedrals</span><span class="p">,</span>
                                            <span class="s2">&quot;dihedral&quot;</span><span class="p">,</span> <span class="s2">&quot;improper&quot;</span><span class="p">,</span>
                                            <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2023, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Henok Ademtew, Shobhit Agarwal, Aya M. Alaa, Irfan Alibay, Kazi Shudipto Amin, Anshul Angaria, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Patricio Barletta, Leonardo Barneschi, Jonathan Barnoud, Estefania Barreto-Ojeda, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Kavya Bisht, Wouter Boomsma, Jose Borreguero, Cédric Bouysset, Kevin Boyd, Meet Brijwani, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, Yantong Cai, David Caplan, Yuanyu Chang, Pratham Chauhan, Matthieu Chavent, Haochuan Chen, Xu Hong Chen, Kathleen Clark, Jennifer A Clark, Orion Cohen, Charlie Cook, Ruggero Cortini, Nicholas Craven, Ramon Crehuet, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Mark D. Driver, Ali Ehlen, Daniel J. Evans, Shujie Fan, Bjarne Feddersen, Lennard van der Feltz, Jake Fennick, Philip Fowler, Guillaume Fraux, Anirvinya G, Ahmed Salah Ghoneim, Mikhail Glagolev, William Glass, Joseph Goose, Alexander Gorfer, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Pratik Gupta, Benjamin Hall, Ameya Harmalkar, Ivan Hristov, Eugen Hruska, Kyle J. Huston, Siddharth Jain, Edis Jakupovic, Joe Jordan, Henrik Jäger, Uma D Kadam, Aditya Kamath, Jon Kapla, Ian M. Kenney, Haleema Khan, Navya Khare, Utsav Khatu, Andrew William King, Henry Kobin, Abhishek A. Kognole, Kosuke Kudo, Atharva Kulkarni, Manish Kumar, Mohit Kumar, Shubham Kumar, Alia Lescoulie, Max Linke, Philip Loche, Jinju Lu, Hugo MacDermott-Opeskin, Shaivi Malik, Egor Marin, Domenico Marson, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Rocco Meli, Manuel Nuno Melo, Marcelo C. R. Melo, Dominik &#39;Rathann&#39; Mierzejewski, Geongi Moon, Henry Mull, Morgan L. Nance, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Meghan Osato, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Dimitrios Papageorgiou, Rafael R. Pappalardo, Vishal Parmar, Danny Parton, Shakul Pathak, Christian Pfaendner, Joshua L. Phillips, Marcelo D. Poleto, Hannah Pollak, Kashish Punjani, Michael Quevillon, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Andrea Rizzi, Xiaoxu Ruan, Carlos Yanez S., Utkarsh Saxena, Moritz Schaeffler, Alexander Schlaich, Marcello Sega, Ricky Sexton, Sean L. Seyler, Faraaz Shah, Sulay Shah, Abhishek Shandilya, Shubham Sharma, Rishabh Shukla, Karthikeyan Singaravelan, Tamandeep Singh, Paul Smith, Andy Somogyi, Caio S. Souza, Shantanu Srivastava, Lukas Stelzl, Jan Stevens, Gorman Stock, Fenil Suchak, Ayush Suhane, Filip T. Szczypiński, Sukeerti T, Matthijs Tadema, Joao Miguel Correia Teixeira, Paarth Thadani, Matthew W. Thompson, Hao Tian, Matteo Tiberti, Zaheer Timol, Wiep van der Toorn, Mieczyslaw Torchala, Aditi Tripathi, Mark Verma, Josh Vermaas, Isaac Virshup, Lily Wang, Nestor Wendt, Zhiyi Wu, Tengyu Xie, Zhuyi Xue, Mingyi Xue, Alexander Yang, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, Raymond Zhao, Yuxuan Zhuang, and Oliver Beckstein.</p>
  </div>

  

<div class="footer"><p>Please see
    our <a href="https://www.mdanalysis.org/pages/privacy/">Privacy Policy</a>
    to learn how <a href="https://www.mdanalysis.org">MDAnalysis</a> collects data.</p>
    <script data-goatcounter="https://mdanalysis.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</div>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
    var versions_json_url = 'https://docs.mdanalysis.org/versions.json'
</script>

<div class="rst-versions" data-toggle="rst-versions" role="note"
     aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
        2.7.0-dev0
      <span class="fa fa-caret-down"></span>
    </span>

    <div class="rst-other-versions">
        <dl id="versionselector">
            <dt>Other Versions</dt>
        </dl>

    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>