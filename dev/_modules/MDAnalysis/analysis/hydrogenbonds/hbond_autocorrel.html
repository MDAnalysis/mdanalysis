


  
    
  




<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="shortcut icon" href="../../../../_static/logo/mda_favicon.ico">
</head>

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MDAnalysis.analysis.hydrogenbonds.hbond_autocorrel &mdash; MDAnalysis 2.8.0-dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/site.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=a9b57af3"></script>
        <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../../_static/js/versions.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 2.8.0-dev0 documentation"
          href="../../../../_static/opensearch.xml"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >




  




<a href="../../../../index.html">
  
    <img src="../../../../_static/logo/mda_logo.png" class="logo" alt="Logo"/>
</a>


  
  
  
    <div class="version">
      2.8.0-dev0
    </div>
  



<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>
<div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
    <!-- <p class="caption" role="heading"></p> -->
    <ul>
        
        <li class="toctree-l1"><a class="reference internal" href="http://mdanalysis.org">MDAnalysis</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="http://userguide.mdanalysis.org">User guide</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="https://mdakits.mdanalysis.org/">MDAKits</a></li>
        
    </ul>
    
        <p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/converters.html">7. Converter modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/trajectory_transformations.html">8. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/selections_modules.html">9. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/auxiliary_modules.html">10. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/core_modules.html">11. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/visualization_modules.html">12. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/lib_modules.html">13. Library functions — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/version.html">14. Version information for MDAnalysis - <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/units.html">15. Constants and unit conversion — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/exceptions.html">16. Custom exceptions and warnings — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/references.html">17. References</a></li>
</ul>

</div>

      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MDAnalysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">MDAnalysis.analysis.hydrogenbonds.hbond_autocorrel</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MDAnalysis.analysis.hydrogenbonds.hbond_autocorrel</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1"># doi: 10.25080/majora-629e541a-00e</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">Hydrogen bond autocorrelation --- :mod:`MDAnalysis.analysis.hydrogenbonds.hbond_autocorrel`</span>
<span class="sd">===========================================================================================</span>

<span class="sd">:Author: Richard J. Gowers</span>
<span class="sd">:Year: 2014</span>
<span class="sd">:Copyright: GNU Public License v3</span>

<span class="sd">.. versionadded:: 0.9.0</span>

<span class="sd">.. versionchanged:: 2.0.0</span>

<span class="sd">   Module moved from :mod:`MDAnalysis.analysis.hbonds.hbond_autocorrel` to</span>
<span class="sd">   :mod:`MDAnalysis.analysis.hydrogenbonds.hbond_autocorrel`.</span>


<span class="sd">Description</span>
<span class="sd">-----------</span>

<span class="sd">Calculates the time autocorrelation function, :math:`C_x(t)`, for the hydrogen</span>
<span class="sd">bonds in the selections passed to it.  The population of hydrogen bonds at a</span>
<span class="sd">given startpoint, :math:`t_0`, is evaluated based on geometric criteria and</span>
<span class="sd">then the lifetime of these bonds is monitored over time.  Multiple passes</span>
<span class="sd">through the trajectory are used to build an average of the behaviour.</span>

<span class="sd">.. math::</span>
<span class="sd">   C_x(t) = \\left \\langle \\frac{h_{ij}(t_0) h_{ij}(t_0 + t)}{h_{ij}(t_0)^2} \\right\\rangle</span>

<span class="sd">The subscript :math:`x` refers to the definition of lifetime being used, either</span>
<span class="sd">continuous or intermittent.  The continuous definition measures the time that</span>
<span class="sd">a particular hydrogen bond remains continuously attached, whilst the</span>
<span class="sd">intermittent definition allows a bond to break and then subsequently reform and</span>
<span class="sd">be counted again.  The relevent lifetime, :math:`\\tau_x`, can then be found</span>
<span class="sd">via integration of this function</span>

<span class="sd">.. math::</span>
<span class="sd">   \\tau_x = \\int_0^\\infty C_x(t) dt`</span>

<span class="sd">For this, the observed behaviour is fitted to a multi exponential function,</span>
<span class="sd">using 2 exponents for the continuous lifetime and 3 for the intermittent</span>
<span class="sd">lifetime.</span>

<span class="sd">.. math::</span>
<span class="sd">    C_x(t) = A_1 \\exp( - t / \\tau_1)</span>
<span class="sd">    + A_2 \\exp( - t / \\tau_2)</span>
<span class="sd">    [+ A_3 \\exp( - t / \\tau_3)]</span>

<span class="sd">Where the final pre expoential factor :math:`A_n` is subject to the condition:</span>

<span class="sd">.. math::</span>
<span class="sd">    A_n = 1 - \\sum\\limits_{i=1}^{n-1} A_i</span>

<span class="sd">For further details see :footcite:p:`Gowers2015`.</span>

<span class="sd">Input</span>
<span class="sd">-----</span>

<span class="sd">Three AtomGroup selections representing the **hydrogens**, **donors** and</span>
<span class="sd">**acceptors** that you wish to analyse.  Note that the **hydrogens** and</span>
<span class="sd">**donors** selections must be aligned, that is **hydrogens[0]** and</span>
<span class="sd">**donors[0]** must represent a bonded pair.  For systems such as water,</span>
<span class="sd">this will mean that each oxygen appears twice in the **donors** AtomGroup.</span>
<span class="sd">The function :func:`find_hydrogen_donors` can be used to construct the donor</span>
<span class="sd">AtomGroup</span>
<span class="sd">::</span>

<span class="sd">  import MDAnalysis as mda</span>
<span class="sd">  from MDAnalysis.analysis import hydrogenbonds</span>
<span class="sd">  from MDAnalysis.tests.datafiles import waterPSF, waterDCD</span>
<span class="sd">  u = mda.Universe(waterPSF, waterDCD)</span>
<span class="sd">  hydrogens = u.select_atoms(&#39;name H*&#39;)</span>
<span class="sd">  donors = hydrogenbonds.find_hydrogen_donors(hydrogens)</span>


<span class="sd">Note that this requires the Universe to have bond information.  If this isn&#39;t</span>
<span class="sd">present in the topology file, the</span>
<span class="sd">:meth:`MDAnalysis.core.groups.AtomGroup.guess_bonds` method can be used</span>
<span class="sd">as so</span>
<span class="sd">::</span>

<span class="sd">  import MDAnalysis as mda</span>
<span class="sd">  from MDAnalysis.analysis import hydrogenbonds</span>
<span class="sd">  from MDAnalysis.tests.datafiles import GRO</span>
<span class="sd">  # we could load the Universe with guess_bonds=True</span>
<span class="sd">  # but this would guess **all** bonds</span>
<span class="sd">  u = mda.Universe(GRO)</span>
<span class="sd">  water = u.select_atoms(&#39;resname SOL and not type DUMMY&#39;)</span>
<span class="sd">  # guess bonds only within our water atoms</span>
<span class="sd">  # this adds the bond information directly to the Universe</span>
<span class="sd">  water.guess_bonds()</span>
<span class="sd">  hydrogens = water.select_atoms(&#39;type H&#39;)</span>
<span class="sd">  # this is now possible as we guessed the bonds</span>
<span class="sd">  donors = hydrogenbonds.find_hydrogen_donors(hydrogens)</span>


<span class="sd">The keyword **exclusions** allows a tuple of array addresses to be provided,</span>
<span class="sd">(Hidx, Aidx),these pairs of hydrogen-acceptor are then not permitted to be</span>
<span class="sd">counted as part of the analysis.  This could be used to exclude the</span>
<span class="sd">consideration of hydrogen bonds within the same functional group, or to perform</span>
<span class="sd">analysis on strictly intermolecular hydrogen bonding.</span>

<span class="sd">Hydrogen bonds are defined on the basis of geometric criteria; a</span>
<span class="sd">Hydrogen-Acceptor distance of less then **dist_crit** and a</span>
<span class="sd">Donor-Hydrogen-Acceptor angle of greater than **angle_crit**.</span>

<span class="sd">The length of trajectory to analyse in ps, **sample_time**, is used to choose</span>
<span class="sd">what length to analyse.</span>

<span class="sd">Multiple passes, controlled by the keyword **nruns**, through the trajectory</span>
<span class="sd">are performed and an average calculated.  For each pass, **nsamples** number</span>
<span class="sd">of points along the run are calculated.</span>


<span class="sd">Output</span>
<span class="sd">------</span>

<span class="sd">All results of the analysis are available through the *solution* attribute.</span>
<span class="sd">This is a dictionary with the following keys</span>

<span class="sd">- *results*:  The raw results of the time autocorrelation function.</span>
<span class="sd">- *time*:     Time axis, in ps, for the results.</span>
<span class="sd">- *fit*:      Results of the exponential curve fitting procedure. For the</span>
<span class="sd">             *continuous* lifetime these are (A1, tau1, tau2), for the</span>
<span class="sd">             *intermittent* lifetime these are (A1, A2, tau1, tau2, tau3).</span>
<span class="sd">- *tau*:      Calculated time constant from the fit.</span>
<span class="sd">- *estimate*: Estimated values generated by the calculated fit.</span>

<span class="sd">The *results* and *time* values are only filled after the :meth:`run` method,</span>
<span class="sd">*fit*, *tau* and *estimate* are filled after the :meth:`solve` method has been</span>
<span class="sd">used.</span>


<span class="sd">Worked Example for Polyamide</span>
<span class="sd">----------------------------</span>

<span class="sd">This example finds the continuous hydrogen bond lifetime between N-H..O in a</span>
<span class="sd">polyamide system.  This will use the default geometric definition for hydrogen</span>
<span class="sd">bonds of length 3.0 Å and angle of 130 degrees.</span>
<span class="sd">It will observe a window of 2.0 ps (`sample_time`) and try to gather 1000</span>
<span class="sd">sample point within this time window (this relies upon the trajectory being</span>
<span class="sd">sampled frequently enough).  This process is repeated for 20 different start</span>
<span class="sd">points to build a better average.</span>

<span class="sd">::</span>

<span class="sd">  import MDAnalysis as mda</span>
<span class="sd">  from MDAnalysis.analysis import hydrogenbonds</span>
<span class="sd">  from MDAnalysis.tests.datafiles import TRZ_psf, TRZ</span>
<span class="sd">  import matplotlib.pyplot as plt</span>
<span class="sd">  # load system</span>
<span class="sd">  u = mda.Universe(TRZ_psf, TRZ)</span>
<span class="sd">  # select atoms of interest into AtomGroups</span>
<span class="sd">  H = u.select_atoms(&#39;name Hn&#39;)</span>
<span class="sd">  N = u.select_atoms(&#39;name N&#39;)</span>
<span class="sd">  O = u.select_atoms(&#39;name O&#39;)</span>
<span class="sd">  # create analysis object</span>
<span class="sd">  hb_ac = hydrogenbonds.HydrogenBondAutoCorrel(u,</span>
<span class="sd">              acceptors=O, hydrogens=H, donors=N,</span>
<span class="sd">              bond_type=&#39;continuous&#39;,</span>
<span class="sd">              sample_time=2.0, nsamples=1000, nruns=20)</span>
<span class="sd">  # call run to gather results</span>
<span class="sd">  hb_ac.run()</span>
<span class="sd">  # attempt to fit results to exponential equation</span>
<span class="sd">  hb_ac.solve()</span>
<span class="sd">  # grab results from inside object</span>
<span class="sd">  tau = hb_ac.solution[&#39;tau&#39;]</span>
<span class="sd">  time = hb_ac.solution[&#39;time&#39;]</span>
<span class="sd">  results = hb_ac.solution[&#39;results&#39;]</span>
<span class="sd">  estimate = hb_ac.solution[&#39;estimate&#39;]</span>
<span class="sd">  # plot to check!</span>
<span class="sd">  plt.plot(time, results, &#39;ro&#39;)</span>
<span class="sd">  plt.plot(time, estimate)</span>
<span class="sd">  plt.show()</span>


<span class="sd">Functions and Classes</span>
<span class="sd">---------------------</span>

<span class="sd">.. autofunction:: find_hydrogen_donors</span>

<span class="sd">.. autoclass:: HydrogenBondAutoCorrel</span>
<span class="sd">   :members:</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">MDAnalysis.lib._cutil</span> <span class="kn">import</span> <span class="n">_in2d</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.log</span> <span class="kn">import</span> <span class="n">ProgressBar</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.distances</span> <span class="kn">import</span> <span class="n">capped_distance</span><span class="p">,</span> <span class="n">calc_angles</span><span class="p">,</span> <span class="n">calc_bonds</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.core.groups</span> <span class="kn">import</span> <span class="n">requires</span>

<span class="kn">from</span> <span class="nn">MDAnalysis.due</span> <span class="kn">import</span> <span class="n">due</span><span class="p">,</span> <span class="n">Doi</span>
<span class="n">due</span><span class="o">.</span><span class="n">cite</span><span class="p">(</span><span class="n">Doi</span><span class="p">(</span><span class="s2">&quot;10.1063/1.4922445&quot;</span><span class="p">),</span>
         <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Hydrogen bonding autocorrelation time&quot;</span><span class="p">,</span>
         <span class="n">path</span><span class="o">=</span><span class="s1">&#39;MDAnalysis.analysis.hydrogenbonds.hbond_autocorrel&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">del</span> <span class="n">Doi</span>


<div class="viewcode-block" id="find_hydrogen_donors">
<a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_autocorrel.html#MDAnalysis.analysis.hydrogenbonds.hbond_autocorrel.find_hydrogen_donors">[docs]</a>
<span class="nd">@requires</span><span class="p">(</span><span class="s1">&#39;bonds&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">find_hydrogen_donors</span><span class="p">(</span><span class="n">hydrogens</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the donor atom for each hydrogen</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hydrogens : AtomGroup</span>
<span class="sd">      the hydrogens that will form hydrogen bonds</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    donors : AtomGroup</span>
<span class="sd">      the donor atom for each hydrogen, found via bond information</span>


<span class="sd">    .. versionadded:: 0.20.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">bonded_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">)</span></div>



<div class="viewcode-block" id="HydrogenBondAutoCorrel">
<a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_autocorrel.html#MDAnalysis.analysis.hydrogenbonds.hbond_autocorrel.HydrogenBondAutoCorrel">[docs]</a>
<span class="k">class</span> <span class="nc">HydrogenBondAutoCorrel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform a time autocorrelation of the hydrogen bonds in the system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    universe : Universe</span>
<span class="sd">        MDAnalysis Universe that all selections belong to</span>
<span class="sd">    hydrogens : AtomGroup</span>
<span class="sd">        AtomGroup of Hydrogens which can form hydrogen bonds</span>
<span class="sd">    acceptors : AtomGroup</span>
<span class="sd">        AtomGroup of all Acceptor atoms</span>
<span class="sd">    donors : AtomGroup</span>
<span class="sd">        The atoms which are connected to the hydrogens.  This group</span>
<span class="sd">        must be identical in length to the hydrogen group and matched,</span>
<span class="sd">        ie hydrogens[0] is bonded to donors[0].</span>
<span class="sd">        For water, this will mean a donor appears twice in this</span>
<span class="sd">        group, once for each hydrogen.</span>
<span class="sd">    bond_type : str</span>
<span class="sd">        Which definition of hydrogen bond lifetime to consider, either</span>
<span class="sd">        &#39;continuous&#39; or &#39;intermittent&#39;.</span>
<span class="sd">    exclusions : ndarray, optional</span>
<span class="sd">        Indices of Hydrogen-Acceptor pairs to be excluded.</span>
<span class="sd">        With nH and nA Hydrogens and Acceptors, a (nH x nA) array of distances</span>
<span class="sd">        is calculated, *exclusions* is used as a mask on this array to exclude</span>
<span class="sd">        some pairs.</span>
<span class="sd">    angle_crit : float, optional</span>
<span class="sd">        The angle (in degrees) which all bonds must be greater than [130.0]</span>
<span class="sd">    dist_crit : float, optional</span>
<span class="sd">        The maximum distance (in Angstroms) for a hydrogen bond [3.0]</span>
<span class="sd">    sample_time : float, optional</span>
<span class="sd">        The amount of time, in ps, that you wish to observe hydrogen</span>
<span class="sd">        bonds for [100]</span>
<span class="sd">    nruns : int, optional</span>
<span class="sd">        The number of different start points within the trajectory</span>
<span class="sd">        to use [1]</span>
<span class="sd">    nsamples : int, optional</span>
<span class="sd">        Within each run, the number of frames to analyse [50]</span>
<span class="sd">    pbc : bool, optional</span>
<span class="sd">        Whether to consider periodic boundaries in calculations [``True``]</span>

<span class="sd">    ..versionchanged: 1.0.0</span>
<span class="sd">      ``save_results()`` method was removed. You can instead use ``np.savez()``</span>
<span class="sd">      on :attr:`HydrogenBondAutoCorrel.solution[&#39;time&#39;]` and</span>
<span class="sd">      :attr:`HydrogenBondAutoCorrel.solution[&#39;results&#39;]` instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span>
                 <span class="n">hydrogens</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">acceptors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">donors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">bond_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">angle_crit</span><span class="o">=</span><span class="mf">130.0</span><span class="p">,</span> <span class="n">dist_crit</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>  <span class="c1"># geometric criteria</span>
                 <span class="n">sample_time</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>  <span class="c1"># expected length of the decay in ps</span>
                 <span class="n">time_cut</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># cutoff time for intermittent hbonds</span>
                 <span class="n">nruns</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># number of times to iterate through the trajectory</span>
                 <span class="n">nsamples</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>  <span class="c1"># number of different points to sample in a run</span>
                 <span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="c1">#warnings.warn(&quot;This class is deprecated, use analysis.hbonds.HydrogenBondAnalysis &quot;</span>
        <span class="c1">#              &quot;which has .autocorrelation function&quot;,</span>
        <span class="c1">#              category=DeprecationWarning)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="c1"># check that slicing is possible</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trajectory must support slicing&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">hydrogens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">acceptors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">donors</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Donors and Hydrogen groups must be identical &quot;</span>
                             <span class="s2">&quot;length.  Try using `find_hydrogen_donors`.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclusions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exclusions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exclusions</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;&#39;exclusion&#39; must be two arrays of identical length&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span>
                <span class="n">exclusions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exclusions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bond_type</span> <span class="o">=</span> <span class="n">bond_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;intermittent&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;bond_type must be either &#39;continuous&#39; or &#39;intermittent&#39;&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a_crit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angle_crit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_crit</span> <span class="o">=</span> <span class="n">dist_crit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_time</span> <span class="o">=</span> <span class="n">sample_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nruns</span> <span class="o">=</span> <span class="n">nruns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slice_traj</span><span class="p">(</span><span class="n">sample_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_cut</span> <span class="o">=</span> <span class="n">time_cut</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;results&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Raw results</span>
            <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Time axis of raw results</span>
            <span class="s1">&#39;fit&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># coefficients for fit</span>
            <span class="s1">&#39;tau&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># integral of exponential fit</span>
            <span class="s1">&#39;estimate&#39;</span><span class="p">:</span> <span class="kc">None</span>  <span class="c1"># y values of fit against time</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_slice_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_time</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up start and end points in the trajectory for the</span>
<span class="sd">        different passes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">dt</span>  <span class="c1"># frame step size in time</span>
        <span class="n">req_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_time</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1"># the number of frames required</span>

        <span class="n">n_frames</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">req_frames</span> <span class="o">&gt;</span> <span class="n">n_frames</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Number of required frames (</span><span class="si">{}</span><span class="s2">) greater than the&quot;</span>
                          <span class="s2">&quot; number of frames in trajectory (</span><span class="si">{}</span><span class="s2">)&quot;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">req_frames</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="n">numruns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nruns</span>
        <span class="k">if</span> <span class="n">numruns</span> <span class="o">&gt;</span> <span class="n">n_frames</span><span class="p">:</span>
            <span class="n">numruns</span> <span class="o">=</span> <span class="n">n_frames</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Number of runs (</span><span class="si">{}</span><span class="s2">) greater than the number of&quot;</span>
                          <span class="s2">&quot; frames in trajectory (</span><span class="si">{}</span><span class="s2">)&quot;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nruns</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">,</span> <span class="n">n_frames</span> <span class="o">/</span> <span class="n">numruns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># limit stop points using clip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_starts</span> <span class="o">+</span> <span class="n">req_frames</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="n">req_frames</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># If nsamples &gt; req_frames</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Desired number of sample points too high, using </span><span class="si">{0}</span><span class="s2">&quot;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">req_frames</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="HydrogenBondAutoCorrel.run">
<a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_autocorrel.html#MDAnalysis.analysis.hydrogenbonds.hbond_autocorrel.HydrogenBondAutoCorrel.run">[docs]</a>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run all the required passes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        force : bool, optional</span>
<span class="sd">            Will overwrite previous results if they exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if results exist, don&#39;t waste any time</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">main_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_starts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">_stops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span><span class="p">),</span>
                                          <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1"># for normalising later</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">main_results</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ProgressBar</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_starts</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_stops</span><span class="p">)),</span> <span class="n">total</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nruns</span><span class="p">,</span>
                                            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Performing run&quot;</span><span class="p">):</span>

            <span class="c1"># needed else trj seek thinks a np.int64 isn&#39;t an int?</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_run</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">stop</span><span class="p">))</span>

            <span class="n">nresults</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nresults</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_results</span><span class="p">):</span>
                <span class="n">main_results</span> <span class="o">+=</span> <span class="n">results</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">main_results</span><span class="p">[:</span><span class="n">nresults</span><span class="p">]</span> <span class="o">+=</span> <span class="n">results</span>
                <span class="n">counter</span><span class="p">[:</span><span class="n">nresults</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>

        <span class="n">main_results</span> <span class="o">/=</span> <span class="n">counter</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">main_results</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">dt</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">main_results</span></div>


    <span class="k">def</span> <span class="nf">_single_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a single pass of the trajectory&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>

        <span class="c1"># Calculate partners at t=0</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># 2d array of all distances</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="n">capped_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                               <span class="n">max_cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_crit</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">,</span>
                               <span class="n">return_distances</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pair</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="o">~</span> <span class="n">_in2d</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span><span class="p">)]</span>

        <span class="n">hidx</span><span class="p">,</span> <span class="n">aidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>


        <span class="n">a</span> <span class="o">=</span> <span class="n">calc_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">hidx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">hidx</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">aidx</span><span class="p">],</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
        <span class="c1"># from amongst those, who also satisfiess angle crit</span>
        <span class="n">idx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_crit</span><span class="p">)</span>
        <span class="n">hidx</span> <span class="o">=</span> <span class="n">hidx</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>
        <span class="n">aidx</span> <span class="o">=</span> <span class="n">aidx</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>

        <span class="n">nbonds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hidx</span><span class="p">)</span>  <span class="c1"># number of hbonds at t=0</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span><span class="p">),</span>
                                   <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_cut</span><span class="p">:</span>
            <span class="c1"># counter for time criteria</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbonds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_skip</span><span class="p">]):</span>
            <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="n">d</span> <span class="o">=</span> <span class="n">calc_bonds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">hidx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">aidx</span><span class="p">],</span>
                           <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">calc_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">hidx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">hidx</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">aidx</span><span class="p">],</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>

            <span class="n">winners</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_crit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_crit</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">winners</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                <span class="c1"># Remove losers for continuous definition</span>
                <span class="n">hidx</span> <span class="o">=</span> <span class="n">hidx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">winners</span><span class="p">)]</span>
                <span class="n">aidx</span> <span class="o">=</span> <span class="n">aidx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">winners</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_type</span> <span class="o">==</span> <span class="s1">&#39;intermittent&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_cut</span><span class="p">:</span>
                    <span class="c1"># Add to counter of where losers are</span>
                    <span class="n">count</span><span class="p">[</span><span class="o">~</span> <span class="n">winners</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">dt</span>
                    <span class="n">count</span><span class="p">[</span><span class="n">winners</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Reset timer for winners</span>

                    <span class="c1"># Remove if you&#39;ve lost too many times</span>
                    <span class="c1"># New arrays contain everything but removals</span>
                    <span class="n">hidx</span> <span class="o">=</span> <span class="n">hidx</span><span class="p">[</span><span class="n">count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_cut</span><span class="p">]</span>
                    <span class="n">aidx</span> <span class="o">=</span> <span class="n">aidx</span><span class="p">[</span><span class="n">count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_cut</span><span class="p">]</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_cut</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hidx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Once everyone has lost, the fun stops</span>
                <span class="k">break</span>

        <span class="n">results</span> <span class="o">/=</span> <span class="n">nbonds</span>

        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="HydrogenBondAutoCorrel.solve">
<a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_autocorrel.html#MDAnalysis.analysis.hydrogenbonds.hbond_autocorrel.HydrogenBondAutoCorrel.solve">[docs]</a>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_guess</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit results to an multi exponential decay and integrate to find</span>
<span class="sd">        characteristic time</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p_guess : tuple of floats, optional</span>
<span class="sd">            Initial guess for the leastsq fit, must match the shape of the</span>
<span class="sd">            expected coefficients</span>


<span class="sd">        Continuous defition results are fitted to a double exponential with</span>
<span class="sd">        :func:`scipy.optimize.leastsq`, intermittent definition are fit to a</span>
<span class="sd">        triple exponential.</span>

<span class="sd">        The results of this fitting procedure are saved into the *fit*,</span>
<span class="sd">        *tau* and *estimate* keywords in the solution dict.</span>

<span class="sd">         - *fit* contains the coefficients, (A1, tau1, tau2) or</span>
<span class="sd">           (A1, A2, tau1, tau2, tau3)</span>
<span class="sd">         - *tau* contains the calculated lifetime in ps for the hydrogen</span>
<span class="sd">           bonding</span>
<span class="sd">         - *estimate* contains the estimate provided by the fit of the time</span>
<span class="sd">           autocorrelation function</span>

<span class="sd">        In addition, the output of the :func:`~scipy.optimize.leastsq` function</span>
<span class="sd">        is saved into the solution dict</span>

<span class="sd">         - *infodict*</span>
<span class="sd">         - *mesg*</span>
<span class="sd">         - *ier*</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Results have not been generated use, the run method first&quot;</span><span class="p">)</span>

        <span class="c1"># Prevents an odd bug with leastsq where it expects</span>
        <span class="c1"># double precision data sometimes...</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">within_bounds</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Returns True/False if boundary conditions are met or not.</span>
<span class="sd">            Uses length of p to detect whether it&#39;s handling continuous /</span>
<span class="sd">            intermittent</span>

<span class="sd">            Boundary conditions are:</span>
<span class="sd">             0 &lt; A_x &lt; 1</span>
<span class="sd">             sum(A_x) &lt; 1</span>
<span class="sd">             0 &lt; tau_x</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">A1</span><span class="p">,</span> <span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span> <span class="o">=</span> <span class="n">p</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">A1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A1</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">tau1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tau2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span><span class="p">,</span> <span class="n">tau3</span> <span class="o">=</span> <span class="n">p</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">A1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A1</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">A2</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">A1</span> <span class="o">+</span> <span class="n">A2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">tau1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tau2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tau3</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">err</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Custom residual function, returns real residual if all</span>
<span class="sd">            boundaries are met, else returns a large number to trick the</span>
<span class="sd">            leastsq algorithm</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">within_bounds</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_my_solve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> <span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Sum of two exponential functions &quot;&quot;&quot;</span>
            <span class="n">A2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">A1</span>
            <span class="k">return</span> <span class="n">A1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">tau1</span><span class="p">)</span> <span class="o">+</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">tau2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">triple</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span><span class="p">,</span> <span class="n">tau3</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Sum of three exponential functions &quot;&quot;&quot;</span>
            <span class="n">A3</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">A1</span> <span class="o">+</span> <span class="n">A2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">A1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">tau1</span><span class="p">)</span> <span class="o">+</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">tau2</span><span class="p">)</span> <span class="o">+</span> <span class="n">A3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">tau3</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_my_solve</span> <span class="o">=</span> <span class="n">double</span>

            <span class="k">if</span> <span class="n">p_guess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">p_guess</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_time</span><span class="p">)</span>

                <span class="n">p</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">infodict</span><span class="p">,</span> <span class="n">mesg</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span>
                <span class="n">err</span><span class="p">,</span> <span class="n">p_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">results</span><span class="p">),</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;fit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">A1</span><span class="p">,</span> <span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">A2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">A1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A1</span> <span class="o">*</span> <span class="n">tau1</span> <span class="o">+</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">tau2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_my_solve</span> <span class="o">=</span> <span class="n">triple</span>

            <span class="k">if</span> <span class="n">p_guess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">p_guess</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.33</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_time</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">sample_time</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_time</span><span class="p">)</span>

            <span class="n">p</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">infodict</span><span class="p">,</span> <span class="n">mesg</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span>
                <span class="n">err</span><span class="p">,</span> <span class="n">p_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">results</span><span class="p">),</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;fit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span><span class="p">,</span> <span class="n">tau3</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">A3</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">A1</span> <span class="o">-</span> <span class="n">A2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A1</span> <span class="o">*</span> <span class="n">tau1</span> <span class="o">+</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">tau2</span> <span class="o">+</span> <span class="n">A3</span> <span class="o">*</span> <span class="n">tau3</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;infodict&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">infodict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;mesg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;ier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ier</span>

        <span class="k">if</span> <span class="n">ier</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>  <span class="c1"># solution found if ier is one of these values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;estimate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_my_solve</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Solution to results not found&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;&lt;MDAnalysis HydrogenBondAutoCorrel analysis measuring the &quot;</span>
                <span class="s2">&quot;</span><span class="si">{btype}</span><span class="s2"> lifetime of </span><span class="si">{n}</span><span class="s2"> different hydrogens&gt;&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">btype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bond_type</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)))</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2024, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Henok Ademtew, Shobhit Agarwal, Aya M. Alaa, Irfan Alibay, Kazi Shudipto Amin, Anshul Angaria, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Patricio Barletta, Leonardo Barneschi, Jonathan Barnoud, Estefania Barreto-Ojeda, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Kavya Bisht, Wouter Boomsma, Jose Borreguero, Cédric Bouysset, Kevin Boyd, Meet Brijwani, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, Yantong Cai, David Caplan, Yuanyu Chang, Pratham Chauhan, Matthieu Chavent, Haochuan Chen, Xu Hong Chen, Kathleen Clark, Jennifer A Clark, Orion Cohen, Charlie Cook, Ruggero Cortini, Nicholas Craven, Ramon Crehuet, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Bradley Dice, Jan Domanski, David L. Dotson, Mark D. Driver, Ali Ehlen, Daniel J. Evans, Shujie Fan, Bjarne Feddersen, Lennard van der Feltz, Jake Fennick, Philip Fowler, Guillaume Fraux, Anirvinya G, Michael Gecht, Ahmed Salah Ghoneim, Mikhail Glagolev, William Glass, Jenna M. Swarthout Goddard, Joseph Goose, Alexander Gorfer, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Pratik Gupta, Sumit Gupta, Benjamin Hall, Ameya Harmalkar, Ivan Hristov, Eugen Hruska, Kyle J. Huston, Siddharth Jain, Edis Jakupovic, Joe Jordan, Henrik Jäger, Uma D Kadam, Aditya Kamath, Jon Kapla, Ian M. Kenney, Aditya Keshari, Haleema Khan, Navya Khare, Utsav Khatu, Andrew William King, Henry Kobin, Abhishek A. Kognole, Kosuke Kudo, Atharva Kulkarni, Manish Kumar, Mohit Kumar, Shubham Kumar, Alia Lescoulie, Zhenbo Li, Max Linke, Philip Loche, Jinju Lu, Hugo MacDermott-Opeskin, Shaivi Malik, Egor Marin, Domenico Marson, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Kurt McKee, Rocco Meli, Manuel Nuno Melo, Marcelo C. R. Melo, Dominik &#39;Rathann&#39; Mierzejewski, David Minh, Geongi Moon, Sampurna Mukherjee, Henry Mull, Morgan L. Nance, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Meghan Osato, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Dimitrios Papageorgiou, Rafael R. Pappalardo, Vishal Parmar, Danny Parton, Shakul Pathak, Christian Pfaendner, Joshua L. Phillips, Marcelo D. Poleto, Hannah Pollak, Kashish Punjani, Michael Quevillon, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Andrea Rizzi, Xiaoxu Ruan, Carlos Yanez S., Utkarsh Saxena, Moritz Schaeffler, Alexander Schlaich, Marcello Sega, Ricky Sexton, Sean L. Seyler, Faraaz Shah, Sulay Shah, Abhishek Shandilya, Shubham Sharma, Rishabh Shukla, Karthikeyan Singaravelan, Tamandeep Singh, Brigitta Sipőcz, Paul Smith, Andy Somogyi, Caio S. Souza, Kai Niklas Spauszus, David van der Spoel, Shantanu Srivastava, Lukas Stelzl, Jan Stevens, Gorman Stock, Philipp Stärk, Johannes Stöckelmaier, Fenil Suchak, Ayush Suhane, Filip T. Szczypiński, Sukeerti T, Matthijs Tadema, Valerij Talagayev, Joao Miguel Correia Teixeira, Paarth Thadani, Matthew W. Thompson, Hao Tian, Matteo Tiberti, Zaheer Timol, Wiep van der Toorn, Mieczyslaw Torchala, Aditi Tripathi, Heet Vekariya, Mark Verma, Josh Vermaas, Isaac Virshup, Lily Wang, Leon Wehrhan, Nestor Wendt, Lawson Woods, Zhiyi Wu, Tengyu Xie, Zhuyi Xue, Mingyi Xue, Alexander Yang, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, Raymond Zhao, Yuxuan Zhuang, Fabian Zills, and Oliver Beckstein.</p>
  </div>

  

<div class="footer"><p>Please see
    our <a href="https://www.mdanalysis.org/pages/privacy/">Privacy Policy</a>
    to learn how <a href="https://www.mdanalysis.org">MDAnalysis</a> collects data.</p>
    <script data-goatcounter="https://mdanalysis.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</div>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
    var versions_json_url = 'https://docs.mdanalysis.org/versions.json'
</script>

<div class="rst-versions" data-toggle="rst-versions" role="note"
     aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
        2.8.0-dev0
      <span class="fa fa-caret-down"></span>
    </span>

    <div class="rst-other-versions">
        <dl id="versionselector">
            <dt>Other Versions</dt>
        </dl>

    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>