
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>MDAnalysis.core.groups &#8212; MDAnalysis 0.18.1-dev documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.18.1-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.18.1-dev documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.core.groups</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">==========================================================</span>
<span class="sd">Core objects: Containers --- :mod:`MDAnalysis.core.groups`</span>
<span class="sd">==========================================================</span>

<span class="sd">The :class:`~MDAnalysis.core.universe.Universe` instance contains all</span>
<span class="sd">the particles in the system (which MDAnalysis calls</span>
<span class="sd">:class:`Atom`). Groups of atoms are handled as :class:`AtomGroup`</span>
<span class="sd">instances. The :class:`AtomGroup` is probably the most important</span>
<span class="sd">object in MDAnalysis because virtually everything can be accessed</span>
<span class="sd">through it. `AtomGroup` instances can be easily created (e.g., from a</span>
<span class="sd">:meth:`AtomGroup.select_atoms` selection or just by slicing).</span>

<span class="sd">For convenience, chemically meaningful groups of atoms such as a</span>
<span class="sd">:class:`Residue` or a :class:`Segment` (typically a whole molecule or</span>
<span class="sd">all of the solvent) also exist as containers, as well as groups of</span>
<span class="sd">these units ((:class:`ResidueGroup`, :class:`SegmentGroup`).</span>


<span class="sd">Classes</span>
<span class="sd">=======</span>

<span class="sd">Collections</span>
<span class="sd">-----------</span>

<span class="sd">.. autoclass:: AtomGroup</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>
<span class="sd">.. autoclass:: ResidueGroup</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>
<span class="sd">.. autoclass:: SegmentGroup</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>
<span class="sd">.. autoclass:: UpdatingAtomGroup</span>
<span class="sd">   :members:</span>

<span class="sd">Chemical units</span>
<span class="sd">--------------</span>

<span class="sd">.. autoclass:: Atom</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>
<span class="sd">.. autoclass:: Residue</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>
<span class="sd">.. autoclass:: Segment</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>

<span class="sd">Levels</span>
<span class="sd">------</span>

<span class="sd">Each of the above classes has a level attribute.  This can be used to</span>
<span class="sd">verify that two objects are of the same level, or to access a particular</span>
<span class="sd">class::</span>

<span class="sd">   u = mda.Universe()</span>

<span class="sd">   ag = u.atoms[:10]</span>
<span class="sd">   at = u.atoms[11]</span>

<span class="sd">   ag.level == at.level  # Returns True</span>

<span class="sd">   ag.level.singular  # Returns Atom class</span>
<span class="sd">   at.level.plural  # Returns AtomGroup class</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">zip</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="k">import</span> <span class="n">string_types</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">numpy.lib.utils</span> <span class="k">import</span> <span class="n">deprecate</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">_ANCHOR_UNIVERSES</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="k">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="k">import</span> <span class="n">distances</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="k">import</span> <span class="n">transformations</span>
<span class="kn">from</span> <span class="nn">..selections</span> <span class="k">import</span> <span class="n">get_writer</span> <span class="k">as</span> <span class="n">get_selection_writer_for</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">selection</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">flags</span>
<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="k">import</span> <span class="n">NoDataError</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">topologyobjects</span>
<span class="kn">from</span> <span class="nn">._get_readers</span> <span class="k">import</span> <span class="n">get_writer_for</span>


<span class="k">def</span> <span class="nf">_unpickle</span><span class="p">(</span><span class="n">uhash</span><span class="p">,</span> <span class="n">ix</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">_ANCHOR_UNIVERSES</span><span class="p">[</span><span class="n">uhash</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1"># doesn&#39;t provide as nice an error message as before as only hash of universe is stored</span>
        <span class="c1"># maybe if we pickled the filename too we could do better...</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;Couldn&#39;t find a suitable Universe to unpickle AtomGroup onto &quot;</span>
            <span class="s2">&quot;with Universe hash &#39;</span><span class="si">{}</span><span class="s2">&#39;.  Available hashes: </span><span class="si">{}</span><span class="s2">&quot;</span>
            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uhash</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_ANCHOR_UNIVERSES</span><span class="o">.</span><span class="n">keys</span><span class="p">()])))</span>
    <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_unpickle_uag</span><span class="p">(</span><span class="n">basepickle</span><span class="p">,</span> <span class="n">selections</span><span class="p">,</span> <span class="n">selstrs</span><span class="p">):</span>
    <span class="n">bfunc</span><span class="p">,</span> <span class="n">bargs</span> <span class="o">=</span> <span class="n">basepickle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">basepickle</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">basegroup</span> <span class="o">=</span> <span class="n">bfunc</span><span class="p">(</span><span class="o">*</span><span class="n">bargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">UpdatingAtomGroup</span><span class="p">(</span><span class="n">basegroup</span><span class="p">,</span> <span class="n">selections</span><span class="p">,</span> <span class="n">selstrs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">make_classes</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Make a fresh copy of all Classes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Two dictionaries. One with a set of :class:`_TopologyAttrContainer` classes</span>
<span class="sd">    to serve as bases for universe-specific MDA container classes. Another with</span>
<span class="sd">    the final merged versions of those classes. The classes themselves are used</span>
<span class="sd">    as hashing keys.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bases</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">classes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="p">(</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)</span>
    <span class="n">components</span> <span class="o">=</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">)</span>

    <span class="c1"># The &#39;GBase&#39; middle man is needed so that a single topologyattr</span>
    <span class="c1">#  patching applies automatically to all groups.</span>
    <span class="n">GBase</span> <span class="o">=</span> <span class="n">bases</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span> <span class="o">=</span> <span class="n">_TopologyAttrContainer</span><span class="o">.</span><span class="n">_subclass</span><span class="p">(</span><span class="n">is_group</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
        <span class="n">bases</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">GBase</span><span class="o">.</span><span class="n">_subclass</span><span class="p">(</span><span class="n">is_group</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># CBase for patching all components</span>
    <span class="n">CBase</span> <span class="o">=</span> <span class="n">bases</span><span class="p">[</span><span class="n">ComponentBase</span><span class="p">]</span> <span class="o">=</span> <span class="n">_TopologyAttrContainer</span><span class="o">.</span><span class="n">_subclass</span><span class="p">(</span>
        <span class="n">is_group</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
        <span class="n">bases</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">CBase</span><span class="o">.</span><span class="n">_subclass</span><span class="p">(</span><span class="n">is_group</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Initializes the class cache.</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">groups</span> <span class="o">+</span> <span class="n">components</span><span class="p">:</span>
        <span class="n">classes</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">bases</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span><span class="o">.</span><span class="n">_mix</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bases</span><span class="p">,</span> <span class="n">classes</span>


<span class="k">class</span> <span class="nc">_TopologyAttrContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class factory for receiving sets of :class:`TopologyAttr` objects.</span>

<span class="sd">    :class:`_TopologyAttrContainer` is a convenience class to encapsulate the</span>
<span class="sd">    functions that deal with:</span>
<span class="sd">    * the import and namespace transplant of :class:`TopologyAttr` objects;</span>
<span class="sd">    * the copying (subclassing) of itself to create distinct bases for the</span>
<span class="sd">      different container classes (:class:`AtomGroup`, :class:`ResidueGroup`,</span>
<span class="sd">      :class:`SegmentGroup`, :class:`Atom`, :class:`Residue`, :class:`Segment`,</span>
<span class="sd">      and subclasses thereof);</span>
<span class="sd">    * the mixing (subclassing and co-inheritance) with the container classes.</span>
<span class="sd">      The mixed subclasses become the final container classes specific to each</span>
<span class="sd">      :class:`Universe`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_subclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">is_group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Factory method returning :class:`_TopologyAttrContainer` subclasses.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        is_group : bool</span>
<span class="sd">            The :attr:`_is_group` of the returned class will be set to</span>
<span class="sd">            *is_group*. This is used to distinguish between Groups (AtomGroup</span>
<span class="sd">            etc.) and Components (Atom etc.) in internal methods when</span>
<span class="sd">            considering actions such as addition between objects, adding</span>
<span class="sd">            TopologyAttributes to them.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            A subclass of :class:`_TopologyAttrContainer`, with the same name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newcls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="bp">cls</span><span class="p">,),</span> <span class="p">{</span><span class="s1">&#39;_is_group&#39;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">is_group</span><span class="p">)})</span>
        <span class="k">if</span> <span class="n">is_group</span><span class="p">:</span>
            <span class="n">newcls</span><span class="o">.</span><span class="n">_SETATTR_WHITELIST</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;positions&#39;</span><span class="p">,</span> <span class="s1">&#39;velocities&#39;</span><span class="p">,</span> <span class="s1">&#39;forces&#39;</span><span class="p">,</span> <span class="s1">&#39;dimensions&#39;</span><span class="p">,</span>
                <span class="s1">&#39;atoms&#39;</span><span class="p">,</span> <span class="s1">&#39;residue&#39;</span><span class="p">,</span> <span class="s1">&#39;residues&#39;</span><span class="p">,</span> <span class="s1">&#39;segment&#39;</span><span class="p">,</span> <span class="s1">&#39;segments&#39;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newcls</span><span class="o">.</span><span class="n">_SETATTR_WHITELIST</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="s1">&#39;velocity&#39;</span><span class="p">,</span> <span class="s1">&#39;force&#39;</span><span class="p">,</span> <span class="s1">&#39;dimensions&#39;</span><span class="p">,</span>
                <span class="s1">&#39;atoms&#39;</span><span class="p">,</span> <span class="s1">&#39;residue&#39;</span><span class="p">,</span> <span class="s1">&#39;residues&#39;</span><span class="p">,</span> <span class="s1">&#39;segment&#39;</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="n">newcls</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_mix</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a subclass with ourselves and another class as parents.</span>

<span class="sd">        Classes mixed at this point override :meth:`__new__`, causing further</span>
<span class="sd">        instantiations to shortcut to :meth:`~object.__new__` (skipping the</span>
<span class="sd">        cache-fetch process for :class:`_MutableBase` subclasses).</span>

<span class="sd">        The new class will have an attribute `_derived_class` added, pointing</span>
<span class="sd">        to itself. This pointer instructs which class to use when</span>
<span class="sd">        slicing/adding instances of the new class. At initialization time the</span>
<span class="sd">        new class may choose to point `_derived_class` to another class (as is</span>
<span class="sd">        done in the initialization of :class:`UpdatingAtomGroup`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : type</span>
<span class="sd">            The class to mix with ourselves.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            A class of parents :class:`_ImmutableBase`, *other* and this class.</span>
<span class="sd">            Its name is the same as *other*&#39;s.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newcls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="n">_ImmutableBase</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">cls</span><span class="p">),</span> <span class="p">{})</span>
        <span class="n">newcls</span><span class="o">.</span><span class="n">_derived_class</span> <span class="o">=</span> <span class="n">newcls</span>
        <span class="k">return</span> <span class="n">newcls</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_prop</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add attr into the namespace for this class</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attr : A TopologyAttr object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">getter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_group</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">attrname</span><span class="p">,</span>
                    <span class="nb">property</span><span class="p">(</span><span class="n">getter</span><span class="p">,</span> <span class="n">setter</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">groupdoc</span><span class="p">))</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_SETATTR_WHITELIST</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">attrname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">singular</span><span class="p">,</span>
                    <span class="nb">property</span><span class="p">(</span><span class="n">getter</span><span class="p">,</span> <span class="n">setter</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">singledoc</span><span class="p">))</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_SETATTR_WHITELIST</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">singular</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># `ag.this = 42` calls setattr(ag, &#39;this&#39;, 42)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span>  <span class="c1"># &#39;private&#39; allowed</span>
                <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SETATTR_WHITELIST</span> <span class="ow">or</span>  <span class="c1"># known attributes allowed</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)):</span>  <span class="c1"># preexisting (eg properties) allowed</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot set arbitrary attributes to a </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s1">&#39;Group&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_group</span> <span class="k">else</span> <span class="s1">&#39;Component&#39;</span><span class="p">))</span>
        <span class="c1"># if it is, we allow the setattr to proceed by deferring to the super</span>
        <span class="c1"># behaviour (ie do it)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_TopologyAttrContainer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_MutableBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class that merges appropriate :class:`_TopologyAttrContainer` classes.</span>

<span class="sd">    Implements :meth:`__new__`. In it the instantiating class is fetched from</span>
<span class="sd">    :attr:`Universe._classes`. If there is a cache miss, a merged class is made</span>
<span class="sd">    with a base from :attr:`Universe._class_bases` and cached.</span>

<span class="sd">    The classes themselves are used as the cache dictionary keys for simplcity</span>
<span class="sd">    in cache retrieval.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># This pre-initialization wrapper must be pretty generic to</span>
        <span class="c1"># allow for different initialization schemes of the possible classes.</span>
        <span class="c1"># All we really need here is to fish a universe out of the arg list.</span>
        <span class="c1"># The AtomGroup cases get priority and are fished out first.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">universe</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># older AtomGroup init method..</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">universe</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="c1"># Let&#39;s be generic and get the first argument that&#39;s either a</span>
                <span class="c1"># Universe, a Group, or a Component, and go from there.</span>
                <span class="c1"># This is where the UpdatingAtomGroup args get matched.</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="o">+</span><span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">,</span> <span class="n">GroupBase</span><span class="p">,</span>
                                        <span class="n">ComponentBase</span><span class="p">)):</span>
                        <span class="n">u</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">universe</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;No universe, or universe-containing &quot;</span>
                                   <span class="s2">&quot;object passed to the initialization of &quot;</span>
                                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_classes</span><span class="p">[</span><span class="bp">cls</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Cache miss. Let&#39;s find which kind of class this is and merge.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">parent_cls</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_class_bases</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>
                                  <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mro</span><span class="p">()</span>
                                  <span class="k">if</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">_class_bases</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Attempted to instantiate class &#39;</span><span class="si">{}</span><span class="s2">&#39; but &quot;</span>
                                <span class="s2">&quot;none of its parents are known to the &quot;</span>
                                <span class="s2">&quot;universe. Currently possible parent &quot;</span>
                                <span class="s2">&quot;classes are: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_class_bases</span><span class="o">.</span><span class="n">keys</span><span class="p">()))))</span>
            <span class="n">newcls</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">_classes</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent_cls</span><span class="o">.</span><span class="n">_mix</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">newcls</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_ImmutableBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class used to shortcut :meth:`__new__` to :meth:`object.__new__`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># When mixed via _TopologyAttrContainer._mix this class has MRO priority.</span>
    <span class="c1">#  Setting __new__ like this will avoid having to go through the</span>
    <span class="c1">#  cache lookup if the class is reused (as in ag._derived_class(...)).</span>
    <span class="fm">__new__</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span>



<span class="k">def</span> <span class="nf">_only_same_level</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">ComponentBase</span><span class="p">,</span> <span class="n">GroupBase</span><span class="p">)):</span>  <span class="c1"># sanity check</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t perform &#39;</span><span class="si">{}</span><span class="s2">&#39; between objects:&quot;</span>
                            <span class="s2">&quot; &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t perform &#39;</span><span class="si">{}</span><span class="s2">&#39; on different level objects&quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">universe</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t operate on objects from different Universes&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapped</span>


<span class="k">class</span> <span class="nc">GroupBase</span><span class="p">(</span><span class="n">_MutableBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class from which a Universe&#39;s Group class is built.</span>

<span class="sd">    Instances of :class:`GroupBase` provide the following operations that</span>
<span class="sd">    conserve element repetitions and order:</span>

<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | Operation                     | Equivalent | Result                     |</span>
<span class="sd">    +===============================+============+============================+</span>
<span class="sd">    | ``len(s)``                    |            | number of elements (atoms, |</span>
<span class="sd">    |                               |            | residues or segment) in    |</span>
<span class="sd">    |                               |            | the group                  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s == t``                    |            | test if ``s`` and ``t``    |</span>
<span class="sd">    |                               |            | contain the same elements  |</span>
<span class="sd">    |                               |            | in the same order          |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``x in s``                    |            | test if component ``x`` is |</span>
<span class="sd">    |                               |            | part of group ``s``        |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.concatenate(t)``          | ``s + t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | from ``s`` and from ``t``  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.subtract(t)``             |            | new Group with elements    |</span>
<span class="sd">    |                               |            | from ``s`` that are not    |</span>
<span class="sd">    |                               |            | in ``t``                   |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>

<span class="sd">    The following operations treat the Group as set. Any result will have any</span>
<span class="sd">    duplicate entries removed and the Group will be sorted.</span>

<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | Operation                     | Equivalent | Result                     |</span>
<span class="sd">    +===============================+============+============================+</span>
<span class="sd">    | ``s.isdisjoint(t)``           |            | ``True`` if ``s`` and      |</span>
<span class="sd">    |                               |            | ``t`` do not share         |</span>
<span class="sd">    |                               |            | elements                   |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.issubset(t)``             |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``s`` are part of ``t``    |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.is_strict_subset(t)``     |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``s`` are part of ``t``,   |</span>
<span class="sd">    |                               |            | and ``s != t``             |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.issuperset(t)``           |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``t`` are part of ``s``    |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.is_strict_superset(t)``   |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``t`` are part of ``s``,   |</span>
<span class="sd">    |                               |            | and ``s != t``             |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.union(t)``                | ``s | t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | from both ``s`` and ``t``  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.intersection(t)``         | ``s &amp; t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | common to ``s`` and ``t``  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.difference(t)``           | ``s - t``  | new Group with elements of |</span>
<span class="sd">    |                               |            | ``s`` that are not in ``t``|</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.symmetric_difference(t)`` | ``s ^ t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | that are part of ``s`` or  |</span>
<span class="sd">    |                               |            | ``t`` but not both         |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># list of atoms/res/segs, old init method</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="p">[</span><span class="n">at</span><span class="o">.</span><span class="n">ix</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">universe</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># current/new init method</span>
                <span class="n">ix</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span>  <span class="c1"># couldn&#39;t find ix/universe</span>
                <span class="ne">TypeError</span><span class="p">):</span>  <span class="c1"># couldn&#39;t iterate the object we got</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Can only initialise a Group from an iterable of Atom/Residue/&quot;</span>
                <span class="s2">&quot;Segment objects eg: AtomGroup([Atom1, Atom2, Atom3]) &quot;</span>
                <span class="s2">&quot;or an iterable of indices and a Universe reference &quot;</span>
                <span class="s2">&quot;eg: AtomGroup([0, 5, 7, 8], u).&quot;</span><span class="p">)</span>

        <span class="c1"># indices for the objects I hold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">u</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="o">.</span><span class="n">tolist</span><span class="p">())))</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="c1"># supports</span>
        <span class="c1"># - integer access</span>
        <span class="c1"># - boolean slicing</span>
        <span class="c1"># - fancy indexing</span>
        <span class="c1"># because our _ix attribute is a numpy array</span>
        <span class="c1"># it can be sliced by all of these already,</span>
        <span class="c1"># so just return ourselves sliced by the item</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">singular</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">item</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="p">:</span>  <span class="c1"># check for empty list</span>
                <span class="c1"># hack to make lists into numpy arrays</span>
                <span class="c1"># important for boolean slicing</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="c1"># We specify _derived_class instead of self.__class__ to allow</span>
            <span class="c1"># subclasses, such as UpdatingAtomGroup, to control the class</span>
            <span class="c1"># resulting from slicing.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">item</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">Group with </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}{}</span><span class="s2">&gt;&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span>
                <span class="s2">&quot;s&quot;</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:]))</span> <span class="c1"># Shorthand for a conditional plural &#39;s&#39;.</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{}</span><span class="s1">Group </span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">(),</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{}</span><span class="s1">Group </span><span class="si">{}</span><span class="s1">, ..., </span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">(),</span>
                                                  <span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)[:</span><span class="mi">3</span><span class="p">])[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                  <span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenate the Group with another Group or Component of the same</span>
<span class="sd">        level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with elements of `self` and `other` concatenated</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Using built-in sum requires supporting 0 + self. If other is</span>
<span class="sd">        anything other 0, an exception will be raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : int</span>
<span class="sd">            Other should be 0, or else an exception will be raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>
<span class="sd">            Group with elements of `self` reproduced</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unsupported operand type(s) for +:&quot;</span>
                            <span class="s2">&quot; &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test group equality.</span>

<span class="sd">        Two groups are equal if they contain the same indices in</span>
<span class="sd">        the same order. Groups that are not at the same level or that belong</span>
<span class="sd">        to different universe cannot be compared.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
            <span class="c1"># maybe raise TypeError instead?</span>
            <span class="c1"># eq method raises Error for wrong comparisons</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">ix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unique indices of the components in the Group.</span>

<span class="sd">        - If this Group is an :class:`AtomGroup`, these are the</span>
<span class="sd">          indices of the :class:`Atom` instances.</span>
<span class="sd">        - If it is a :class:`ResidueGroup`, these are the indices of</span>
<span class="sd">          the :class:`Residue` instances.</span>
<span class="sd">        - If it is a :class:`SegmentGroup`, these are the indices of</span>
<span class="sd">          the :class:`Segment` instances.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ix_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unique indices of the components in the Group.</span>

<span class="sd">        For a Group, ix_array is the same as ix. This method gives a</span>
<span class="sd">        consistent API between components and groups.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Obtain a copy of the dimensions of the currently loaded Timestep&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@dimensions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">dimensions</span>

    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate center of group given some weights</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weights : array_like</span>
<span class="sd">            weights to be used</span>
<span class="sd">        pbc : boolean, optional</span>
<span class="sd">            ``True``: Move all atoms within the primary unit cell</span>
<span class="sd">            before calculation [``False``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        center : ndarray</span>
<span class="sd">            weighted center of group</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        To find the charge weighted center of a given Atomgroup::</span>

<span class="sd">            &gt;&gt;&gt; sel = u.select_atoms(&#39;prop mass &gt; 4.0&#39;)</span>
<span class="sd">            &gt;&gt;&gt; sel.center(sel.charges)</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the :class:`MDAnalysis.core.flags` flag *use_pbc* is set to</span>
<span class="sd">        ``True`` then the `pbc` keyword is used by default.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">if</span> <span class="n">pbc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pbc</span> <span class="o">=</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">center_of_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Center of geometry (also known as centroid) of the selection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : boolean, optional</span>
<span class="sd">            ``True``: Move all atoms within the primary unit cell</span>
<span class="sd">            before calculation [``False``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        center : ndarray</span>
<span class="sd">            geometric center of group</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the :class:`MDAnalysis.core.flags` flag *use_pbc* is set to</span>
<span class="sd">        ``True`` then the `pbc` keyword is used by default.</span>


<span class="sd">        .. versionchanged:: 0.8 Added `pbc` keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">)</span>

    <span class="n">centroid</span> <span class="o">=</span> <span class="n">center_of_geometry</span>

    <span class="k">def</span> <span class="nf">bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bounding box of the selection.</span>

<span class="sd">        The lengths A,B,C of the orthorhombic enclosing box are ::</span>

<span class="sd">          L = AtomGroup.bbox()</span>
<span class="sd">          A,B,C = L[1] - L[0]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">         corners : array</span>
<span class="sd">            2x3 array giving corners of bounding box as</span>
<span class="sd">            [[xmin, ymin, zmin], [xmax, ymax, zmax]].</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">        ``True`` allows the *pbc* flag to be used by default.</span>


<span class="sd">        .. versionadded:: 0.7.2</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">bsphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bounding sphere of the selection.</span>

<span class="sd">        The sphere is calculated relative to the centre of geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R : float</span>
<span class="sd">            Radius of bounding sphere.</span>
<span class="sd">        center : array</span>
<span class="sd">            Coordinates of sphere center as ``[xcen,ycen,zcen]``.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">        ``True`` allows the *pbc* flag to be used by default.</span>


<span class="sd">        .. versionadded:: 0.7.3</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_geometry</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_geometry</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">centroid</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply homogenous transformation matrix `M` to the coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        M : array</span>
<span class="sd">            4x4 matrix, with the rotation in ``R = M[:3,:3]`` and the</span>
<span class="sd">            translation in ``t = M[:3,3]``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        MDAnalysis.lib.transformations : module of all coordinate transforms</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The rotation :math:`\mathsf{R}` is applied before the translation</span>
<span class="sd">        :math:`\mathbf{t}`:</span>

<span class="sd">        .. math::</span>

<span class="sd">           \mathbf{x}&#39; = \mathsf{R}\mathbf{x} + \mathbf{t}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply translation vector `t` to the selection&#39;s coordinates.</span>

<span class="sd">        Atom coordinates are translated in-place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : array_like</span>
<span class="sd">            vector to translate coordinates with</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        MDAnalysis.lib.transformations : module of all coordinate transforms</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The method applies a translation to the :class:`AtomGroup`</span>
<span class="sd">        from current coordinates :math:`\mathbf{x}` to new coordinates</span>
<span class="sd">        :math:`\mathbf{x}&#39;`:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathbf{x}&#39; = \mathbf{x} + \mathbf{t}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">unique</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="c1"># changes the coordinates in place</span>
        <span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">+=</span> <span class="n">vector</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a rotation matrix `R` to the selection&#39;s coordinates.</span>
<span class="sd">        :math:`\mathsf{R}` is a 3x3 orthogonal matrix that transforms a vector</span>
<span class="sd">        :math:`\mathbf{x} \rightarrow \mathbf{x}&#39;`:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathbf{x}&#39; = \mathsf{R}\mathbf{x}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        R : array_like</span>
<span class="sd">            3x3 rotation matrix to use for applying rotation.</span>
<span class="sd">        point : array_like, optional</span>
<span class="sd">            Center of rotation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : AtomGroup</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        By default rotates around center of origin ``point=(0, 0, 0)``. To</span>
<span class="sd">        rotate around center of geometry of the atomgroup use ``ag.rotate(R,</span>
<span class="sd">        point=ag.centroid)``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        rotateby : rotate around given axis and angle</span>
<span class="sd">        MDAnalysis.lib.transformations : module of all coordinate transforms</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="c1"># changes the coordinates (in place)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">point</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">unique</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">unique</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">rotateby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a rotation to the selection&#39;s coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float</span>
<span class="sd">            Rotation angle in degrees.</span>
<span class="sd">        axis : array_like</span>
<span class="sd">            Rotation axis vector.</span>
<span class="sd">        point : array_like, optional</span>
<span class="sd">            Center of rotation. If ``None`` then the center of geometry of this</span>
<span class="sd">            group is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : AtomGroup</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The transformation from current coordinates :math:`\mathbf{x}`</span>
<span class="sd">        to new coordinates :math:`\mathbf{x}&#39;` is</span>

<span class="sd">        .. math::</span>

<span class="sd">          \mathbf{x}&#39; = \mathsf{R}\,(\mathbf{x}-\mathbf{p}) + \mathbf{p}</span>

<span class="sd">        where :math:`\mathsf{R}` is the rotation by `angle` around the</span>
<span class="sd">        `axis` going through `point` :math:`\mathbf{p}`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        MDAnalysis.lib.transformations.rotation_matrix : calculate :math:`\mathsf{R}`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">transformations</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="n">point</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pack_into_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Shift all atoms in this group to be within the primary unit cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        box : array_like</span>
<span class="sd">            Box dimensions, can be either orthogonal or triclinic information.</span>
<span class="sd">            Cell dimensions must be in an identical to format to those returned</span>
<span class="sd">            by :attr:`MDAnalysis.coordinates.base.Timestep.dimensions`,</span>
<span class="sd">            ``[lx, ly, lz, alpha, beta, gamma]``. If ``None``, uses these</span>
<span class="sd">            timestep dimensions.</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            ``True`` to change coordinates in place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coords : array</span>
<span class="sd">            Shifted atom coordinates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All atoms will be moved so that they lie between 0 and boxlength</span>
<span class="sd">        :math:`L_i` in all dimensions, i.e. the lower left corner of the</span>
<span class="sd">        simulation box is taken to be at (0,0,0):</span>

<span class="sd">        .. math::</span>

<span class="sd">           x_i&#39; = x_i - \left\lfloor\frac{x_i}{L_i}\right\rfloor</span>

<span class="sd">        The default is to take unit cell information from the underlying</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.base.Timestep` instance. The optional</span>
<span class="sd">        argument `box` can be used to provide alternative unit cell information</span>
<span class="sd">        (in the MDAnalysis standard format ``[Lx, Ly, Lz, alpha, beta,</span>
<span class="sd">        gamma]``).</span>

<span class="sd">        Works with either orthogonal or triclinic box types.</span>


<span class="sd">        .. versionadded:: 0.8</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">unique</span>
        <span class="k">if</span> <span class="n">box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Try and auto detect box dimensions</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">dimensions</span>  <span class="c1"># Can accept any box</span>

        <span class="k">if</span> <span class="n">box</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="c1"># for a vector representation, diagonal cannot be zero</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more box dimensions is zero.&quot;</span>
                                 <span class="s2">&quot;  You can specify a boxsize with &#39;box =&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">box</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>  <span class="c1"># Check that a box dimension isn&#39;t zero</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more box dimensions is zero.&quot;</span>
                                 <span class="s2">&quot;  You can specify a boxsize with &#39;box=&#39;&quot;</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">apply_PBC</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span>

        <span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">apply_PBC</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s2">&quot;atoms&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s2">&quot;com&quot;</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shift the contents of this Group back into the unit cell.</span>

<span class="sd">        This is a more powerful version of :meth:`pack_into_box`, allowing</span>
<span class="sd">        groups of atoms to be kept together through the process.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compound : {&#39;atoms&#39;, &#39;group&#39;, &#39;residues&#39;, &#39;segments&#39;, &#39;fragments&#39;}</span>
<span class="sd">            The group which will be kept together through the shifting process.</span>
<span class="sd">        center : {&#39;com&#39;, &#39;cog&#39;}</span>
<span class="sd">            How to define the center of a given group of atoms.</span>
<span class="sd">        box : array</span>
<span class="sd">            Box dimensions, can be either orthogonal or triclinic information.</span>
<span class="sd">            Cell dimensions must be in an identical to format to those returned</span>
<span class="sd">            by :attr:`MDAnalysis.coordinates.base.Timestep.dimensions`,</span>
<span class="sd">            ``[lx, ly, lz, alpha, beta, gamma]``. If ``None``, uses these</span>
<span class="sd">            timestep dimensions.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When specifying a `compound`, the translation is calculated based on</span>
<span class="sd">        each compound. The same translation is applied to all atoms</span>
<span class="sd">        within this compound, meaning it will not be broken by the shift.</span>
<span class="sd">        This might however mean that all atoms from the compound are not</span>
<span class="sd">        inside the unit cell, but rather the center of the compound is.</span>

<span class="sd">        `center` allows the definition of the center of each group to be</span>
<span class="sd">        specified. This can be either &#39;com&#39; for center of mass, or &#39;cog&#39; for</span>
<span class="sd">        center of geometry.</span>

<span class="sd">        `box` allows a unit cell to be given for the transformation. If not</span>
<span class="sd">        specified, an the dimensions information from the current Timestep will</span>
<span class="sd">        be used.</span>

<span class="sd">        .. note::</span>
<span class="sd">           wrap with all default keywords is identical to :meth:`pack_into_box`</span>


<span class="sd">        .. versionadded:: 0.9.2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">unique</span>
        <span class="k">if</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;atoms&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="p">[</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;residues&#39;</span><span class="p">:</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">residues</span>
        <span class="k">elif</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;segments&#39;</span><span class="p">:</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">segments</span>
        <span class="k">elif</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;fragments&#39;</span><span class="p">:</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">fragments</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognised compound definition: </span><span class="si">{0}</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;Please use one of &#39;group&#39; &#39;residues&#39; &#39;segments&#39;&quot;</span>
                             <span class="s2">&quot;or &#39;fragments&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">compound</span><span class="p">))</span>

        <span class="c1"># TODO: ADD TRY-EXCEPT FOR MASSES PRESENCE</span>
        <span class="k">if</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;com&#39;</span><span class="p">,</span> <span class="s1">&#39;centerofmass&#39;</span><span class="p">):</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;cog&#39;</span><span class="p">,</span> <span class="s1">&#39;centroid&#39;</span><span class="p">,</span> <span class="s1">&#39;centerofgeometry&#39;</span><span class="p">):</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">center_of_geometry</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognised center definition: </span><span class="si">{0}</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;Please use one of &#39;com&#39; or &#39;cog&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">center</span><span class="p">))</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">centers</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="c1"># calculate shift per object center</span>
        <span class="n">dests</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">apply_PBC</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">dests</span> <span class="o">-</span> <span class="n">centers</span>

        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">shifts</span><span class="p">):</span>
            <span class="c1"># Save some needless shifts</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="n">o</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topattrs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Group together items in this group according to values of *topattr*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        topattrs: str or list</span>
<span class="sd">           One or more topology attribute to group components by.</span>
<span class="sd">           Single arguments are passed as a string. Multiple arguments</span>
<span class="sd">           are passed as a list.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Unique values of the multiple combinations of topology attributes </span>
<span class="sd">            as keys, Groups as values.</span>

<span class="sd">        Example</span>
<span class="sd">        -------      </span>
<span class="sd">        To group atoms with the same mass together:     </span>
<span class="sd">                </span>
<span class="sd">        &gt;&gt;&gt; ag.groupby(&#39;masses&#39;)</span>
<span class="sd">        {12.010999999999999: &lt;AtomGroup with 462 atoms&gt;,</span>
<span class="sd">         14.007: &lt;AtomGroup with 116 atoms&gt;,</span>
<span class="sd">         15.999000000000001: &lt;AtomGroup with 134 atoms&gt;}        </span>

<span class="sd">        To group atoms with the same residue name and mass together:</span>

<span class="sd">          &gt;&gt;&gt; ag.groupby([&#39;resnames&#39;, &#39;masses&#39;])</span>
<span class="sd">          {(&#39;ALA&#39;, 1.008): &lt;AtomGroup with 95 atoms&gt;,</span>
<span class="sd">           (&#39;ALA&#39;, 12.011): &lt;AtomGroup with 57 atoms&gt;,</span>
<span class="sd">           (&#39;ALA&#39;, 14.007): &lt;AtomGroup with 19 atoms&gt;,</span>
<span class="sd">           (&#39;ALA&#39;, 15.999): &lt;AtomGroup with 19 atoms&gt;},</span>
<span class="sd">           (&#39;ARG&#39;, 1.008): &lt;AtomGroup with 169 atoms&gt;,</span>
<span class="sd">           ...}</span>
<span class="sd">          </span>
<span class="sd">          &gt;&gt;&gt; ag.groupby([&#39;resnames&#39;, &#39;masses&#39;])(&#39;ALA&#39;, 15.999)</span>
<span class="sd">           &lt;AtomGroup with 19 atoms&gt;</span>
<span class="sd">        </span>
<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        .. versionchanged:: 0.18.0 The function accepts multiple attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">res</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topattrs</span><span class="p">,</span> <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
            <span class="n">attr</span><span class="o">=</span><span class="n">topattrs</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topattrs</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                <span class="n">attr</span> <span class="o">=</span> <span class="n">topattrs</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
            <span class="n">ta</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">ta</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">ta</span><span class="p">)}</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">topattrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ta</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">ta</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">topattrs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ta</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ta</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">topattrs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    
            <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">flatten_dict</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>


    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenate with another Group or Component of the same level.</span>

<span class="sd">        Duplicate entries and original order is preserved. It is synomymous to</span>
<span class="sd">        the `+` operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with elements of `self` and `other` concatenated</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        The order of the original contents (including duplicates)</span>
<span class="sd">        are preserved when performing a concatenation.</span>

<span class="sd">        &gt;&gt;&gt; ag1 = u.select_atoms(&#39;name O&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ag2 = u.select_atoms(&#39;name N&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ag3 = ag1 + ag2  # or ag1.concatenate(ag2)</span>
<span class="sd">        &gt;&gt;&gt; ag3[:3].names</span>
<span class="sd">        array([&#39;O&#39;, &#39;O&#39;, &#39;O&#39;], dtype=object)</span>
<span class="sd">        &gt;&gt;&gt; ag3[-3:].names</span>
<span class="sd">        array([&#39;N&#39;, &#39;N&#39;, &#39;N&#39;], dtype=object)</span>

<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">]),</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Group of elements either in this Group or another</span>

<span class="sd">        On the contrary to concatenation, this method sort the elements and</span>
<span class="sd">        removes duplicate ones. It is synomymous to the `|` operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with the combined elements of `self` and `other`, without</span>
<span class="sd">            duplicate elements</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        In contrast to :meth:`concatenate`, any duplicates are dropped</span>
<span class="sd">        and the result is sorted.</span>

<span class="sd">        &gt;&gt;&gt; ag1 = u.select_atoms(&#39;name O&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ag2 = u.select_atoms(&#39;name N&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ag3 = ag1 | ag2  # or ag1.union(ag2)</span>
<span class="sd">        &gt;&gt;&gt; ag3[:3].names</span>
<span class="sd">        array([&#39;N&#39;, &#39;O&#39;, &#39;N&#39;], dtype=object)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        concatenate, intersection</span>

<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Group of elements which are in both this Group and another</span>

<span class="sd">        This method removes duplicate elements and sorts the result. It is</span>
<span class="sd">        synomymous to the `&amp;` operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with the common elements of `self` and `other`, without</span>
<span class="sd">            duplicate elements</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        Intersections can be used when the select atoms string would</span>
<span class="sd">        become too complicated.  For example to find the water atoms</span>
<span class="sd">        which are within 4.0A of two segments:</span>

<span class="sd">        &gt;&gt;&gt; water = u.select_atoms(&#39;resname SOL&#39;)</span>
<span class="sd">        &gt;&gt;&gt; shell1 = water.select_atoms(&#39;around 4.0 segid 1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; shell2 = water.select_atoms(&#39;around 4.0 segid 2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; common = shell1 &amp; shell2  # or shell1.intersection(shell2)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        union</span>

<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Group with elements from this Group that don&#39;t appear in other</span>

<span class="sd">        The original order of this group is kept, as well as any duplicate</span>
<span class="sd">        elements. If an element of this Group is duplicated and appears in</span>
<span class="sd">        the other Group or Component, then all the occurences of that element</span>
<span class="sd">        are removed from the returned Group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with the elements of `self` that are not in  `other`,</span>
<span class="sd">            conserves order and duplicates.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        Unlike :meth:`difference` this method will not sort or remove</span>
<span class="sd">        duplicates.</span>

<span class="sd">        &gt;&gt;&gt; ag1 = u.atoms[[3, 3, 2, 2, 1, 1]]</span>
<span class="sd">        &gt;&gt;&gt; ag2 = u.atoms[2]</span>
<span class="sd">        &gt;&gt;&gt; ag3 = ag1 - ag2  # or ag1.subtract(ag2)</span>
<span class="sd">        &gt;&gt;&gt; ag1.indices</span>
<span class="sd">        array([3, 3, 1, 1])</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        concatenate, difference</span>

<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="n">in_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">)</span>  <span class="c1"># mask of in self.ix AND other</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="o">~</span><span class="n">in_other</span><span class="p">]</span>  <span class="c1"># ie inverse of previous mask</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Elements from this Group that do not appear in another</span>

<span class="sd">        This method removes duplicate elements and sorts the result. As such,</span>
<span class="sd">        it is different from :meth:`subtract`. :meth:`difference` is synomymous</span>
<span class="sd">        to the `-` operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with the elements of `self` that are not in  `other`, without</span>
<span class="sd">            duplicate elements</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        subtract, symmetric_difference</span>

<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">symmetric_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Group of elements which are only in one of this Group or another</span>

<span class="sd">        This method removes duplicate elements and the result is sorted. It is</span>
<span class="sd">        synomym to the `^` operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with the elements that are in `self` or in `other` but not in</span>
<span class="sd">            both, without duplicate elements</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; ag1 = u.atoms[[0, 1, 5, 3, 3, 2]]</span>
<span class="sd">        &gt;&gt;&gt; ag2 = u.atoms[[4, 4, 6, 2, 3, 5]]</span>
<span class="sd">        &gt;&gt;&gt; ag3 = ag1 ^ ag2  # or ag1.symmetric_difference(ag2)</span>
<span class="sd">        &gt;&gt;&gt; ag3.indices  # 0 and 1 are only in ag1, 4 and 6 are only in ag2</span>
<span class="sd">        [0, 1, 4, 6]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        difference</span>

<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setxor1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isdisjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the Group has no elements in common with the other Group</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Bool</span>
<span class="sd">            True if the two Groups do not have common elements</span>

<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">issubset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If all elements of this Group are part of another Group</span>

<span class="sd">        Note that an empty group is a subset of any group of the same level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Bool</span>
<span class="sd">            True if this Group is a subset of the other one</span>

<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ix_array</span><span class="p">)</span>
        <span class="n">s_ix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s_ix</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">o_ix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_strict_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If this Group is a subset of another Group but not identical</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Bool</span>
<span class="sd">            True if this Group is a strict subset of the other one</span>

<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">issuperset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If all elements of another Group are part of this Group</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Bool</span>
<span class="sd">            True if this Group is a subset of the other one</span>

<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ix_array</span><span class="p">)</span>
        <span class="n">s_ix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s_ix</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">o_ix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_strict_superset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If this Group is a superset of another Group but not identical</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Bool</span>
<span class="sd">            True if this Group is a strict superset of the other one</span>

<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>


<div class="viewcode-block" id="AtomGroup"><a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.AtomGroup">[docs]</a><span class="k">class</span> <span class="nc">AtomGroup</span><span class="p">(</span><span class="n">GroupBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An ordered array of atoms.</span>

<span class="sd">    Can be initiated from an iterable of Atoms::</span>

<span class="sd">        ag = AtomGroup([Atom1, Atom2, Atom3])</span>

<span class="sd">    Or from providing a list of indices and the Universe which is should belong</span>
<span class="sd">    to::</span>

<span class="sd">        ag = AtomGroup([72, 14, 25], u)</span>

<span class="sd">    Alternatively an :class:`AtomGroup` is generated by indexing/slicing another</span>
<span class="sd">    AtomGroup, such as the Group of all atoms in the :class:`Universe` at</span>
<span class="sd">    :attr:`MDAnalysis.core.universe.Universe.atoms`.</span>

<span class="sd">    An AtomGroup can be indexed and sliced like a list::</span>

<span class="sd">        ag[0], ag[-1]</span>

<span class="sd">    will return the first and the last :class:`Atom` in the group whereas the</span>
<span class="sd">    slice ::</span>

<span class="sd">        ag[0:6:2]</span>

<span class="sd">    returns an AtomGroup of every second element, corresponding to indices 0,</span>
<span class="sd">    2, and 4.</span>

<span class="sd">    It also supports &quot;advanced slicing&quot; when the argument is a</span>
<span class="sd">    :class:`numpy.ndarray` or a :class:`list`::</span>

<span class="sd">        aslice = [0, 3, -1, 10, 3]</span>
<span class="sd">        ag[aslice]</span>

<span class="sd">    will return a new AtomGroup of atoms with those indices in the old</span>
<span class="sd">    AtomGroup.</span>

<span class="sd">    Finally, AtomGroups can be created from a selection.  See</span>
<span class="sd">    :meth:`select_atoms`.</span>

<span class="sd">    .. note::</span>

<span class="sd">        AtomGroups originating from a selection are sorted and</span>
<span class="sd">        duplicate elements are removed. This is not true for AtomGroups</span>
<span class="sd">        produced by slicing. Thus slicing can be used when the order of</span>
<span class="sd">        atoms is crucial (for instance, in order to define angles or</span>
<span class="sd">        dihedrals).</span>

<span class="sd">    AtomGroups can be compared and combined using group operators. For</span>
<span class="sd">    instance, AtomGroups can be concatenated using `+` or :meth:`concatenate`::</span>

<span class="sd">        ag_concat = ag1 + ag2  # or ag_concat = ag1.concatenate(ag2)</span>

<span class="sd">    When groups are concatenated, the order of the atoms is conserved. If atoms</span>
<span class="sd">    appear several times in one of the groups, the duplicates are kept in the</span>
<span class="sd">    resulting group. On the contrary to :meth:`concatenate`, :meth:`union`</span>
<span class="sd">    treats the AtomGroups as sets, duplicates are removed from the resulting</span>
<span class="sd">    group, and atoms are ordered. The `|` operator is synomymous to</span>
<span class="sd">    :meth:`union`::</span>

<span class="sd">        ag_union = ag1 | ag2  # or ag_union = ag1.union(ag2)</span>

<span class="sd">    The opposite operation to :meth:`concatenate` is :meth:`subtract`. This</span>
<span class="sd">    method creates a new group with all the atoms of the group that are not in</span>
<span class="sd">    a given other group; the order of the atoms is kept, so as duplicates.</span>
<span class="sd">    :meth:`difference` is the set version of :meth:`subtract`. The resulting</span>
<span class="sd">    group is sorted and deduplicated.</span>

<span class="sd">    All set methods are listed in the table below. These methods treat the</span>
<span class="sd">    groups as sorted and deduplicated sets of atoms.</span>

<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | Operation                     | Equivalent | Result                     |</span>
<span class="sd">    +===============================+============+============================+</span>
<span class="sd">    | ``s.isdisjoint(t)``           |            | ``True`` if ``s`` and      |</span>
<span class="sd">    |                               |            | ``t`` do not share         |</span>
<span class="sd">    |                               |            | elements                   |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.issubset(t)``             |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``s`` are part of ``t``    |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.is_strict_subset(t)``     |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``s`` are part of ``t``,   |</span>
<span class="sd">    |                               |            | and ``s != t``             |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.issuperset(t)``           |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``t`` are part of ``s``    |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.is_strict_superset(t)``   |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``t`` are part of ``s``,   |</span>
<span class="sd">    |                               |            | and ``s != t``             |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.union(t)``                | ``s | t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | from both ``s`` and ``t``  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.intersection(t)``         | ``s &amp; t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | common to ``s`` and ``t``  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.difference(t)``           | ``s - t``  | new Group with elements of |</span>
<span class="sd">    |                               |            | ``s`` that are not in ``t``|</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.symmetric_difference(t)`` | ``s ^ t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | that are part of ``s`` or  |</span>
<span class="sd">    |                               |            | ``t`` but not both         |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>

<span class="sd">    The following methods keep the order of the atoms, and keep duplicated</span>
<span class="sd">    atoms.</span>

<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | Operation                     | Equivalent | Result                     |</span>
<span class="sd">    +===============================+============+============================+</span>
<span class="sd">    | ``len(s)``                    |            | number of elements (atoms, |</span>
<span class="sd">    |                               |            | residues or segment) in    |</span>
<span class="sd">    |                               |            | the group                  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s == t``                    |            | test if ``s`` and ``t``    |</span>
<span class="sd">    |                               |            | contain the same elements  |</span>
<span class="sd">    |                               |            | in the same order          |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.concatenate(t)``          | ``s + t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | from ``s`` and from ``t``  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.subtract(t)``             |            | new Group with elements    |</span>
<span class="sd">    |                               |            | from ``s`` that are not    |</span>
<span class="sd">    |                               |            | in ``t``                   |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>

<span class="sd">    The `in` operator allows to test if an :class:`Atom` is in the AtomGroup.</span>

<span class="sd">    AtomGroup instances are always bound to a</span>
<span class="sd">    :class:`MDAnalysis.core.universe.Universe`. They cannot exist in isolation.</span>


<span class="sd">    .. rubric:: Deprecated functionality</span>

<span class="sd">    *Instant selectors* will be removed in the 1.0 release.  See issue `#1377</span>
<span class="sd">    &lt;https://github.com/MDAnalysis/mdanalysis/issues/1377&gt;`_ for more details.</span>

<span class="sd">    Atoms can also be accessed in a Pythonic fashion by using the atom name as</span>
<span class="sd">    an attribute. For instance, ::</span>

<span class="sd">        ag.CA</span>

<span class="sd">    will provide a :class:`AtomGroup` of all CA atoms in the</span>
<span class="sd">    group. These *instant selector* attributes are auto-generated for</span>
<span class="sd">    each atom name encountered in the group.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The name-attribute instant selector access to atoms is mainly</span>
<span class="sd">    meant for quick interactive work. Thus it either returns a</span>
<span class="sd">    single :class:`Atom` if there is only one matching atom, *or* a</span>
<span class="sd">    new :class:`AtomGroup` for multiple matches.  This makes it</span>
<span class="sd">    difficult to use the feature consistently in scripts.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`MDAnalysis.core.universe.Universe`</span>


<span class="sd">    .. deprecated:: 0.16.2</span>
<span class="sd">       *Instant selectors* of AtomGroup will be removed in the 1.0 release.</span>
<span class="sd">       See :ref:`Instant selectors &lt;instance-selectors&gt;` for details and alternatives.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="c1"># DEPRECATED in 0.16.2</span>
        <span class="c1"># REMOVE in 1.0</span>
        <span class="c1">#</span>
        <span class="c1"># u.atoms[&#39;HT1&#39;] access, otherwise default</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_named_atom</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">):</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="c1"># DEPRECATED in 0.16.2</span>
        <span class="c1"># REMOVE in 1.0</span>
        <span class="c1">#</span>
        <span class="c1"># is this a known attribute failure?</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;fragments&#39;</span><span class="p">,):</span>  <span class="c1"># TODO: Generalise this to cover many attributes</span>
            <span class="c1"># eg:</span>
            <span class="c1"># if attr in _ATTR_ERRORS:</span>
            <span class="c1"># raise NDE(_ATTR_ERRORS[attr])</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;AtomGroup has no fragments; this requires Bonds&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="p">,</span> <span class="s1">&#39;names&#39;</span><span class="p">):</span>
            <span class="c1"># Ugly hack to make multiple __getattr__s work</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_named_atom</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2"> has no attribute </span><span class="si">{attr}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_unpickle</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">anchor_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get another AtomGroup identical to this one.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of atoms in AtomGroup.</span>

<span class="sd">        Equivalent to ``len(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get sorted :class:`ResidueGroup` of the (unique) residues</span>
<span class="sd">        represented in the AtomGroup.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resindices</span><span class="p">)]</span>

    <span class="nd">@residues</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="c1"># Can set with Res, ResGroup or list/tuple of Res</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">Residue</span><span class="p">):</span>
            <span class="n">r_ix</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="n">new</span><span class="o">.</span><span class="n">resindex</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">):</span>
            <span class="n">r_ix</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">resindices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">r_ix</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">resindex</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only set AtomGroup residues to Residue &quot;</span>
                                <span class="s2">&quot;or ResidueGroup not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new</span>
                                              <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Residue</span><span class="p">))</span>
                                <span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r_ix</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_ix</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incorrect size: </span><span class="si">{}</span><span class="s2"> for AtomGroup of size: </span><span class="si">{}</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="c1"># Optimisation TODO:</span>
        <span class="c1"># This currently rebuilds the tt len(self) times</span>
        <span class="c1"># Ideally all changes would happen and *afterwards* tables are built</span>
        <span class="c1"># Alternatively, if the changes didn&#39;t rebuild table, this list</span>
        <span class="c1"># comprehension isn&#39;t terrible.</span>
        <span class="k">for</span> <span class="n">at</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r_ix</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">move_atom</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of unique residues represented in the AtomGroup.</span>

<span class="sd">        Equivalent to ``len(self.residues)``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get sorted :class:`SegmentGroup` of the (unique) segments</span>
<span class="sd">        represented in the AtomGroup.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segindices</span><span class="p">)]</span>

    <span class="nd">@segments</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot assign Segments to AtomGroup. &quot;</span>
                                  <span class="s2">&quot;Segments are assigned to Residues&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of unique segments represented in the AtomGroup.</span>

<span class="sd">        Equivalent to ``len(self.segments)``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an AtomGroup containing sorted and unique atoms only.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">           &gt;&gt;&gt; ag = u.atoms[[2, 1, 2, 2, 1, 0]]</span>
<span class="sd">           &gt;&gt;&gt; ag</span>
<span class="sd">           &lt;AtomGroup with 6 atoms&gt;</span>
<span class="sd">           &gt;&gt;&gt; ag.ix</span>
<span class="sd">           array([2, 1, 2, 2, 1, 0])</span>
<span class="sd">           &gt;&gt;&gt; ag2 = ag.unique</span>
<span class="sd">           &gt;&gt;&gt; ag2</span>
<span class="sd">           &lt;AtomGroup with 3 atoms&gt;</span>
<span class="sd">           &gt;&gt;&gt; ag2.ix</span>
<span class="sd">           array([0, 1, 2])</span>

<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coordinates of the atoms in the AtomGroup.</span>

<span class="sd">        The positions can be changed by assigning an array of the appropriate</span>
<span class="sd">        shape, i.e. either Nx3 to assign individual coordinates or 3, to assign</span>
<span class="sd">        the *same* coordinate to all atoms (e.g. ``ag.positions =</span>
<span class="sd">        array([0,0,0])`` will move all particles to the origin).</span>

<span class="sd">        .. note:: Changing the position is not reflected in any files;</span>
<span class="sd">                  reading any frame from the trajectory will replace</span>
<span class="sd">                  the change with that from the file *except* if the</span>
<span class="sd">                  trajectory is held in memory, e.g., when the</span>
<span class="sd">                  :class:`~MDAnalysis.core.universe.Universe.transfer_to_memory`</span>
<span class="sd">                  method was used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span>

    <span class="nd">@positions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">velocities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Velocities of the atoms in the AtomGroup.</span>

<span class="sd">        The velocities can be changed by assigning an array of the appropriate</span>
<span class="sd">        shape, i.e. either Nx3 to assign individual velocities or 3 to assign</span>
<span class="sd">        the *same* velocity to all atoms (e.g. ``ag.velocity = array([0,0,0])``</span>
<span class="sd">        will give all particles zero velocity).</span>

<span class="sd">        Raises a :exc:`NoDataError` if the underlying</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.base.Timestep` does not contain</span>
<span class="sd">        :attr:`~MDAnalysis.coordinates.base.Timestep.velocities`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">])</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Timestep does not contain velocities&quot;</span><span class="p">)</span>

    <span class="nd">@velocities</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">velocities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Timestep does not contain velocities&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">forces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Forces on each atom in the AtomGroup.</span>

<span class="sd">        The velocities can be changed by assigning an array of the appropriate</span>
<span class="sd">        shape, i.e. either Nx3 to assign individual velocities or 3 to assign</span>
<span class="sd">        the *same* velocity to all atoms (e.g. ``ag.velocity = array([0,0,0])``</span>
<span class="sd">        will give all particles zero velocity).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ts</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Timestep does not contain forces&quot;</span><span class="p">)</span>

    <span class="nd">@forces</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Timestep does not contain forces&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Temporary Timestep that contains the selection coordinates.</span>

<span class="sd">        A :class:`~MDAnalysis.coordinates.base.Timestep` instance,</span>
<span class="sd">        which can be passed to a trajectory writer.</span>

<span class="sd">        If :attr:`~AtomGroup.ts` is modified then these modifications</span>
<span class="sd">        will be present until the frame number changes (which</span>
<span class="sd">        typically happens when the underlying trajectory frame</span>
<span class="sd">        changes).</span>

<span class="sd">        It is not possible to assign a new</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.base.Timestep` to the</span>
<span class="sd">        :attr:`AtomGroup.ts` attribute; change attributes of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trj_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>  <span class="c1"># original time step</span>

        <span class="k">return</span> <span class="n">trj_ts</span><span class="o">.</span><span class="n">copy_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>

    <span class="c1"># As with universe.select_atoms, needing to fish out specific kwargs</span>
    <span class="c1"># (namely, &#39;updating&#39;) doesn&#39;t allow a very clean signature.</span>
<div class="viewcode-block" id="AtomGroup.select_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.AtomGroup.select_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="o">*</span><span class="n">othersel</span><span class="p">,</span> <span class="o">**</span><span class="n">selgroups</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select atoms using a selection string.</span>

<span class="sd">        Returns an :class:`AtomGroup` with atoms sorted according to</span>
<span class="sd">        their index in the topology (this is to ensure that there</span>
<span class="sd">        are not any duplicates, which can happen with complicated</span>
<span class="sd">        selections).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        All simple selection listed below support multiple arguments which are</span>
<span class="sd">        implicitly combined with an or operator. For example</span>

<span class="sd">           &gt;&gt;&gt; sel = universe.select_atoms(&#39;resname MET GLY&#39;)</span>

<span class="sd">        is equivalent to</span>

<span class="sd">           &gt;&gt;&gt; sel = universe.select_atoms(&#39;resname MET or resname GLY&#39;)</span>

<span class="sd">        Will select all atoms with a residue name of either MET or GLY.</span>

<span class="sd">        Subselections can be grouped with parentheses.</span>

<span class="sd">           &gt;&gt;&gt; sel = universe.select_atoms(&quot;segid DMPC and not ( name H* O* )&quot;)</span>
<span class="sd">           &gt;&gt;&gt; sel</span>
<span class="sd">           &lt;AtomGroup with 3420 atoms&gt;</span>


<span class="sd">        Existing :class:`AtomGroup` objects can be passed as named arguments,</span>
<span class="sd">        which will then be available to the selection parser.</span>

<span class="sd">           &gt;&gt;&gt; universe.select_atoms(&quot;around 10 group notHO&quot;, notHO=sel)</span>
<span class="sd">           &lt;AtomGroup with 1250 atoms&gt;</span>

<span class="sd">        Selections can be set to update automatically on frame change, by</span>
<span class="sd">        setting the `updating` keyword argument to `True`.  This will return</span>
<span class="sd">        a :class:`UpdatingAtomGroup` which can represent the solvation shell</span>
<span class="sd">        around another object.</span>

<span class="sd">           &gt;&gt;&gt; universe.select_atoms(&quot;resname SOL and around 2.0 protein&quot;, updating=True)</span>
<span class="sd">           &lt;Updating AtomGroup with 100 atoms&gt;</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        If exact ordering of atoms is required (for instance, for</span>
<span class="sd">        :meth:`~AtomGroup.angle` or :meth:`~AtomGroup.dihedral`</span>
<span class="sd">        calculations) then one supplies selections *separately* in the</span>
<span class="sd">        required order. Also, when multiple :class:`AtomGroup`</span>
<span class="sd">        instances are concatenated with the ``+`` operator then the</span>
<span class="sd">        order of :class:`Atom` instances is preserved and duplicates</span>
<span class="sd">        are not removed.</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`selection-commands-label` for further details and examples.</span>


<span class="sd">        .. rubric:: Selection syntax</span>


<span class="sd">        The selection parser understands the following CASE SENSITIVE</span>
<span class="sd">        *keywords*:</span>

<span class="sd">        **Simple selections**</span>

<span class="sd">            protein, backbone, nucleic, nucleicbackbone</span>
<span class="sd">                selects all atoms that belong to a standard set of residues;</span>
<span class="sd">                a protein is identfied by a hard-coded set of residue names so</span>
<span class="sd">                it  may not work for esoteric residues.</span>
<span class="sd">            segid *seg-name*</span>
<span class="sd">                select by segid (as given in the topology), e.g. ``segid 4AKE``</span>
<span class="sd">                or ``segid DMPC``</span>
<span class="sd">            resid *residue-number-range*</span>
<span class="sd">                resid can take a single residue number or a range of numbers. A</span>
<span class="sd">                range consists of two numbers separated by a colon (inclusive)</span>
<span class="sd">                such as ``resid 1:5``. A residue number (&quot;resid&quot;) is taken</span>
<span class="sd">                directly from the topology.</span>
<span class="sd">                If icodes are present in the topology, then these will be</span>
<span class="sd">                taken into account.  Ie &#39;resid 163B&#39; will only select resid</span>
<span class="sd">                163 with icode B while &#39;resid 163&#39; will select only residue 163.</span>
<span class="sd">                Range selections will also respect icodes, so &#39;resid 162-163B&#39;</span>
<span class="sd">                will select all residues in 162 and those in 163 up to icode B.</span>
<span class="sd">            resnum *resnum-number-range*</span>
<span class="sd">                resnum is the canonical residue number; typically it is set to</span>
<span class="sd">                the residue id in the original PDB structure.</span>
<span class="sd">            resname *residue-name*</span>
<span class="sd">                select by residue name, e.g. ``resname LYS``</span>
<span class="sd">            name *atom-name*</span>
<span class="sd">                select by atom name (as given in the topology). Often, this is</span>
<span class="sd">                force field dependent. Example: ``name CA`` (for C&amp;alpha; atoms)</span>
<span class="sd">                or ``name OW`` (for SPC water oxygen)</span>
<span class="sd">            type *atom-type*</span>
<span class="sd">                select by atom type; this is either a string or a number and</span>
<span class="sd">                depends on the force field; it is read from the topology file</span>
<span class="sd">                (e.g. the CHARMM PSF file contains numeric atom types). It has</span>
<span class="sd">                non-sensical values when a PDB or GRO file is used as a topology</span>
<span class="sd">            atom *seg-name*  *residue-number*  *atom-name*</span>
<span class="sd">                a selector for a single atom consisting of segid resid atomname,</span>
<span class="sd">                e.g. ``DMPC 1 C2`` selects the C2 carbon of the first residue of</span>
<span class="sd">                the DMPC segment</span>
<span class="sd">            altloc *alternative-location*</span>
<span class="sd">                a selection for atoms where alternative locations are available,</span>
<span class="sd">                which is often the case with high-resolution crystal structures</span>
<span class="sd">                e.g. `resid 4 and resname ALA and altloc B` selects only the</span>
<span class="sd">                atoms of ALA-4 that have an altloc B record.</span>
<span class="sd">            moltype *molecule-type*</span>
<span class="sd">                select by molecule type, e.g. ``moltype Protein_A``. At the</span>
<span class="sd">                moment, only the TPR format defines the molecule type.</span>

<span class="sd">        **Boolean**</span>

<span class="sd">            not</span>
<span class="sd">                all atoms not in the selection, e.g. ``not protein`` selects</span>
<span class="sd">                all atoms that aren&#39;t part of a protein</span>

<span class="sd">            and, or</span>
<span class="sd">                combine two selections according to the rules of boolean</span>
<span class="sd">                algebra, e.g. ``protein and not resname ALA LYS``</span>
<span class="sd">                selects all atoms that belong to a protein, but are not in a</span>
<span class="sd">                lysine or alanine residue</span>

<span class="sd">        **Geometric**</span>

<span class="sd">            around *distance*  *selection*</span>
<span class="sd">                selects all atoms a certain cutoff away from another selection,</span>
<span class="sd">                e.g. ``around 3.5 protein`` selects all atoms not belonging to</span>
<span class="sd">                protein that are within 3.5 Angstroms from the protein</span>
<span class="sd">            point *x* *y* *z*  *distance*</span>
<span class="sd">                selects all atoms within a cutoff of a point in space, make sure</span>
<span class="sd">                coordinate is separated by spaces,</span>
<span class="sd">                e.g. ``point 5.0 5.0 5.0  3.5`` selects all atoms within 3.5</span>
<span class="sd">                Angstroms of the coordinate (5.0, 5.0, 5.0)</span>
<span class="sd">            prop [abs] *property*  *operator*  *value*</span>
<span class="sd">                selects atoms based on position, using *property*  **x**, **y**,</span>
<span class="sd">                or **z** coordinate. Supports the **abs** keyword (for absolute</span>
<span class="sd">                value) and the following *operators*: **&lt;, &gt;, &lt;=, &gt;=, ==, !=**.</span>
<span class="sd">                For example, ``prop z &gt;= 5.0`` selects all atoms with z</span>
<span class="sd">                coordinate greater than 5.0; ``prop abs z &lt;= 5.0`` selects all</span>
<span class="sd">                atoms within -5.0 &lt;= z &lt;= 5.0.</span>
<span class="sd">            sphzone *radius* *selection*</span>
<span class="sd">                Selects all atoms that are within *radius* of the center of</span>
<span class="sd">                geometry of *selection*</span>
<span class="sd">            sphlayer *inner radius* *outer radius* *selection*</span>
<span class="sd">                Similar to sphzone, but also excludes atoms that are within</span>
<span class="sd">                *inner radius* of the selection COG</span>
<span class="sd">            cyzone *externalRadius* *zMax* *zMin* *selection*</span>
<span class="sd">                selects all atoms within a cylindric zone centered in the</span>
<span class="sd">                center of geometry (COG) of a given selection,</span>
<span class="sd">                e.g. ``cyzone 15 4 -8 protein and resid 42`` selects the</span>
<span class="sd">                center of geometry of protein and resid 42, and creates a</span>
<span class="sd">                cylinder of external radius 15 centered on the COG. In z, the</span>
<span class="sd">                cylinder extends from 4 above the COG to 8 below. Positive</span>
<span class="sd">                values for *zMin*, or negative ones for *zMax*, are allowed.</span>
<span class="sd">            cylayer *innerRadius* *externalRadius* *zMax* *zMin* *selection*</span>
<span class="sd">                selects all atoms within a cylindric layer centered in the</span>
<span class="sd">                center of geometry (COG) of a given selection,</span>
<span class="sd">                e.g. ``cylayer 5 10 10 -8 protein`` selects the center of</span>
<span class="sd">                geometry of protein, and creates a cylindrical layer of inner</span>
<span class="sd">                radius 5, external radius 10 centered on the COG. In z, the</span>
<span class="sd">                cylinder extends from 10 above the COG to 8 below. Positive</span>
<span class="sd">                values for *zMin*, or negative ones for *zMax*, are allowed.</span>

<span class="sd">        **Connectivity**</span>

<span class="sd">            byres *selection*</span>
<span class="sd">                selects all atoms that are in the same segment and residue as</span>
<span class="sd">                selection, e.g. specify the subselection after the byres keyword</span>
<span class="sd">            bonded *selection*</span>
<span class="sd">                selects all atoms that are bonded to selection</span>
<span class="sd">                eg: ``select name H and bonded name O`` selects only hydrogens</span>
<span class="sd">                bonded to oxygens</span>

<span class="sd">        **Index**</span>

<span class="sd">            bynum *index-range*</span>
<span class="sd">                selects all atoms within a range of (1-based) inclusive indices,</span>
<span class="sd">                e.g. ``bynum 1`` selects the first atom in the universe;</span>
<span class="sd">                ``bynum 5:10`` selects atoms 5 through 10 inclusive. All atoms</span>
<span class="sd">                in the :class:`MDAnalysis.Universe` are consecutively numbered,</span>
<span class="sd">                and the index runs from 1 up to the total number of atoms.</span>

<span class="sd">        **Preexisting selections**</span>

<span class="sd">            group `group-name`</span>
<span class="sd">                selects the atoms in the :class:`AtomGroup` passed to the</span>
<span class="sd">                function as an argument named `group-name`. Only the atoms</span>
<span class="sd">                common to `group-name` and the instance</span>
<span class="sd">                :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms`</span>
<span class="sd">                was called from will be considered, unless ``group`` is</span>
<span class="sd">                preceded by the ``global`` keyword. `group-name` will be</span>
<span class="sd">                included in the parsing just by comparison of atom indices.</span>
<span class="sd">                This means that it is up to the user to make sure the</span>
<span class="sd">                `group-name` group was defined in an appropriate</span>
<span class="sd">                :class:`Universe`.</span>

<span class="sd">            global *selection*</span>
<span class="sd">                by default, when issuing</span>
<span class="sd">                :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` from an</span>
<span class="sd">                :class:`~MDAnalysis.core.groups.AtomGroup`, selections and</span>
<span class="sd">                subselections are returned intersected with the atoms of that</span>
<span class="sd">                instance. Prefixing a selection term with ``global`` causes its</span>
<span class="sd">                selection to be returned in its entirety.  As an example, the</span>
<span class="sd">                ``global`` keyword allows for</span>
<span class="sd">                ``lipids.select_atoms(&quot;around 10 global protein&quot;)`` --- where</span>
<span class="sd">                ``lipids`` is a group that does not contain any proteins. Were</span>
<span class="sd">                ``global`` absent, the result would be an empty selection since</span>
<span class="sd">                the ``protein`` subselection would itself be empty. When issuing</span>
<span class="sd">                :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` from a</span>
<span class="sd">                :class:`~MDAnalysis.core.universe.Universe`, ``global`` is ignored.</span>

<span class="sd">        **Dynamic selections**</span>
<span class="sd">            If :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` is</span>
<span class="sd">            invoked with named argument `updating` set to `True`, an</span>
<span class="sd">            :class:`~MDAnalysis.core.groups.UpdatingAtomGroup` instance will be</span>
<span class="sd">            returned, instead of a regular</span>
<span class="sd">            :class:`~MDAnalysis.core.groups.AtomGroup`. It behaves just like</span>
<span class="sd">            the latter, with the difference that the selection expressions are</span>
<span class="sd">            re-evaluated every time the trajectory frame changes (this happens</span>
<span class="sd">            lazily, only when the</span>
<span class="sd">            :class:`~MDAnalysis.core.groups.UpdatingAtomGroup` is accessed so</span>
<span class="sd">            that there is no redundant updating going on).</span>
<span class="sd">            Issuing an updating selection from an already updating group will</span>
<span class="sd">            cause later updates to also reflect the updating of the base group.</span>
<span class="sd">            A non-updating selection or a slicing operation made on an</span>
<span class="sd">            :class:`~MDAnalysis.core.groups.UpdatingAtomGroup` will return a</span>
<span class="sd">            static :class:`~MDAnalysis.core.groups.AtomGroup`, which will no</span>
<span class="sd">            longer update across frames.</span>


<span class="sd">        .. versionchanged:: 0.7.4</span>
<span class="sd">           Added *resnum* selection.</span>
<span class="sd">        .. versionchanged:: 0.8.1</span>
<span class="sd">           Added *group* and *fullgroup* selections.</span>
<span class="sd">        .. deprecated:: 0.11</span>
<span class="sd">           The use of ``fullgroup`` has been deprecated in favor of the equivalent</span>
<span class="sd">           ``global group``.</span>
<span class="sd">        .. versionchanged:: 0.13.0</span>
<span class="sd">           Added *bonded* selection</span>
<span class="sd">        .. versionchanged:: 0.16.0</span>
<span class="sd">           Resid selection now takes icodes into account where present.</span>
<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">           Updating selections now possible by setting the ``updating`` argument.</span>
<span class="sd">        .. versionadded:: 0.17.0</span>
<span class="sd">           Added *moltype* and *molnum* selections.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">updating</span> <span class="o">=</span> <span class="n">selgroups</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;updating&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">sel_strs</span> <span class="o">=</span> <span class="p">(</span><span class="n">sel</span><span class="p">,)</span> <span class="o">+</span> <span class="n">othersel</span>
        <span class="n">selections</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">selection</span><span class="o">.</span><span class="n">Parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">selgroups</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sel_strs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">updating</span><span class="p">:</span>
            <span class="n">atomgrp</span> <span class="o">=</span> <span class="n">UpdatingAtomGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selections</span><span class="p">,</span> <span class="n">sel_strs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Apply the first selection and sum to it</span>
            <span class="n">atomgrp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">sel</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">sel</span> <span class="ow">in</span> <span class="n">selections</span><span class="p">[</span><span class="mi">1</span><span class="p">:]],</span>
                          <span class="n">selections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">atomgrp</span></div>

<div class="viewcode-block" id="AtomGroup.split"><a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.AtomGroup.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split AtomGroup into a list of atomgroups by `level`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : {&#39;atom&#39;, &#39;residue&#39;, &#39;molecule&#39;, &#39;segment&#39;}</span>


<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.17.0</span>
<span class="sd">           Added the &#39;molecule&#39; level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">accessors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;segment&#39;</span><span class="p">:</span> <span class="s1">&#39;segindices&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;residue&#39;</span><span class="p">:</span> <span class="s1">&#39;resindices&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;molecule&#39;</span><span class="p">:</span> <span class="s1">&#39;molnums&#39;</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="s2">&quot;atom&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[[</span><span class="n">a</span><span class="o">.</span><span class="n">ix</span><span class="p">]]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

        <span class="c1"># higher level groupings</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">levelindices</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">accessors</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;This universe does not have </span><span class="si">{}</span><span class="s1"> &#39;</span>
                             <span class="s1">&#39;information. Maybe it is not provided in the &#39;</span>
                             <span class="s1">&#39;topology format in use.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;level = &#39;</span><span class="si">{0}</span><span class="s2">&#39; not supported, &quot;</span>
                             <span class="s2">&quot;must be one of </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="p">,</span>
                                                         <span class="n">accessors</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">levelindices</span> <span class="o">==</span> <span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span>
                <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">levelindices</span><span class="p">)]</span></div>

<div class="viewcode-block" id="AtomGroup.guess_bonds"><a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.AtomGroup.guess_bonds">[docs]</a>    <span class="k">def</span> <span class="nf">guess_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vdwradii</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Guess bonds that exist within this AtomGroup and add to Universe</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vdwradii : dict, optional</span>
<span class="sd">          Dict relating atom type: vdw radii</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`MDAnalysis.topology.guessers.guess_bonds`</span>


<span class="sd">        .. versionadded:: 0.10.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="k">import</span> <span class="n">guess_bonds</span><span class="p">,</span> <span class="n">guess_angles</span><span class="p">,</span> <span class="n">guess_dihedrals</span>
        <span class="kn">from</span> <span class="nn">.topologyattrs</span> <span class="k">import</span> <span class="n">Bonds</span><span class="p">,</span> <span class="n">Angles</span><span class="p">,</span> <span class="n">Dihedrals</span>

        <span class="k">def</span> <span class="nf">get_TopAttr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;either get *name* or create one from *cls*&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_topology</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">attr</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">([])</span>
                <span class="n">u</span><span class="o">.</span><span class="n">add_TopologyAttr</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">attr</span>

        <span class="c1"># indices of bonds</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">guess_bonds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">vdwradii</span><span class="o">=</span><span class="n">vdwradii</span><span class="p">)</span>
        <span class="n">bondattr</span> <span class="o">=</span> <span class="n">get_TopAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="s1">&#39;bonds&#39;</span><span class="p">,</span> <span class="n">Bonds</span><span class="p">)</span>
        <span class="n">bondattr</span><span class="o">.</span><span class="n">add_bonds</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">guess_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span>
        <span class="n">angleattr</span> <span class="o">=</span> <span class="n">get_TopAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="s1">&#39;angles&#39;</span><span class="p">,</span> <span class="n">Angles</span><span class="p">)</span>
        <span class="n">angleattr</span><span class="o">.</span><span class="n">add_bonds</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">guess_dihedrals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">diheattr</span> <span class="o">=</span> <span class="n">get_TopAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="s1">&#39;dihedrals&#39;</span><span class="p">,</span> <span class="n">Dihedrals</span><span class="p">)</span>
        <span class="n">diheattr</span><span class="o">.</span><span class="n">add_bonds</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bond</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This AtomGroup represented as a Bond object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">          A :class:`MDAnalysis.core.topologyobjects.Bond` object</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">          `ValueError` if the AtomGroup is not length 2</span>


<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;bond only makes sense for a group with exactly 2 atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">topologyobjects</span><span class="o">.</span><span class="n">Bond</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This AtomGroup represented as an Angle object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">          A :class:`MDAnalysis.core.topologyobjects.Angle` object</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">          `ValueError` if the AtomGroup is not length 3</span>


<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;angle only makes sense for a group with exactly 3 atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">topologyobjects</span><span class="o">.</span><span class="n">Angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dihedral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This AtomGroup represented as a Dihedral object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">          A :class:`MDAnalysis.core.topologyobjects.Dihedral` object</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">          `ValueError` if the AtomGroup is not length 4</span>


<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;dihedral only makes sense for a group with exactly 4 atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">topologyobjects</span><span class="o">.</span><span class="n">Dihedral</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">improper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This AtomGroup represented as an ImproperDihedral object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">          A :class:`MDAnalysis.core.topologyobjects.ImproperDihedral` object</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">          `ValueError` if the AtomGroup is not length 4</span>


<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;improper only makes sense for a group with exactly 4 atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">topologyobjects</span><span class="o">.</span><span class="n">ImproperDihedral</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

<div class="viewcode-block" id="AtomGroup.write"><a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.AtomGroup.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file_format</span><span class="o">=</span><span class="s2">&quot;PDB&quot;</span><span class="p">,</span>
              <span class="n">filenamefmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{trjname}</span><span class="s2">_</span><span class="si">{frame}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write `AtomGroup` to a file.</span>

<span class="sd">        The output can either be a coordinate file or a selection, depending on</span>
<span class="sd">        the `format`. Only single-frame coordinate files are supported. If you</span>
<span class="sd">        need to write out a trajectory, see :mod:`MDAnalysis.coordinates`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            ``None``: create TRJNAME_FRAME.FORMAT from filenamefmt [``None``]</span>
<span class="sd">        file_format : str, optional</span>
<span class="sd">            PDB, CRD, GRO, VMD (tcl), PyMol (pml), Gromacs (ndx) CHARMM (str)</span>
<span class="sd">            Jmol (spt); case-insensitive and can also be supplied as the</span>
<span class="sd">            filename extension [PDB]</span>
<span class="sd">        filenamefmt : str, optional</span>
<span class="sd">            format string for default filename; use substitution tokens</span>
<span class="sd">            &#39;trjname&#39; and &#39;frame&#39; [&quot;%(trjname)s_%(frame)d&quot;]</span>
<span class="sd">        bonds : str, optional</span>
<span class="sd">            how to handle bond information, especially relevant for PDBs.</span>
<span class="sd">            ``&quot;conect&quot;``: write only the CONECT records defined in the original</span>
<span class="sd">            file. ``&quot;all&quot;``: write out all bonds, both the original defined and</span>
<span class="sd">            those guessed by MDAnalysis. ``None``: do not write out bonds.</span>
<span class="sd">            Default os ``&quot;conect&quot;``.</span>


<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Merged with write_selection.  This method can now write both</span>
<span class="sd">           selections out.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check that AtomGroup actually has any atoms (Issue #434)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Cannot write an AtomGroup with 0 atoms&quot;</span><span class="p">)</span>

        <span class="n">trj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span>  <span class="c1"># unified trajectory API</span>

        <span class="k">if</span> <span class="n">trj</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;multiframe&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trjname</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">trj</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filenamefmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trjname</span><span class="o">=</span><span class="n">trjname</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">trj</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">file_format</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># From the following blocks, one must pass.</span>
        <span class="c1"># Both can&#39;t pass as the extensions don&#39;t overlap.</span>
        <span class="c1"># Try and select a Class using get_ methods (becomes `writer`)</span>
        <span class="c1"># Once (and if!) class is selected, use it in with block</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># format keyword works differently in get_writer and get_selection_writer</span>
            <span class="c1"># here it overrides everything, in get_sel it is just a default</span>
            <span class="c1"># apply sparingly here!</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># strip initial dot!</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span> <span class="ow">or</span> <span class="n">file_format</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

            <span class="n">multiframe</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;multiframe&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="n">writer</span> <span class="o">=</span> <span class="n">get_writer_for</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="n">multiframe</span><span class="o">=</span><span class="n">multiframe</span><span class="p">)</span>
            <span class="c1">#MDAnalysis.coordinates.writer(filename, **kwargs)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># here `file_format` is only used as default,</span>
            <span class="c1"># anything pulled off `filename` will be used preferentially</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">get_selection_writer_for</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">file_format</span><span class="p">)</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">):</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">coords</span> <span class="ow">or</span> <span class="n">selection</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No writer found for format: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">writer</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
                <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ResidueGroup"><a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.ResidueGroup">[docs]</a><span class="k">class</span> <span class="nc">ResidueGroup</span><span class="p">(</span><span class="n">GroupBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;ResidueGroup base class.</span>

<span class="sd">    This class is used by a :class:`Universe` for generating its</span>
<span class="sd">    Topology-specific :class:`ResidueGroup` class. All the</span>
<span class="sd">    :class:`TopologyAttr` components are obtained from</span>
<span class="sd">    :class:`GroupBase`, so this class only includes ad-hoc methods</span>
<span class="sd">    specific to ResidueGroups.</span>

<span class="sd">    ResidueGroups can be compared and combined using group operators. See the</span>
<span class="sd">    list of these operators on :class:`GroupBase`.</span>

<span class="sd">    .. deprecated:: 0.16.2</span>
<span class="sd">       *Instant selectors* of Segments will be removed in the 1.0 release.</span>
<span class="sd">       See :ref:`Instant selectors &lt;instance-selectors&gt;` for details and alternatives.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an :class:`AtomGroup` of atoms represented in this</span>
<span class="sd">        :class:`ResidueGroup`.</span>

<span class="sd">        The atoms are ordered locally by residue in the</span>
<span class="sd">        :class:`ResidueGroup`.  No duplicates are removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of atoms represented in :class:`ResidueGroup`, including</span>
<span class="sd">        duplicate residues.</span>

<span class="sd">        Equivalent to ``len(self.atoms)``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get another :class:`ResidueGroup` identical to this one.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of residues in ResidueGroup. Equivalent to ``len(self)``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get sorted SegmentGroup of the (unique) segments represented in the</span>
<span class="sd">        ResidueGroup.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segindices</span><span class="p">)]</span>

    <span class="nd">@segments</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="c1"># Can set with Seg, SegGroup or list/tuple of Seg</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">Segment</span><span class="p">):</span>
            <span class="n">s_ix</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="n">new</span><span class="o">.</span><span class="n">segindex</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">):</span>
            <span class="n">s_ix</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">segindices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">s_ix</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">segindex</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only set ResidueGroup residues to Segment &quot;</span>
                                <span class="s2">&quot;or ResidueGroup not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new</span>
                                              <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Segment</span><span class="p">))</span>
                                <span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s_ix</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_ix</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incorrect size: </span><span class="si">{}</span><span class="s2"> for ResidueGroup of size: </span><span class="si">{}</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="c1"># Optimisation TODO:</span>
        <span class="c1"># This currently rebuilds the tt len(self) times</span>
        <span class="c1"># Ideally all changes would happen and *afterwards* tables are built</span>
        <span class="c1"># Alternatively, if the changes didn&#39;t rebuild table, this list</span>
        <span class="c1"># comprehension isn&#39;t terrible.</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_ix</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">move_residue</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of unique segments represented in the ResidueGroup.</span>

<span class="sd">        Equivalent to ``len(self.segments)``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a ResidueGroup containing sorted and unique residues only.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">           &gt;&gt;&gt; rg = u.residues[[2, 1, 2, 2, 1, 0]]</span>
<span class="sd">           &gt;&gt;&gt; rg</span>
<span class="sd">           &lt;ResidueGroup with 6 residues&gt;</span>
<span class="sd">           &gt;&gt;&gt; rg.ix</span>
<span class="sd">           array([2, 1, 2, 2, 1, 0])</span>
<span class="sd">           &gt;&gt;&gt; rg2 = rg.unique</span>
<span class="sd">           &gt;&gt;&gt; rg2</span>
<span class="sd">           &lt;ResidueGroup with 3 residues&gt;</span>
<span class="sd">           &gt;&gt;&gt; rg2.ix</span>
<span class="sd">           array([0, 1, 2])</span>

<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)]</span></div>


<div class="viewcode-block" id="SegmentGroup"><a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.SegmentGroup">[docs]</a><span class="k">class</span> <span class="nc">SegmentGroup</span><span class="p">(</span><span class="n">GroupBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;SegmentGroup base class.</span>

<span class="sd">    This class is used by a Universe for generating its Topology-specific</span>
<span class="sd">    SegmentGroup class. All the TopologyAttr components are obtained from</span>
<span class="sd">    GroupBase, so this class only includes ad-hoc methods specific to</span>
<span class="sd">    SegmentGroups.</span>

<span class="sd">    SegmentGroups can be compared and combined using group operators. See the</span>
<span class="sd">    list of these operators on :class:`GroupBase`.</span>

<span class="sd">    .. deprecated:: 0.16.2</span>
<span class="sd">       *Instant selectors* of Segments will be removed in the 1.0 release.</span>
<span class="sd">       See :ref:`Instant selectors &lt;instance-selectors&gt;` for details and alternatives.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an AtomGroup of atoms represented in this SegmentGroup.</span>

<span class="sd">        The atoms are ordered locally by residue, which are further ordered by</span>
<span class="sd">        segment in the SegmentGroup. No duplicates are removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of atoms represented in SegmentGroup, including duplicate</span>
<span class="sd">        segments.</span>

<span class="sd">        Equivalent to ``len(self.atoms)``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a ResidueGroup of residues represented in this SegmentGroup.</span>

<span class="sd">        The residues are ordered locally by segment in the SegmentGroup.</span>
<span class="sd">        No duplicates are removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resindices</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of residues represented in SegmentGroup, including duplicate</span>
<span class="sd">        segments.</span>

<span class="sd">        Equivalent to ``len(self.residues)``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get another SegmentGroup identical to this one.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of segments in SegmentGroup. Equivalent to ``len(self)``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a SegmentGroup containing sorted and unique segments only.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">           &gt;&gt;&gt; sg = u.segments[[2, 1, 2, 2, 1, 0]]</span>
<span class="sd">           &gt;&gt;&gt; sg</span>
<span class="sd">           &lt;SegmentGroup with 6 segments&gt;</span>
<span class="sd">           &gt;&gt;&gt; sg.ix</span>
<span class="sd">           array([2, 1, 2, 2, 1, 0])</span>
<span class="sd">           &gt;&gt;&gt; sg2 = sg.unique</span>
<span class="sd">           &gt;&gt;&gt; sg2</span>
<span class="sd">           &lt;SegmentGroup with 3 segments&gt;</span>
<span class="sd">           &gt;&gt;&gt; sg2.ix</span>
<span class="sd">           array([0, 1, 2])</span>

<span class="sd">        .. versionadded:: 0.16.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)]</span></div>


<span class="nd">@functools</span><span class="o">.</span><span class="n">total_ordering</span>
<span class="k">class</span> <span class="nc">ComponentBase</span><span class="p">(</span><span class="n">_MutableBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class from which a Universe&#39;s Component class is built.</span>

<span class="sd">    Components are the individual objects that are found in Groups.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># index of component</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span> <span class="o">=</span> <span class="n">ix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">u</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t compare different level objects&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">ix</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t compare different level objects&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">ix</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenate the Component with another Component or Group of the</span>
<span class="sd">        same level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Component or Group</span>
<span class="sd">            Component or Group with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with elements of `self` and `other` concatenated</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">plural</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ix_array</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Using built-in sum requires supporting 0 + self. If other is</span>
<span class="sd">        anything other 0, an exception will be raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : int</span>
<span class="sd">            Other should be 0, or else an exception will be raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>
<span class="sd">            Group with elements of `self` reproduced</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">plural</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unsupported operand type(s) for +:&quot;</span>
                            <span class="s2">&quot; &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unique index of this component.</span>

<span class="sd">        If this component is an Atom, this is the index of the atom.</span>
<span class="sd">        If it is a Residue, this is the index of the residue.</span>
<span class="sd">        If it is a Segment, this is the index of the segment.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ix_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unique index of this component as an array.</span>

<span class="sd">        This method gives a consistent API between components and groups.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>


<div class="viewcode-block" id="Atom"><a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.Atom">[docs]</a><span class="k">class</span> <span class="nc">Atom</span><span class="p">(</span><span class="n">ComponentBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Atom base class.</span>

<span class="sd">    This class is used by a Universe for generating its Topology-specific Atom</span>
<span class="sd">    class. All the TopologyAttr components are obtained from ComponentBase, so</span>
<span class="sd">    this class only includes ad-hoc methods specific to Atoms.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try and catch known attributes and give better error message&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;fragment&#39;</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Atom has no fragment data, this requires Bonds&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2"> has no attribute </span><span class="si">{attr}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">me</span> <span class="o">=</span> <span class="s1">&#39;&lt;Atom </span><span class="si">{}</span><span class="s1">:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; of type </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;resname&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; of resname </span><span class="si">{}</span><span class="s1">,&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;resid&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; resid </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;segid&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; and segid </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segid</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;altLoc&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; and altLoc </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">altLoc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">me</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">residue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">resindices</span><span class="p">[</span><span class="bp">self</span><span class="p">]]</span>

    <span class="nd">@residue</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">residue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">Residue</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Can only set Atom residue to Residue, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">new</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">move_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">new</span><span class="o">.</span><span class="n">resindex</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">segindices</span><span class="p">[</span><span class="bp">self</span><span class="p">]]</span>

    <span class="nd">@segment</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot set atom segment.  &quot;</span>
                                  <span class="s2">&quot;Segments are assigned to Residues&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coordinates of the atom.</span>

<span class="sd">        The position can be changed by assigning an array of length (3,).</span>

<span class="sd">        .. note:: changing the position is not reflected in any files; reading any</span>
<span class="sd">                  frame from the trajectory will replace the change with that</span>
<span class="sd">                  from the file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@position</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Velocity of the atom.</span>

<span class="sd">        The velocity can be changed by assigning an array of shape (3,).</span>

<span class="sd">        .. note:: changing the velocity is not reflected in any files; reading any</span>
<span class="sd">                  frame from the trajectory will replace the change with that</span>
<span class="sd">                  from the file</span>

<span class="sd">        A :exc:`~MDAnalysis.NoDataError` is raised if the trajectory</span>
<span class="sd">        does not contain velocities.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ts</span><span class="o">.</span><span class="n">velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Timestep does not contain velocities&quot;</span><span class="p">)</span>

    <span class="nd">@velocity</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Timestep does not contain velocities&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">force</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Force on the atom.</span>

<span class="sd">        The force can be changed by assigning an array of shape (3,).</span>

<span class="sd">        .. note:: changing the force is not reflected in any files; reading any</span>
<span class="sd">                  frame from the trajectory will replace the change with that</span>
<span class="sd">                  from the file</span>

<span class="sd">        A :exc:`~MDAnalysis.NoDataError` is raised if the trajectory</span>
<span class="sd">        does not contain forces.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ts</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Timestep does not contain forces&quot;</span><span class="p">)</span>

    <span class="nd">@force</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Timestep does not contain forces&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Residue"><a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.Residue">[docs]</a><span class="k">class</span> <span class="nc">Residue</span><span class="p">(</span><span class="n">ComponentBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Residue base class.</span>

<span class="sd">    This class is used by a Universe for generating its Topology-specific</span>
<span class="sd">    Residue class. All the TopologyAttr components are obtained from</span>
<span class="sd">    ComponentBase, so this class only includes ad-hoc methods specific to</span>
<span class="sd">    Residues.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">me</span> <span class="o">=</span> <span class="s1">&#39;&lt;Residue&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;resname&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">,&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;resid&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">me</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">self</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">segindices</span><span class="p">[</span><span class="bp">self</span><span class="p">]]</span>

    <span class="nd">@segment</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">Segment</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Can only set Residue segment to Segment, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">new</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">move_residue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">new</span><span class="o">.</span><span class="n">segindex</span><span class="p">)</span></div>


<div class="viewcode-block" id="Segment"><a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.Segment">[docs]</a><span class="k">class</span> <span class="nc">Segment</span><span class="p">(</span><span class="n">ComponentBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Segment base class.</span>

<span class="sd">    This class is used by a Universe for generating its Topology-specific</span>
<span class="sd">    Segment class. All the TopologyAttr components are obtained from</span>
<span class="sd">    ComponentBase, so this class only includes ad-hoc methods specific to</span>
<span class="sd">    Segments.</span>

<span class="sd">    .. deprecated:: 0.16.2</span>
<span class="sd">       *Instant selectors* of Segments will be removed in the 1.0 release.</span>
<span class="sd">       See :ref:`Instant selectors &lt;instance-selectors&gt;` for details and alternatives.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">me</span> <span class="o">=</span> <span class="s1">&#39;&lt;Segment&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;segid&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">me</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">self</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">resindices</span><span class="p">[</span><span class="bp">self</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="c1"># DEPRECATED in 0.16.2</span>
        <span class="c1"># REMOVE in 1.0</span>
        <span class="c1">#</span>
        <span class="c1"># Segment.r1 access</span>
        <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">resnum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">rg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">resnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># convert to 0 based</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Instant selectors Segment.r&lt;N&gt; will be removed in 1.0. &quot;</span>
                          <span class="s2">&quot;Use Segment.residues[N-1] instead.&quot;</span><span class="p">,</span>
                          <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rg</span>
        <span class="c1"># Resname accesss</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">,</span> <span class="s1">&#39;resnames&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">_get_named_residue</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2"> has no attribute </span><span class="si">{attr}</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">))</span></div>

<span class="c1"># Accessing these attrs doesn&#39;t trigger an update. The class and instance</span>
<span class="c1"># methods of UpdatingAtomGroup that are used during __init__ must all be</span>
<span class="c1"># here, otherwise we get __getattribute__ infinite loops.</span>
<span class="n">_UAG_SHORTCUT_ATTRS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># Class information of the UAG</span>
    <span class="s2">&quot;__class__&quot;</span><span class="p">,</span> <span class="s2">&quot;_derived_class&quot;</span><span class="p">,</span>
    <span class="c1"># Metadata of the UAG</span>
    <span class="s2">&quot;_base_group&quot;</span><span class="p">,</span> <span class="s2">&quot;_selections&quot;</span><span class="p">,</span> <span class="s2">&quot;_lastupdate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="s2">&quot;_u&quot;</span><span class="p">,</span> <span class="s2">&quot;universe&quot;</span><span class="p">,</span>
    <span class="c1"># Methods of the UAG</span>
    <span class="s2">&quot;_ensure_updated&quot;</span><span class="p">,</span>
    <span class="s2">&quot;is_uptodate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;update_selection&quot;</span><span class="p">,</span>
<span class="p">}</span>

<div class="viewcode-block" id="UpdatingAtomGroup"><a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.UpdatingAtomGroup">[docs]</a><span class="k">class</span> <span class="nc">UpdatingAtomGroup</span><span class="p">(</span><span class="n">AtomGroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;:class:`AtomGroup` subclass that dynamically updates its selected atoms.</span>

<span class="sd">    Accessing any attribute/method of an :class:`UpdatingAtomGroup` instance</span>
<span class="sd">    triggers a check for the last frame the group was updated. If the last</span>
<span class="sd">    frame matches the current trajectory frame, the attribute is returned</span>
<span class="sd">    normally; otherwise the group is updated (the stored selections are</span>
<span class="sd">    re-applied), and only then is the attribute returned.</span>

<span class="sd">    .. versionadded:: 0.16.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># WARNING: This class has __getattribute__ and __getattr__ methods (the</span>
    <span class="c1"># latter inherited from AtomGroup). Because of this bugs introduced in the</span>
    <span class="c1"># class that cause an AttributeError may be very hard to diagnose and</span>
    <span class="c1"># debug: the most obvious symptom is an infinite loop going through both</span>
    <span class="c1"># __getattribute__ and __getattr__, and a solution might be to add said</span>
    <span class="c1"># attribute to _UAG_SHORTCUT_ATTRS.</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_group</span><span class="p">,</span> <span class="n">selections</span><span class="p">,</span> <span class="n">strings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base_group : :class:`AtomGroup`</span>
<span class="sd">            group on which *selections* are to be applied.</span>
<span class="sd">        selections : a tuple of :class:`~MDAnalysis.core.selection.Selection`</span>
<span class="sd">            instances selections ready to be applied to *base_group*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Because we&#39;re implementing __getattribute__, which needs _u for</span>
        <span class="c1"># its check, no self.attribute access can be made before this line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">base_group</span><span class="o">.</span><span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selections</span> <span class="o">=</span> <span class="n">selections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selection_strings</span> <span class="o">=</span> <span class="n">strings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_group</span> <span class="o">=</span> <span class="n">base_group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lastupdate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span> <span class="o">=</span> <span class="n">base_group</span><span class="o">.</span><span class="n">_derived_class</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selections</span><span class="p">:</span>
            <span class="c1"># Allows the creation of a cheap placeholder UpdatingAtomGroup</span>
            <span class="c1"># by passing an empty selection tuple.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_updated</span><span class="p">()</span>

<div class="viewcode-block" id="UpdatingAtomGroup.update_selection"><a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.UpdatingAtomGroup.update_selection">[docs]</a>    <span class="k">def</span> <span class="nf">update_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forces the reevaluation and application of the group&#39;s selection(s).</span>

<span class="sd">        This method is triggered automatically when accessing attributes, if</span>
<span class="sd">        the last update occurred under a different trajectory frame.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_group</span>
        <span class="n">sels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selections</span>
        <span class="k">if</span> <span class="n">sels</span><span class="p">:</span>
            <span class="c1"># As with select_atoms, we select the first sel and then sum to it.</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">sel</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">bg</span><span class="p">)</span> <span class="k">for</span> <span class="n">sel</span> <span class="ow">in</span> <span class="n">sels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]],</span>
                     <span class="n">sels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">bg</span><span class="p">))</span><span class="o">.</span><span class="n">ix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="c1"># Run back through AtomGroup init with this information to remake ourselves</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UpdatingAtomGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_uptodate</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_uptodate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the selection needs updating based on frame number only.</span>

<span class="sd">        Modifications to the coordinate data that render selections stale are</span>
<span class="sd">        not caught, and in those cases :attr:`is_uptodate` may return an</span>
<span class="sd">        erroneous value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            `True` if the group&#39;s selection is up-to-date, `False` otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">frame</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lastupdate</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># self.universe has no trajectory</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lastupdate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@is_uptodate</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">is_uptodate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lastupdate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">frame</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># self.universe has no trajectory</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lastupdate</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This always marks the selection as outdated</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lastupdate</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_ensure_updated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the selection needs updating and updates it, if needed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            `True` if the group was already up-to-date, `False` otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uptodate</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">status</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">status</span>

    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># ALL attribute access goes through here</span>
        <span class="c1"># If the requested attribute is public (not starting with &#39;_&#39;) and</span>
        <span class="c1"># isn&#39;t in the shortcut list, update ourselves</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_UAG_SHORTCUT_ATTRS</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_updated</span><span class="p">()</span>
        <span class="c1"># Going via object.__getattribute__ then bypasses this check stage</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># strategy for unpickling is:</span>
        <span class="c1"># - unpickle base group</span>
        <span class="c1"># - recreate UAG as created through select_atoms (basegroup and selstrs)</span>
        <span class="c1"># even if base_group is a UAG this will work through recursion</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_unpickle_uag</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_group</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selections</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection_strings</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">basestr</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">UpdatingAtomGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection_strings</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">basestr</span>
        <span class="n">sels</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;&#39; + &#39;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_selection_strings</span><span class="p">))</span>
        <span class="c1"># Cheap comparison. Might fail for corner cases but this is</span>
        <span class="c1"># mostly cosmetic.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_group</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">basegrp</span> <span class="o">=</span> <span class="s2">&quot;the entire Universe.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">basegrp</span> <span class="o">=</span> <span class="s2">&quot;another AtomGroup.&quot;</span>
        <span class="c1"># With a shorthand to conditionally append the &#39;s&#39; in &#39;selections&#39;.</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">, with selection</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> on </span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basestr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s2">&quot;s&quot;</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_selection_strings</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:],</span> <span class="n">sels</span><span class="p">,</span> <span class="n">basegrp</span><span class="p">)</span></div>

<span class="c1"># Define relationships between these classes</span>
<span class="c1"># with Level objects</span>
<span class="n">_Level</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Level&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;singular&#39;</span><span class="p">,</span> <span class="s1">&#39;plural&#39;</span><span class="p">])</span>
<span class="n">ATOMLEVEL</span> <span class="o">=</span> <span class="n">_Level</span><span class="p">(</span><span class="s1">&#39;atom&#39;</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)</span>
<span class="n">RESIDUELEVEL</span> <span class="o">=</span> <span class="n">_Level</span><span class="p">(</span><span class="s1">&#39;residue&#39;</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">)</span>
<span class="n">SEGMENTLEVEL</span> <span class="o">=</span> <span class="n">_Level</span><span class="p">(</span><span class="s1">&#39;segment&#39;</span><span class="p">,</span> <span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)</span>

<span class="n">Atom</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">ATOMLEVEL</span>
<span class="n">AtomGroup</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">ATOMLEVEL</span>
<span class="n">Residue</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">RESIDUELEVEL</span>
<span class="n">ResidueGroup</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">RESIDUELEVEL</span>
<span class="n">Segment</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">SEGMENTLEVEL</span>
<span class="n">SegmentGroup</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">SEGMENTLEVEL</span>

<span class="k">def</span> <span class="nf">requires</span><span class="p">(</span><span class="o">*</span><span class="n">attrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator to check if all AtomGroup arguments have certain attributes</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    When used to wrap a function, will check all AtomGroup arguments for the</span>
<span class="sd">    listed requirements</span>

<span class="sd">    @requires(&#39;masses&#39;, &#39;charges&#39;)</span>
<span class="sd">    def mass_times_charge(atomgroup):</span>
<span class="sd">        return atomgroup.masses * atomgroup.charges</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">require_dec</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">check_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>  <span class="c1"># for each argument</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">):</span>
                    <span class="c1"># Make list of missing attributes</span>
                    <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span>
                               <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">attr</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{funcname}</span><span class="s2"> failed. &quot;</span>
                            <span class="s2">&quot;AtomGroup is missing the following required &quot;</span>
                            <span class="s2">&quot;attributes: </span><span class="si">{attrs}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">funcname</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                <span class="n">attrs</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">check_args</span>
    <span class="k">return</span> <span class="n">require_dec</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logos/mdanalysis-logo-200x150.png" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=MDAnalysis&repo=mdanalysis&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections_modules.html">7. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/auxiliary_modules.html">8. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/core_modules.html">9. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/visualization_modules.html">10. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/lib_modules.html">11. Library functions  <code class="docutils literal"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/version.html">12. Version information for MDAnalysis - <code class="docutils literal"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/units.html">13. Constants and unit conversion  <code class="docutils literal"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/exceptions.html">14. Custom exceptions and warnings  <code class="docutils literal"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/references.html">15. References</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2005-2017, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Shobhit Agarwal, Balasubramanian, Utkarsh Bansal, Jonathan Barnoud, Tone Bengtsen, Alejandro Bernardin, Mateusz Bieniek, Wouter Boomsma, Jose Borreguero, Bart Bruininks, Sbastien Buchoux, Sren von Blow, David Caplan, Matthieu Chavent, Kathleen Clark, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Benjamin Hall, Eugen Hruska, Kyle J. Huston, Joe Jordan, Jon Kapla, Navya Khare, Andrew William King, Max Linke, Jinju Lu, Micaela Matta, Robert McGibbon, Manuel Nuno Melo, Dominik 'Rathann' Mierzejewski, Fiona Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Nabarun Pal, Mattia F. Palermo, Danny Parton, Joshua L. Phillips, Vedant Rathore, Tyler Reddy, Paul Rigor, Carlos Yanez S., Utkarsh Saxena, Sean L. Seyler, Andy Somogyi, Caio S. Souza, Shantanu Srivastava, Lukas Stelzl, Gorman Stock, Ayush Suhane, Matteo Tiberti, Isaac Virshup, Nestor Wendt, Zhiyi Wu, Zhuyi Xue, Juan Eiros Zamora, Johannes Zeman, and Oliver Beckstein.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.7</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    
    <a href="https://github.com/MDAnalysis/mdanalysis" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>