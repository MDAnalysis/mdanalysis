

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>MDAnalysis.analysis.hbonds.wbridge_analysis &mdash; MDAnalysis 0.20.2-dev0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../../_static/mdanalysis-logo.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.20.2-dev0 documentation"
          href="../../../../_static/opensearch.xml"/>

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="../../../../index.html">
          

          
            
            <img src="../../../../_static/mdanalysis-logo-thin.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.20
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/converters.html">7. Converter modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/trajectory_transformations.html">8. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/selections_modules.html">9. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/auxiliary_modules.html">10. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/core_modules.html">11. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/visualization_modules.html">12. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/lib_modules.html">13. Library functions — <code class="docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/version.html">14. Version information for MDAnalysis - <code class="docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/units.html">15. Constants and unit conversion — <code class="docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/exceptions.html">16. Custom exceptions and warnings — <code class="docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/references.html">17. References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MDAnalysis</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>MDAnalysis.analysis.hbonds.wbridge_analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for MDAnalysis.analysis.hbonds.wbridge_analysis</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1"># doi: 10.25080/majora-629e541a-00e</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="c1"># Water Bridge Analysis</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;Water Bridge analysis --- :mod:`MDAnalysis.analysis.hbonds.WaterBridgeAnalysis`</span>
<span class="sd">===============================================================================</span>

<span class="sd">:Author: Zhiyi Wu</span>
<span class="sd">:Year: 2017-2018</span>
<span class="sd">:Copyright: GNU Public License v3</span>
<span class="sd">:Maintainer: Zhiyi Wu &lt;zhiyi.wu@gtc.ox.ac.uk&gt;,  `@xiki-tempula`_ on GitHub</span>


<span class="sd">.. _`@xiki-tempula`: https://github.com/xiki-tempula</span>


<span class="sd">Given a :class:`~MDAnalysis.core.universe.Universe` (simulation</span>
<span class="sd">trajectory with 1 or more frames) measure all water bridges for each</span>
<span class="sd">frame between selections 1 and 2.</span>
<span class="sd">Water bridge is defined as a bridging water which simultaneously forms</span>
<span class="sd">two hydrogen bonds with atoms from both selection 1 and selection 2.</span>

<span class="sd">A water bridge can form between two hydrogen bond acceptors.</span>

<span class="sd">e.g. -CO\ :sub:`2`\ :sup:`-`:···H−O−H···:\ :sup:`-`\ O\ :sub:`2`\ C-</span>

<span class="sd">A water bridge can also form between two hydrogen bond donors.</span>

<span class="sd">e.g. -NH···:O:···HN- (where O is the oxygen of a bridging water)</span>

<span class="sd">A hydrogen bond acceptor and another hydrogen bond donor can be bridged by a</span>
<span class="sd">water.</span>

<span class="sd">e.g. -CO\ :sub:`2`\ :sup:`-`:···H−O:···HN- (where H−O is part of **H−O**\ −H)</span>

<span class="sd">A higher order water bridge is defined as more than one water bridging</span>
<span class="sd">hydrogen bond acceptor and donor. An example of a second order water bridge:</span>

<span class="sd">e.g. -CO\ :sub:`2`\ :sup:`-`:···H−O:···H−O:···HN- (where H−O is part of **H−O**\ −H)</span>

<span class="sd">The following keyword arguments are important to control the behaviour of the</span>
<span class="sd">water bridge analysis:</span>

<span class="sd"> - *water_selection* (``resname SOL``): the selection string for the bridging</span>
<span class="sd">   water</span>
<span class="sd"> - *order* the maximum number of water bridging both ends</span>
<span class="sd"> - donor-acceptor *distance* (Å): 3.0</span>
<span class="sd"> - Angle *cutoff* (degrees): 120.0</span>
<span class="sd"> - *forcefield* to switch between default values for different force fields</span>
<span class="sd"> - *donors* and *acceptors* atom types (to add additional atom names)</span>

<span class="sd">Theory</span>
<span class="sd">------</span>

<span class="sd">This module attempts to find multi-order water bridge by an approach similar</span>
<span class="sd">to breadth-first search, where the first solvation shell of selection 1 is</span>
<span class="sd">selected, followed by the selection of the second solvation shell as well as</span>
<span class="sd">any hydrogen bonding partner from selection 1. After that, the third solvation</span>
<span class="sd">shell, as well as any binding partners from selection 2, are detected. This</span>
<span class="sd">process is repeated until the maximum order of water bridges is reached.</span>

<span class="sd">.. _wb_Analysis_Network:</span>

<span class="sd">Output as Network</span>
<span class="sd">-----------------</span>

<span class="sd">Since the waters connecting the two ends of the selections are by nature a network.</span>
<span class="sd">We provide a network representation of the water network. Water bridge data are</span>
<span class="sd">returned per frame, which is stored in :attr:`WaterBridgeAnalysis.network`. Each</span>
<span class="sd">frame is represented as a dictionary, where the keys are the hydrogen bonds</span>
<span class="sd">originating from selection 1 and the values are new dictionaries representing</span>
<span class="sd">the hydrogen bonds coming out of the corresponding molecules making hydrogen bonds</span>
<span class="sd">with selection 1.</span>

<span class="sd">As for the hydrogen bonds which reach the selection 2, the values of the</span>
<span class="sd">corresponding keys are None. One example where selection 1 and selection 2 are</span>
<span class="sd">joined by one water molecule (A) which also hydrogen bond to another water (B)</span>
<span class="sd">which also hydrogen bond to selection 2 would be represented as ::</span>

<span class="sd">    # (selection 1)-O:···H-O(water 1):···H-(selection 2)</span>
<span class="sd">    #                      |             :</span>
<span class="sd">    #                      H·············O-H(water2)</span>
<span class="sd">    #                                    H</span>
<span class="sd">    {(sele1_acceptor, None, water1_donor, water1_donor_heavy, distance, angle):</span>
<span class="sd">         {(water1_acceptor, None, sele2_donor, sele2_donor_heavy, distance, angle): None},</span>
<span class="sd">         {(water1_donor, water1_donor_heavy, water2_acceptor, None, distance, angle):</span>
<span class="sd">              {(water2_acceptor, None, sele2_donor, sele2_donor_heavy, distance, angle): None}</span>
<span class="sd">          },</span>
<span class="sd">    }</span>

<span class="sd">The atoms are represented by atom index and if the atom is hydrogen bond donor,</span>
<span class="sd">it is followed by the index of the corresponding heavy atom</span>
<span class="sd">``(donor_proton, donor_heavy_atom)``.</span>
<span class="sd">If the atom is a hydrogen bond acceptor, it is followed by none.</span>

<span class="sd">.. _wb_Analysis_Timeseries:</span>

<span class="sd">Output as Timeseries</span>
<span class="sd">--------------------</span>

<span class="sd">For lower order water bridges, it might be desirable to represent the connections as</span>
<span class="sd">:attr:`WaterBridgeAnalysis.timeseries`. The results are returned per frame and</span>
<span class="sd">are a list of hydrogen bonds between the selection 1 or selection 2 and the</span>
<span class="sd">bridging waters. Due to the complexity of the higher order water bridge and the</span>
<span class="sd">fact that one hydrogen bond between two waters can appear in both third and</span>
<span class="sd">fourth order water bridge, the hydrogen bonds in the</span>
<span class="sd">:attr:`WaterBridgeAnalysis.timeseries` attribute are generated in a depth-first</span>
<span class="sd">search manner to avoid duplication. Example code of how</span>
<span class="sd">:attr:`WaterBridgeAnalysis.timeseries` is generated::</span>

<span class="sd">    def network2timeseries(network, timeseries):</span>
<span class="sd">        &#39;&#39;&#39;Traverse the network in a depth-first fashion.</span>
<span class="sd">        expand_timeseries will expand the compact representation to the familiar</span>
<span class="sd">        timeseries representation.&#39;&#39;&#39;</span>

<span class="sd">        if network is None:</span>
<span class="sd">            return</span>
<span class="sd">        else:</span>
<span class="sd">            for node in network:</span>
<span class="sd">                timeseries.append(expand_timeseries(node))</span>
<span class="sd">                network2timeseries(network[node], timeseries)</span>

<span class="sd">    timeseries = []</span>
<span class="sd">    network2timeseries(network, timeseries)</span>

<span class="sd">The list is formatted similar to the \ :attr:`HydrogenBondAnalysis.timeseries</span>
<span class="sd">&lt;MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.timeseries&gt;`</span>
<span class="sd">except that the atom identifier is expressed as (residue name, residue number,</span>
<span class="sd">atom name). An example would be. ::</span>

<span class="sd">    results = [</span>
<span class="sd">        [ # frame 1</span>
<span class="sd">           [ &lt;donor index&gt;, &lt;acceptor index&gt;,</span>
<span class="sd">            (&lt;donor residue name&gt;, &lt;donor residue number&gt;, &lt;donor atom name&gt;),</span>
<span class="sd">            (&lt;acceptor residue name&gt;, &lt;acceptor residue number&gt;, &lt;acceptor atom name&gt;),</span>
<span class="sd">             &lt;distance&gt;, &lt;angle&gt;],</span>
<span class="sd">           ....</span>
<span class="sd">        ],</span>
<span class="sd">        [ # frame 2</span>
<span class="sd">          [ ... ], [ ... ], ...</span>
<span class="sd">        ],</span>
<span class="sd">        ...</span>
<span class="sd">    ]</span>

<span class="sd">Using the :meth:`WaterBridgeAnalysis.generate_table` method one can reformat</span>
<span class="sd">the results as a flat &quot;normalised&quot; table that is easier to import into a</span>
<span class="sd">database or dataframe for further processing.</span>

<span class="sd">Detection of water bridges</span>
<span class="sd">--------------------------</span>
<span class="sd">Water bridges are recorded if a bridging water simultaneously forms</span>
<span class="sd">hydrogen bonds with selection 1 and selection 2.</span>

<span class="sd">Hydrogen bonds are detected as is described in \</span>
<span class="sd">:class:`~MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis`, see \</span>
<span class="sd">:ref:`Detection-of-hydrogen-bonds`.</span>

<span class="sd">The lists of donor and acceptor names can be extended by providing lists of</span>
<span class="sd">atom names in the `donors` and `acceptors` keywords to</span>
<span class="sd">:class:`WaterBridgeAnalysis`. If the lists are entirely inappropriate</span>
<span class="sd">(e.g. when analysing simulations done with a force field that uses very</span>
<span class="sd">different atom names) then one should either use the value &quot;other&quot; for</span>
<span class="sd">`forcefield` to set no default values or derive a new class and set the</span>
<span class="sd">default list oneself::</span>

<span class="sd"> class WaterBridgeAnalysis_OtherFF(WaterBridgeAnalysis):</span>
<span class="sd">       DEFAULT_DONORS = {&quot;OtherFF&quot;: tuple(set([...]))}</span>
<span class="sd">       DEFAULT_ACCEPTORS = {&quot;OtherFF&quot;: tuple(set([...]))}</span>

<span class="sd">Then simply use the new class instead of the parent class and call it with</span>
<span class="sd">```forcefield` = &quot;OtherFF&quot;``. Please also consider contributing the list of heavy</span>
<span class="sd">atom names to MDAnalysis.</span>

<span class="sd">How to perform WaterBridgeAnalysis</span>
<span class="sd">----------------------------------</span>

<span class="sd">All water bridges between arginine and aspartic acid can be analysed with ::</span>

<span class="sd">  import MDAnalysis</span>
<span class="sd">  import MDAnalysis.analysis.hbonds</span>

<span class="sd">  u = MDAnalysis.Universe(&#39;topology&#39;, &#39;trajectory&#39;)</span>
<span class="sd">  w = MDAnalysis.analysis.hbonds.WaterBridgeAnalysis(u, &#39;resname ARG&#39;, &#39;resname ASP&#39;)</span>
<span class="sd">  w.run()</span>

<span class="sd">The maximum number of bridging waters detected can be changed using the order keyword. ::</span>

<span class="sd">  w = MDAnalysis.analysis.hbonds.WaterBridgeAnalysis(u, &#39;resname ARG&#39;, &#39;resname ASP&#39;,</span>
<span class="sd">                                                     order=3)</span>

<span class="sd">Thus, a maximum of three bridging waters will be detected.</span>

<span class="sd">An example of using the :attr:`~WaterBridgeAnalysis` would be</span>
<span class="sd">detecting the percentage of time a certain water bridge exits.</span>

<span class="sd">Trajectory :code:`u` has two frames, where the first frame contains a water</span>
<span class="sd">bridge from the oxygen of the first arginine to one of the oxygens in the carboxylic</span>
<span class="sd">group of aspartate (ASP3:OD1). In the second frame, the same water bridge forms but</span>
<span class="sd">is between the oxygen of the arginine and the other oxygen in the carboxylic</span>
<span class="sd">group (ASP3:OD2). ::</span>

<span class="sd">  # index residue id residue name atom name</span>
<span class="sd">  #     0          1          ARG         O</span>
<span class="sd">  #     1          2          SOL        OW</span>
<span class="sd">  #     2          2          SOL       HW1</span>
<span class="sd">  #     3          2          SOL       HW2</span>
<span class="sd">  #     4          3          ASP       OD1</span>
<span class="sd">  #     5          3          ASP       OD2</span>
<span class="sd">  print(w.timeseries)</span>

<span class="sd">prints out. ::</span>

<span class="sd">  [ # frame 1</span>
<span class="sd">    # A water bridge SOL2 links O from ARG1 to the carboxylic group OD1 of ASP3</span>
<span class="sd">   [[0,2,(&#39;ARG&#39;,1,  &#39;O&#39;),(&#39;SOL&#39;,2,&#39;HW1&#39;),  3.0,180],</span>
<span class="sd">    [3,4,(&#39;SOL&#39;,2,&#39;HW2&#39;),(&#39;ASP&#39;,3,&#39;OD1&#39;),  3.0,180],</span>
<span class="sd">   ],</span>
<span class="sd">    # frame 2</span>
<span class="sd">    # Another water bridge SOL2 links O from ARG1 to the other oxygen of the</span>
<span class="sd">    # carboxylic group OD2 of ASP3</span>
<span class="sd">   [[0,2,(&#39;ARG&#39;,1,  &#39;O&#39;),(&#39;SOL&#39;,2,&#39;HW1&#39;),  3.0,180],</span>
<span class="sd">    [3,5,(&#39;SOL&#39;,2,&#39;HW2&#39;),(&#39;ASP&#39;,3,&#39;OD2&#39;),  3.0,180],</span>
<span class="sd">   ],</span>
<span class="sd">  ]</span>


<span class="sd">.. _wb_count_by_type:</span>

<span class="sd">Use count_by_type</span>
<span class="sd">-----------------</span>

<span class="sd">We can use the :meth:`~WaterBridgeAnalysis.count_by_type` to</span>
<span class="sd">generate the frequence of all water bridges in the simulation. ::</span>

<span class="sd">  w.count_by_type()</span>

<span class="sd">Returns ::</span>

<span class="sd">  [(0, 3, &#39;ARG&#39;, 1, &#39;O&#39;, &#39;ASP&#39;, 3, &#39;OD1&#39;, 0.5),</span>
<span class="sd">   (0, 4, &#39;ARG&#39;, 1, &#39;O&#39;, &#39;ASP&#39;, 3, &#39;OD2&#39;, 0.5),]</span>

<span class="sd">You might think that the OD1 and OD2 are the same oxygen and the aspartate has just flipped</span>
<span class="sd">and thus, they should be counted as the same type of water bridge. The type of the water</span>
<span class="sd">bridge can be customised by supplying an analysis function to</span>
<span class="sd">:meth:`~WaterBridgeAnalysis.count_by_type`.</span>

<span class="sd">The analysis function has two parameters. The current and the output. The current is a list</span>
<span class="sd">of hydrogen bonds from selection 1 to selection 2, formatted in the same fashion as</span>
<span class="sd">:attr:`WaterBridgeAnalysis.network`, and an example will be ::</span>

<span class="sd">  [ # sele1 acceptor idx,     , water donor index, donor heavy atom idx, dist, ang.</span>
<span class="sd">   [                   0, None,                 2,                     1, 3.0,180],</span>
<span class="sd">    # water donor idx, donor heavy atom idx, sele2 acceptor idx, distance, angle.</span>
<span class="sd">   [                 3,                   1,                  4, None, 3.0,180],]</span>

<span class="sd">Where ``current[0]`` is the first hydrogen bond originating from selection 1 and ``current[-1]`` is</span>
<span class="sd">the final hydrogen bond ending in selection 2. The output sums up all the information in the</span>
<span class="sd">current frame and is a dictionary with a user-defined key and the value is the weight of the</span>
<span class="sd">corresponding key. During the analysis phase, the function analysis iterates through all the</span>
<span class="sd">water bridges and modify the output in-place. At the end of the analysis, the keys from</span>
<span class="sd">all the frames are collected and the corresponding values will be summed up and returned. ::</span>

<span class="sd">  def analysis(current, output, u):</span>
<span class="sd">      r&#39;&#39;&#39;This function defines how the type of water bridge should be specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current : list</span>
<span class="sd">            The current water bridge being analysed is a list of hydrogen bonds from</span>
<span class="sd">            selection 1 to selection 2.</span>
<span class="sd">        output : dict</span>
<span class="sd">            A dictionary which is modified in-place where the key is the type of</span>
<span class="sd">            the water bridge and the value is the weight of this type of water bridge.</span>
<span class="sd">        u : MDAnalysis.universe</span>
<span class="sd">            The current Universe for looking up atoms.&#39;&#39;&#39;</span>

<span class="sd">      # decompose the first hydrogen bond.</span>
<span class="sd">      sele1_index, sele1_heavy_index, atom2, heavy_atom2, dist, angle = current[0]</span>
<span class="sd">      # decompose the last hydrogen bond.</span>
<span class="sd">      atom1, heavy_atom1, sele2_index, sele2_heavy_index, dist, angle = current[-1]</span>
<span class="sd">      # expand the atom index to the resname, resid, atom names</span>
<span class="sd">      sele1 = u.atoms[sele1_index]</span>
<span class="sd">      sele2 = u.atoms[sele2_index]</span>
<span class="sd">      (s1_resname, s1_resid, s1_name) = (sele1.resname, sele1.resid, sele1.name)</span>
<span class="sd">      (s2_resname, s2_resid, s2_name) = (sele2.resname, sele2.resid, sele2.name)</span>
<span class="sd">      # if the residue name is ASP and the atom name is OD2 or OD1,</span>
<span class="sd">      # the atom name is changed to OD</span>
<span class="sd">      if s2_resname == &#39;ASP&#39; and (s2_name == &#39;OD1&#39; or s2_name == &#39;OD2&#39;):</span>
<span class="sd">          s2_name = &#39;OD&#39;</span>
<span class="sd">      # setting up the key which defines this type of water bridge.</span>
<span class="sd">      key = (s1_resname, s1_resid, s1_name, s2_resname, s2_resid, s2_name)</span>
<span class="sd">      # The number of this type of water bridge is incremented by 1.</span>
<span class="sd">      output[key] += 1</span>

<span class="sd">  w.count_by_type(analysis_func=analysis)</span>

<span class="sd">Returns ::</span>

<span class="sd">  [((&#39;ARG&#39;, 1, &#39;O&#39;, &#39;ASP&#39;, 3, &#39;OD&#39;), 1.0),]</span>

<span class="sd">Note that the result is arranged in the format of ``(key, the proportion of time)``. When no</span>
<span class="sd">custom analysis function is supplied, the key is expanded for backward compatibility. So</span>
<span class="sd">that when the same code is executed, the result returned will be the same as the result</span>
<span class="sd">given since version 0.17.0 and the same as the</span>
<span class="sd">:meth:`HydrogenBondAnalysis.count_by_type`.</span>

<span class="sd">Some people might only interested in contacts between residues and pay no attention</span>
<span class="sd">to the details regarding the atom name. However, since multiple water bridges can</span>
<span class="sd">exist between two residues, which sometimes can give a result such that the water</span>
<span class="sd">bridge between two residues exists 300% of the time. Though this might be a desirable</span>
<span class="sd">result for some people, others might want the water bridge between two residues to be</span>
<span class="sd">only counted once per frame. This can also be achieved by supplying an analysis function</span>
<span class="sd">to :meth:`~WaterBridgeAnalysis.count_by_type`. ::</span>

<span class="sd">  def analysis(current, output, u):</span>
<span class="sd">      &#39;&#39;&#39;This function defines how the type of water bridge should be specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current : list</span>
<span class="sd">            The current water bridge being analysed is a list of hydrogen bonds from</span>
<span class="sd">            selection 1 to selection 2.</span>
<span class="sd">        output : dict</span>
<span class="sd">            A dictionary which is modified in-place where the key is the type of</span>
<span class="sd">            the water bridge and the value is the weight of this type of water bridge.</span>
<span class="sd">        u : MDAnalysis.universe</span>
<span class="sd">            The current Universe for looking up atoms.</span>
<span class="sd">      &#39;&#39;&#39;</span>

<span class="sd">      # decompose the first hydrogen bond.</span>
<span class="sd">      sele1_index, sele1_heavy_index, atom2, heavy_atom2, dist, angle = current[0]</span>
<span class="sd">      # decompose the last hydrogen bond.</span>
<span class="sd">      atom1, heavy_atom1, sele2_index, sele2_heavy_index, dist, angle = current[-1]</span>
<span class="sd">      # expand the atom index to the resname, resid, atom names</span>
<span class="sd">      sele1 = u.atoms[sele1_index]</span>
<span class="sd">      sele2 = u.atoms[sele2_index]</span>
<span class="sd">      (s1_resname, s1_resid, s1_name) = (sele1.resname, sele1.resid, sele1.name)</span>
<span class="sd">      (s2_resname, s2_resid, s2_name) = (sele2.resname, sele2.resid, sele2.name)</span>
<span class="sd">      # s1_name and s2_name are not included in the key</span>
<span class="sd">      key = (s1_resname, s1_resid, s2_resname, s2_resid)</span>

<span class="sd">      # Each residue is only counted once per frame</span>
<span class="sd">      output[key] = 1</span>

<span class="sd">  w.count_by_type(analysis_func=analysis)</span>

<span class="sd">Returns ::</span>

<span class="sd">  [((&#39;ARG&#39;, 1, &#39;ASP&#39;, 3), 1.0),]</span>

<span class="sd">On the other hand, other people may insist that the first order and second-order water</span>
<span class="sd">bridges shouldn&#39;t be mixed together, which can also be achieved by supplying an analysis</span>
<span class="sd">function to :meth:`~WaterBridgeAnalysis.count_by_type`.  ::</span>

<span class="sd">  def analysis(current, output, u):</span>
<span class="sd">      &#39;&#39;&#39;This function defines how the type of water bridge should be specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current : list</span>
<span class="sd">            The current water bridge being analysed is a list of hydrogen bonds from</span>
<span class="sd">            selection 1 to selection 2.</span>
<span class="sd">        output : dict</span>
<span class="sd">            A dictionary which is modified in-place where the key is the type of</span>
<span class="sd">            the water bridge and the value is the weight of this type of water bridge.</span>
<span class="sd">        u : MDAnalysis.universe</span>
<span class="sd">            The current Universe for looking up atoms.</span>
<span class="sd">      &#39;&#39;&#39;</span>

<span class="sd">      # decompose the first hydrogen bond.</span>
<span class="sd">      sele1_index, sele1_heavy_index, atom2, heavy_atom2, dist, angle = current[0]</span>
<span class="sd">      # decompose the last hydrogen bond.</span>
<span class="sd">      atom1, heavy_atom1, sele2_index, sele2_heavy_index, dist, angle = current[-1]</span>
<span class="sd">      # expand the atom index to the resname, resid, atom names</span>
<span class="sd">      sele1 = u.atoms[sele1_index]</span>
<span class="sd">      sele2 = u.atoms[sele2_index]</span>
<span class="sd">      (s1_resname, s1_resid, s1_name) = (sele1.resname, sele1.resid, sele1.name)</span>
<span class="sd">      (s2_resname, s2_resid, s2_name) = (sele2.resname, sele2.resid, sele2.name)</span>
<span class="sd">      # order of the current water bridge is computed</span>
<span class="sd">      order_of_water_bridge = len(current) - 1</span>
<span class="sd">      # and is included in the key</span>
<span class="sd">      key = (s1_resname, s1_resid, s2_resname, s2_resid, order_of_water_bridge)</span>
<span class="sd">      # The number of this type of water bridge is incremented by 1.</span>
<span class="sd">      output[key] += 1</span>

<span class="sd">  w.count_by_type(analysis_func=analysis)</span>

<span class="sd">The extra number 1 precede the 1.0 indicate that this is a first order water bridge ::</span>

<span class="sd">  [((&#39;ARG&#39;, 1, &#39;ASP&#39;, 3, 1), 1.0),]</span>

<span class="sd">Some people might not be interested in the interactions related to arginine. The undesirable</span>
<span class="sd">interactions can be discarded by supplying an analysis function to</span>
<span class="sd">:meth:`~WaterBridgeAnalysis.count_by_type`.  ::</span>

<span class="sd">  def analysis(current, output, u):</span>
<span class="sd">      &#39;&#39;&#39;This function defines how the type of water bridge should be specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current : list</span>
<span class="sd">            The current water bridge being analysed is a list of hydrogen bonds from</span>
<span class="sd">            selection 1 to selection 2.</span>
<span class="sd">        output : dict</span>
<span class="sd">            A dictionary which is modified in-place where the key is the type of</span>
<span class="sd">            the water bridge and the value is the number of this type of water bridge.</span>
<span class="sd">        u : MDAnalysis.universe</span>
<span class="sd">            The current Universe for looking up atoms.</span>
<span class="sd">      &#39;&#39;&#39;</span>

<span class="sd">      # decompose the first hydrogen bond.</span>
<span class="sd">      sele1_index, sele1_heavy_index, atom2, heavy_atom2, dist, angle = current[0]</span>
<span class="sd">      # decompose the last hydrogen bond.</span>
<span class="sd">      atom1, heavy_atom1, sele2_index, sele2_heavy_index, dist, angle = current[-1]</span>
<span class="sd">      # expand the atom index to the resname, resid, atom names</span>
<span class="sd">      sele1 = u.atoms[sele1_index]</span>
<span class="sd">      sele2 = u.atoms[sele2_index]</span>
<span class="sd">      (s1_resname, s1_resid, s1_name) = (sele1.resname, sele1.resid, sele1.name)</span>
<span class="sd">      (s2_resname, s2_resid, s2_name) = (sele2.resname, sele2.resid, sele2.name)</span>
<span class="sd">      if not s1_resname == &#39;ARG&#39;:</span>
<span class="sd">          key = (s1_resname, s1_resid, s2_resname, s2_resid)</span>
<span class="sd">          output[key] += 1</span>

<span class="sd">  w.count_by_type(analysis_func=analysis)</span>

<span class="sd">Returns nothing in this case ::</span>

<span class="sd">  [,]</span>

<span class="sd">Additional keywords can be supplied to the analysis function by passing through</span>
<span class="sd">:meth:`~WaterBridgeAnalysis.count_by_type`.  ::</span>

<span class="sd">  def analysis(current, output, **kwargs):</span>
<span class="sd">      ...</span>
<span class="sd">  w.count_by_type(analysis_func=analysis, **kwargs)</span>


<span class="sd">.. _wb_count_by_time:</span>

<span class="sd">Use count_by_time</span>
<span class="sd">-----------------</span>

<span class="sd">:meth:`~WaterBridgeAnalysis.count_by_type` aggregates data across frames, which</span>
<span class="sd">might be desirable in some cases but not the others. :meth:`~WaterBridgeAnalysis.count_by_time`</span>
<span class="sd">provides additional functionality for aggregating results for each frame.</span>

<span class="sd">The default behaviour of :meth:`~WaterBridgeAnalysis.count_by_time` is counting the number of</span>
<span class="sd">water bridges from selection 1 to selection 2 for each frame. Take the previous ASP, ARG salt</span>
<span class="sd">bridge for example:  ::</span>

<span class="sd">  w.count_by_time()</span>

<span class="sd">As one water bridge is found in both frames, the method returns ::</span>

<span class="sd">  [(1.0, 1), (2.0, 1), ]</span>

<span class="sd">Similar to :meth:`~WaterBridgeAnalysis.count_by_type`</span>
<span class="sd">The behaviour of :meth:`~WaterBridgeAnalysis.count_by_time` can also be modified by supplying</span>
<span class="sd">an analysis function.</span>

<span class="sd">Suppose we want to count</span>

<span class="sd">  - the **number** of water molecules involved in bridging selection 1 to selection 2.</span>
<span class="sd">  - only if water bridge terminates in atom name **OD1 of ASP**.</span>
<span class="sd">  - only when water bridge is joined by less than **two** water.</span>

<span class="sd">The analysis function can be written as::</span>

<span class="sd">  def analysis(current, output, u, **kwargs):</span>
<span class="sd">      &#39;&#39;&#39;This function defines how the counting of water bridge should be specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current : list</span>
<span class="sd">            The current water bridge being analysed is a list of hydrogen bonds from</span>
<span class="sd">            selection 1 to selection 2.</span>
<span class="sd">        output : dict</span>
<span class="sd">            A dictionary which is modified in-place where the key is the type of</span>
<span class="sd">            the water bridge and the value is the number of this type of water bridge.</span>
<span class="sd">        u : MDAnalysis.universe</span>
<span class="sd">            The current Universe for looking up atoms.</span>
<span class="sd">      &#39;&#39;&#39;</span>

<span class="sd">      # decompose the first hydrogen bond.</span>
<span class="sd">      sele1_index, sele1_heavy_index, atom2, heavy_atom2, dist, angle = current[0]</span>
<span class="sd">      # decompose the last hydrogen bond.</span>
<span class="sd">      atom1, heavy_atom1, sele2_index, sele2_heavy_index, dist, angle = current[-1]</span>
<span class="sd">      # expand the atom index to the resname, resid, atom names</span>
<span class="sd">      sele1 = u.atoms[sele1_index]</span>
<span class="sd">      sele2 = u.atoms[sele2_index]</span>
<span class="sd">      (s1_resname, s1_resid, s1_name) = (sele1.resname, sele1.resid, sele1.name)</span>
<span class="sd">      (s2_resname, s2_resid, s2_name) = (sele2.resname, sele2.resid, sele2.name)</span>

<span class="sd">      # only the residue name is ASP and the atom name is OD1,</span>
<span class="sd">      if s2_resname == &#39;ASP&#39; and s2_name == &#39;OD1&#39;:</span>
<span class="sd">          # only if the order of water bridge is less than 2</span>
<span class="sd">          if len(current) -1 &lt; 2:</span>
<span class="sd">              # extract all water molecules involved in the water bridge</span>
<span class="sd">              # extract the first water from selection 1</span>
<span class="sd">              s1_index, to_index, (s1_resname, s1_resid, s1_name),</span>
<span class="sd">              (to_resname, to_resid, to_name), dist, angle = current[0]</span>
<span class="sd">              key = (to_resname, to_resid)</span>
<span class="sd">              output[key] = 1</span>

<span class="sd">              # extract all the waters between selection 1 and selection 2</span>
<span class="sd">              for hbond in current[1:-1]:</span>
<span class="sd">                  # decompose the hydrogen bond.</span>
<span class="sd">                  from_index, to_index, (from_resname, from_resid, from_name),</span>
<span class="sd">                  (to_resname, to_resid, to_name), dist, angle = hbond</span>
<span class="sd">                  # add first water</span>
<span class="sd">                  key1 = (from_resname, from_resid)</span>
<span class="sd">                  output[key1] = 1</span>
<span class="sd">                  # add second water</span>
<span class="sd">                  key2 = (to_resname, to_resid)</span>
<span class="sd">                  output[key2] = 1</span>

<span class="sd">              # extract the last water to selection 2</span>
<span class="sd">              from_index, s2_index, (from_resname, from_resid, from_name),</span>
<span class="sd">              (s2_resname, s2_resid, s2_name), dist, angle = current[-1]</span>
<span class="sd">              key = (from_resname, from_resid)</span>
<span class="sd">              output[key] = 1</span>

<span class="sd">  w.count_by_time(analysis_func=analysis)</span>

<span class="sd">Returns ::</span>

<span class="sd">  [(1.0, 1), (2.0, 0),]</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>

<span class="sd">.. autoclass:: WaterBridgeAnalysis</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: timesteps</span>

<span class="sd">      List of the times of each timestep. This can be used together with</span>
<span class="sd">      :attr:`~WaterBridgeAnalysis.timeseries` to find the specific time point</span>
<span class="sd">      of a water bridge existence.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">..base</span> <span class="kn">import</span> <span class="n">AnalysisBase</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.NeighborSearch</span> <span class="kn">import</span> <span class="n">AtomNeighborSearch</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.distances</span> <span class="kn">import</span> <span class="n">capped_distance</span><span class="p">,</span> <span class="n">calc_angles</span>
<span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">NoDataError</span><span class="p">,</span> <span class="n">MissingDataWarning</span><span class="p">,</span> <span class="n">SelectionError</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib</span> <span class="kn">import</span> <span class="n">distances</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;MDAnalysis.analysis.WaterBridgeAnalysis&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="WaterBridgeAnalysis"><a class="viewcode-back" href="../../../../documentation_pages/analysis/wbridge_analysis.html#MDAnalysis.analysis.hbonds.wbridge_analysis.WaterBridgeAnalysis">[docs]</a><span class="k">class</span> <span class="nc">WaterBridgeAnalysis</span><span class="p">(</span><span class="n">AnalysisBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a water bridge analysis</span>

<span class="sd">    The analysis of the trajectory is performed with the</span>
<span class="sd">    :meth:`WaterBridgeAnalysis.run` method. The result is stored in</span>
<span class="sd">    :attr:`WaterBridgeAnalysis.timeseries`. See</span>
<span class="sd">    :meth:`~WaterBridgeAnalysis.run` for the format.</span>

<span class="sd">    :class:`WaterBridgeAnalysis` uses the same default atom names as</span>
<span class="sd">    :class:`~MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis`,</span>
<span class="sd">    see :ref:`Default atom names for hydrogen bonding analysis`</span>


<span class="sd">    .. versionadded:: 0.17.0</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># use tuple(set()) here so that one can just copy&amp;paste names from the</span>
    <span class="c1"># table; set() takes care for removing duplicates. At the end the</span>
    <span class="c1"># DEFAULT_DONORS and DEFAULT_ACCEPTORS should simply be tuples.</span>

    <span class="c1">#: default heavy atom names whose hydrogens are treated as *donors*</span>
    <span class="c1">#: (see :ref:`Default atom names for hydrogen bonding analysis`);</span>
    <span class="c1">#: use the keyword `donors` to add a list of additional donor names.</span>
    <span class="n">DEFAULT_DONORS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;CHARMM27&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span>
            <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;OH2&#39;</span><span class="p">,</span> <span class="s1">&#39;OW&#39;</span><span class="p">,</span> <span class="s1">&#39;NE&#39;</span><span class="p">,</span> <span class="s1">&#39;NH1&#39;</span><span class="p">,</span> <span class="s1">&#39;NH2&#39;</span><span class="p">,</span> <span class="s1">&#39;ND2&#39;</span><span class="p">,</span> <span class="s1">&#39;SG&#39;</span><span class="p">,</span> <span class="s1">&#39;NE2&#39;</span><span class="p">,</span> <span class="s1">&#39;ND1&#39;</span><span class="p">,</span>
            <span class="s1">&#39;NZ&#39;</span><span class="p">,</span> <span class="s1">&#39;OG&#39;</span><span class="p">,</span> <span class="s1">&#39;OG1&#39;</span><span class="p">,</span> <span class="s1">&#39;NE1&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">])),</span>
        <span class="s1">&#39;GLYCAM06&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;NT&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">,</span> <span class="s1">&#39;OW&#39;</span><span class="p">])),</span>
        <span class="s1">&#39;other&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([]))}</span>

    <span class="c1">#: default atom names that are treated as hydrogen *acceptors*</span>
    <span class="c1">#: (see :ref:`Default atom names for hydrogen bonding analysis`);</span>
    <span class="c1">#: use the keyword `acceptors` to add a list of additional acceptor names.</span>
    <span class="n">DEFAULT_ACCEPTORS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;CHARMM27&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span>
            <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;OC1&#39;</span><span class="p">,</span> <span class="s1">&#39;OC2&#39;</span><span class="p">,</span> <span class="s1">&#39;OH2&#39;</span><span class="p">,</span> <span class="s1">&#39;OW&#39;</span><span class="p">,</span> <span class="s1">&#39;OD1&#39;</span><span class="p">,</span> <span class="s1">&#39;OD2&#39;</span><span class="p">,</span> <span class="s1">&#39;SG&#39;</span><span class="p">,</span> <span class="s1">&#39;OE1&#39;</span><span class="p">,</span> <span class="s1">&#39;OE1&#39;</span><span class="p">,</span>
            <span class="s1">&#39;OE2&#39;</span><span class="p">,</span> <span class="s1">&#39;ND1&#39;</span><span class="p">,</span> <span class="s1">&#39;NE2&#39;</span><span class="p">,</span> <span class="s1">&#39;SD&#39;</span><span class="p">,</span> <span class="s1">&#39;OG&#39;</span><span class="p">,</span> <span class="s1">&#39;OG1&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">])),</span>
        <span class="s1">&#39;GLYCAM06&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;NT&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;O2&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">,</span> <span class="s1">&#39;OS&#39;</span><span class="p">,</span> <span class="s1">&#39;OW&#39;</span><span class="p">,</span> <span class="s1">&#39;OY&#39;</span><span class="p">,</span> <span class="s1">&#39;SM&#39;</span><span class="p">])),</span>
        <span class="s1">&#39;other&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([]))}</span>

    <span class="c1">#: A :class:`collections.defaultdict` of covalent radii of common donors</span>
    <span class="c1">#: (used in :meth`_get_bonded_hydrogens_list` to check if a hydrogen is</span>
    <span class="c1">#: sufficiently close to its donor heavy atom). Values are stored for</span>
    <span class="c1">#: N, O, P, and S. Any other heavy atoms are assumed to have hydrogens</span>
    <span class="c1">#: covalently bound at a maximum distance of 1.5 Å.</span>
    <span class="n">r_cov</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">,</span>  <span class="c1"># default value</span>
                        <span class="n">N</span><span class="o">=</span><span class="mf">1.31</span><span class="p">,</span> <span class="n">O</span><span class="o">=</span><span class="mf">1.31</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="mf">1.58</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="mf">1.55</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="n">selection1</span><span class="o">=</span><span class="s1">&#39;protein&#39;</span><span class="p">,</span>
                 <span class="n">selection2</span><span class="o">=</span><span class="s1">&#39;not resname SOL&#39;</span><span class="p">,</span> <span class="n">water_selection</span><span class="o">=</span><span class="s1">&#39;resname SOL&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">selection1_type</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">update_selection</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">update_water_selection</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">filter_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">distance_type</span><span class="o">=</span><span class="s1">&#39;hydrogen&#39;</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
                 <span class="n">angle</span><span class="o">=</span><span class="mf">120.0</span><span class="p">,</span> <span class="n">forcefield</span><span class="o">=</span><span class="s1">&#39;CHARMM27&#39;</span><span class="p">,</span> <span class="n">donors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">acceptors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="s2">&quot;sele1_sele2&quot;</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set up the calculation of water bridges between two selections in a</span>
<span class="sd">        universe.</span>

<span class="sd">        The timeseries is accessible as the attribute</span>
<span class="sd">        :attr:`WaterBridgeAnalysis.timeseries`.</span>

<span class="sd">        If no hydrogen bonds are detected or if the initial check fails, look</span>
<span class="sd">        at the log output (enable with :func:`MDAnalysis.start_logging` and set</span>
<span class="sd">        `verbose` ``=True``). It is likely that the default names for donors</span>
<span class="sd">        and acceptors are not suitable (especially for non-standard</span>
<span class="sd">        ligands). In this case, either change the `forcefield` or use</span>
<span class="sd">        customized `donors` and/or `acceptors`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        universe : Universe</span>
<span class="sd">            Universe object</span>
<span class="sd">        selection1 : str (optional)</span>
<span class="sd">            Selection string for first selection [&#39;protein&#39;]</span>
<span class="sd">        selection2 : str (optional)</span>
<span class="sd">            Selection string for second selection [&#39;not resname SOL&#39;]</span>
<span class="sd">            This string selects everything except water where water is assumed</span>
<span class="sd">            to have a residue name as SOL.</span>
<span class="sd">        water_selection : str (optional)</span>
<span class="sd">            Selection string for bridging water selection [&#39;resname SOL&#39;]</span>
<span class="sd">            The default selection assumes that the water molecules have residue</span>
<span class="sd">            name &quot;SOL&quot;. Change it to the appropriate selection for your</span>
<span class="sd">            specific force field.</span>

<span class="sd">            However, in theory, this selection can be anything which forms</span>
<span class="sd">            a hydrogen bond with selection 1 and selection 2.</span>
<span class="sd">        order : int (optional)</span>
<span class="sd">            The maximum number of water bridges linking both selections.</span>
<span class="sd">            if the order is set to 3, then all the residues linked with less than</span>
<span class="sd">            three water molecules will be detected. [1]</span>

<span class="sd">            Computation of high order water bridges can be very time-consuming.</span>
<span class="sd">            Think carefully before running the calculation, do you really want</span>
<span class="sd">            to compute the 20th order water bridge between domain A and domain B</span>
<span class="sd">            or you just want to know the third order water bridge between two residues.</span>
<span class="sd">        selection1_type : {&quot;donor&quot;, &quot;acceptor&quot;, &quot;both&quot;} (optional)</span>
<span class="sd">            Selection 1 can be &#39;donor&#39;, &#39;acceptor&#39; or &#39;both&#39;. Note that the</span>
<span class="sd">            value for `selection1_type` automatically determines how</span>
<span class="sd">            `selection2` handles donors and acceptors: If `selection1` contains</span>
<span class="sd">            &#39;both&#39; then `selection2` will also contain &#39;both&#39;. If `selection1`</span>
<span class="sd">            is set to &#39;donor&#39; then `selection2` is &#39;acceptor&#39; (and vice versa).</span>
<span class="sd">            [&#39;both&#39;].</span>
<span class="sd">        update_selection : bool (optional)</span>
<span class="sd">            Update selection 1 and 2 at each frame. Setting to ``True`` if the</span>
<span class="sd">            selection is not static. Selections are filtered first to speed up</span>
<span class="sd">            performance. Thus, setting to ``True`` is recommended if contact</span>
<span class="sd">            surface between selection 1 and selection 2 is constantly</span>
<span class="sd">            changing. [``False``]</span>
<span class="sd">        update_water_selection : bool (optional)</span>
<span class="sd">            Update selection of water at each frame. Setting to ``False`` is</span>
<span class="sd">            **only** recommended when the total amount of water molecules in the</span>
<span class="sd">            simulation are small and when water molecules remain static across</span>
<span class="sd">            the simulation.</span>

<span class="sd">            However, in normal simulations, only a tiny proportion of water is</span>
<span class="sd">            engaged in the formation of water bridge. It is recommended to</span>
<span class="sd">            update the water selection and set keyword `filter_first` to</span>
<span class="sd">            ``True`` so as to filter out water not residing between the two</span>
<span class="sd">            selections. [``True``]</span>
<span class="sd">        filter_first : bool (optional)</span>
<span class="sd">            Filter the water selection to only include water within 4 Å + `order` *</span>
<span class="sd">            (2 Å + `distance`) away from `both` selection 1 and selection 2.</span>
<span class="sd">            Selection 1 and selection 2 are both filtered to only include atoms</span>
<span class="sd">            with the same distance away from the other selection. [``True``]</span>
<span class="sd">        distance : float (optional)</span>
<span class="sd">            Distance cutoff for hydrogen bonds; only interactions with a H-A</span>
<span class="sd">            distance &lt;= `distance` (and the appropriate D-H-A angle, see</span>
<span class="sd">            `angle`) are recorded. (Note: `distance_type` can change this to</span>
<span class="sd">            the D-A distance.) [3.0]</span>
<span class="sd">        angle : float (optional)</span>
<span class="sd">            Angle cutoff for hydrogen bonds; an ideal H-bond has an angle of</span>
<span class="sd">            180º.  A hydrogen bond is only recorded if the D-H-A angle is</span>
<span class="sd">            &gt;=  `angle`. The default of 120º also finds fairly non-specific</span>
<span class="sd">            hydrogen interactions and possibly better value is 150º. [120.0]</span>
<span class="sd">        forcefield : {&quot;CHARMM27&quot;, &quot;GLYCAM06&quot;, &quot;other&quot;} (optional)</span>
<span class="sd">            Name of the forcefield used. Switches between different</span>
<span class="sd">            :attr:`~HydrogenBondAnalysis.DEFAULT_DONORS` and</span>
<span class="sd">            :attr:`~HydrogenBondAnalysis.DEFAULT_ACCEPTORS` values.</span>
<span class="sd">            [&quot;CHARMM27&quot;]</span>
<span class="sd">        donors : sequence (optional)</span>
<span class="sd">            Extra H donor atom types (in addition to those in</span>
<span class="sd">            :attr:`~HydrogenBondAnalysis.DEFAULT_DONORS`), must be a sequence.</span>
<span class="sd">        acceptors : sequence (optional)</span>
<span class="sd">            Extra H acceptor atom types (in addition to those in</span>
<span class="sd">            :attr:`~HydrogenBondAnalysis.DEFAULT_ACCEPTORS`), must be a</span>
<span class="sd">            sequence.</span>
<span class="sd">        distance_type : {&quot;hydrogen&quot;, &quot;heavy&quot;} (optional)</span>
<span class="sd">            Measure hydrogen bond lengths between donor and acceptor heavy</span>
<span class="sd">            atoms (&quot;heavy&quot;) or between donor hydrogen and acceptor heavy</span>
<span class="sd">            atom (&quot;hydrogen&quot;). If using &quot;heavy&quot; then one should set the</span>
<span class="sd">            *distance* cutoff to a higher value such as 3.5 Å. [&quot;hydrogen&quot;]</span>
<span class="sd">        output_format: {&quot;sele1_sele2&quot;, &quot;donor_acceptor&quot;} (optional)</span>
<span class="sd">            Setting the output format for timeseries and table. If set to</span>
<span class="sd">            &quot;sele1_sele2&quot;, for each hydrogen bond, the one close to selection 1</span>
<span class="sd">            will be placed before selection 2. If set to &quot;donor_acceptor&quot;, the</span>
<span class="sd">            donor will be placed before acceptor. &quot;sele1_sele2&quot;]</span>
<span class="sd">        debug : bool (optional)</span>
<span class="sd">            If set to ``True`` enables per-frame debug logging. This is disabled</span>
<span class="sd">            by default because it generates a very large amount of output in</span>
<span class="sd">            the log file. (Note that a logger must have been started to see</span>
<span class="sd">            the output, e.g. using :func:`MDAnalysis.start_logging`.)</span>
<span class="sd">        verbose : bool (optional)</span>
<span class="sd">            Toggle progress output. (Can also be given as keyword argument to</span>
<span class="sd">            :meth:`run`.)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In order to speed up processing, atoms are filtered by a coarse</span>
<span class="sd">        distance criterion before a detailed hydrogen bonding analysis is</span>
<span class="sd">        performed (`filter_first` = ``True``).</span>

<span class="sd">        If selection 1 and selection 2 are very mobile during the simulation</span>
<span class="sd">        and the contact surface is constantly changing (i.e. residues are</span>
<span class="sd">        moving farther than 4 Å + `order` * (2 Å + `distance`)), you might</span>
<span class="sd">        consider setting the `update_selection` keywords to ``True``</span>
<span class="sd">        to ensure correctness.</span>

<span class="sd">        .. versionchanged 0.20.0</span>
<span class="sd">           The :attr:`WaterBridgeAnalysis.timeseries` has been updated</span>
<span class="sd">           see :attr:`WaterBridgeAnalysis.timeseries` for detail.</span>
<span class="sd">           This class is now based on</span>
<span class="sd">           :class:`~MDAnalysis.analysis.base.AnalysisBase`.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WaterBridgeAnalysis</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">,</span>
                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">water_selection</span> <span class="o">=</span> <span class="n">water_selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_water_selection</span> <span class="o">=</span> <span class="n">update_water_selection</span>
        <span class="c1"># per-frame debugging output?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>

        <span class="c1"># set the output format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_format</span> <span class="o">=</span> <span class="n">output_format</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection1</span> <span class="o">=</span> <span class="n">selection1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span> <span class="o">=</span> <span class="n">selection2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="o">=</span> <span class="n">selection1_type</span>

        <span class="c1"># if the selection 1 and selection 2 are the same</span>
        <span class="k">if</span> <span class="n">selection1</span> <span class="o">==</span> <span class="n">selection2</span><span class="p">:</span>
            <span class="c1"># eliminate the duplication</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="o">=</span> <span class="s2">&quot;donor&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span> <span class="o">=</span> <span class="n">update_selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_first</span> <span class="o">=</span> <span class="n">filter_first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span> <span class="o">=</span> <span class="n">distance_type</span>  <span class="c1"># note: everything except &#39;heavy&#39; will give the default behavior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>

        <span class="c1"># set up the donors/acceptors lists</span>
        <span class="k">if</span> <span class="n">donors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">donors</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">if</span> <span class="n">acceptors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">acceptors</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcefield</span> <span class="o">=</span> <span class="n">forcefield</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">donors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_DONORS</span><span class="p">[</span><span class="n">forcefield</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">donors</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_ACCEPTORS</span><span class="p">[</span><span class="n">forcefield</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">acceptors</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;HydrogenBondAnalysis: Invalid selection type </span><span class="si">{0!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_network</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># final result accessed as self.network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># time for each frame</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log_parameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_log_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Log important parameters to the logfile.&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: selection = </span><span class="si">%r</span><span class="s2"> (update: </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: water selection = </span><span class="si">%r</span><span class="s2"> (update: </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">water_selection</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_water_selection</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: criterion: donor </span><span class="si">%s</span><span class="s2"> atom and acceptor </span><span class="se">\</span>
<span class="s2">        atom distance &lt;= </span><span class="si">%.3f</span><span class="s2"> A&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: criterion: angle D-H-A &gt;= </span><span class="si">%.3f</span><span class="s2"> degrees&quot;</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: force field </span><span class="si">%s</span><span class="s2"> to guess donor and </span><span class="se">\</span>
<span class="s2">        acceptor names&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcefield</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_residue_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
        <span class="c1"># Build the residue_dict where the key is the residue name</span>
        <span class="c1"># The content is a dictionary where hydrogen bond donor heavy atom names is the key</span>
        <span class="c1"># The content is the hydrogen bond donor hydrogen atom names</span>
        <span class="n">atom_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">atom_group</span><span class="o">.</span><span class="n">residues</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">residue</span><span class="o">.</span><span class="n">resname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residue_dict</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_residue_dict</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">resname</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_residue_dict</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">resname</span><span class="p">][</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_donor_h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_ix</span><span class="p">,</span> <span class="n">h_donors</span><span class="p">,</span> <span class="n">donors_h</span><span class="p">):</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_ix</span><span class="p">]</span>
        <span class="n">residue</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span>
        <span class="n">hydrogen_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residue_dict</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">resname</span><span class="p">][</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">hydrogen_names</span><span class="p">:</span>
            <span class="n">hydrogens</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">hydrogen_names</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">:</span>
                <span class="n">h_donors</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom_ix</span>
                <span class="n">donors_h</span><span class="p">[</span><span class="n">atom_ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_h_donors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_h_donors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">)</span><span class="o">.</span><span class="n">ix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">)</span><span class="o">.</span><span class="n">ix</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_first</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s1">&#39;Size of selection 1 before filtering:&#39;</span>
                              <span class="s1">&#39; </span><span class="si">{}</span><span class="s1"> atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">)))</span>
            <span class="n">ns_selection_1</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">],</span> <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s1</span> <span class="o">=</span> <span class="n">ns_selection_1</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection_distance</span><span class="p">)</span><span class="o">.</span><span class="n">ix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Size of selection 1: </span><span class="si">{0}</span><span class="s2"> atoms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Selection 1 &quot;</span><span class="si">{0}</span><span class="s1">&quot; did not select any atoms.&#39;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">)[:</span><span class="mi">80</span><span class="p">]))</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_first</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s1">&#39;Size of selection 2 before filtering:&#39;</span>
                              <span class="s1">&#39; </span><span class="si">{}</span><span class="s1"> atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)))</span>
            <span class="n">ns_selection_2</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">],</span> <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span> <span class="o">=</span> <span class="n">ns_selection_2</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection_distance</span><span class="p">)</span><span class="o">.</span><span class="n">ix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s1">&#39;Size of selection 2: </span><span class="si">{0}</span><span class="s1"> atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Selection 2 &quot;</span><span class="si">{0}</span><span class="s1">&quot; did not select any atoms.&#39;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">)[:</span><span class="mi">80</span><span class="p">]))</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">]</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="k">for</span> <span class="n">atom_ix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_donor_h</span><span class="p">(</span><span class="n">atom_ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_h_donors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 donors: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 donor hydrogens: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_h_donors</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">]</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 acceptors: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">]</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 acceptors: </span><span class="si">{0:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">]</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="k">for</span> <span class="n">atom_ix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_donor_h</span><span class="p">(</span><span class="n">atom_ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_h_donors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 donors: </span><span class="si">{0:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 donor hydrogens: </span><span class="si">{0:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_h_donors</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_update_water_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_water_donors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_water_h_donors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_water_donors_h</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_water_acceptors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_water</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">water_selection</span><span class="p">)</span><span class="o">.</span><span class="n">ix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s1">&#39;Size of water selection before filtering:&#39;</span>
                          <span class="s1">&#39; </span><span class="si">{}</span><span class="s1"> atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_first</span><span class="p">:</span>
            <span class="n">filtered_s1</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">],</span> <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">],</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">selection_distance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">filtered_s1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_water</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="n">filtered_s1</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">],</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">selection_distance</span><span class="p">)</span><span class="o">.</span><span class="n">ix</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Size of water selection: </span><span class="si">{0}</span><span class="s2"> atoms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Water selection &#39;</span><span class="si">{0}</span><span class="s2">&#39; did not select any atoms.&quot;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">water_selection</span><span class="p">)[:</span><span class="mi">80</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_water_donors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">]</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="k">for</span> <span class="n">atom_ix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_donors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_donor_h</span><span class="p">(</span><span class="n">atom_ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_h_donors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_donors_h</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Water donors: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water_donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Water donor hydrogens: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water_h_donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_water_acceptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">]</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Water acceptors: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water_acceptors</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_get_bonded_hydrogens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find hydrogens bonded within cutoff to `atom`.</span>

<span class="sd">        Hydrogens are detected by either name (&quot;H*&quot;, &quot;[123]H*&quot;) or type (&quot;H&quot;);</span>
<span class="sd">        this is not fool-proof as the atom type is not always a character but</span>
<span class="sd">        the name pattern should catch most typical occurrences.</span>

<span class="sd">        The distance from `atom` is calculated for all hydrogens in the residue</span>
<span class="sd">        and only those within a cutoff are kept. The cutoff depends on the</span>
<span class="sd">        heavy atom (more precisely, on its element, which is taken as the first</span>
<span class="sd">        letter of its name ``atom.name[0]``) and is parameterized in</span>
<span class="sd">        :attr:`HydrogenBondAnalysis.r_cov`. If no match is found then the</span>
<span class="sd">        default of 1.5 Å is used.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : groups.Atom</span>
<span class="sd">             heavy atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hydrogen_atoms : AtomGroup or []</span>
<span class="sd">            list of hydrogens (can be a :class:`~MDAnalysis.core.groups.AtomGroup`)</span>
<span class="sd">            or empty list ``[]`` if none were found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s2">&quot;(name H* 1H* 2H* 3H* or type H) and around </span><span class="si">{0:f}</span><span class="s2"> name </span><span class="si">{1!s}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r_cov</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">NoDataError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">logger_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The distance for selection is defined as twice the maximum bond length of an O-H bond (2A)</span>
        <span class="c1"># plus order of water bridge times the length of OH bond plus hydrogne bond distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_distance</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_residue_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_residue_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_residue_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_residue_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">water_selection</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_selection</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_water_selection</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: no atoms found in the selection.&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: initial checks passed.&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: starting&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: donors    </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: acceptors </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: water bridge </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">water_selection</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Toggling debug to </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: For full step-by-step debugging output use debug=True&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting analysis (frame index start=</span><span class="si">%d</span><span class="s2"> stop=</span><span class="si">%d</span><span class="s2">, step=</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_donor2acceptor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">donors</span><span class="p">,</span> <span class="n">h_donors</span><span class="p">,</span> <span class="n">acceptor</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">donors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">acceptor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span> <span class="o">!=</span> <span class="s1">&#39;heavy&#39;</span><span class="p">:</span>
            <span class="n">donors_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">h_donors</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">donors_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">donors</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Code modified from p-j-smith</span>
        <span class="n">pairs</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="n">capped_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">donors_idx</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">acceptor</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                           <span class="n">max_cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">,</span>
                                           <span class="n">return_distances</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span> <span class="o">!=</span> <span class="s1">&#39;heavy&#39;</span><span class="p">:</span>
            <span class="n">tmp_donors</span> <span class="o">=</span> <span class="p">[</span><span class="n">h_donors</span><span class="p">[</span><span class="n">donors_idx</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">tmp_hydrogens</span> <span class="o">=</span> <span class="p">[</span><span class="n">donors_idx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">tmp_acceptors</span> <span class="o">=</span> <span class="p">[</span><span class="n">acceptor</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp_donors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">tmp_hydrogens</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">tmp_acceptors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">donors</span><span class="p">[</span><span class="n">donors_idx</span><span class="p">[</span><span class="n">pairs</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mi">0</span><span class="p">]]]:</span>
                    <span class="n">tmp_donors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">donors_idx</span><span class="p">[</span><span class="n">pairs</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">tmp_hydrogens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                    <span class="n">tmp_acceptors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">acceptor</span><span class="p">[</span><span class="n">pairs</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span>
            <span class="n">calc_angles</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">tmp_donors</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">tmp_hydrogens</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">tmp_acceptors</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">hbond_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">angles</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">hbond_indices</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">tmp_hydrogens</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">tmp_donors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">tmp_acceptors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_index</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_index</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
                       <span class="n">distances</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">angles</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_single_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ts</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_selection</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_water_selection</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_water_selection</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="n">selection_1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">water_pool</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">next_round_water</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="n">selection_2</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="c1"># check for direct hbond from s1 to s2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 Donors &lt;-&gt; Selection 2 Acceptors&quot;</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_h_donors</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> <span class="p">(</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                <span class="n">water_pool</span><span class="p">[(</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">selection_1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                <span class="n">selection_2</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 Donors &lt;-&gt; Water Acceptors&quot;</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_h_donors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_acceptors</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                    <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> <span class="p">(</span>
                    <span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="n">selection_1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Water Donors &lt;-&gt; Selection 2 Acceptors&quot;</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water_donors_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_h_donors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                    <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> <span class="p">(</span>
                    <span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="n">water_pool</span><span class="p">[(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                    <span class="n">selection_2</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 Donors &lt;-&gt; Selection 1 Acceptors&quot;</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_h_donors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> <span class="p">(</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                <span class="n">water_pool</span><span class="p">[(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">selection_1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                <span class="n">selection_2</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 Donors &lt;-&gt; Water Acceptors&quot;</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_h_donors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_acceptors</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                    <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> <span class="p">(</span>
                    <span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="n">water_pool</span><span class="p">[(</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                    <span class="n">selection_2</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">))</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 Acceptors &lt;-&gt; Water Donors&quot;</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water_donors_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_h_donors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                    <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> <span class="p">(</span>
                    <span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="n">selection_1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Water donor &lt;-&gt; Water Acceptors&quot;</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water_donors_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_h_donors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_acceptors</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> <span class="p">(</span>
                <span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                <span class="n">water_pool</span><span class="p">[(</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                <span class="n">water_pool</span><span class="p">[(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>

        <span class="c1"># solve the connectivity network</span>
        <span class="c1"># The following code attempt to generate a water network which is formed by the class dict.</span>
        <span class="c1"># Suppose we have a water bridge connection ARG1 to ASP3 via the two hydrogen bonds.</span>
        <span class="c1">#     [0,1,(&#39;ARG&#39;,1,&#39;O&#39;),  (&#39;SOL&#39;,2,&#39;HW1&#39;),  3.0,180],</span>
        <span class="c1">#     [2,3,(&#39;SOL&#39;,2,&#39;HW2&#39;),(&#39;ASP&#39;,3,&#39;OD1&#39;),  3.0,180],</span>
        <span class="c1"># The resulting network will be</span>
        <span class="c1">#{(0,1,(&#39;ARG&#39;,1,&#39;O&#39;),  (&#39;SOL&#39;,2,&#39;HW1&#39;),  3.0,180): {(2,3,(&#39;SOL&#39;,2,&#39;HW2&#39;),(&#39;ASP&#39;,3,&#39;OD1&#39;),  3.0,180): None}}</span>
        <span class="c1"># Where the key of the a dict will be all the hydrogen bonds starting from this nodes.</span>
        <span class="c1"># The corresponding value of a certain key will be a dictionary whose key will be all the hydrogen bonds from</span>
        <span class="c1"># the destination of in the key.</span>
        <span class="c1"># If the value of a certain key is None, which means it is reaching selection 2.</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;start&#39;</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">),</span> <span class="s1">&#39;water&#39;</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)}</span>

        <span class="k">def</span> <span class="nf">add_route</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">route</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">route</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">][</span><span class="n">route</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># exclude the the selection which goes back to itself</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">route</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">route</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">2</span><span class="p">])):</span>
                    <span class="k">return</span>

                <span class="c1"># selection 2 to water</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;water&#39;</span><span class="p">][</span><span class="n">route</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># water to water</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">route</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;water&#39;</span><span class="p">][</span><span class="n">route</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">route</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;water&#39;</span><span class="p">][</span><span class="n">route</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                <span class="c1"># selection 1 to water</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">][</span><span class="n">route</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">route</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;water&#39;</span><span class="p">][</span><span class="n">route</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">def</span> <span class="nf">traverse_water_network</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">route</span><span class="p">,</span> <span class="n">maxdepth</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">route</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">end</span><span class="p">:</span>
                    <span class="c1"># check if any duplication happens</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">route</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">route</span><span class="p">)):</span>
                        <span class="n">add_route</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">new_node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                        <span class="n">new_route</span> <span class="o">=</span> <span class="n">route</span><span class="p">[:]</span>
                        <span class="n">new_route</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
                        <span class="n">new_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span><span class="s1">&#39;sele1_sele2&#39;</span><span class="p">)[</span><span class="mi">3</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">traverse_water_network</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">new_node</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">new_route</span><span class="p">,</span> <span class="n">maxdepth</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">selection_1</span><span class="p">:</span>
            <span class="n">route</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="p">]</span>
            <span class="n">next_mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="s1">&#39;sele1_sele2&#39;</span><span class="p">)[</span><span class="mi">3</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">traverse_water_network</span><span class="p">(</span><span class="n">water_pool</span><span class="p">,</span> <span class="n">next_mol</span><span class="p">,</span> <span class="n">selection_2</span><span class="p">,</span> <span class="n">route</span><span class="p">[:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_traverse_water_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">analysis_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">link_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function recursively traverses the water network self._network and finds the hydrogen bonds which connect</span>
<span class="sd">        the current atom to the next atom. The newly found hydrogen bond will be appended to the hydrogen bonds</span>
<span class="sd">        connecting the selection 1 to the current atom via link_func. When selection 2 is reached, the full list of</span>
<span class="sd">        hydrogen bonds connecting the selection 1 to selection 2 will be fed into analysis_func, which will then modify</span>
<span class="sd">        the output in place.</span>
<span class="sd">        :param graph: The connection network describes the connection between the atoms in the water network.</span>
<span class="sd">        :param current: The hydrogen bonds from selection 1 until now.</span>
<span class="sd">        :param analysis_func: The analysis function which is called to analysis the hydrogen bonds.</span>
<span class="sd">        :param output: where the result is stored.</span>
<span class="sd">        :param link_func: The new hydrogen bonds will be appended to current.</span>
<span class="sd">        :param kwargs: the keywords which are passed into the analysis_func.</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">link_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If no link_func is provided, the default link_func will be used</span>
            <span class="n">link_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_link</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if selection 2 is reached</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">analysis_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># the result is analysed by analysis_func which will change the output</span>
                <span class="n">analysis_func</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># make sure no loop can occur</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
                    <span class="c1"># the new hydrogen bond will be added to the existing bonds</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">link_func</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_water_network</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">new</span><span class="p">,</span> <span class="n">analysis_func</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">link_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Expand the index into (resname, resid, name).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Expand the compact data format into the old timeseries form.</span>
<span class="sd">        The old is defined as the format for release up to 0.19.2.</span>
<span class="sd">        As is discussed in Issue #2177, the internal storage of the hydrogen</span>
<span class="sd">        bond information has been changed to the compact format.</span>
<span class="sd">        The function takes in the argument `output_format` to see which output format will be chosen.</span>
<span class="sd">        if `output_format` is not specified, the value will be taken from :attr:`output_format`.</span>
<span class="sd">        If `output_format` is &#39;sele1_sele2&#39;, the output will be the old water bridge analysis format::</span>

<span class="sd">          # donor from selection 1 to acceptor in selection 2</span>
<span class="sd">          [sele1_index, sele2_index,</span>
<span class="sd">           (sele1_resname, sele1_resid, sele1_name),</span>
<span class="sd">           (sele2_resname, sele2_resid, sele2_name), dist, angle]</span>

<span class="sd">        If `output_format` is &#39;donor_acceptor&#39;, the output will be the old hydrogen bond analysis format::</span>

<span class="sd">          # From donor to acceptor</span>
<span class="sd">          [donor_index, acceptor_index,</span>
<span class="sd">           (donor_resname, donor_resid, donor_name),</span>
<span class="sd">           (acceptor_resname, acceptor_resid, acceptor_name), dist, angle]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">output_format</span> <span class="o">=</span> <span class="n">output_format</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_format</span>
        <span class="c1"># Expand the compact entry into atom1, which is the first index in the output and atom2, which is the second</span>
        <span class="c1"># entry.</span>
        <span class="n">atom1</span><span class="p">,</span> <span class="n">heavy_atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">heavy_atom2</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">entry</span>
        <span class="k">if</span> <span class="n">output_format</span> <span class="o">==</span> <span class="s1">&#39;sele1_sele2&#39;</span><span class="p">:</span>
            <span class="c1"># If the output format is the sele1_sele2, no change will be executed</span>
            <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span> <span class="o">=</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span>
        <span class="k">elif</span> <span class="n">output_format</span> <span class="o">==</span> <span class="s1">&#39;donor_acceptor&#39;</span><span class="p">:</span>
            <span class="c1"># If the output format is donor_acceptor, use heavy atom position to check which is donor and which is</span>
            <span class="c1"># acceptor</span>
            <span class="k">if</span> <span class="n">heavy_atom1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># atom1 is hydrogen bond acceptor and thus, the position of atom1 and atom2 are swapped.</span>
                <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span> <span class="o">=</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># atom1 is hydrogen bond donor, position not swapped.</span>
                <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span> <span class="o">=</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Only &#39;sele1_sele2&#39; or &#39;donor_acceptor&#39; are allowed as output format&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_index</span><span class="p">(</span><span class="n">atom1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_index</span><span class="p">(</span><span class="n">atom2</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generate_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Time series of water bridges.</span>

<span class="sd">        The output is generated per frame as is explained in :ref:`wb_Analysis_Timeseries`.</span>
<span class="sd">        The format of output can be changed via the output_format selection.</span>
<span class="sd">        If ``output_format=&quot;sele1_sele2&quot;``, the hydrogen bond forms a directional</span>
<span class="sd">        link from selection 1 to selection 2. If ``output_format=&quot;donor_acceptor&quot;``,</span>
<span class="sd">        for each hydrogen bond, the donor is always written before the acceptor.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        To find an acceptor atom in :attr:`Universe.atoms` by</span>
<span class="sd">        *index* one would use ``u.atoms[acceptor_index]``.</span>

<span class="sd">        The :attr:`timeseries` is a managed attribute and it is generated</span>
<span class="sd">        from the underlying data in :attr:`_network` every time the</span>
<span class="sd">        attribute is accessed. It is therefore costly to call and if</span>
<span class="sd">        :attr:`timeseries` is needed repeatedly it is recommended that you</span>
<span class="sd">        assign to a variable::</span>

<span class="sd">           w = WaterBridgeAnalysis(u)</span>
<span class="sd">           w.run()</span>
<span class="sd">           timeseries = w.timeseries</span>

<span class="sd">        .. versionchanged 0.20.0</span>
<span class="sd">           The :attr:`WaterBridgeAnalysis.timeseries` has been updated where</span>
<span class="sd">           the donor and acceptor string has been changed to tuple</span>
<span class="sd">           (resname string, resid, name_string).</span>


<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">output_format</span> <span class="o">=</span> <span class="n">output_format</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_format</span>
        <span class="k">def</span> <span class="nf">analysis</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">current</span>

        <span class="n">timeseries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="p">:</span>
            <span class="n">new_frame</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_water_network</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">new_frame</span><span class="p">,</span> <span class="n">analysis_func</span><span class="o">=</span><span class="n">analysis</span><span class="p">,</span>
            <span class="n">output</span><span class="o">=</span><span class="n">new_frame</span><span class="p">,</span> <span class="n">link_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compact_link</span><span class="p">)</span>
            <span class="n">timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">output_format</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">new_frame</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">timeseries</span>

    <span class="n">timeseries</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_generate_timeseries</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_network</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Network representation of the water network.</span>

<span class="sd">        The output is generated per frame as is explained in :ref:`wb_Analysis_Network`.</span>
<span class="sd">        Each hydrogen bond has a compact representation of ::</span>

<span class="sd">          [sele1_acceptor_idx, None, sele2_donor_idx, donor_heavy_idx, distance, angle]</span>

<span class="sd">        or ::</span>

<span class="sd">          [sele1_donor_idx, donor_heavy_idx, sele1_acceptor_idx, None, distance, angle]</span>

<span class="sd">        The donor_heavy_idx is the heavy atom bonding to the proton and atoms</span>
<span class="sd">        can be retrived from the universe::</span>

<span class="sd">          atom = u.atoms[idx]</span>

<span class="sd">        .. versionadded:: 0.20.0</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network</span>

    <span class="k">def</span> <span class="nf">set_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_network</span> <span class="o">=</span> <span class="n">network</span>

    <span class="n">network</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_network</span><span class="p">,</span> <span class="n">set_network</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_full_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A function used in _traverse_water_network to add the new hydrogen bond to the existing bonds.</span>
<span class="sd">        :param output: The existing hydrogen bonds from selection 1</span>
<span class="sd">        :param node: The new hydrogen bond</span>
<span class="sd">        :return: The hydrogen bonds from selection 1 with the new hydrogen bond added</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">output</span><span class="p">[:]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_compact_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A function used in _traverse_water_network to add the new hydrogen bond to the existing bonds.</span>
<span class="sd">        In this form no new list is created and thus, one bridge will only appear once.</span>
<span class="sd">        :param output: The existing hydrogen bonds from selection 1</span>
<span class="sd">        :param node: The new hydrogen bond</span>
<span class="sd">        :return: The hydrogen bonds from selection 1 with the new hydrogen bond added</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_count_by_type_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generates the key for count_by_type analysis.</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">s1_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="p">(</span><span class="n">s1_resname</span><span class="p">,</span> <span class="n">s1_resid</span><span class="p">,</span> <span class="n">s1_name</span><span class="p">),</span> <span class="p">(</span><span class="n">to_resname</span><span class="p">,</span> <span class="n">to_resid</span><span class="p">,</span> <span class="n">to_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">from_index</span><span class="p">,</span> <span class="n">s2_index</span><span class="p">,</span> <span class="p">(</span><span class="n">from_resname</span><span class="p">,</span> <span class="n">from_resid</span><span class="p">,</span> <span class="n">from_name</span><span class="p">),</span> <span class="p">(</span><span class="n">s2_resname</span><span class="p">,</span> <span class="n">s2_resid</span><span class="p">,</span> <span class="n">s2_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1_index</span><span class="p">,</span> <span class="n">s2_index</span><span class="p">,</span> <span class="n">s1_resname</span><span class="p">,</span> <span class="n">s1_resid</span><span class="p">,</span> <span class="n">s1_name</span><span class="p">,</span> <span class="n">s2_resname</span><span class="p">,</span> <span class="n">s2_resid</span><span class="p">,</span> <span class="n">s2_name</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<div class="viewcode-block" id="WaterBridgeAnalysis.count_by_type"><a class="viewcode-back" href="../../../../documentation_pages/analysis/wbridge_analysis.html#MDAnalysis.analysis.hbonds.wbridge_analysis.WaterBridgeAnalysis.count_by_type">[docs]</a>    <span class="k">def</span> <span class="nf">count_by_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Counts the frequency of water bridge of a specific type.</span>

<span class="sd">        If one atom *A* from *selection 1* is linked to atom *B* from</span>
<span class="sd">        *selection 2* through one or more bridging waters, an entity will be created and</span>
<span class="sd">        the proportion of time that this linkage exists in the whole simulation</span>
<span class="sd">        will be calculated.</span>

<span class="sd">        The identification of a specific type of water bridge can be modified by</span>
<span class="sd">        supplying the analysis_func function. See :ref:`wb_count_by_type`</span>
<span class="sd">        for detail.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        counts : list</span>
<span class="sd">            Returns a :class:`list` containing atom indices for *A* and</span>
<span class="sd">            *B*, residue names, residue numbers, atom names (for both A and B) and</span>
<span class="sd">            the fraction of the total time during which the water bridge was</span>
<span class="sd">            detected. This method returns None if method</span>
<span class="sd">            :meth:`WaterBridgeAnalysis.run` was not executed first.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">analysis_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">analysis_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_by_type_analysis</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;combined&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="p">)</span>
            <span class="n">result_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="p">:</span>
                <span class="n">frame_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_water_network</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="p">[],</span> <span class="n">analysis_func</span><span class="o">=</span><span class="n">analysis_func</span><span class="p">,</span>
                                             <span class="n">output</span><span class="o">=</span><span class="n">frame_dict</span><span class="p">,</span>
                                             <span class="n">link_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_full_link</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">frame_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">result_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frame_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;combined&#39;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result_dict</span><span class="p">]</span>
                <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">/</span><span class="n">length</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result_dict</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="n">result_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">/</span><span class="n">length</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result_dict</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_count_by_time_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">s1_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="p">(</span><span class="n">s1_resname</span><span class="p">,</span> <span class="n">s1_resid</span><span class="p">,</span> <span class="n">s1_name</span><span class="p">),</span> <span class="p">(</span><span class="n">to_resname</span><span class="p">,</span> <span class="n">to_resid</span><span class="p">,</span> <span class="n">to_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">from_index</span><span class="p">,</span> <span class="n">s2_index</span><span class="p">,</span> <span class="p">(</span><span class="n">from_resname</span><span class="p">,</span> <span class="n">from_resid</span><span class="p">,</span> <span class="n">from_name</span><span class="p">),</span> <span class="p">(</span><span class="n">s2_resname</span><span class="p">,</span> <span class="n">s2_resid</span><span class="p">,</span> <span class="n">s2_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1_index</span><span class="p">,</span> <span class="n">s2_index</span><span class="p">,</span> <span class="n">s1_resname</span><span class="p">,</span> <span class="n">s1_resid</span><span class="p">,</span> <span class="n">s1_name</span><span class="p">,</span> <span class="n">s2_resname</span><span class="p">,</span> <span class="n">s2_resid</span><span class="p">,</span> <span class="n">s2_name</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<div class="viewcode-block" id="WaterBridgeAnalysis.count_by_time"><a class="viewcode-back" href="../../../../documentation_pages/analysis/wbridge_analysis.html#MDAnalysis.analysis.hbonds.wbridge_analysis.WaterBridgeAnalysis.count_by_time">[docs]</a>    <span class="k">def</span> <span class="nf">count_by_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Counts the number of water bridges per timestep.</span>

<span class="sd">        The counting behaviour can be adjusted by supplying analysis_func.</span>
<span class="sd">        See :ref:`wb_count_by_time` for details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        counts : list</span>
<span class="sd">             Returns a time series ``N(t)`` where ``N`` is the total</span>
<span class="sd">             number of observed water bridges at time ``t``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">analysis_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">analysis_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_by_time_analysis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="p">):</span>
                <span class="n">result_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_water_network</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="p">[],</span> <span class="n">analysis_func</span><span class="o">=</span><span class="n">analysis_func</span><span class="p">,</span>
                                             <span class="n">output</span><span class="o">=</span><span class="n">result_dict</span><span class="p">,</span>
                                             <span class="n">link_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_full_link</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="nb">sum</span><span class="p">([</span><span class="n">result_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result_dict</span><span class="p">])))</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_timesteps_by_type_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">s1_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="p">(</span><span class="n">s1_resname</span><span class="p">,</span> <span class="n">s1_resid</span><span class="p">,</span> <span class="n">s1_name</span><span class="p">),</span> <span class="p">(</span><span class="n">to_resname</span><span class="p">,</span> <span class="n">to_resid</span><span class="p">,</span> <span class="n">to_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">from_index</span><span class="p">,</span> <span class="n">s2_index</span><span class="p">,</span> <span class="p">(</span><span class="n">from_resname</span><span class="p">,</span> <span class="n">from_resid</span><span class="p">,</span> <span class="n">from_name</span><span class="p">),</span> <span class="p">(</span><span class="n">s2_resname</span><span class="p">,</span> <span class="n">s2_resid</span><span class="p">,</span> <span class="n">s2_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1_index</span><span class="p">,</span> <span class="n">s2_index</span><span class="p">,</span> <span class="n">s1_resname</span><span class="p">,</span> <span class="n">s1_resid</span><span class="p">,</span> <span class="n">s1_name</span><span class="p">,</span> <span class="n">s2_resname</span><span class="p">,</span> <span class="n">s2_resid</span><span class="p">,</span> <span class="n">s2_name</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">))</span>

<div class="viewcode-block" id="WaterBridgeAnalysis.timesteps_by_type"><a class="viewcode-back" href="../../../../documentation_pages/analysis/wbridge_analysis.html#MDAnalysis.analysis.hbonds.wbridge_analysis.WaterBridgeAnalysis.timesteps_by_type">[docs]</a>    <span class="k">def</span> <span class="nf">timesteps_by_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Frames during which each water bridges existed, sorted by each water bridges.</span>

<span class="sd">        Processes :attr:`WaterBridgeAnalysis._network` and returns a</span>
<span class="sd">        :class:`list` containing atom indices, residue names, residue</span>
<span class="sd">        numbers (from selection 1 and selection 2) and each timestep at which the</span>
<span class="sd">        water bridge was detected.</span>

<span class="sd">        Similar to :meth:`~WaterBridgeAnalysis.count_by_type` and</span>
<span class="sd">        :meth:`~WaterBridgeAnalysis.count_by_time`, the behavior can be adjusted by</span>
<span class="sd">        supplying an analysis_func.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">analysis_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">analysis_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timesteps_by_type_analysis</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;combined&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">timesteps</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">timesteps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span>
            <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">timesteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_water_network</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="p">[],</span> <span class="n">analysis_func</span><span class="o">=</span><span class="n">analysis_func</span><span class="p">,</span>
                                             <span class="n">output</span><span class="o">=</span><span class="n">result</span><span class="p">,</span>
                                             <span class="n">link_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_full_link</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">result_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">time_list</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">time_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;combined&#39;</span><span class="p">:</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                        <span class="n">key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
                        <span class="n">result_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">time</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">result_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="WaterBridgeAnalysis.generate_table"><a class="viewcode-back" href="../../../../documentation_pages/analysis/wbridge_analysis.html#MDAnalysis.analysis.hbonds.wbridge_analysis.WaterBridgeAnalysis.generate_table">[docs]</a>    <span class="k">def</span> <span class="nf">generate_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a normalised table of the results.</span>

<span class="sd">        The table is stored as a :class:`numpy.recarray` in the</span>
<span class="sd">        attribute :attr:`~WaterBridgeAnalysis.table`.</span>

<span class="sd">        The output format of :attr:`~WaterBridgeAnalysis.table` can also be</span>
<span class="sd">        changed using output_format in a fashion similar to :attr:`WaterBridgeAnalysis.timeseries`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output_format</span> <span class="o">=</span> <span class="n">output_format</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_format</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_network</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No data computed, do run() first.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">MissingDataWarning</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_timeseries</span><span class="p">(</span><span class="n">output_format</span><span class="p">)</span>

        <span class="n">num_records</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">hframe</span><span class="p">)</span> <span class="k">for</span> <span class="n">hframe</span> <span class="ow">in</span> <span class="n">timeseries</span><span class="p">])</span>
        <span class="c1"># build empty output table</span>
        <span class="k">if</span> <span class="n">output_format</span> <span class="o">==</span> <span class="s1">&#39;sele1_sele2&#39;</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;sele1_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sele2_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;sele1_resnm&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sele1_resid&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sele1_atom&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;sele2_resnm&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sele2_resid&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sele2_atom&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;angle&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">output_format</span> <span class="o">==</span> <span class="s1">&#39;donor_acceptor&#39;</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;donor_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;acceptor_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;donor_resnm&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;donor_resid&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;donor_atom&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;acceptor_resnm&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;acceptor_resid&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;acceptor_atom&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;angle&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)]</span>

        <span class="c1"># according to Lukas&#39; notes below, using a recarray at this stage is ineffective</span>
        <span class="c1"># and speedups of ~x10 can be achieved by filling a standard array, like this:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_records</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># current row</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">hframe</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span> <span class="n">timeseries</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">donor_index</span><span class="p">,</span> <span class="n">acceptor_index</span><span class="p">,</span> <span class="n">donor</span><span class="p">,</span>
                 <span class="n">acceptor</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span> <span class="ow">in</span> <span class="n">hframe</span><span class="p">:</span>
                <span class="c1"># donor|acceptor = (resname, resid, atomid)</span>
                <span class="n">out</span><span class="p">[</span><span class="n">cursor</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">donor_index</span><span class="p">,</span> <span class="n">acceptor_index</span><span class="p">)</span> <span class="o">+</span> \
                <span class="n">donor</span> <span class="o">+</span> <span class="n">acceptor</span> <span class="o">+</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
                <span class="n">cursor</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">cursor</span> <span class="o">==</span> <span class="n">num_records</span><span class="p">,</span> <span class="s2">&quot;Internal Error: Not all wb records stored&quot;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;WBridge: Stored results as table with </span><span class="si">%(num_records)d</span><span class="s2"> entries.&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2005-2020, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Shobhit Agarwal, Irfan Alibay, Anshul Angaria, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Jonathan Barnoud, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Wouter Boomsma, Jose Borreguero, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, David Caplan, Yuanyu Chang, Matthieu Chavent, Kathleen Clark, Charlie Cook, Ruggero Cortini, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Ali Ehlen, Shujie Fan, Lennard van der Feltz, Philip Fowler, Guillaume Fraux, Joseph Goose, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Benjamin Hall, Ivan Hristov, Eugen Hruska, Kyle J. Huston, Joe Jordan, Jon Kapla, Navya Khare, Andrew William King, Abhishek A. Kognole, Max Linke, Philip Loche, Jinju Lu, Hugo MacDermott-Opeskin, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Rocco Meli, Manuel Nuno Melo, Dominik &#39;Rathann&#39; Mierzejewski, Henry Mull, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Danny Parton, Joshua L. Phillips, Kashish Punjani, Michael Quevillon, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Carlos Yanez S., Utkarsh Saxena, Sean L. Seyler, Abhishek Shandilya, Shubham Sharma, Paul Smith, Andy Somogyi, Caio S. Souza, Shantanu Srivastava, Lukas Stelzl, Gorman Stock, Fenil Suchak, Ayush Suhane, Matthijs Tadema, Joao Miguel Correia Teixeira, Xiki Tempula, Matthew W. Thompson, Hao Tian, Matteo Tiberti, Isaac Virshup, Lily Wang, Nestor Wendt, Zhiyi Wu, Zhuyi Xue, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, Yuxuan Zhuang, and Oliver Beckstein

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>