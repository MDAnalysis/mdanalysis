<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MDAnalysis.analysis.psa &mdash; MDAnalysis 2.5.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/msmb.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/js/versions.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 2.5.0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="../../../index.html">
            
              <img src="../../../_static/mdanalysis-logo-thin.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2.5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/converters.html">7. Converter modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/trajectory_transformations.html">8. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections_modules.html">9. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/auxiliary_modules.html">10. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/core_modules.html">11. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/visualization_modules.html">12. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/lib_modules.html">13. Library functions — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/version.html">14. Version information for MDAnalysis - <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/units.html">15. Constants and unit conversion — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/exceptions.html">16. Custom exceptions and warnings — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/references.html">17. References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MDAnalysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">MDAnalysis.analysis.psa</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MDAnalysis.analysis.psa</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1"># doi: 10.25080/majora-629e541a-00e</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Calculating path similarity --- :mod:`MDAnalysis.analysis.psa`</span>
<span class="sd">==========================================================================</span>

<span class="sd">:Author: Sean Seyler</span>
<span class="sd">:Year: 2015</span>
<span class="sd">:Copyright: GNU Public License v3</span>

<span class="sd">.. versionadded:: 0.10.0</span>

<span class="sd">The module contains code to calculate the geometric similarity of trajectories</span>
<span class="sd">using path metrics such as the Hausdorff or Fréchet distances</span>
<span class="sd">:cite:p:`Seyler2015`. The path metrics are functions of two paths and return a</span>
<span class="sd">nonnegative number, i.e., a distance. Two paths are identical if their distance</span>
<span class="sd">is zero, and large distances indicate dissimilarity. Each path metric is a</span>
<span class="sd">function of the individual points (e.g., coordinate snapshots) that comprise</span>
<span class="sd">each path and, loosely speaking, identify the two points, one per path of a</span>
<span class="sd">pair of paths, where the paths deviate the most.  The distance between these</span>
<span class="sd">points of maximal deviation is measured by the root mean square deviation</span>
<span class="sd">(RMSD), i.e., to compute structural similarity.</span>

<span class="sd">One typically computes the pairwise similarity for an ensemble of paths to</span>
<span class="sd">produce a symmetric distance matrix, which can be clustered to, at a glance,</span>
<span class="sd">identify patterns in the trajectory data. To properly analyze a path ensemble,</span>
<span class="sd">one must select a suitable reference structure to which all paths (each</span>
<span class="sd">conformer in each path) will be universally aligned using the rotations</span>
<span class="sd">determined by the best-fit rmsds. Distances between paths and their structures</span>
<span class="sd">are then computed directly with no further alignment. This pre-processing step</span>
<span class="sd">is necessary to preserve the metric properties of the Hausdorff and Fréchet</span>
<span class="sd">metrics; using the best-fit rmsd on a pairwise basis does not generally</span>
<span class="sd">preserve the triangle inequality.</span>

<span class="sd">Note</span>
<span class="sd">----</span>
<span class="sd">The `PSAnalysisTutorial`_ outlines a typical application of PSA to</span>
<span class="sd">a set of trajectories, including doing proper alignment,</span>
<span class="sd">performing distance comparisons, and generating heat</span>
<span class="sd">map-dendrogram plots from hierarchical clustering.</span>


<span class="sd">.. Rubric:: References</span>

<span class="sd">.. bibliography::</span>
<span class="sd">    :filter: False</span>
<span class="sd">    :style: MDA</span>

<span class="sd">    Seyler2015</span>

<span class="sd">.. _`PSAnalysisTutorial`: https://github.com/Becksteinlab/PSAnalysisTutorial</span>


<span class="sd">Helper functions and variables</span>
<span class="sd">------------------------------</span>
<span class="sd">The following convenience functions are used by other functions in this module.</span>

<span class="sd">.. autofunction:: sqnorm</span>
<span class="sd">.. autofunction:: get_msd_matrix</span>
<span class="sd">.. autofunction:: get_coord_axes</span>


<span class="sd">Classes, methods, and functions</span>
<span class="sd">-------------------------------</span>

<span class="sd">.. autofunction:: get_path_metric_func</span>
<span class="sd">.. autofunction:: hausdorff</span>
<span class="sd">.. autofunction:: hausdorff_wavg</span>
<span class="sd">.. autofunction:: hausdorff_avg</span>
<span class="sd">.. autofunction:: hausdorff_neighbors</span>
<span class="sd">.. autofunction:: discrete_frechet</span>
<span class="sd">.. autofunction:: dist_mat_to_vec</span>

<span class="sd">.. autoclass:: Path</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: u_original</span>

<span class="sd">      :class:`MDAnalysis.Universe` object with a trajectory</span>

<span class="sd">   .. attribute:: u_reference</span>

<span class="sd">      :class:`MDAnalysis.Universe` object containing a reference structure</span>

<span class="sd">   .. attribute:: select</span>

<span class="sd">      string, selection for</span>
<span class="sd">      :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` to select frame</span>
<span class="sd">      from :attr:`Path.u_reference`</span>

<span class="sd">   .. attribute:: path_select</span>

<span class="sd">      string, selection for</span>
<span class="sd">      :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` to select atoms</span>
<span class="sd">      to compose :attr:`Path.path`</span>

<span class="sd">   .. attribute:: ref_frame</span>

<span class="sd">      int, frame index to select frame from :attr:`Path.u_reference`</span>

<span class="sd">   .. attribute:: u_fitted</span>

<span class="sd">      :class:`MDAnalysis.Universe` object with the fitted trajectory</span>

<span class="sd">   .. attribute:: path</span>

<span class="sd">      :class:`numpy.ndarray` object representation of the fitted trajectory</span>

<span class="sd">.. autoclass:: PSAPair</span>

<span class="sd">   .. attribute:: npaths</span>

<span class="sd">      int, total number of paths in the comparison in which *this*</span>
<span class="sd">      :class:`PSAPair` was generated</span>

<span class="sd">   .. attribute:: matrix_id</span>

<span class="sd">      (int, int), (row, column) indices of the location of *this*</span>
<span class="sd">      :class:`PSAPair` in the corresponding pairwise distance matrix</span>

<span class="sd">   .. attribute:: pair_id</span>

<span class="sd">      int, ID of *this* :class:`PSAPair` (the pair_id:math:`^\text{th}`</span>
<span class="sd">      comparison) in the distance vector corresponding to the pairwise distance</span>
<span class="sd">      matrix</span>

<span class="sd">   .. attribute:: nearest_neighbors</span>

<span class="sd">      dict, contains the nearest neighbors by frame index and the</span>
<span class="sd">      nearest neighbor distances for each path in *this* :class:`PSAPair`</span>

<span class="sd">   .. attribute:: hausdorff_pair</span>

<span class="sd">      dict, contains the frame indices of the Hausdorff pair for each path in</span>
<span class="sd">      *this* :class:`PSAPair` and the corresponding (Hausdorff) distance</span>

<span class="sd">.. autoclass:: PSAnalysis</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: universes</span>

<span class="sd">      list of :class:`MDAnalysis.Universe` objects containing trajectories</span>

<span class="sd">   .. attribute:: u_reference</span>

<span class="sd">      :class:`MDAnalysis.Universe` object containing a reference structure</span>

<span class="sd">   .. attribute:: select</span>

<span class="sd">      string, selection for</span>
<span class="sd">      :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` to select frame</span>
<span class="sd">      from :attr:`PSAnalysis.u_reference`</span>

<span class="sd">   .. attribute:: path_select</span>

<span class="sd">      string, selection for</span>
<span class="sd">      :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` to select atoms</span>
<span class="sd">      to compose :attr:`Path.path`</span>

<span class="sd">   .. attribute:: ref_frame</span>

<span class="sd">      int, frame index to select frame from :attr:`Path.u_reference`</span>

<span class="sd">   .. attribute:: paths</span>

<span class="sd">      list of :class:`numpy.ndarray` objects representing the set/ensemble of</span>
<span class="sd">      fitted trajectories</span>

<span class="sd">   .. attribute:: D</span>

<span class="sd">      :class:`numpy.ndarray` which stores the calculated distance matrix</span>


<span class="sd">.. Markup definitions</span>
<span class="sd">.. ------------------</span>
<span class="sd">..</span>
<span class="sd">.. |3Dp| replace:: :math:`N_p \times N \times 3`</span>
<span class="sd">.. |2Dp| replace:: :math:`N_p \times (3N)`</span>
<span class="sd">.. |3Dq| replace:: :math:`N_q \times N \times 3`</span>
<span class="sd">.. |2Dq| replace:: :math:`N_q \times (3N)`</span>
<span class="sd">.. |3D| replace:: :math:`N_p\times N\times 3`</span>
<span class="sd">.. |2D| replace:: :math:`N_p\times 3N`</span>
<span class="sd">.. |Np| replace:: :math:`N_p`</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numbers</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">spatial</span><span class="p">,</span> <span class="n">cluster</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">directed_hausdorff</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">import</span> <span class="nn">MDAnalysis.analysis.align</span>
<span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">NoDataError</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.util</span> <span class="kn">import</span> <span class="n">deprecate</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;MDAnalysis.analysis.psa&#39;</span><span class="p">)</span>


<span class="kn">from</span> <span class="nn">..due</span> <span class="kn">import</span> <span class="n">due</span><span class="p">,</span> <span class="n">Doi</span>

<span class="n">due</span><span class="o">.</span><span class="n">cite</span><span class="p">(</span><span class="n">Doi</span><span class="p">(</span><span class="s2">&quot;10.1371/journal.pcbi.1004568&quot;</span><span class="p">),</span>
         <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Path Similarity Analysis algorithm and implementation&quot;</span><span class="p">,</span>
         <span class="n">path</span><span class="o">=</span><span class="s2">&quot;MDAnalysis.analysis.psa&quot;</span><span class="p">,</span>
         <span class="n">cite_module</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">del</span> <span class="n">Doi</span>


<div class="viewcode-block" id="get_path_metric_func"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.get_path_metric_func">[docs]</a><span class="k">def</span> <span class="nf">get_path_metric_func</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Selects a path metric function by name.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        name of path metric</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    path_metric : function</span>
<span class="sd">        The path metric function specified by *name* (if found).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path_metrics</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;hausdorff&#39;</span> <span class="p">:</span> <span class="n">hausdorff</span><span class="p">,</span>
            <span class="s1">&#39;weighted_average_hausdorff&#39;</span> <span class="p">:</span> <span class="n">hausdorff_wavg</span><span class="p">,</span>
            <span class="s1">&#39;average_hausdorff&#39;</span> <span class="p">:</span> <span class="n">hausdorff_avg</span><span class="p">,</span>
            <span class="s1">&#39;hausdorff_neighbors&#39;</span> <span class="p">:</span> <span class="n">hausdorff_neighbors</span><span class="p">,</span>
            <span class="s1">&#39;discrete_frechet&#39;</span> <span class="p">:</span> <span class="n">discrete_frechet</span>
    <span class="p">}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">key</span><span class="p">:</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Path metric &quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">&quot; not found. Valid selections: &#39;</span>
                  <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">path_metrics</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="sqnorm"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.sqnorm">[docs]</a><span class="k">def</span> <span class="nf">sqnorm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the sum of squares of elements along specified axes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v :  numpy.ndarray</span>
<span class="sd">         coordinates</span>
<span class="sd">    axes : None / int / tuple (optional)</span>
<span class="sd">         Axes or axes along which a sum is performed. The default</span>
<span class="sd">         (*axes* = ``None``) performs a sum over all the dimensions of</span>
<span class="sd">         the input array.  The value of *axes* may be negative, in</span>
<span class="sd">         which case it counts from the last axis to the zeroth axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">          the sum of the squares of the elements of `v` along `axes`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_msd_matrix"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.get_msd_matrix">[docs]</a><span class="k">def</span> <span class="nf">get_msd_matrix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate the matrix of pairwise mean-squared deviations between paths.</span>

<span class="sd">    The MSDs between all pairs of points in `P` and `Q` are</span>
<span class="sd">    calculated, each pair having a point from `P` and a point from</span>
<span class="sd">    `Q`.</span>

<span class="sd">    `P` (`Q`) is a :class:`numpy.ndarray` of :math:`N_p` (:math:`N_q`) time</span>
<span class="sd">    steps, :math:`N` atoms, and :math:`3N` coordinates (e.g.,</span>
<span class="sd">    :attr:`MDAnalysis.core.groups.AtomGroup.positions`). The pairwise MSD</span>
<span class="sd">    matrix has dimensions :math:`N_p` by :math:`N_q`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P : numpy.ndarray</span>
<span class="sd">        the points in the first path</span>
<span class="sd">    Q : numpy.ndarray</span>
<span class="sd">        the points in the second path</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    msd_matrix : numpy.ndarray</span>
<span class="sd">         matrix of pairwise MSDs between points in `P` and points</span>
<span class="sd">         in `Q`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    We calculate the MSD matrix</span>

<span class="sd">    .. math::</span>
<span class="sd">       M_{ij} = ||p_i - q_j||^2</span>

<span class="sd">    where :math:`p_i \in P` and :math:`q_j \in Q`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">sqnorm</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">Q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">])</span></div>


<span class="k">def</span> <span class="nf">reshaper</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flatten path when appropriate to facilitate calculations</span>
<span class="sd">    requiring two dimensional input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">path</span>

<div class="viewcode-block" id="get_coord_axes"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.get_coord_axes">[docs]</a><span class="k">def</span> <span class="nf">get_coord_axes</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the number of atoms and the axes corresponding to atoms</span>
<span class="sd">    and coordinates for a given path.</span>

<span class="sd">    The `path` is assumed to be a :class:`numpy.ndarray` where the 0th axis</span>
<span class="sd">    corresponds to a frame (a snapshot of coordinates). The :math:`3N`</span>
<span class="sd">    (Cartesian) coordinates are assumed to be either:</span>

<span class="sd">    1. all in the 1st axis, starting with the x,y,z coordinates of the</span>
<span class="sd">       first atom, followed by the *x*,*y*,*z* coordinates of the 2nd, etc.</span>
<span class="sd">    2. in the 1st *and* 2nd axis, where the 1st axis indexes the atom</span>
<span class="sd">       number and the 2nd axis contains the *x*,*y*,*z* coordinates of</span>
<span class="sd">       each atom.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : numpy.ndarray</span>
<span class="sd">         representing a path</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (int, (int, ...))</span>
<span class="sd">         the number of atoms and the axes containing coordinates</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path_dimensions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path_dimensions</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># 1st axis: atoms, 2nd axis: x,y,z coords</span>
    <span class="k">elif</span> <span class="n">path_dimensions</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># can use mod to check if total # coords divisible by 3</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">3</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="c1"># 1st axis: 3N structural coords (x1,y1,z1,...,xN,xN,zN)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Path must have 2 or 3 dimensions; the first &quot;</span>
                         <span class="s2">&quot;dimensions (axis 0) must correspond to frames, &quot;</span>
                         <span class="s2">&quot;axis 1 (and axis 2, if present) must contain atomic &quot;</span>
                         <span class="s2">&quot;coordinates.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">N</span><span class="p">,</span> <span class="n">axis</span></div>


<div class="viewcode-block" id="hausdorff"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.hausdorff">[docs]</a><span class="k">def</span> <span class="nf">hausdorff</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the symmetric Hausdorff distance between two paths.</span>

<span class="sd">    The metric used is RMSD, as opposed to the more conventional L2</span>
<span class="sd">    (Euclidean) norm, because this is convenient for i.e., comparing</span>
<span class="sd">    protein configurations.</span>

<span class="sd">    *P* (*Q*) is a :class:`numpy.ndarray` of :math:`N_p` (:math:`N_q`) time</span>
<span class="sd">    steps, :math:`N` atoms, and :math:`3N` coordinates (e.g.,</span>
<span class="sd">    :attr:`MDAnalysis.core.groups.AtomGroup.positions`). *P* (*Q*) has</span>
<span class="sd">    either shape |3Dp| (|3Dq|), or |2Dp| (|2Dq|) in flattened form.</span>

<span class="sd">    Note that reversing the path does not change the Hausdorff distance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P : numpy.ndarray</span>
<span class="sd">        the points in the first path</span>
<span class="sd">    Q : numpy.ndarray</span>
<span class="sd">        the points in the second path</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        the Hausdorff distance between paths `P` and `Q`</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Calculate the Hausdorff distance between two halves of a trajectory:</span>

<span class="sd">     &gt;&gt;&gt; import MDAnalysis as mda</span>
<span class="sd">     &gt;&gt;&gt; import numpy</span>
<span class="sd">     &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">     &gt;&gt;&gt; from MDAnalysis.analysis import psa</span>
<span class="sd">     &gt;&gt;&gt; u = mda.Universe(PSF,DCD)</span>
<span class="sd">     &gt;&gt;&gt; mid = int(len(u.trajectory)/2)</span>
<span class="sd">     &gt;&gt;&gt; ca = u.select_atoms(&#39;name CA&#39;)</span>
<span class="sd">     &gt;&gt;&gt; P = numpy.array([</span>
<span class="sd">     ...                ca.positions for _ in u.trajectory[:mid:]</span>
<span class="sd">     ...              ]) # first half of trajectory</span>
<span class="sd">     &gt;&gt;&gt; Q = numpy.array([</span>
<span class="sd">     ...                ca.positions for _ in u.trajectory[mid::]</span>
<span class="sd">     ...              ]) # second half of trajectory</span>
<span class="sd">     &gt;&gt;&gt; psa.hausdorff(P,Q)</span>
<span class="sd">     4.778663899862152</span>
<span class="sd">     &gt;&gt;&gt; psa.hausdorff(P,Q[::-1]) # hausdorff distance w/ reversed 2nd trajectory</span>
<span class="sd">     4.778663899862152</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    :func:`scipy.spatial.distance.directed_hausdorff` is an optimized</span>
<span class="sd">    implementation of the early break algorithm of :cite:p:`Taha2015`; the</span>
<span class="sd">    latter code is used here to calculate the symmetric Hausdorff</span>
<span class="sd">    distance with an RMSD metric</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. bibliography::</span>
<span class="sd">        :filter: False</span>
<span class="sd">        :style: MDA</span>

<span class="sd">        Taha2015</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N_p</span><span class="p">,</span> <span class="n">axis_p</span> <span class="o">=</span> <span class="n">get_coord_axes</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">N_q</span><span class="p">,</span> <span class="n">axis_q</span> <span class="o">=</span> <span class="n">get_coord_axes</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">N_p</span> <span class="o">!=</span> <span class="n">N_q</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;P and Q must have matching sizes&quot;</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">reshaper</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">axis_p</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">reshaper</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">axis_q</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">directed_hausdorff</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
               <span class="n">directed_hausdorff</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">P</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N_p</span><span class="p">)</span></div>


<div class="viewcode-block" id="hausdorff_wavg"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.hausdorff_wavg">[docs]</a><span class="k">def</span> <span class="nf">hausdorff_wavg</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the weighted average Hausdorff distance between two paths.</span>

<span class="sd">    *P* (*Q*) is a :class:`numpy.ndarray` of :math:`N_p` (:math:`N_q`) time</span>
<span class="sd">    steps, :math:`N` atoms, and :math:`3N` coordinates (e.g.,</span>
<span class="sd">    :attr:`MDAnalysis.core.groups.AtomGroup.positions`). *P* (*Q*) has</span>
<span class="sd">    either shape |3Dp| (|3Dq|), or |2Dp| (|2Dq|) in flattened form. The nearest</span>
<span class="sd">    neighbor distances for *P* (to *Q*) and those of *Q* (to *P*) are averaged</span>
<span class="sd">    individually to get the average nearest neighbor distance for *P* and</span>
<span class="sd">    likewise for *Q*. These averages are then summed and divided by 2 to get a</span>
<span class="sd">    measure that gives equal weight to *P* and *Q*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P : numpy.ndarray</span>
<span class="sd">        the points in the first path</span>
<span class="sd">    Q : numpy.ndarray</span>
<span class="sd">        the points in the second path</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        the weighted average Hausdorff distance between paths `P` and `Q`</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">     &gt;&gt;&gt; import MDAnalysis as mda</span>
<span class="sd">     &gt;&gt;&gt; from MDAnalysis import Universe</span>
<span class="sd">     &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">     &gt;&gt;&gt; from MDAnalysis.analysis import psa</span>
<span class="sd">     &gt;&gt;&gt; u = mda.Universe(PSF,DCD)</span>
<span class="sd">     &gt;&gt;&gt; mid = int(len(u.trajectory)/2)</span>
<span class="sd">     &gt;&gt;&gt; ca = u.select_atoms(&#39;name CA&#39;)</span>
<span class="sd">     &gt;&gt;&gt; P = numpy.array([</span>
<span class="sd">     ...                ca.positions for _ in u.trajectory[:mid:]</span>
<span class="sd">     ...              ]) # first half of trajectory</span>
<span class="sd">     &gt;&gt;&gt; Q = numpy.array([</span>
<span class="sd">     ...                ca.positions for _ in u.trajectory[mid::]</span>
<span class="sd">     ...              ]) # second half of trajectory</span>
<span class="sd">     &gt;&gt;&gt; psa.hausdorff_wavg(P,Q)</span>
<span class="sd">     2.5669644353703447</span>
<span class="sd">     &gt;&gt;&gt; psa.hausdorff_wavg(P,Q[::-1]) # weighted avg hausdorff dist w/ Q reversed</span>
<span class="sd">     2.5669644353703447</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The weighted average Hausdorff distance is not a true metric (it does not</span>
<span class="sd">    obey the triangle inequality); see :cite:p:`Seyler2015` for further</span>
<span class="sd">    details.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">get_coord_axes</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">get_msd_matrix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">out</span> <span class="o">/</span> <span class="n">N</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span></div>


<div class="viewcode-block" id="hausdorff_avg"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.hausdorff_avg">[docs]</a><span class="k">def</span> <span class="nf">hausdorff_avg</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the average Hausdorff distance between two paths.</span>

<span class="sd">    *P* (*Q*) is a :class:`numpy.ndarray` of :math:`N_p` (:math:`N_q`) time</span>
<span class="sd">    steps, :math:`N` atoms, and :math:`3N` coordinates (e.g.,</span>
<span class="sd">    :attr:`MDAnalysis.core.groups.AtomGroup.positions`). *P* (*Q*) has</span>
<span class="sd">    either shape |3Dp| (|3Dq|), or |2Dp| (|2Dq|) in flattened form. The nearest</span>
<span class="sd">    neighbor distances for *P* (to *Q*) and those of *Q* (to *P*) are all</span>
<span class="sd">    averaged together to get a mean nearest neighbor distance. This measure</span>
<span class="sd">    biases the average toward the path that has more snapshots, whereas weighted</span>
<span class="sd">    average Hausdorff gives equal weight to both paths.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P : numpy.ndarray</span>
<span class="sd">        the points in the first path</span>
<span class="sd">    Q : numpy.ndarray</span>
<span class="sd">        the points in the second path</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        the average Hausdorff distance between paths `P` and `Q`</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">     &gt;&gt;&gt; import MDAnalysis as mda</span>
<span class="sd">     &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">     &gt;&gt;&gt; from MDAnalysis.analysis import psa</span>
<span class="sd">     &gt;&gt;&gt; u = mda.Universe(PSF,DCD)</span>
<span class="sd">     &gt;&gt;&gt; mid = int(len(u.trajectory)/2)</span>
<span class="sd">     &gt;&gt;&gt; ca = u.select_atoms(&#39;name CA&#39;)</span>
<span class="sd">     &gt;&gt;&gt; P = numpy.array([</span>
<span class="sd">     ...                ca.positions for _ in u.trajectory[:mid:]</span>
<span class="sd">     ...              ]) # first half of trajectory</span>
<span class="sd">     &gt;&gt;&gt; Q = numpy.array([</span>
<span class="sd">     ...                ca.positions for _ in u.trajectory[mid::]</span>
<span class="sd">     ...              ]) # second half of trajectory</span>
<span class="sd">     &gt;&gt;&gt; psa.hausdorff_avg(P,Q)</span>
<span class="sd">     2.5669646575869005</span>
<span class="sd">     &gt;&gt;&gt; psa.hausdorff_avg(P,Q[::-1]) # hausdorff distance w/ reversed 2nd trajectory</span>
<span class="sd">     2.5669646575869005</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The average Hausdorff distance is not a true metric (it does not obey the</span>
<span class="sd">    triangle inequality); see :cite:p:`Seyler2015` for further details.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">get_coord_axes</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">get_msd_matrix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">out</span> <span class="o">/</span> <span class="n">N</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span></div>


<div class="viewcode-block" id="hausdorff_neighbors"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.hausdorff_neighbors">[docs]</a><span class="k">def</span> <span class="nf">hausdorff_neighbors</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Find the Hausdorff neighbors of two paths.</span>

<span class="sd">    *P* (*Q*) is a :class:`numpy.ndarray` of :math:`N_p` (:math:`N_q`) time</span>
<span class="sd">    steps, :math:`N` atoms, and :math:`3N` coordinates (e.g.,</span>
<span class="sd">    :attr:`MDAnalysis.core.groups.AtomGroup.positions`). *P* (*Q*) has</span>
<span class="sd">    either shape |3Dp| (|3Dq|), or |2Dp| (|2Dq|) in flattened form.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P : numpy.ndarray</span>
<span class="sd">        the points in the first path</span>
<span class="sd">    Q : numpy.ndarray</span>
<span class="sd">        the points in the second path</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        dictionary of two pairs of numpy arrays, the first pair (key</span>
<span class="sd">        &quot;frames&quot;) containing the indices of (Hausdorff) nearest</span>
<span class="sd">        neighbors for `P` and `Q`, respectively, the second (key</span>
<span class="sd">        &quot;distances&quot;) containing (corresponding) nearest neighbor</span>
<span class="sd">        distances for `P` and `Q`, respectively</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Hausdorff neighbors are those points on the two paths that are separated by</span>
<span class="sd">      the Hausdorff distance. They are the farthest nearest neighbors and are</span>
<span class="sd">      maximally different in the sense of the Hausdorff distance</span>
<span class="sd">      :cite:p:`Seyler2015`.</span>
<span class="sd">    - :func:`scipy.spatial.distance.directed_hausdorff` can also provide the</span>
<span class="sd">      hausdorff neighbors.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">get_coord_axes</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">get_msd_matrix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">nearest_neighbors</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;frames&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
        <span class="s1">&#39;distances&#39;</span> <span class="p">:</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">nearest_neighbors</span></div>


<div class="viewcode-block" id="discrete_frechet"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.discrete_frechet">[docs]</a><span class="k">def</span> <span class="nf">discrete_frechet</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the discrete Fréchet distance between two paths.</span>

<span class="sd">    *P* (*Q*) is a :class:`numpy.ndarray` of :math:`N_p` (:math:`N_q`) time</span>
<span class="sd">    steps, :math:`N` atoms, and :math:`3N` coordinates (e.g.,</span>
<span class="sd">    :attr:`MDAnalysis.core.groups.AtomGroup.positions`). *P* (*Q*) has</span>
<span class="sd">    either shape |3Dp| (|3Dq|), or :|2Dp| (|2Dq|) in flattened form.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P : numpy.ndarray</span>
<span class="sd">        the points in the first path</span>
<span class="sd">    Q : numpy.ndarray</span>
<span class="sd">        the points in the second path</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        the discrete Fréchet distance between paths *P* and *Q*</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Calculate the discrete Fréchet distance between two halves of a</span>
<span class="sd">    trajectory.</span>

<span class="sd">     &gt;&gt;&gt; import MDAnalysis as mda</span>
<span class="sd">     &gt;&gt;&gt; import numpy as np</span>
<span class="sd">     &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">     &gt;&gt;&gt; from MDAnalysis.analysis import psa</span>
<span class="sd">     &gt;&gt;&gt; u = mda.Universe(PSF,DCD)</span>
<span class="sd">     &gt;&gt;&gt; mid = int(len(u.trajectory)/2)</span>
<span class="sd">     &gt;&gt;&gt; ca = u.select_atoms(&#39;name CA&#39;)</span>
<span class="sd">     &gt;&gt;&gt; P = np.array([</span>
<span class="sd">     ...                ca.positions for _ in u.trajectory[:mid:]</span>
<span class="sd">     ...              ]) # first half of trajectory</span>
<span class="sd">     &gt;&gt;&gt; Q = np.array([</span>
<span class="sd">     ...                ca.positions for _ in u.trajectory[mid::]</span>
<span class="sd">     ...              ]) # second half of trajectory</span>
<span class="sd">     &gt;&gt;&gt; psa.discrete_frechet(P,Q)</span>
<span class="sd">     4.778663984013591</span>
<span class="sd">     &gt;&gt;&gt; psa.discrete_frechet(P,Q[::-1]) # frechet distance w/ 2nd trj reversed 2nd</span>
<span class="sd">     6.842901117711383</span>

<span class="sd">    Note that reversing the direction increased the Fréchet distance:</span>
<span class="sd">    it is sensitive to the direction of the path.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The discrete Fréchet metric is an approximation to the continuous Fréchet</span>
<span class="sd">    metric :cite:p:`Frechet1906,Alt1995`. The calculation of the continuous</span>
<span class="sd">    Fréchet distance is implemented with the dynamic programming algorithm of</span>
<span class="sd">    :cite:p:`EiterMannila1994,EiterMannila1997`.</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. bibliography::</span>
<span class="sd">        :filter: False</span>
<span class="sd">        :style: MDA</span>

<span class="sd">        Frechet1906</span>
<span class="sd">        Alt1995</span>
<span class="sd">        EiterMannila1994</span>
<span class="sd">        EiterMannila1997</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">get_coord_axes</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">Np</span><span class="p">,</span> <span class="n">Nq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">get_msd_matrix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Np</span><span class="p">,</span> <span class="n">Nq</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the coupling distance for two partial paths formed by *P* and</span>
<span class="sd">        *Q*, where both begin at frame 0 and end (inclusive) at the respective</span>
<span class="sd">        frame indices :math:`i-1` and :math:`j-1`. The partial path of *P* (*Q*)</span>
<span class="sd">        up to frame *i* (*j*) is formed by the slicing ``P[0:i]`` (``Q[0:j]``).</span>

<span class="sd">        :func:`c` is called recursively to compute the coupling distance</span>
<span class="sd">        between the two full paths *P* and *Q*  (i.e., the discrete Frechet</span>
<span class="sd">        distance) in terms of coupling distances between their partial paths.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            partial path of *P* through final frame *i-1*</span>
<span class="sd">        j : int</span>
<span class="sd">            partial path of *Q* through final frame *j-1*</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dist : float</span>
<span class="sd">            the coupling distance between partial paths `P[0:i]` and `Q[0:j]`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span>
            <span class="k">return</span> <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">c</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">Np</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nq</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span></div>


<div class="viewcode-block" id="dist_mat_to_vec"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.dist_mat_to_vec">[docs]</a><span class="k">def</span> <span class="nf">dist_mat_to_vec</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert distance matrix indices (in the upper triangle) to the index of</span>
<span class="sd">    the corresponding distance vector.</span>

<span class="sd">    This is a convenience function to locate distance matrix elements (and the</span>
<span class="sd">    pair generating it) in the corresponding distance vector. The row index *j*</span>
<span class="sd">    should be greater than *i+1*, corresponding to the upper triangle of the</span>
<span class="sd">    distance matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        size of the distance matrix (of shape *N*-by-*N*)</span>
<span class="sd">    i : int</span>
<span class="sd">        row index (starting at 0) of the distance matrix</span>
<span class="sd">    j : int</span>
<span class="sd">        column index (starting at 0) of the distance matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        index (of the matrix element) in the corresponding distance vector</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;N, i, j all must be of type int&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix indices are invalid; i and j must be greater &quot;</span>
                         <span class="s2">&quot;than 0 and N must be greater the 2&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">N</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix indices are out of range; i and j must be &quot;</span>
                         <span class="s2">&quot;less than N = </span><span class="si">{0:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># old-style division for int output</span>
    <span class="k">elif</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Column index entered (j = </span><span class="si">{:d}</span><span class="s2"> is smaller than row &quot;</span>
                      <span class="s2">&quot;index (i = </span><span class="si">{:d}</span><span class="s2">). Using symmetric element in upper &quot;</span>
                      <span class="s2">&quot;triangle of distance matrix instead: i --&gt; j, &quot;</span>
                      <span class="s2">&quot;j --&gt; i&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># old-style division for int output</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error in processing matrix indices; i and j must &quot;</span>
                         <span class="s2">&quot;be integers less than integer N = </span><span class="si">{0:d}</span><span class="s2"> such that&quot;</span>
                         <span class="s2">&quot; j &gt;= i+1.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">))</span></div>


<div class="viewcode-block" id="Path"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.Path">[docs]</a><span class="k">class</span> <span class="nc">Path</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represent a path based on a :class:`~MDAnalysis.core.universe.Universe`.</span>

<span class="sd">    Pre-process a :class:`Universe` object: (1) fit the trajectory to a</span>
<span class="sd">    reference structure, (2) convert fitted time series to a</span>
<span class="sd">    :class:`numpy.ndarray` representation of :attr:`Path.path`.</span>

<span class="sd">    The analysis is performed with :meth:`PSAnalysis.run` and stores the result</span>
<span class="sd">    in the :class:`numpy.ndarray` distance matrix :attr:`PSAnalysis.D`.</span>
<span class="sd">    :meth:`PSAnalysis.run` also generates a fitted trajectory and path from</span>
<span class="sd">    alignment of the original trajectories to a reference structure.</span>

<span class="sd">    .. versionadded:: 0.9.1</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s1">&#39;name CA&#39;</span><span class="p">,</span>
                 <span class="n">path_select</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">ref_frame</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Setting up trajectory alignment and fitted path generation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        universe : Universe</span>
<span class="sd">             :class:`MDAnalysis.Universe` object containing a trajectory</span>
<span class="sd">        reference : Universe</span>
<span class="sd">             reference structure (uses `ref_frame` from the trajectory)</span>
<span class="sd">        select : str or dict or tuple (optional)</span>
<span class="sd">             The selection to operate on for rms fitting; can be one of:</span>

<span class="sd">             1. any valid selection string for</span>
<span class="sd">                :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` that</span>
<span class="sd">                produces identical selections in *mobile* and *reference*; or</span>
<span class="sd">             2. a dictionary ``{&#39;mobile&#39;:sel1, &#39;reference&#39;:sel2}`` (the</span>
<span class="sd">                :func:`MDAnalysis.analysis.align.fasta2select` function returns</span>
<span class="sd">                such a dictionary based on a ClustalW_ or STAMP_ sequence</span>
<span class="sd">                alignment); or</span>
<span class="sd">             3. a tuple ``(sel1, sel2)``</span>

<span class="sd">             When using 2. or 3. with *sel1* and *sel2* then these selections</span>
<span class="sd">             can also each be a list of selection strings (to generate an</span>
<span class="sd">             AtomGroup with defined atom order as described under</span>
<span class="sd">             :ref:`ordered-selections-label`).</span>
<span class="sd">        ref_frame : int</span>
<span class="sd">             frame index to select the coordinate frame from</span>
<span class="sd">             `select.trajectory`</span>
<span class="sd">        path_select : selection_string</span>
<span class="sd">             atom selection composing coordinates of (fitted) path; if ``None``</span>
<span class="sd">             then `path_select` is set to `select` [``None``]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_original</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_reference</span> <span class="o">=</span> <span class="n">reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="n">select</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">=</span> <span class="n">ref_frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_select</span> <span class="o">=</span> <span class="n">path_select</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">top_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_original</span><span class="o">.</span><span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trj_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_original</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newtrj_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_fitted</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Path.fit_to_reference"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.Path.fit_to_reference">[docs]</a>    <span class="k">def</span> <span class="nf">fit_to_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">postfix</span><span class="o">=</span><span class="s1">&#39;_fit&#39;</span><span class="p">,</span>
                         <span class="n">rmsdfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">targetdir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">,</span>
                         <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Align each trajectory frame to the reference structure</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str (optional)</span>
<span class="sd">             file name for the RMS-fitted trajectory or pdb; defaults to the</span>
<span class="sd">             original trajectory filename (from :attr:`Path.u_original`) with</span>
<span class="sd">             `prefix` prepended</span>
<span class="sd">        prefix : str (optional)</span>
<span class="sd">             prefix for auto-generating the new output filename</span>
<span class="sd">        rmsdfile : str (optional)</span>
<span class="sd">             file name for writing the RMSD time series [``None``]</span>
<span class="sd">        weights : {&quot;mass&quot;, ``None``} or array_like (optional)</span>
<span class="sd">             choose weights. With ``&quot;mass&quot;`` uses masses as weights; with</span>
<span class="sd">             ``None`` weigh each atom equally. If a float array of the same</span>
<span class="sd">             length as the selected AtomGroup is provided, use each element of</span>
<span class="sd">             the `array_like` as a weight for the corresponding atom in the</span>
<span class="sd">             AtomGroup.</span>
<span class="sd">        tol_mass : float (optional)</span>
<span class="sd">             Reject match if the atomic masses for matched atoms differ by more</span>
<span class="sd">             than `tol_mass` [0.1]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Universe</span>
<span class="sd">            :class:`MDAnalysis.Universe` object containing a fitted trajectory</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses :class:`MDAnalysis.analysis.align.AlignTraj` for the fitting.</span>


<span class="sd">        .. deprecated:: 0.16.1</span>
<span class="sd">           Instead of ``mass_weighted=True`` use new ``weights=&#39;mass&#39;``;</span>
<span class="sd">           refactored to fit with AnalysisBase API</span>

<span class="sd">        .. versionchanged:: 0.17.0</span>
<span class="sd">           Deprecated keyword `mass_weighted` was removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trj_name</span><span class="p">)</span>
        <span class="n">oldname</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="ow">or</span> <span class="n">oldname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newtrj_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">filename</span> <span class="o">+</span> <span class="n">postfix</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_reference</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span><span class="p">]</span> <span class="c1"># select frame from ref traj</span>
        <span class="n">aligntrj</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">align</span><span class="o">.</span><span class="n">AlignTraj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_original</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">u_reference</span><span class="p">,</span>
                                                       <span class="n">select</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">,</span>
                                                       <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">newtrj_name</span><span class="p">,</span>
                                                       <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span>
                                                       <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                                                       <span class="n">tol_mass</span><span class="o">=</span><span class="n">tol_mass</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">rmsdfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aligntrj</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">rmsdfile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">newtrj_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Path.to_path"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.Path.to_path">[docs]</a>    <span class="k">def</span> <span class="nf">to_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generates a coordinate time series from the fitted universe</span>
<span class="sd">        trajectory.</span>

<span class="sd">        Given a selection of *N* atoms from *select*, the atomic positions for</span>
<span class="sd">        each frame in the fitted universe (:attr:`Path.u_fitted`) trajectory</span>
<span class="sd">        (with |Np| total frames) are appended sequentially to form a 3D or 2D</span>
<span class="sd">        (if *flat* is ``True``) :class:`numpy.ndarray` representation of the</span>
<span class="sd">        fitted trajectory (with dimensions |3D| or |2D|, respectively).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fitted : bool (optional)</span>
<span class="sd">             construct a :attr:`Path.path` from the :attr:`Path.u_fitted`</span>
<span class="sd">             trajectory; if ``False`` then :attr:`Path.path` is generated with</span>
<span class="sd">             the trajectory from :attr:`Path.u_original` [``False``]</span>
<span class="sd">        select : str (optional)</span>
<span class="sd">             the selection for constructing the coordinates of each frame in</span>
<span class="sd">             :attr:`Path.path`; if ``None`` then :attr:`Path.path_select`</span>
<span class="sd">             is used, else it is overridden by *select* [``None``]</span>
<span class="sd">        flat : bool (optional)</span>
<span class="sd">             represent :attr:`Path.path` as a 2D (|2D|) :class:`numpy.ndarray`;</span>
<span class="sd">             if ``False`` then :attr:`Path.path` is a 3D (|3D|)</span>
<span class="sd">             :class:`numpy.ndarray` [``False``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">              representing a time series of atomic positions of an</span>
<span class="sd">              :class:`MDAnalysis.core.groups.AtomGroup` selection from</span>
<span class="sd">              :attr:`Path.u_fitted.trajectory`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">select</span> <span class="k">if</span> <span class="n">select</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_select</span>
        <span class="k">if</span> <span class="n">fitted</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_fitted</span><span class="p">,</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Fitted universe not found. Generate a fitted &quot;</span> <span class="o">+</span>
                        <span class="s2">&quot;universe with fit_to_reference() first, or explicitly &quot;</span><span class="o">+</span>
                        <span class="s2">&quot;set argument </span><span class="se">\&quot;</span><span class="s2">fitted</span><span class="se">\&quot;</span><span class="s2"> to </span><span class="se">\&quot;</span><span class="s2">False</span><span class="se">\&quot;</span><span class="s2"> to generate a &quot;</span>   <span class="o">+</span>
                        <span class="s2">&quot;path from the original universe.&quot;</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_fitted</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_original</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">frames</span><span class="o">.</span><span class="n">rewind</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">])</span></div>

<div class="viewcode-block" id="Path.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.Path.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">postfix</span><span class="o">=</span><span class="s1">&#39;_fit&#39;</span><span class="p">,</span> <span class="n">rmsdfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">targetdir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
            <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate a path from a trajectory and reference structure.</span>

<span class="sd">        As part of the path generation, the trajectory can be superimposed</span>
<span class="sd">        (&quot;aligned&quot;) to a reference structure if specified.</span>

<span class="sd">        This is a convenience method to generate a fitted trajectory from an</span>
<span class="sd">        inputted universe (:attr:`Path.u_original`) and reference structure</span>
<span class="sd">        (:attr:`Path.u_reference`). :meth:`Path.fit_to_reference` and</span>
<span class="sd">        :meth:`Path.to_path` are used consecutively to generate a new universe</span>
<span class="sd">        (:attr:`Path.u_fitted`) containing the fitted trajectory along with the</span>
<span class="sd">        corresponding :attr:`Path.path` represented as an</span>
<span class="sd">        :class:`numpy.ndarray`. The method returns a tuple of the topology name</span>
<span class="sd">        and new trajectory name, which can be fed directly into an</span>
<span class="sd">        :class:`MDAnalysis.Universe` object after unpacking the tuple using the</span>
<span class="sd">        ``*`` operator, as in</span>
<span class="sd">        ``MDAnalysis.Universe(*(top_name, newtraj_name))``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        align : bool (optional)</span>
<span class="sd">             Align trajectory to atom selection :attr:`Path.select` of</span>
<span class="sd">             :attr:`Path.u_reference`. If ``True``, a universe containing an</span>
<span class="sd">             aligned trajectory is produced with :meth:`Path.fit_to_reference`</span>
<span class="sd">             [``False``]</span>
<span class="sd">        filename : str (optional)</span>
<span class="sd">             filename for the RMS-fitted trajectory or pdb; defaults to the</span>
<span class="sd">             original trajectory filename (from :attr:`Path.u_original`) with</span>
<span class="sd">             *prefix* prepended</span>
<span class="sd">        postfix : str (optional)</span>
<span class="sd">             prefix for auto-generating the new output filename</span>
<span class="sd">        rmsdfile : str (optional)</span>
<span class="sd">             file name for writing the RMSD time series [``None``]</span>
<span class="sd">        weights : {&quot;mass&quot;, ``None``} or array_like (optional)</span>
<span class="sd">             choose weights. With ``&quot;mass&quot;`` uses masses as weights; with</span>
<span class="sd">             ``None`` weigh each atom equally. If a float array of the same</span>
<span class="sd">             length as the selected AtomGroup is provided, use each element of</span>
<span class="sd">             the `array_like` as a weight for the corresponding atom in the</span>
<span class="sd">             AtomGroup.</span>
<span class="sd">        tol_mass : float (optional)</span>
<span class="sd">             Reject match if the atomic masses for matched atoms differ by more</span>
<span class="sd">             than *tol_mass* [0.1]</span>
<span class="sd">        flat : bool (optional)</span>
<span class="sd">             represent :attr:`Path.path` with 2D (|2D|) :class:`numpy.ndarray`;</span>
<span class="sd">             if ``False`` then :attr:`Path.path` is a 3D (|3D|)</span>
<span class="sd">             :class:`numpy.ndarray` [``False``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology_trajectory : tuple</span>
<span class="sd">             A tuple of the topology name and new trajectory name.</span>


<span class="sd">        .. deprecated:: 0.16.1</span>
<span class="sd">           Instead of ``mass_weighted=True`` use new ``weights=&#39;mass&#39;``;</span>
<span class="sd">           refactored to fit with AnalysisBase API</span>

<span class="sd">        .. versionchanged:: 0.17.0</span>
<span class="sd">           Deprecated keyword `mass_weighted` was removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">align</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u_fitted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_to_reference</span><span class="p">(</span>
                                <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">postfix</span><span class="o">=</span><span class="n">postfix</span><span class="p">,</span>
                                <span class="n">rmsdfile</span><span class="o">=</span><span class="n">rmsdfile</span><span class="p">,</span> <span class="n">targetdir</span><span class="o">=</span><span class="n">targetdir</span><span class="p">,</span>
                                <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_path</span><span class="p">(</span><span class="n">fitted</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">newtrj_name</span></div>

<div class="viewcode-block" id="Path.get_num_atoms"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.Path.get_num_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_num_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of atoms used to construct the :class:`Path`.</span>

<span class="sd">        Must run :meth:`Path.to_path` prior to calling this method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            the number of atoms in the :class:`Path`</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No path data; do &#39;Path.to_path()&#39; first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span></div></div>


<div class="viewcode-block" id="PSAPair"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAPair">[docs]</a><span class="k">class</span> <span class="nc">PSAPair</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate nearest neighbor and Hausdorff pair information between a pair</span>
<span class="sd">    of paths from an all-pairs comparison generated by :class:`PSA`.</span>

<span class="sd">    The nearest neighbors for each path of a pair of paths is generated by</span>
<span class="sd">    :meth:`PSAPair.compute_nearest_neighbors` and stores the result</span>
<span class="sd">    in a dictionary (:attr:`nearest_neighbors`): each path has a</span>
<span class="sd">    :class:`numpy.ndarray` of the frames of its nearest neighbors, and a</span>
<span class="sd">    :class:`numpy.ndarray` of its nearest neighbor distances</span>
<span class="sd">    :attr:`PSAnalysis.D`. For example, *nearest_neighbors[&#39;frames&#39;]* is a pair</span>
<span class="sd">    of :class:`numpy.ndarray`, the first being the frames of the nearest</span>
<span class="sd">    neighbors of the first path, *i*, the second being those of the second path,</span>
<span class="sd">    *j*.</span>

<span class="sd">    The Hausdorff pair for the pair of paths is found by calling</span>
<span class="sd">    :meth:`find_hausdorff_pair` (locates the nearest neighbor pair having the</span>
<span class="sd">    largest overall distance separating them), which stores the result in a</span>
<span class="sd">    dictionary (:attr:`hausdorff_pair`) containing the frames (indices) of the</span>
<span class="sd">    pair along with the corresponding (Hausdorff) distance.</span>
<span class="sd">    *hausdorff_pair[&#39;frame&#39;]* contains a pair of frames in the first path, *i*,</span>
<span class="sd">    and the second path, *j*, respectively, that correspond to the Hausdorff</span>
<span class="sd">    distance between them.</span>

<span class="sd">    .. versionadded:: 0.11</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">npaths</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up a :class:`PSAPair` for a pair of paths that are part of a</span>
<span class="sd">        :class:`PSA` comparison of *npaths* total paths.</span>

<span class="sd">        Each unique pair of paths compared using :class:`PSA` is related by</span>
<span class="sd">        their nearest neighbors (and corresponding distances) and the Hausdorff</span>
<span class="sd">        pair and distance. :class:`PSAPair` is a convenience class for</span>
<span class="sd">        calculating and encapsulating nearest neighbor and Hausdorff pair</span>
<span class="sd">        information for one pair of paths.</span>

<span class="sd">        Given *npaths*, :class:`PSA` performs and all-pairs comparison among all</span>
<span class="sd">        paths for a total of :math:`\text{npaths}*(\text{npaths}-1)/2` unique</span>
<span class="sd">        comparisons. If distances between paths are computed, the all-pairs</span>
<span class="sd">        comparison can be summarized in a symmetric distance matrix whose upper</span>
<span class="sd">        triangle can be mapped to a corresponding distance vector form in a</span>
<span class="sd">        one-to-one manner. A particular comparison of a pair of paths in a</span>
<span class="sd">        given instance of :class:`PSAPair` is thus unique identified by the row</span>
<span class="sd">        and column indices in the distance matrix representation (whether or not</span>
<span class="sd">        distances are actually computed), or a single ID (index) in the</span>
<span class="sd">        corresponding distance vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        npaths : int</span>
<span class="sd">            total number of paths in :class:`PSA` used to generate *this*</span>
<span class="sd">            :class:`PSAPair`</span>
<span class="sd">        i : int</span>
<span class="sd">             row index (starting at 0) of the distance matrix</span>
<span class="sd">        j : int</span>
<span class="sd">             column index (starting at 0) of the distance matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npaths</span> <span class="o">=</span> <span class="n">npaths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pair_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dvec_idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>

        <span class="c1"># Set by calling hausdorff_nn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;frames&#39;</span> <span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;distances&#39;</span> <span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

        <span class="c1"># Set by self.getHausdorffPair</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hausdorff_pair</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;frames&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;distance&#39;</span> <span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_dvec_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert distance matrix indices (in the upper triangle) to the index</span>
<span class="sd">        of the corresponding distance vector.</span>

<span class="sd">        This is a convenience function to locate distance matrix elements (and</span>
<span class="sd">        the pair generating it) in the corresponding distance vector. The row</span>
<span class="sd">        index *j* should be greater than *i+1*, corresponding to the upper</span>
<span class="sd">        triangle of the distance matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            row index (starting at 0) of the distance matrix</span>
<span class="sd">        j : int</span>
<span class="sd">            column index (starting at 0) of the distance matrix</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">             (matrix element) index in the corresponding distance vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npaths</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

    <span class="k">def</span> <span class="nf">compute_nearest_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates Hausdorff nearest neighbor lists of *frames* (by index) and</span>
<span class="sd">        *distances* for *this* pair of paths corresponding to distance matrix</span>
<span class="sd">        indices (*i*,*j*).</span>

<span class="sd">        :meth:`PSAPair.compute_nearest_neighbors` calls</span>
<span class="sd">        :func:`hausdorff_neighbors` to populate the dictionary of the nearest</span>
<span class="sd">        neighbor lists of frames (by index) and distances</span>
<span class="sd">        (:attr:`PSAPair.nearest_neighbors`). This method must explicitly take as</span>
<span class="sd">        arguments a pair of paths, *P* and *Q*, where *P* is the</span>
<span class="sd">        :math:`i^\text{th}` path and *Q* is the :math:`j^\text{th}` path among</span>
<span class="sd">        the set of *N* total paths in the comparison.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        P : numpy.ndarray</span>
<span class="sd">            representing a path</span>
<span class="sd">        Q : numpy.ndarray</span>
<span class="sd">            representing a path</span>
<span class="sd">        N : int</span>
<span class="sd">            size of the distance matrix (of shape *N*-by-*N*) [``None``]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hn</span> <span class="o">=</span> <span class="n">hausdorff_neighbors</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hn</span><span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">[</span><span class="s1">&#39;distances&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hn</span><span class="p">[</span><span class="s1">&#39;distances&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">find_hausdorff_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Find the Hausdorff pair (of frames) for *this* pair of paths.</span>

<span class="sd">        :meth:`PSAPair.find_hausdorff_pair` requires that</span>
<span class="sd">        `:meth:`PSAPair.compute_nearest_neighbors` be called first to</span>
<span class="sd">        generate the nearest neighbors (and corresponding distances) for each</span>
<span class="sd">        path in *this* :class:`PSAPair`. The Hausdorff pair is the nearest</span>
<span class="sd">        neighbor pair (of snapshots/frames), one in the first path and one in</span>
<span class="sd">        the second, with the largest separation distance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">[</span><span class="s1">&#39;distances&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Nearest neighbors have not been calculated yet;&quot;</span>
                              <span class="s2">&quot; run compute_nearest_neighbors() first.&quot;</span><span class="p">)</span>

        <span class="n">nn_idx_P</span><span class="p">,</span> <span class="n">nn_idx_Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">]</span>
        <span class="n">nn_dist_P</span><span class="p">,</span> <span class="n">nn_dist_Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">[</span><span class="s1">&#39;distances&#39;</span><span class="p">]</span>
        <span class="n">max_nn_dist_P</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nn_dist_P</span><span class="p">)</span>
        <span class="n">max_nn_dist_Q</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nn_dist_Q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_nn_dist_P</span> <span class="o">&gt;</span> <span class="n">max_nn_dist_Q</span><span class="p">:</span>
            <span class="n">max_nn_idx_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">nn_dist_P</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hausdorff_pair</span><span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_nn_idx_P</span><span class="p">,</span> <span class="n">nn_idx_P</span><span class="p">[</span><span class="n">max_nn_idx_P</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hausdorff_pair</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">max_nn_dist_P</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_nn_idx_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">nn_dist_Q</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hausdorff_pair</span><span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn_idx_Q</span><span class="p">[</span><span class="n">max_nn_idx_Q</span><span class="p">],</span> <span class="n">max_nn_idx_Q</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hausdorff_pair</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_nn_dist_Q</span>

    <span class="k">def</span> <span class="nf">get_nearest_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">distances</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the nearest neighbor frame indices, distances, or both, for</span>
<span class="sd">        each path in *this* :class:`PSAPair`.</span>

<span class="sd">        :meth:`PSAPair.get_nearest_neighbors` requires that the nearest</span>
<span class="sd">        neighbors (:attr:`nearest_neighbors`) be initially computed by first</span>
<span class="sd">        calling :meth:`compute_nearest_neighbors`. At least one of *frames*</span>
<span class="sd">        or *distances* must be ``True``, or else a ``NoDataError`` is raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frames :  bool</span>
<span class="sd">             if ``True``, return nearest neighbor frame indices</span>
<span class="sd">             [``True``]</span>
<span class="sd">         distances : bool</span>
<span class="sd">             if ``True``, return nearest neighbor distances [``True``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict or tuple</span>
<span class="sd">             If both *frames* and *distances* are ``True``, return the entire</span>
<span class="sd">             dictionary (:attr:`nearest_neighbors`); if only *frames* is</span>
<span class="sd">             ``True``, return a pair of :class:`numpy.ndarray` containing the</span>
<span class="sd">             indices of the frames (for the pair of paths) of the nearest</span>
<span class="sd">             neighbors; if only *distances* is ``True``, return a pair of</span>
<span class="sd">             :class:`numpy.ndarray` of the nearest neighbor distances (for the</span>
<span class="sd">             pair of paths).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">[</span><span class="s1">&#39;distances&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Nearest neighbors have not been calculated yet;&quot;</span>
                              <span class="s2">&quot; run compute_nearest_neighbors() first.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">frames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">distances</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">distances</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">[</span><span class="s1">&#39;distances&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s1">&#39;Need to select Hausdorff pair &quot;frames&quot; or&#39;</span>
                              <span class="s1">&#39; &quot;distances&quot; or both. &quot;frames&quot; and &quot;distances&quot;&#39;</span>
                              <span class="s1">&#39; cannot both be set to False.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_hausdorff_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the Hausdorff pair of frames indices, the Hausdorff distance,</span>
<span class="sd">        or both, for the paths in *this* :class:`PSAPair`.</span>

<span class="sd">        :meth:`PSAPair.get_hausdorff_pair` requires that the Hausdorff pair</span>
<span class="sd">        (and distance) be initially found by first calling</span>
<span class="sd">        :meth:`find_hausdorff_pair`. At least one of *frames* or *distance*</span>
<span class="sd">        must be ``True``, or else a ``NoDataError`` is raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frames : bool</span>
<span class="sd">             if ``True``, return the indices of the frames</span>
<span class="sd">             of the Hausdorff pair [``True``]</span>
<span class="sd">        distances : bool</span>
<span class="sd">             if ``True``, return Hausdorff distance [``True``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict or tuple</span>
<span class="sd">             If both *frames* and *distance* are ``True``, return the entire</span>
<span class="sd">             dictionary (:attr:`hausdorff_pair`); if only *frames* is</span>
<span class="sd">             ``True``, return a pair of ``int`` containing the indices of the</span>
<span class="sd">             frames (one index per path) of the Hausdorff pair; if only *distance*</span>
<span class="sd">             is ``True``, return the Hausdorff distance for this path pair.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hausdorff_pair</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Hausdorff pair has not been calculated yet;&quot;</span>
                              <span class="s2">&quot; run find_hausdorff_pair() first.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">frames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">distance</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hausdorff_pair</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hausdorff_pair</span><span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">distance</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hausdorff_pair</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s1">&#39;Need to select Hausdorff pair &quot;frames&quot; or&#39;</span>
                              <span class="s1">&#39; &quot;distance&quot; or both. &quot;frames&quot; and &quot;distance&quot;&#39;</span>
                              <span class="s1">&#39; cannot both be set to False.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PSAnalysis"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis">[docs]</a><span class="k">class</span> <span class="nc">PSAnalysis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform Path Similarity Analysis (PSA) on a set of trajectories.</span>

<span class="sd">    The analysis is performed with :meth:`PSAnalysis.run` and stores the result</span>
<span class="sd">    in the :class:`numpy.ndarray` distance matrix :attr:`PSAnalysis.D`.</span>
<span class="sd">    :meth:`PSAnalysis.run` also generates a fitted trajectory and path from</span>
<span class="sd">    alignment of the original trajectories to a reference structure.</span>

<span class="sd">    .. versionadded:: 0.8</span>

<span class="sd">    .. versionchanged:: 1.0.0</span>
<span class="sd">       ``save_result()`` method has been removed. You can use ``np.save()`` on</span>
<span class="sd">       :attr:`PSAnalysis.D` instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universes</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s1">&#39;name CA&#39;</span><span class="p">,</span>
                 <span class="n">ref_frame</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">path_select</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">targetdir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Setting up Path Similarity Analysis.</span>

<span class="sd">        The mutual similarity between all unique pairs of trajectories</span>
<span class="sd">        are computed using a selected path metric.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        universes : list</span>
<span class="sd">             a list of universes (:class:`MDAnalysis.Universe` object), each</span>
<span class="sd">             containing a trajectory</span>
<span class="sd">        reference : Universe</span>
<span class="sd">             reference coordinates; :class:`MDAnalysis.Universe` object; if</span>
<span class="sd">             ``None`` the first time step of the first item in `universes` is used</span>
<span class="sd">             [``None``]</span>
<span class="sd">        select : str or dict or tuple</span>
<span class="sd">             The selection to operate on; can be one of:</span>

<span class="sd">             1. any valid selection string for</span>
<span class="sd">                :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` that</span>
<span class="sd">                produces identical selections in *mobile* and *reference*; or</span>
<span class="sd">             2. a dictionary ``{&#39;mobile&#39;:sel1, &#39;reference&#39;:sel2}`` (the</span>
<span class="sd">                :func:`MDAnalysis.analysis.align.fasta2select` function returns</span>
<span class="sd">                such a dictionary based on a ClustalW_ or STAMP_ sequence</span>
<span class="sd">                alignment); or</span>
<span class="sd">             3. a tuple ``(sel1, sel2)``</span>

<span class="sd">             When using 2. or 3. with *sel1* and *sel2* then these selections</span>
<span class="sd">             can also each be a list of selection strings (to generate an</span>
<span class="sd">             AtomGroup with defined atom order as described under</span>
<span class="sd">             :ref:`ordered-selections-label`).</span>
<span class="sd">        tol_mass : float</span>
<span class="sd">             Reject match if the atomic masses for matched atoms differ by more</span>
<span class="sd">             than *tol_mass* [0.1]</span>
<span class="sd">        ref_frame : int</span>
<span class="sd">             frame index to select frame from *reference* [0]</span>
<span class="sd">        path_select : str</span>
<span class="sd">             atom selection composing coordinates of (fitted) path; if ``None``</span>
<span class="sd">             then *path_select* is set to *select* [``None``]</span>
<span class="sd">        targetdir : str</span>
<span class="sd">            output files are saved there; if ``None`` then &quot;./psadata&quot; is</span>
<span class="sd">            created and used [.]</span>
<span class="sd">        labels : list</span>
<span class="sd">             list of strings, names of trajectories to be analyzed</span>
<span class="sd">             (:class:`MDAnalysis.Universe`); if ``None``, defaults to trajectory</span>
<span class="sd">             names [``None``]</span>


<span class="sd">        .. _ClustalW: http://www.clustal.org/</span>
<span class="sd">        .. _STAMP: http://www.compbio.dundee.ac.uk/manuals/stamp.4.2/</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universes</span> <span class="o">=</span> <span class="n">universes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_reference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="n">select</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">=</span> <span class="n">ref_frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span> <span class="k">if</span> <span class="n">path_select</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">path_select</span>
        <span class="k">if</span> <span class="n">targetdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">targetdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">,</span> <span class="s1">&#39;psadata&#39;</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">targetdir</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">targetdir</span><span class="p">):</span>
                    <span class="k">raise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">targetdir</span><span class="p">)</span>

        <span class="c1"># Set default directory names for storing topology/reference structures,</span>
        <span class="c1"># fitted trajectories, paths, distance matrices, and plots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fitted_trajs&#39;</span> <span class="p">:</span> <span class="s1">&#39;fitted_trajs&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;paths&#39;</span> <span class="p">:</span> <span class="s1">&#39;paths&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;distance_matrices&#39;</span> <span class="p">:</span> <span class="s1">&#39;distance_matrices&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;plots&#39;</span> <span class="p">:</span> <span class="s1">&#39;plots&#39;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">dir_name</span><span class="p">,</span> <span class="n">directory</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">full_dir_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">full_dir_name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">full_dir_name</span><span class="p">):</span>
                    <span class="k">raise</span>

        <span class="c1"># Keep track of topology, trajectory, and related files</span>
        <span class="n">trj_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universes</span><span class="p">):</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">filename</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">trj_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trj_names</span> <span class="o">=</span> <span class="n">trj_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_trj_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">universes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">trj_names</span>

        <span class="c1"># Names of persistence (pickle) files where topology and trajectory</span>
        <span class="c1"># filenames are stored--should not be modified by user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_top_pkl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="s2">&quot;psa_top-name.pkl&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trjs_pkl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="s2">&quot;psa_orig-traj-names.pkl&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_trjs_pkl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="s2">&quot;psa_fitted-traj-names.pkl&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths_pkl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="s2">&quot;psa_path-names.pkl&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels_pkl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="s2">&quot;psa_labels.pkl&quot;</span><span class="p">)</span>
        <span class="c1"># Pickle topology and trajectory filenames for this analysis to curdir</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top_pkl</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_name</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trjs_pkl</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trj_names</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels_pkl</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npaths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># pairwise distances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_HP</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># (distance vector order) list of all Hausdorff pairs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NN</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># (distance vector order) list of all nearest neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psa_pairs</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># (distance vector order) list of all PSAPairs</span>

<div class="viewcode-block" id="PSAnalysis.generate_paths"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.generate_paths">[docs]</a>    <span class="k">def</span> <span class="nf">generate_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">infix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">tol_mass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ref_frame</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate paths, aligning each to reference structure if necessary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        align : bool</span>
<span class="sd">             Align trajectories to atom selection :attr:`PSAnalysis.select`</span>
<span class="sd">             of :attr:`PSAnalysis.u_reference` [``False``]</span>
<span class="sd">        filename : str</span>
<span class="sd">             strings representing base filename for fitted trajectories and</span>
<span class="sd">             paths [``None``]</span>
<span class="sd">        infix : str</span>
<span class="sd">             additional tag string that is inserted into the output filename of</span>
<span class="sd">             the fitted trajectory files [&#39;&#39;]</span>
<span class="sd">        weights : {&quot;mass&quot;, ``None``} or array_like (optional)</span>
<span class="sd">             choose weights. With ``&quot;mass&quot;`` uses masses as weights; with</span>
<span class="sd">             ``None`` weigh each atom equally. If a float array of the same</span>
<span class="sd">             length as the selected AtomGroup is provided, use each element of</span>
<span class="sd">             the `array_like` as a weight for the corresponding atom in the</span>
<span class="sd">             AtomGroup [``None``]</span>
<span class="sd">        tol_mass : float</span>
<span class="sd">             Reject match if the atomic masses for matched atoms differ by more</span>
<span class="sd">             than *tol_mass* [``False``]</span>
<span class="sd">        ref_frame : int</span>
<span class="sd">             frame index to select frame from *reference* [``None``]</span>
<span class="sd">        flat : bool</span>
<span class="sd">             represent :attr:`Path.path` as a 2D (|2D|) :class:`numpy.ndarray`;</span>
<span class="sd">             if ``False`` then :attr:`Path.path` is a 3D (|3D|)</span>
<span class="sd">             :class:`numpy.ndarray` [``False``]</span>
<span class="sd">        save : bool</span>
<span class="sd">             if ``True``, pickle list of names for fitted trajectories</span>
<span class="sd">             [``True``]</span>
<span class="sd">        store : bool</span>
<span class="sd">             if ``True`` then writes each path (:class:`numpy.ndarray`)</span>
<span class="sd">             in :attr:`PSAnalysis.paths` to compressed npz (numpy) files</span>
<span class="sd">             [``False``]</span>


<span class="sd">        The fitted trajectories are written to new files in the</span>
<span class="sd">        &quot;/trj_fit&quot; subdirectory in :attr:`PSAnalysis.targetdir` named</span>
<span class="sd">        &quot;filename(*trajectory*)XXX*infix*_psa&quot;, where &quot;XXX&quot; is a number between</span>
<span class="sd">        000 and 999; the extension of each file is the same as its original.</span>
<span class="sd">        Optionally, the trajectories can also be saved in numpy compressed npz</span>
<span class="sd">        format in the &quot;/paths&quot; subdirectory in :attr:`PSAnalysis.targetdir` for</span>
<span class="sd">        persistence and can be accessed as the attribute</span>
<span class="sd">        :attr:`PSAnalysis.paths`.</span>


<span class="sd">        .. deprecated:: 0.16.1</span>
<span class="sd">           Instead of ``mass_weighted=True`` use new ``weights=&#39;mass&#39;``;</span>
<span class="sd">           refactored to fit with AnalysisBase API</span>

<span class="sd">        .. versionchanged:: 0.17.0</span>
<span class="sd">           Deprecated keyword `mass_weighted` was removed.</span>

<span class="sd">        .. versionchanged:: 1.0.0</span>
<span class="sd">           Defaults for the `store` and `filename` keywords have been changed</span>
<span class="sd">           from `True` and `fitted` to `False` and `None` respectively. These</span>
<span class="sd">           now match the docstring documented defaults.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ref_frame</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span>

        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fit_trj_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universes</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_reference</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">,</span>
                     <span class="n">path_select</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path_select</span><span class="p">,</span> <span class="n">ref_frame</span><span class="o">=</span><span class="n">ref_frame</span><span class="p">)</span>
            <span class="n">trj_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span><span class="p">[</span><span class="s1">&#39;fitted_trajs&#39;</span><span class="p">])</span>
            <span class="n">postfix</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}{1}{2:03n}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">infix</span><span class="p">,</span> <span class="s1">&#39;_psa&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">top_name</span><span class="p">,</span> <span class="n">fit_trj_name</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
                                           <span class="n">postfix</span><span class="o">=</span><span class="n">postfix</span><span class="p">,</span>
                                           <span class="n">targetdir</span><span class="o">=</span><span class="n">trj_dir</span><span class="p">,</span>
                                           <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                                           <span class="n">tol_mass</span><span class="o">=</span><span class="n">tol_mass</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span>
            <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="n">fit_trj_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_trj_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">get_coord_axes</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="o">=</span> <span class="n">paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npaths</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_trj_names</span> <span class="o">=</span> <span class="n">fit_trj_names</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fit_trjs_pkl</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_trj_names</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_paths</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="PSAnalysis.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform path similarity analysis on the trajectories to compute</span>
<span class="sd">        the distance matrix.</span>

<span class="sd">        A number of parameters can be changed from the defaults. The</span>
<span class="sd">        result is stored as the array :attr:`PSAnalysis.D`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metric : str or callable</span>
<span class="sd">             selection string specifying the path metric to measure pairwise</span>
<span class="sd">             distances among :attr:`PSAnalysis.paths` or a callable with the</span>
<span class="sd">             same call signature as :func:`hausdorff`</span>
<span class="sd">             [``&#39;hausdorff&#39;``]</span>
<span class="sd">        start : int</span>
<span class="sd">             `start` and `stop` frame index with `step` size: analyze</span>
<span class="sd">             ``trajectory[start:stop:step]`` [``None``]</span>
<span class="sd">        stop : int</span>
<span class="sd">        step : int</span>

<span class="sd">        .. versionchanged:: 1.0.0</span>
<span class="sd">           `store` and `filename` have been removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;metric&#39;</span><span class="p">,</span> <span class="s1">&#39;hausdorff&#39;</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;stop&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;step&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">metric_func</span> <span class="o">=</span> <span class="n">get_path_metric_func</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">metric</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">metric_func</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="n">numpaths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npaths</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numpaths</span><span class="p">,</span><span class="n">numpaths</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numpaths</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">numpaths</span><span class="p">):</span>
                <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
                <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">metric_func</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
                <span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">D</span></div>

<div class="viewcode-block" id="PSAnalysis.run_pairs_analysis"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.run_pairs_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_pairs_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform PSA Hausdorff (nearest neighbor) pairs analysis on all unique</span>
<span class="sd">        pairs of paths in :attr:`PSAnalysis.paths`.</span>

<span class="sd">        Partial results can be stored in separate lists, where each list is</span>
<span class="sd">        indexed according to distance vector convention (i.e., element *(i,j)*</span>
<span class="sd">        in distance matrix representation corresponds to element</span>
<span class="sd">        :math:`s=N*i+j-(i+1)*(i+2)` in distance vector representation, which is</span>
<span class="sd">        the :math:`s^\text{th}` comparison). For each unique pair of paths, the</span>
<span class="sd">        nearest neighbors for that pair can be stored in :attr:`NN` and the</span>
<span class="sd">        Hausdorff pair in :attr:`HP`. :attr:`PP` stores the full information</span>
<span class="sd">        of Hausdorff pairs analysis that is available for each pair of path,</span>
<span class="sd">        including nearest neighbors lists and the Hausdorff pairs.</span>

<span class="sd">        The pairwise distances are stored as the array :attr:`PSAnalysis.D`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int</span>
<span class="sd">             `start` and `stop` frame index with `step` size: analyze</span>
<span class="sd">             ``trajectory[start:stop:step]`` [``None``]</span>
<span class="sd">        stop : int</span>
<span class="sd">        step : int</span>
<span class="sd">        neighbors : bool</span>
<span class="sd">             if ``True``, then stores dictionary of nearest neighbor</span>
<span class="sd">             frames/distances in :attr:`PSAnalysis.NN` [``False``]</span>
<span class="sd">        hausdorff_pairs : bool</span>
<span class="sd">             if ``True``, then stores dictionary of Hausdorff pair</span>
<span class="sd">             frames/distances in :attr:`PSAnalysis.HP` [``False``]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;stop&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;step&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;neighbors&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">hausdorff_pairs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;hausdorff_pairs&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">numpaths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npaths</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numpaths</span><span class="p">,</span><span class="n">numpaths</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NN</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of nearest neighbors pairs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_HP</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of Hausdorff pairs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psa_pairs</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of PSAPairs</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numpaths</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">numpaths</span><span class="p">):</span>
                <span class="n">pp</span> <span class="o">=</span> <span class="n">PSAPair</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">numpaths</span><span class="p">)</span>
                <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">compute_nearest_neighbors</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">)</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">find_hausdorff_pair</span><span class="p">()</span>
                <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">hausdorff_pair</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span>
                <span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_psa_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">neighbors</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_NN</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">get_nearest_neighbors</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">hausdorff_pairs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_HP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">get_hausdorff_pair</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">D</span></div>

<div class="viewcode-block" id="PSAnalysis.save_paths"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.save_paths">[docs]</a>    <span class="k">def</span> <span class="nf">save_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save fitted :attr:`PSAnalysis.paths` to numpy compressed npz files.</span>

<span class="sd">        The data are saved with :func:`numpy.savez_compressed` in the directory</span>
<span class="sd">        specified by :attr:`PSAnalysis.targetdir`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">             specifies filename [``None``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filename : str</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        load</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="ow">or</span> <span class="s1">&#39;path_psa&#39;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span><span class="p">[</span><span class="s1">&#39;paths&#39;</span><span class="p">])</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Paths have not been calculated yet&quot;</span><span class="p">)</span>
        <span class="n">path_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">):</span>
            <span class="n">current_outfile</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}{1:03n}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">current_outfile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">path_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_outfile</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Wrote path to file </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">current_outfile</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_names</span> <span class="o">=</span> <span class="n">path_names</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_paths_pkl</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_names</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filename</span></div>

<div class="viewcode-block" id="PSAnalysis.load"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load fitted paths specified by &#39;psa_path-names.pkl&#39; in</span>
<span class="sd">        :attr:`PSAnalysis.targetdir`.</span>

<span class="sd">        All filenames are determined by :class:`PSAnalysis`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        save_paths</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_paths_pkl</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Fitted trajectories cannot be loaded; save file&quot;</span> <span class="o">+</span>
                              <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> does not exist.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_paths_pkl</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_paths_pkl</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pname</span><span class="p">)</span> <span class="k">for</span> <span class="n">pname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels_pkl</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels_pkl</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loaded paths from </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths_pkl</span><span class="p">)</span></div>

<div class="viewcode-block" id="PSAnalysis.plot"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linkage</span><span class="o">=</span><span class="s1">&#39;ward&#39;</span><span class="p">,</span> <span class="n">count_sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">distance_sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="mf">4.5</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot a clustered distance matrix.</span>

<span class="sd">        Usese method *linkage* and plots the corresponding dendrogram. Rows</span>
<span class="sd">        (and columns) are identified using the list of strings specified by</span>
<span class="sd">        :attr:`PSAnalysis.labels`.</span>

<span class="sd">        If `filename` is supplied then the figure is also written to file (the</span>
<span class="sd">        suffix determines the file type, e.g. pdf, png, eps, ...). All other</span>
<span class="sd">        keyword arguments are passed on to :func:`matplotlib.pyplot.matshow`.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">             save figure to *filename* [``None``]</span>
<span class="sd">        linkage : str</span>
<span class="sd">             name of linkage criterion for clustering [``&#39;ward&#39;``]</span>
<span class="sd">        count_sort : bool</span>
<span class="sd">             see :func:`scipy.cluster.hierarchy.dendrogram` [``False``]</span>
<span class="sd">        distance_sort : bool</span>
<span class="sd">             see :func:`scipy.cluster.hierarchy.dendrogram` [``False``]</span>
<span class="sd">        figsize : float</span>
<span class="sd">             set the vertical size of plot in inches [``4.5``]</span>
<span class="sd">        labelsize : float</span>
<span class="sd">             set the font size for colorbar labels; font size for path labels on</span>
<span class="sd">             dendrogram default to 3 points smaller [``12``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Z</span>
<span class="sd">          `Z` from :meth:`cluster`</span>
<span class="sd">        dgram</span>
<span class="sd">          `dgram` from :meth:`cluster`</span>
<span class="sd">        dist_matrix_clus</span>
<span class="sd">          clustered distance matrix (reordered)</span>

<span class="sd">        .. versionchanged:: 1.0.0</span>
<span class="sd">            :attr:`tick1On`, :attr:`tick2On`, :attr:`label1On` and :attr:`label2On`</span>
<span class="sd">            changed to :attr:`tick1line`, :attr:`tick2line`, :attr:`label1` and</span>
<span class="sd">            :attr:`label2` due to upstream deprecation (see #2493)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">figure</span><span class="p">,</span> <span class="n">colorbar</span><span class="p">,</span> <span class="n">cm</span><span class="p">,</span> <span class="n">savefig</span><span class="p">,</span> <span class="n">clf</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No distance data; do &#39;PSAnalysis.run()&#39; first.&quot;</span><span class="p">)</span>
        <span class="n">npaths</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>

        <span class="n">dgram_loc</span><span class="p">,</span> <span class="n">hmap_loc</span><span class="p">,</span> <span class="n">cbar_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plot_obj_locs</span><span class="p">()</span>
        <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="mf">1.25</span>
        <span class="n">clf</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">figsize</span><span class="o">*</span><span class="n">aspect_ratio</span><span class="p">,</span> <span class="n">figsize</span><span class="p">))</span>
        <span class="n">ax_hmap</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span><span class="n">hmap_loc</span><span class="p">)</span>
        <span class="n">ax_dgram</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span><span class="n">dgram_loc</span><span class="p">)</span>

        <span class="n">Z</span><span class="p">,</span> <span class="n">dgram</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">linkage</span><span class="p">,</span>                                 \
                                <span class="n">count_sort</span><span class="o">=</span><span class="n">count_sort</span><span class="p">,</span>                          \
                                <span class="n">distance_sort</span><span class="o">=</span><span class="n">distance_sort</span><span class="p">)</span>
        <span class="n">rowidx</span> <span class="o">=</span> <span class="n">colidx</span> <span class="o">=</span> <span class="n">dgram</span><span class="p">[</span><span class="s1">&#39;leaves&#39;</span><span class="p">]</span> <span class="c1"># get row-wise ordering from clustering</span>
        <span class="n">ax_dgram</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span> <span class="c1"># Place origin at up left (from low left)</span>

        <span class="n">minDist</span><span class="p">,</span> <span class="n">maxDist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>
        <span class="n">dist_matrix_clus</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">rowidx</span><span class="p">,:]</span>
        <span class="n">dist_matrix_clus</span> <span class="o">=</span> <span class="n">dist_matrix_clus</span><span class="p">[:,</span><span class="n">colidx</span><span class="p">]</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">dist_matrix_clus</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span>   \
                    <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">YlGn</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">minDist</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">maxDist</span><span class="p">)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span> <span class="c1"># Place origin at upper left (from lower left)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">locator_params</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="n">npaths</span><span class="p">)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npaths</span><span class="p">),</span> <span class="n">minor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npaths</span><span class="p">),</span> <span class="n">minor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span>            \
                        <span class="n">labelright</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">labeltop</span><span class="o">=</span><span class="s1">&#39;on&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="s1">&#39;on&#39;</span><span class="p">,</span>             \
                <span class="n">labelright</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">labeltop</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">rowlabels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rowidx</span><span class="p">]</span>
        <span class="n">collabels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">colidx</span><span class="p">]</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">collabels</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span>                 \
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">labelsize</span><span class="o">-</span><span class="mi">4</span><span class="p">),</span> <span class="n">multialignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ax_hmap</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">rowlabels</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span>               \
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">labelsize</span><span class="o">-</span><span class="mi">4</span><span class="p">),</span> <span class="n">multialignment</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span>          \
                <span class="n">minor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">ax_color</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span><span class="n">cbar_loc</span><span class="p">)</span>
        <span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">ax_color</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">minDist</span><span class="p">,</span> <span class="n">maxDist</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>  \
                <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%0.1f</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ax_color</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="n">labelsize</span><span class="p">)</span>

        <span class="c1"># Remove major ticks and labels from both heat map axes</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick2line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">label1</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">label2</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick2line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">label1</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">label2</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Remove minor ticks from both heat map axes</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_minor_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick2line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_minor_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick2line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Remove tickmarks from colorbar</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_color</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick2line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span><span class="p">[</span><span class="s1">&#39;plots&#39;</span><span class="p">])</span>
            <span class="n">outfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Z</span><span class="p">,</span> <span class="n">dgram</span><span class="p">,</span> <span class="n">dist_matrix_clus</span></div>

<div class="viewcode-block" id="PSAnalysis.plot_annotated_heatmap"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.plot_annotated_heatmap">[docs]</a>    <span class="k">def</span> <span class="nf">plot_annotated_heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linkage</span><span class="o">=</span><span class="s1">&#39;ward&#39;</span><span class="p">,</span>             \
                               <span class="n">count_sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">distance_sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>           \
                               <span class="n">figsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">annot_size</span><span class="o">=</span><span class="mf">6.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot a clustered distance matrix.</span>

<span class="sd">        Uses method `linkage` and plots annotated distances in the matrix. Rows</span>
<span class="sd">        (and columns) are identified using the list of strings specified by</span>
<span class="sd">        :attr:`PSAnalysis.labels`.</span>

<span class="sd">        If `filename` is supplied then the figure is also written to file (the</span>
<span class="sd">        suffix determines the file type, e.g. pdf, png, eps, ...). All other</span>
<span class="sd">        keyword arguments are passed on to :func:`matplotlib.pyplot.imshow`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">             save figure to *filename* [``None``]</span>
<span class="sd">        linkage : str</span>
<span class="sd">             name of linkage criterion for clustering [``&#39;ward&#39;``]</span>
<span class="sd">        count_sort : bool</span>
<span class="sd">             see :func:`scipy.cluster.hierarchy.dendrogram` [``False``]</span>
<span class="sd">        distance_sort : bool</span>
<span class="sd">             see :func:`scipy.cluster.hierarchy.dendrogram` [``False``]</span>
<span class="sd">        figsize : float</span>
<span class="sd">             set the vertical size of plot in inches [``4.5``]</span>
<span class="sd">        annot_size : float</span>
<span class="sd">             font size of annotation labels on heat map [``6.5``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Z</span>
<span class="sd">          `Z` from :meth:`cluster`</span>
<span class="sd">        dgram</span>
<span class="sd">          `dgram` from :meth:`cluster`</span>
<span class="sd">        dist_matrix_clus</span>
<span class="sd">          clustered distance matrix (reordered)</span>


<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This function requires the seaborn_ package, which can be installed</span>
<span class="sd">        with `pip install seaborn` or `conda install seaborn`.</span>

<span class="sd">        .. _seaborn: https://seaborn.pydata.org/</span>

<span class="sd">        .. versionchanged:: 1.0.0</span>
<span class="sd">            :attr:`tick1On`, :attr:`tick2On`, :attr:`label1On` and :attr:`label2On`</span>
<span class="sd">            changed to :attr:`tick1line`, :attr:`tick2line`, :attr:`label1` and</span>
<span class="sd">            :attr:`label2` due to upstream deprecation (see #2493)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">figure</span><span class="p">,</span> <span class="n">colorbar</span><span class="p">,</span> <span class="n">cm</span><span class="p">,</span> <span class="n">savefig</span><span class="p">,</span> <span class="n">clf</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;ERROR --- The seaborn package cannot be found!</span>

<span class="sd">                The seaborn API could not be imported. Please install it first.</span>
<span class="sd">                You can try installing with pip directly from the</span>
<span class="sd">                internet:</span>

<span class="sd">                  pip install seaborn</span>

<span class="sd">                Alternatively, download the package from</span>

<span class="sd">                  http://pypi.python.org/pypi/seaborn/</span>

<span class="sd">                and install in the usual manner.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No distance data; do &#39;PSAnalysis.run()&#39; first.&quot;</span><span class="p">)</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>

        <span class="n">Z</span><span class="p">,</span> <span class="n">dgram</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">linkage</span><span class="p">,</span>                                 \
                                <span class="n">count_sort</span><span class="o">=</span><span class="n">count_sort</span><span class="p">,</span>                          \
                                <span class="n">distance_sort</span><span class="o">=</span><span class="n">distance_sort</span><span class="p">,</span>                    \
                                <span class="n">no_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">rowidx</span> <span class="o">=</span> <span class="n">colidx</span> <span class="o">=</span> <span class="n">dgram</span><span class="p">[</span><span class="s1">&#39;leaves&#39;</span><span class="p">]</span> <span class="c1"># get row-wise ordering from clustering</span>
        <span class="n">dist_matrix_clus</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">rowidx</span><span class="p">,:]</span>
        <span class="n">dist_matrix_clus</span> <span class="o">=</span> <span class="n">dist_matrix_clus</span><span class="p">[:,</span><span class="n">colidx</span><span class="p">]</span>

        <span class="n">clf</span><span class="p">()</span>
        <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="mf">1.25</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">figsize</span><span class="o">*</span><span class="n">aspect_ratio</span><span class="p">,</span> <span class="n">figsize</span><span class="p">))</span>
        <span class="n">ax_hmap</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax_hmap</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">dist_matrix_clus</span><span class="p">,</span>                                 \
                         <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">YlGn</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;3.1f&#39;</span><span class="p">,</span> \
                         <span class="n">square</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">xticklabels</span><span class="o">=</span><span class="n">rowidx</span><span class="p">,</span> <span class="n">yticklabels</span><span class="o">=</span><span class="n">colidx</span><span class="p">,</span>   \
                         <span class="n">annot_kws</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax_hmap</span><span class="p">)</span>

        <span class="c1"># Remove major ticks from both heat map axes</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick2line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">label1</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">label2</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick2line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">label1</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">label2</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Remove minor ticks from both heat map axes</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_minor_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick2line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">ax_hmap</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_minor_ticks</span><span class="p">():</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick1line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tic</span><span class="o">.</span><span class="n">tick2line</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span><span class="p">[</span><span class="s1">&#39;plots&#39;</span><span class="p">])</span>
            <span class="n">outfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Z</span><span class="p">,</span> <span class="n">dgram</span><span class="p">,</span> <span class="n">dist_matrix_clus</span></div>

<div class="viewcode-block" id="PSAnalysis.plot_nearest_neighbors"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.plot_nearest_neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">plot_nearest_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>                      \
                               <span class="n">labels</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Path 1&#39;</span><span class="p">,</span> <span class="s1">&#39;Path 2&#39;</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="mf">4.5</span><span class="p">,</span>        \
                               <span class="n">multiplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">aspect_ratio</span><span class="o">=</span><span class="mf">1.75</span><span class="p">,</span>              \
                               <span class="n">labelsize</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot nearest neighbor distances as a function of normalized frame</span>
<span class="sd">        number.</span>

<span class="sd">        The frame number is mapped to the interval *[0, 1]*.</span>

<span class="sd">        If `filename` is supplied then the figure is also written to file (the</span>
<span class="sd">        suffix determines the file type, e.g. pdf, png, eps, ...). All other</span>
<span class="sd">        keyword arguments are passed on to :func:`matplotlib.pyplot.imshow`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">             save figure to *filename* [``None``]</span>
<span class="sd">        idx : int</span>
<span class="sd">             index of path (pair) comparison to plot [``0``]</span>
<span class="sd">        labels : (str, str)</span>
<span class="sd">             pair of names to label nearest neighbor distance</span>
<span class="sd">             curves [``(&#39;Path 1&#39;, &#39;Path 2&#39;)``]</span>
<span class="sd">        figsize : float</span>
<span class="sd">             set the vertical size of plot in inches [``4.5``]</span>
<span class="sd">        multiplot : bool</span>
<span class="sd">             set to ``True`` to enable plotting multiple nearest</span>
<span class="sd">             neighbor distances on the same figure [``False``]</span>
<span class="sd">        aspect_ratio : float</span>
<span class="sd">             set the ratio of width to height of the plot [``1.75``]</span>
<span class="sd">        labelsize : float</span>
<span class="sd">             set the font size for colorbar labels; font size for path labels on</span>
<span class="sd">             dendrogram default to 3 points smaller [``12``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : axes</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This function requires the seaborn_ package, which can be installed</span>
<span class="sd">        with `pip install seaborn` or `conda install seaborn`.</span>

<span class="sd">        .. _seaborn: https://seaborn.pydata.org/</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">figure</span><span class="p">,</span> <span class="n">savefig</span><span class="p">,</span> <span class="n">tight_layout</span><span class="p">,</span> <span class="n">clf</span><span class="p">,</span> <span class="n">show</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;ERROR --- The seaborn package cannot be found!</span>

<span class="sd">                The seaborn API could not be imported. Please install it first.</span>
<span class="sd">                You can try installing with pip directly from the</span>
<span class="sd">                internet:</span>

<span class="sd">                  pip install seaborn</span>

<span class="sd">                Alternatively, download the package from</span>

<span class="sd">                  http://pypi.python.org/pypi/seaborn/</span>

<span class="sd">                and install in the usual manner.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

        <span class="n">colors</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">xkcd_palette</span><span class="p">([</span><span class="s2">&quot;cherry&quot;</span><span class="p">,</span> <span class="s2">&quot;windows blue&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NN</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No nearest neighbor data; run &quot;</span>
                             <span class="s2">&quot;&#39;PSAnalysis.run_pairs_analysis(neighbors=True)&#39; first.&quot;</span><span class="p">)</span>

        <span class="n">sns</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="s1">&#39;whitegrid&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">multiplot</span><span class="p">:</span>
            <span class="n">clf</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">figsize</span><span class="o">*</span><span class="n">aspect_ratio</span><span class="p">,</span> <span class="n">figsize</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="n">nn_dist_P</span><span class="p">,</span> <span class="n">nn_dist_Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NN</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;distances&#39;</span><span class="p">]</span>
        <span class="n">frames_P</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nn_dist_P</span><span class="p">)</span>
        <span class="n">frames_Q</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nn_dist_Q</span><span class="p">)</span>
        <span class="n">progress_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">frames_P</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">*</span><span class="n">frames_P</span><span class="p">)</span>
        <span class="n">progress_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">frames_Q</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">*</span><span class="n">frames_Q</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">progress_P</span><span class="p">,</span> <span class="n">nn_dist_P</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">progress_Q</span><span class="p">,</span> <span class="n">nn_dist_Q</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(normalized) progress by frame number&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;nearest neighbor rmsd ($\AA$)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;major&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">sns</span><span class="o">.</span><span class="n">despine</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadirs</span><span class="p">[</span><span class="s1">&#39;plots&#39;</span><span class="p">])</span>
            <span class="n">outfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="PSAnalysis.cluster"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.cluster">[docs]</a>    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_mat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ward&#39;</span><span class="p">,</span> <span class="n">count_sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>           \
                <span class="n">distance_sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">no_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">no_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>             \
                <span class="n">color_threshold</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cluster trajectories and optionally plot the dendrogram.</span>

<span class="sd">        This method is used by :meth:`PSAnalysis.plot` to generate a heatmap-</span>
<span class="sd">        dendrogram combination plot. By default, the distance matrix,</span>
<span class="sd">        :attr:`PSAnalysis.D`, is assumed to exist, converted to</span>
<span class="sd">        distance-vector form, and inputted to :func:`cluster.hierarchy.linkage`</span>
<span class="sd">        to generate a clustering. For convenience in plotting arbitrary</span>
<span class="sd">        distance matrices, one can also be specify `dist_mat`, which will be</span>
<span class="sd">        checked for proper distance matrix form by</span>
<span class="sd">        :func:`spatial.distance.squareform`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dist_mat : numpy.ndarray</span>
<span class="sd">            user-specified distance matrix to be clustered [``None``]</span>
<span class="sd">        method : str</span>
<span class="sd">            name of linkage criterion for clustering [``&#39;ward&#39;``]</span>
<span class="sd">        no_plot : bool</span>
<span class="sd">            if ``True``, do not render the dendrogram [``False``]</span>
<span class="sd">        no_labels : bool</span>
<span class="sd">            if ``True`` then do not label dendrogram [``True``]</span>
<span class="sd">        color_threshold : float</span>
<span class="sd">            For brevity, let t be the color_threshold. Colors all the</span>
<span class="sd">            descendent links below a cluster node k the same color if k is</span>
<span class="sd">            the first node below the cut threshold t. All links connecting</span>
<span class="sd">            nodes with distances greater than or equal to the threshold are</span>
<span class="sd">            colored blue. If t is less than or equal to zero, all nodes are</span>
<span class="sd">            colored blue. If color_threshold is None or ‘default’,</span>
<span class="sd">            corresponding with MATLAB(TM) behavior, the threshold is set to</span>
<span class="sd">            0.7*max(Z[:,2]). [``4``]]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Z</span>
<span class="sd">            output from :func:`scipy.cluster.hierarchy.linkage`;</span>
<span class="sd">            list of indices representing the row-wise order of the objects</span>
<span class="sd">            after clustering</span>
<span class="sd">        dgram</span>
<span class="sd">            output from :func:`scipy.cluster.hierarchy.dendrogram`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># perhaps there is a better way to manipulate the plot... or perhaps it</span>
        <span class="c1"># is not even necessary? In any case, the try/finally makes sure that</span>
        <span class="c1"># we are not permanently changing the user&#39;s global state</span>
        <span class="n">orig_linewidth</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.linewidth&#39;</span><span class="p">]</span>
        <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.linewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dist_mat</span><span class="p">:</span>
                <span class="n">dist_vec</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">dist_mat</span><span class="p">,</span>
                                                       <span class="n">force</span><span class="o">=</span><span class="s1">&#39;tovector&#39;</span><span class="p">,</span>
                                                       <span class="n">checks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dist_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pairwise_distances</span><span class="p">(</span><span class="n">vectorform</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">linkage</span><span class="p">(</span><span class="n">dist_vec</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
            <span class="n">dgram</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">dendrogram</span><span class="p">(</span>
                <span class="n">Z</span><span class="p">,</span> <span class="n">no_labels</span><span class="o">=</span><span class="n">no_labels</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span>
                <span class="n">count_sort</span><span class="o">=</span><span class="n">count_sort</span><span class="p">,</span> <span class="n">distance_sort</span><span class="o">=</span><span class="n">distance_sort</span><span class="p">,</span>
                <span class="n">no_plot</span><span class="o">=</span><span class="n">no_plot</span><span class="p">,</span> <span class="n">color_threshold</span><span class="o">=</span><span class="n">color_threshold</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.linewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_linewidth</span>
        <span class="k">return</span> <span class="n">Z</span><span class="p">,</span> <span class="n">dgram</span></div>

    <span class="k">def</span> <span class="nf">_get_plot_obj_locs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find and return coordinates for dendrogram, heat map, and colorbar.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">          tuple of coordinates for placing the dendrogram, heat map, and</span>
<span class="sd">          colorbar in the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plot_xstart</span> <span class="o">=</span> <span class="mf">0.04</span>
        <span class="n">plot_ystart</span> <span class="o">=</span> <span class="mf">0.04</span>
        <span class="n">label_margin</span> <span class="o">=</span> <span class="mf">0.155</span>

        <span class="n">dgram_height</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="c1"># dendrogram heights(s)</span>
        <span class="n">hmap_xstart</span> <span class="o">=</span> <span class="n">plot_xstart</span> <span class="o">+</span> <span class="n">dgram_height</span> <span class="o">+</span> <span class="n">label_margin</span>

        <span class="c1"># Set locations for dendrogram(s), matrix, and colorbar</span>
        <span class="n">hmap_height</span> <span class="o">=</span> <span class="mf">0.8</span>
        <span class="n">hmap_width</span> <span class="o">=</span> <span class="mf">0.6</span>
        <span class="n">dgram_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">plot_xstart</span><span class="p">,</span> <span class="n">plot_ystart</span><span class="p">,</span> <span class="n">dgram_height</span><span class="p">,</span> <span class="n">hmap_height</span><span class="p">]</span>
        <span class="n">cbar_width</span> <span class="o">=</span> <span class="mf">0.02</span>
        <span class="n">cbar_xstart</span> <span class="o">=</span> <span class="n">hmap_xstart</span> <span class="o">+</span> <span class="n">hmap_width</span> <span class="o">+</span> <span class="mf">0.01</span>
        <span class="n">cbar_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">cbar_xstart</span><span class="p">,</span> <span class="n">plot_ystart</span><span class="p">,</span> <span class="n">cbar_width</span><span class="p">,</span> <span class="n">hmap_height</span><span class="p">]</span>
        <span class="n">hmap_loc</span> <span class="o">=</span>  <span class="p">[</span><span class="n">hmap_xstart</span><span class="p">,</span> <span class="n">plot_ystart</span><span class="p">,</span> <span class="n">hmap_width</span><span class="p">,</span> <span class="n">hmap_height</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dgram_loc</span><span class="p">,</span> <span class="n">hmap_loc</span><span class="p">,</span> <span class="n">cbar_loc</span>

<div class="viewcode-block" id="PSAnalysis.get_num_atoms"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.get_num_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_num_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of atoms used to construct the :class:`Path` instances in</span>
<span class="sd">        :class:`PSA`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            the number of atoms in any path</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Must run :meth:`PSAnalysis.generate_paths` prior to calling this</span>
<span class="sd">        method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No path data; do &#39;PSAnalysis.generate_paths()&#39; first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span></div>

<div class="viewcode-block" id="PSAnalysis.get_num_paths"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.get_num_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_num_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of paths in :class:`PSA`.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Must run :meth:`PSAnalysis.generate_paths` prior to calling this method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">           the number of paths in :class:`PSA`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npaths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No path data; do &#39;PSAnalysis.generate_paths()&#39; first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">npaths</span></div>

<div class="viewcode-block" id="PSAnalysis.get_paths"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.get_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the paths in :class:`PSA`.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Must run :meth:`PSAnalysis.generate_paths` prior to calling this</span>
<span class="sd">        method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of :class:`numpy.ndarray` representations of paths in</span>
<span class="sd">            :class:`PSA`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No path data; do &#39;PSAnalysis.generate_paths()&#39; first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span></div>

<div class="viewcode-block" id="PSAnalysis.get_pairwise_distances"><a class="viewcode-back" href="../../../documentation_pages/analysis/psa.html#MDAnalysis.analysis.psa.PSAnalysis.get_pairwise_distances">[docs]</a>    <span class="k">def</span> <span class="nf">get_pairwise_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectorform</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the distance matrix (or vector) of pairwise path distances.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Must run :meth:`PSAnalysis.run` prior to calling this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vectorform : bool</span>
<span class="sd">             if ``True``, return the distance vector instead [``False``]</span>
<span class="sd">        checks : bool</span>
<span class="sd">             if ``True``, check that :attr:`PSAnalysis.D` is a proper distance</span>
<span class="sd">             matrix [``False``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">             representation of the distance matrix (or vector)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No distance data; do &#39;PSAnalysis.run()&#39; first.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vectorform</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="s1">&#39;tovector&#39;</span><span class="p">,</span>
                                               <span class="n">checks</span><span class="o">=</span><span class="n">checks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">psa_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The list of :class:`PSAPair` instances for each pair of paths.</span>

<span class="sd">        :attr:`psa_pairs` is a list of all :class:`PSAPair` objects (in</span>
<span class="sd">        distance vector order). The elements of a :class:`PSAPair` are pairs of</span>
<span class="sd">        paths that have been compared using</span>
<span class="sd">        :meth:`PSAnalysis.run_pairs_analysis`. Each :class:`PSAPair` contains</span>
<span class="sd">        nearest neighbor and Hausdorff pair information specific to a pair of</span>
<span class="sd">        paths. The nearest neighbor frames and distances for a :class:`PSAPair`</span>
<span class="sd">        can be accessed in the nearest neighbor dictionary using the keys</span>
<span class="sd">        &#39;frames&#39; and &#39;distances&#39;, respectively. E.g.,</span>
<span class="sd">        :attr:`PSAPair.nearest_neighbors[&#39;distances&#39;]` returns a *pair* of</span>
<span class="sd">        :class:`numpy.ndarray` corresponding to the nearest neighbor distances</span>
<span class="sd">        for each path. Similarly, Hausdorff pair information can be accessed</span>
<span class="sd">        using :attr:`PSAPair.hausdorff_pair` with the keys &#39;frames&#39; and</span>
<span class="sd">        &#39;distance&#39;.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Must run :meth:`PSAnalysis.run_pairs_analysis` prior to calling this</span>
<span class="sd">        method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psa_pairs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No nearest neighbors data; do&quot;</span>
                             <span class="s2">&quot; &#39;PSAnalysis.run_pairs_analysis()&#39; first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psa_pairs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hausdorff_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The Hausdorff pair for each (unique) pairs of paths.</span>

<span class="sd">        This attribute contains a list of Hausdorff pair information (in</span>
<span class="sd">        distance vector order), where each element is a dictionary containing</span>
<span class="sd">        the pair of frames and the (Hausdorff) distance between a pair of</span>
<span class="sd">        paths. See :meth:`PSAnalysis.psa_pairs` and</span>
<span class="sd">        :attr:`PSAPair.hausdorff_pair` for more information about accessing</span>
<span class="sd">        Hausdorff pair data.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Must run :meth:`PSAnalysis.run_pairs_analysis` with</span>
<span class="sd">        ``hausdorff_pairs=True`` prior to calling this method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No Hausdorff pairs data; do &quot;</span>
                             <span class="s2">&quot;&#39;PSAnalysis.run_pairs_analysis(hausdorff_pairs=True)&#39; &quot;</span>
                             <span class="s2">&quot;first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HP</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nearest_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The nearest neighbors for each (unique) pair of paths.</span>

<span class="sd">        This attribute contains a list of nearest neighbor information (in</span>
<span class="sd">        distance vector order), where each element is a dictionary containing</span>
<span class="sd">        the nearest neighbor frames and distances between a pair of paths. See</span>
<span class="sd">        :meth:`PSAnalysis.psa_pairs` and :attr:`PSAPair.nearest_neighbors` for</span>
<span class="sd">        more information about accessing nearest neighbor data.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Must run :meth:`PSAnalysis.run_pairs_analysis` with</span>
<span class="sd">        ``neighbors=True`` prior to calling this method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NN</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No nearest neighbors data; do&quot;</span>
                             <span class="s2">&quot; &#39;PSAnalysis.run_pairs_analysis(neighbors=True)&#39;&quot;</span>
                             <span class="s2">&quot; first.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NN</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2023, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Henok Ademtew, Shobhit Agarwal, Aya M. Alaa, Irfan Alibay, Kazi Shudipto Amin, Anshul Angaria, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Patricio Barletta, Leonardo Barneschi, Jonathan Barnoud, Estefania Barreto-Ojeda, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Kavya Bisht, Wouter Boomsma, Jose Borreguero, Cédric Bouysset, Kevin Boyd, Meet Brijwani, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, Yantong Cai, David Caplan, Yuanyu Chang, Pratham Chauhan, Matthieu Chavent, Haochuan Chen, Xu Hong Chen, Kathleen Clark, Jennifer A Clark, Orion Cohen, Charlie Cook, Ruggero Cortini, Nicholas Craven, Ramon Crehuet, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Mark D. Driver, Ali Ehlen, Daniel J. Evans, Shujie Fan, Bjarne Feddersen, Lennard van der Feltz, Jake Fennick, Philip Fowler, Guillaume Fraux, Anirvinya G, Ahmed Salah Ghoneim, Mikhail Glagolev, William Glass, Joseph Goose, Alexander Gorfer, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Pratik Gupta, Benjamin Hall, Ameya Harmalkar, Ivan Hristov, Eugen Hruska, Kyle J. Huston, Siddharth Jain, Edis Jakupovic, Joe Jordan, Henrik Jäger, Uma D Kadam, Aditya Kamath, Jon Kapla, Haleema Khan, Navya Khare, Utsav Khatu, Andrew William King, Henry Kobin, Abhishek A. Kognole, Kosuke Kudo, Atharva Kulkarni, Manish Kumar, Alia Lescoulie, Max Linke, Philip Loche, Jinju Lu, Hugo MacDermott-Opeskin, Shaivi Malik, Egor Marin, Domenico Marson, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Rocco Meli, Manuel Nuno Melo, Marcelo C. R. Melo, Dominik &#39;Rathann&#39; Mierzejewski, Henry Mull, Morgan L. Nance, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Meghan Osato, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Dimitrios Papageorgiou, Rafael R. Pappalardo, Vishal Parmar, Danny Parton, Shakul Pathak, Christian Pfaendner, Joshua L. Phillips, Marcelo D. Poleto, Hannah Pollak, Kashish Punjani, Michael Quevillon, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Andrea Rizzi, Xiaoxu Ruan, Carlos Yanez S., Utkarsh Saxena, Moritz Schaeffler, Alexander Schlaich, Marcello Sega, Ricky Sexton, Sean L. Seyler, Faraaz Shah, Sulay Shah, Abhishek Shandilya, Shubham Sharma, Rishabh Shukla, Karthikeyan Singaravelan, Tamandeep Singh, Paul Smith, Andy Somogyi, Caio S. Souza, Shantanu Srivastava, Lukas Stelzl, Jan Stevens, Gorman Stock, Fenil Suchak, Ayush Suhane, Filip T. Szczypiński, Sukeerti T, Matthijs Tadema, Joao Miguel Correia Teixeira, Paarth Thadani, Matthew W. Thompson, Hao Tian, Matteo Tiberti, Wiep van der Toorn, Mieczyslaw Torchala, Aditi Tripathi, Mark Verma, Josh Vermaas, Isaac Virshup, Lily Wang, Nestor Wendt, Zhiyi Wu, Tengyu Xie, Zhuyi Xue, Mingyi Xue, Alexander Yang, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, Raymond Zhao, Yuxuan Zhuang, and Oliver Beckstein.</p>
  </div>

  
 
<div class="footer"><p>Please see
    our <a href="https://www.mdanalysis.org/pages/privacy/">Privacy Policy</a>
    to learn how <a href="https://www.mdanalysis.org">MDAnalysis</a> collects data.</p>
    <script data-goatcounter="https://mdanalysis.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
    var versions_json_url = 'https://docs.mdanalysis.org/versions.json'
</script>

<div class="rst-versions" data-toggle="rst-versions" role="note"
     aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
        2.5.0
      <span class="fa fa-caret-down"></span>
    </span>

    <div class="rst-other-versions">
        <dl id="versionselector">
            <dt>Other Versions</dt>
        </dl>

    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>