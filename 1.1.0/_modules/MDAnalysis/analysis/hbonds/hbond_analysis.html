

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>MDAnalysis.analysis.hbonds.hbond_analysis &mdash; MDAnalysis 1.1.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/msmb.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/mdanalysis-logo.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../../../../_static/js/versions.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 1.1.0 documentation"
          href="../../../../_static/opensearch.xml"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="../../../../index.html">
          

          
            
            <img src="../../../../_static/mdanalysis-logo-thin.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/converters.html">7. Converter modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/trajectory_transformations.html">8. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/selections_modules.html">9. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/auxiliary_modules.html">10. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/core_modules.html">11. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/visualization_modules.html">12. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/lib_modules.html">13. Library functions — <code class="docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/version.html">14. Version information for MDAnalysis - <code class="docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/units.html">15. Constants and unit conversion — <code class="docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/exceptions.html">16. Custom exceptions and warnings — <code class="docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/references.html">17. References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MDAnalysis</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>MDAnalysis.analysis.hbonds.hbond_analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for MDAnalysis.analysis.hbonds.hbond_analysis</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1"># doi: 10.25080/majora-629e541a-00e</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="c1"># Hydrogen Bonding Analysis</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;Hydrogen Bond analysis (Deprecated) --- :mod:`MDAnalysis.analysis.hbonds.hbond_analysis`</span>
<span class="sd">============================================================================================</span>

<span class="sd">:Author: David Caplan, Lukas Grossar, Oliver Beckstein</span>
<span class="sd">:Year: 2010-2017</span>
<span class="sd">:Copyright: GNU Public License v3</span>

<span class="sd">..Warning:</span>
<span class="sd">    This module is deprecated and will be removed in version 2.0.</span>
<span class="sd">    Please use :mod:`MDAnalysis.analysis.hydrogenbonds.hbond_analysis` instead.</span>

<span class="sd">Given a :class:`~MDAnalysis.core.universe.Universe` (simulation</span>
<span class="sd">trajectory with 1 or more frames) measure all hydrogen bonds for each</span>
<span class="sd">frame between selections 1 and 2.</span>

<span class="sd">The :class:`HydrogenBondAnalysis` class is modeled after the `VMD</span>
<span class="sd">HBONDS plugin`_.</span>

<span class="sd">.. _`VMD HBONDS plugin`: http://www.ks.uiuc.edu/Research/vmd/plugins/hbonds/</span>

<span class="sd">Options:</span>
<span class="sd">  - *update_selections* (``True``): update selections at each frame?</span>
<span class="sd">  - *selection_1_type* (&quot;both&quot;): selection 1 is the: &quot;donor&quot;, &quot;acceptor&quot;, &quot;both&quot;</span>
<span class="sd">  - donor-acceptor *distance* (Å): 3.0</span>
<span class="sd">  - Angle *cutoff* (degrees): 120.0</span>
<span class="sd">  - *forcefield* to switch between default values for different force fields</span>
<span class="sd">  - *donors* and *acceptors* atom types (to add additional atom names)</span>

<span class="sd">.. _Analysis Output:</span>

<span class="sd">Output</span>
<span class="sd">------</span>

<span class="sd">The results are</span>
<span class="sd">  - the **identities** of donor and acceptor heavy-atoms,</span>
<span class="sd">  - the **distance** between the heavy atom acceptor atom and the hydrogen atom</span>
<span class="sd">    that is bonded to the heavy atom donor,</span>
<span class="sd">  - the **angle** donor-hydrogen-acceptor angle (180º is linear).</span>

<span class="sd">Hydrogen bond data are returned per frame, which is stored in</span>
<span class="sd">:attr:`HydrogenBondAnalysis.timeseries` (In the following description, ``#``</span>
<span class="sd">indicates comments that are not part of the output.)::</span>

<span class="sd">    results = [</span>
<span class="sd">        [ # frame 1</span>
<span class="sd">           [ # hbond 1</span>
<span class="sd">              &lt;donor index (0-based)&gt;,</span>
<span class="sd">              &lt;acceptor index (0-based)&gt;, &lt;donor string&gt;, &lt;acceptor string&gt;,</span>
<span class="sd">              &lt;distance&gt;, &lt;angle&gt;</span>
<span class="sd">           ],</span>
<span class="sd">           [ # hbond 2</span>
<span class="sd">              &lt;donor index (0-based)&gt;,</span>
<span class="sd">              &lt;acceptor index (0-based)&gt;, &lt;donor string&gt;, &lt;acceptor string&gt;,</span>
<span class="sd">              &lt;distance&gt;, &lt;angle&gt;</span>
<span class="sd">           ],</span>
<span class="sd">           ....</span>
<span class="sd">        ],</span>
<span class="sd">        [ # frame 2</span>
<span class="sd">          [ ... ], [ ... ], ...</span>
<span class="sd">        ],</span>
<span class="sd">        ...</span>
<span class="sd">    ]</span>

<span class="sd">Using the :meth:`HydrogenBondAnalysis.generate_table` method one can reformat</span>
<span class="sd">the results as a flat &quot;normalised&quot; table that is easier to import into a</span>
<span class="sd">database or dataframe for further processing. The table itself is a</span>
<span class="sd">:class:`numpy.recarray`.</span>

<span class="sd">.. _Detection-of-hydrogen-bonds:</span>

<span class="sd">Detection of hydrogen bonds</span>
<span class="sd">---------------------------</span>

<span class="sd">Hydrogen bonds are recorded based on a geometric criterion:</span>

<span class="sd">1. The distance between acceptor and hydrogen is less than or equal to</span>
<span class="sd">   `distance` (default is 3 Å).</span>

<span class="sd">2. The angle between donor-hydrogen-acceptor is greater than or equal to</span>
<span class="sd">   `angle` (default is 120º).</span>

<span class="sd">The cut-off values `angle` and `distance` can be set as keywords to</span>
<span class="sd">:class:`HydrogenBondAnalysis`.</span>

<span class="sd">Donor and acceptor heavy atoms are detected from atom names. The current</span>
<span class="sd">defaults are appropriate for the CHARMM27 and GLYCAM06 force fields as defined</span>
<span class="sd">in Table `Default atom names for hydrogen bonding analysis`_.</span>

<span class="sd">Hydrogen atoms bonded to a donor are searched with one of two algorithms,</span>
<span class="sd">selected with the `detect_hydrogens` keyword.</span>

<span class="sd">&quot;distance&quot;</span>
<span class="sd">   Searches for all hydrogens (name &quot;H*&quot; or name &quot;[123]H&quot; or type &quot;H&quot;) in the</span>
<span class="sd">   same residue as the donor atom within a cut-off distance of 1.2 Å.</span>

<span class="sd">&quot;heuristic&quot;</span>
<span class="sd">   Looks at the next three atoms in the list of atoms following the donor and</span>
<span class="sd">   selects any atom whose name matches (name &quot;H*&quot; or name &quot;[123]H&quot;). For</span>

<span class="sd">The &quot;distance&quot; search is more rigorous but slower and is set as the</span>
<span class="sd">default. Until release 0.7.6, only the heuristic search was implemented.</span>

<span class="sd">.. versionchanged:: 0.7.6</span>
<span class="sd">   Distance search added (see</span>
<span class="sd">   :meth:`HydrogenBondAnalysis._get_bonded_hydrogens_dist`) and heuristic</span>
<span class="sd">   search improved (:meth:`HydrogenBondAnalysis._get_bonded_hydrogens_list`)</span>

<span class="sd">.. _Default atom names for hydrogen bonding analysis:</span>

<span class="sd">.. table:: Default heavy atom names for CHARMM27 force field.</span>

<span class="sd">   =========== ==============  =========== ====================================</span>
<span class="sd">   group       donor           acceptor    comments</span>
<span class="sd">   =========== ==============  =========== ====================================</span>
<span class="sd">   main chain  N               O, OC1, OC2 OC1, OC2 from amber99sb-ildn</span>
<span class="sd">                                           (Gromacs)</span>
<span class="sd">   water       OH2, OW         OH2, OW     SPC, TIP3P, TIP4P (CHARMM27,Gromacs)</span>

<span class="sd">   ARG         NE, NH1, NH2</span>
<span class="sd">   ASN         ND2             OD1</span>
<span class="sd">   ASP                         OD1, OD2</span>
<span class="sd">   CYS         SG</span>
<span class="sd">   CYH                         SG          possible false positives for CYS</span>
<span class="sd">   GLN         NE2             OE1</span>
<span class="sd">   GLU                         OE1, OE2</span>
<span class="sd">   HIS         ND1, NE2        ND1, NE2    presence of H determines if donor</span>
<span class="sd">   HSD         ND1             NE2</span>
<span class="sd">   HSE         NE2             ND1</span>
<span class="sd">   HSP         ND1, NE2</span>
<span class="sd">   LYS         NZ</span>
<span class="sd">   MET                         SD          see e.g. [Gregoret1991]_</span>
<span class="sd">   SER         OG              OG</span>
<span class="sd">   THR         OG1             OG1</span>
<span class="sd">   TRP         NE1</span>
<span class="sd">   TYR         OH              OH</span>
<span class="sd">   =========== ==============  =========== ====================================</span>

<span class="sd">.. table:: Heavy atom types for GLYCAM06 force field.</span>

<span class="sd">   =========== =========== ==================</span>
<span class="sd">   element     donor       acceptor</span>
<span class="sd">   =========== =========== ==================</span>
<span class="sd">   N           N,NT,N3     N,NT</span>
<span class="sd">   O           OH,OW       O,O2,OH,OS,OW,OY</span>
<span class="sd">   S                       SM</span>
<span class="sd">   =========== =========== ==================</span>

<span class="sd">Donor and acceptor names for the CHARMM27 force field will also work for e.g.</span>
<span class="sd">OPLS/AA (tested in Gromacs). Residue names in the table are for information</span>
<span class="sd">only and are not taken into account when determining acceptors and donors.</span>
<span class="sd">This can potentially lead to some ambiguity in the assignment of</span>
<span class="sd">donors/acceptors for residues such as histidine or cytosine.</span>

<span class="sd">For more information about the naming convention in GLYCAM06 have a look at the</span>
<span class="sd">`Carbohydrate Naming Convention in Glycam`_.</span>

<span class="sd">.. _`Carbohydrate Naming Convention in Glycam`:</span>
<span class="sd">   http://glycam.ccrc.uga.edu/documents/FutureNomenclature.htm</span>

<span class="sd">The lists of donor and acceptor names can be extended by providing lists of</span>
<span class="sd">atom names in the `donors` and `acceptors` keywords to</span>
<span class="sd">:class:`HydrogenBondAnalysis`. If the lists are entirely inappropriate</span>
<span class="sd">(e.g. when analysing simulations done with a force field that uses very</span>
<span class="sd">different atom names) then one should either use the value &quot;other&quot; for `forcefield`</span>
<span class="sd">to set no default values, or derive a new class and set the default list oneself::</span>

<span class="sd"> class HydrogenBondAnalysis_OtherFF(HydrogenBondAnalysis):</span>
<span class="sd">       DEFAULT_DONORS = {&quot;OtherFF&quot;: tuple(set([...]))}</span>
<span class="sd">       DEFAULT_ACCEPTORS = {&quot;OtherFF&quot;: tuple(set([...]))}</span>

<span class="sd">Then simply use the new class instead of the parent class and call it with</span>
<span class="sd">`forcefield` = &quot;OtherFF&quot;. Please also consider to contribute the list of heavy</span>
<span class="sd">atom names to MDAnalysis.</span>

<span class="sd">.. rubric:: References</span>

<span class="sd">.. [Gregoret1991] L.M. Gregoret, S.D. Rader, R.J. Fletterick, and</span>
<span class="sd">   F.E. Cohen. Hydrogen bonds involving sulfur atoms in proteins. Proteins,</span>
<span class="sd">   9(2):99–107, 1991. `10.1002/prot.340090204`_.</span>

<span class="sd">.. _`10.1002/prot.340090204`: http://dx.doi.org/10.1002/prot.340090204</span>


<span class="sd">How to perform HydrogenBondAnalysis</span>
<span class="sd">-----------------------------------</span>

<span class="sd">All protein-water hydrogen bonds can be analysed with ::</span>

<span class="sd">  import MDAnalysis</span>
<span class="sd">  import MDAnalysis.analysis.hbonds</span>

<span class="sd">  u = MDAnalysis.Universe(&#39;topology&#39;, &#39;trajectory&#39;)</span>
<span class="sd">  h = MDAnalysis.analysis.hbonds.HydrogenBondAnalysis(u, &#39;protein&#39;, &#39;resname HOH&#39;, distance=3.0, angle=120.0)</span>
<span class="sd">  h.run()</span>

<span class="sd">.. Note::</span>

<span class="sd">   Due to the way :class:`HydrogenBondAnalysis` is implemented, it is</span>
<span class="sd">   more efficient to have the second selection (`selection2`) be the</span>
<span class="sd">   *larger* group, e.g. the water when looking at water-protein</span>
<span class="sd">   H-bonds or the whole protein when looking at ligand-protein</span>
<span class="sd">   interactions.</span>


<span class="sd">The results are stored as the attribute</span>
<span class="sd">:attr:`HydrogenBondAnalysis.timeseries`; see :ref:`Analysis Output` for the</span>
<span class="sd">format and further options.</span>

<span class="sd">A number of convenience functions are provided to process the</span>
<span class="sd">:attr:`~HydrogenBondAnalysis.timeseries` according to varying criteria:</span>

<span class="sd">:meth:`~HydrogenBondAnalysis.count_by_time`</span>
<span class="sd">   time series of the number of hydrogen bonds per time step</span>
<span class="sd">:meth:`~HydrogenBondAnalysis.count_by_type`</span>
<span class="sd">   data structure with the frequency of each observed hydrogen bond</span>
<span class="sd">:meth:`~HydrogenBondAnalysis.timesteps_by_type`</span>
<span class="sd">   data structure with a list of time steps for each observed hydrogen bond</span>

<span class="sd">For further data analysis it is convenient to process the</span>
<span class="sd">:attr:`~HydrogenBondAnalysis.timeseries` data into a normalized table with the</span>
<span class="sd">:meth:`~HydrogenBondAnalysis.generate_table` method, which creates a new data</span>
<span class="sd">structure :attr:`HydrogenBondAnalysis.table` that contains one row for each</span>
<span class="sd">observation of a hydrogen bond::</span>

<span class="sd">  h.generate_table()</span>

<span class="sd">This table can then be easily turned into, e.g., a `pandas.DataFrame`_, and</span>
<span class="sd">further analyzed::</span>

<span class="sd">  import pandas as pd</span>
<span class="sd">  df = pd.DataFrame.from_records(h.table)</span>

<span class="sd">For example, plotting a histogram of the hydrogen bond angles and lengths is as</span>
<span class="sd">simple as ::</span>

<span class="sd">  df.hist(column=[&quot;angle&quot;, &quot;distance&quot;])</span>

<span class="sd">.. _pandas.DataFrame: http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html</span>


<span class="sd">.. TODO: notes on selection updating</span>


<span class="sd">Classes</span>
<span class="sd">-------</span>

<span class="sd">.. autoclass:: HydrogenBondAnalysis</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: timesteps</span>

<span class="sd">      List of the times of each timestep. This can be used together with</span>
<span class="sd">      :attr:`~HydrogenBondAnalysis.timeseries` to find the specific time point</span>
<span class="sd">      of a hydrogen bond existence, or see :attr:`~HydrogenBondAnalysis.table`.</span>

<span class="sd">   .. attribute:: table</span>

<span class="sd">      A normalised table of the data in</span>
<span class="sd">      :attr:`HydrogenBondAnalysis.timeseries`, generated by</span>
<span class="sd">      :meth:`HydrogenBondAnalysis.generate_table`. It is a</span>
<span class="sd">      :class:`numpy.recarray` with the following columns:</span>

<span class="sd">          0. &quot;time&quot;</span>
<span class="sd">          1. &quot;donor_index&quot;</span>
<span class="sd">          2. &quot;acceptor_index&quot;</span>
<span class="sd">          3. &quot;donor_resnm&quot;</span>
<span class="sd">          4. &quot;donor_resid&quot;</span>
<span class="sd">          5. &quot;donor_atom&quot;</span>
<span class="sd">          6. &quot;acceptor_resnm&quot;</span>
<span class="sd">          7. &quot;acceptor_resid&quot;</span>
<span class="sd">          8. &quot;acceptor_atom&quot;</span>
<span class="sd">          9. &quot;distance&quot;</span>
<span class="sd">          10. &quot;angle&quot;</span>

<span class="sd">      It takes up more space than :attr:`~HydrogenBondAnalysis.timeseries` but</span>
<span class="sd">      it is easier to analyze and to import into databases or dataframes.</span>


<span class="sd">      .. rubric:: Example</span>

<span class="sd">      For example, to create a `pandas.DataFrame`_ from ``h.table``::</span>

<span class="sd">         import pandas as pd</span>
<span class="sd">         df = pd.DataFrame.from_records(h.table)</span>


<span class="sd">      .. versionchanged:: 0.17.0</span>
<span class="sd">         The 1-based donor and acceptor indices (*donor_idx* and</span>
<span class="sd">         *acceptor_idx*) are deprecated in favor of 0-based indices.</span>

<span class="sd">   .. automethod:: _get_bonded_hydrogens</span>

<span class="sd">   .. automethod:: _get_bonded_hydrogens_dist</span>

<span class="sd">   .. automethod:: _get_bonded_hydrogens_list</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">zip</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">MissingDataWarning</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">,</span> <span class="n">SelectionError</span><span class="p">,</span> <span class="n">SelectionWarning</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">base</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.log</span> <span class="kn">import</span> <span class="n">ProgressBar</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.NeighborSearch</span> <span class="kn">import</span> <span class="n">AtomNeighborSearch</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib</span> <span class="kn">import</span> <span class="n">distances</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.correlations</span> <span class="kn">import</span> <span class="n">autocorrelation</span><span class="p">,</span> <span class="n">correct_intermittency</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;MDAnalysis.analysis.hbonds&#39;</span><span class="p">)</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;This module is deprecated as of MDAnalysis version 1.0.&quot;</span>
            <span class="s2">&quot;It will be removed in MDAnalysis version 2.0&quot;</span>
            <span class="s2">&quot;Please use MDAnalysis.analysis.hydrogenbonds.hbond_analysis instead.&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span>
        <span class="p">)</span>


<div class="viewcode-block" id="HydrogenBondAnalysis"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis">[docs]</a><span class="k">class</span> <span class="nc">HydrogenBondAnalysis</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">AnalysisBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a hydrogen bond analysis</span>

<span class="sd">    The analysis of the trajectory is performed with the</span>
<span class="sd">    :meth:`HydrogenBondAnalysis.run` method. The result is stored in</span>
<span class="sd">    :attr:`HydrogenBondAnalysis.timeseries`. See</span>
<span class="sd">    :meth:`~HydrogenBondAnalysis.run` for the format.</span>

<span class="sd">    The default atom names are taken from the CHARMM 27 force field files, which</span>
<span class="sd">    will also work for e.g. OPLS/AA in Gromacs, and GLYCAM06.</span>

<span class="sd">    *Donors* (associated hydrogens are deduced from topology)</span>
<span class="sd">      *CHARMM 27*</span>
<span class="sd">        N of the main chain, water OH2/OW, ARG NE/NH1/NH2, ASN ND2, HIS ND1/NE2,</span>
<span class="sd">        SER OG, TYR OH, CYS SG, THR OG1, GLN NE2, LYS NZ, TRP NE1</span>
<span class="sd">      *GLYCAM06*</span>
<span class="sd">        N,NT,N3,OH,OW</span>

<span class="sd">    *Acceptors*</span>
<span class="sd">      *CHARMM 27*</span>
<span class="sd">        O of the main chain, water OH2/OW, ASN OD1, ASP OD1/OD2, CYH SG, GLN OE1,</span>
<span class="sd">        GLU OE1/OE2, HIS ND1/NE2, MET SD, SER OG, THR OG1, TYR OH</span>
<span class="sd">      *GLYCAM06*</span>
<span class="sd">        N,NT,O,O2,OH,OS,OW,OY,P,S,SM</span>
<span class="sd">      *amber99sb-ildn(Gromacs)*</span>
<span class="sd">        OC1, OC2 of the main chain</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :ref:`Default atom names for hydrogen bonding analysis`</span>


<span class="sd">    .. versionchanged:: 0.7.6</span>
<span class="sd">       DEFAULT_DONORS/ACCEPTORS is now embedded in a dict to switch between</span>
<span class="sd">       default values for different force fields.</span>

<span class="sd">    .. versionchanged:: 1.0.0</span>
<span class="sd">        Added autocorrelation (MDAnalysis.lib.correlations.py) for calculating hydrogen bond lifetime</span>
<span class="sd">       ``save_table()`` method has been removed. You can use ``np.save()`` or</span>
<span class="sd">       ``cPickle.dump()`` on :attr:`HydrogenBondAnalysis.table` instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># use tuple(set()) here so that one can just copy&amp;paste names from the</span>
    <span class="c1"># table; set() takes care for removing duplicates. At the end the</span>
    <span class="c1"># DEFAULT_DONORS and DEFAULT_ACCEPTORS should simply be tuples.</span>

    <span class="c1">#: default heavy atom names whose hydrogens are treated as *donors*</span>
    <span class="c1">#: (see :ref:`Default atom names for hydrogen bonding analysis`);</span>
    <span class="c1">#: use the keyword `donors` to add a list of additional donor names.</span>
    <span class="n">DEFAULT_DONORS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;CHARMM27&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span>
            <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;OH2&#39;</span><span class="p">,</span> <span class="s1">&#39;OW&#39;</span><span class="p">,</span> <span class="s1">&#39;NE&#39;</span><span class="p">,</span> <span class="s1">&#39;NH1&#39;</span><span class="p">,</span> <span class="s1">&#39;NH2&#39;</span><span class="p">,</span> <span class="s1">&#39;ND2&#39;</span><span class="p">,</span> <span class="s1">&#39;SG&#39;</span><span class="p">,</span> <span class="s1">&#39;NE2&#39;</span><span class="p">,</span> <span class="s1">&#39;ND1&#39;</span><span class="p">,</span> <span class="s1">&#39;NZ&#39;</span><span class="p">,</span> <span class="s1">&#39;OG&#39;</span><span class="p">,</span> <span class="s1">&#39;OG1&#39;</span><span class="p">,</span> <span class="s1">&#39;NE1&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">])),</span>
        <span class="s1">&#39;GLYCAM06&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;NT&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">,</span> <span class="s1">&#39;OW&#39;</span><span class="p">])),</span>
        <span class="s1">&#39;other&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([]))}</span>

    <span class="c1">#: default atom names that are treated as hydrogen *acceptors*</span>
    <span class="c1">#: (see :ref:`Default atom names for hydrogen bonding analysis`);</span>
    <span class="c1">#: use the keyword `acceptors` to add a list of additional acceptor names.</span>
    <span class="n">DEFAULT_ACCEPTORS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;CHARMM27&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span>
            <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;OC1&#39;</span><span class="p">,</span> <span class="s1">&#39;OC2&#39;</span><span class="p">,</span> <span class="s1">&#39;OH2&#39;</span><span class="p">,</span> <span class="s1">&#39;OW&#39;</span><span class="p">,</span> <span class="s1">&#39;OD1&#39;</span><span class="p">,</span> <span class="s1">&#39;OD2&#39;</span><span class="p">,</span> <span class="s1">&#39;SG&#39;</span><span class="p">,</span> <span class="s1">&#39;OE1&#39;</span><span class="p">,</span> <span class="s1">&#39;OE1&#39;</span><span class="p">,</span> <span class="s1">&#39;OE2&#39;</span><span class="p">,</span> <span class="s1">&#39;ND1&#39;</span><span class="p">,</span> <span class="s1">&#39;NE2&#39;</span><span class="p">,</span> <span class="s1">&#39;SD&#39;</span><span class="p">,</span> <span class="s1">&#39;OG&#39;</span><span class="p">,</span> <span class="s1">&#39;OG1&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">])),</span>
        <span class="s1">&#39;GLYCAM06&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;NT&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;O2&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">,</span> <span class="s1">&#39;OS&#39;</span><span class="p">,</span> <span class="s1">&#39;OW&#39;</span><span class="p">,</span> <span class="s1">&#39;OY&#39;</span><span class="p">,</span> <span class="s1">&#39;SM&#39;</span><span class="p">])),</span>
        <span class="s1">&#39;other&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([]))}</span>

    <span class="c1">#: A :class:`collections.defaultdict` of covalent radii of common donors</span>
    <span class="c1">#: (used in :meth`_get_bonded_hydrogens_list` to check if a hydrogen is</span>
    <span class="c1">#: sufficiently close to its donor heavy atom). Values are stored for</span>
    <span class="c1">#: N, O, P, and S. Any other heavy atoms are assumed to have hydrogens</span>
    <span class="c1">#: covalently bound at a maximum distance of 1.5 Å.</span>
    <span class="n">r_cov</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">,</span>  <span class="c1"># default value</span>
                        <span class="n">N</span><span class="o">=</span><span class="mf">1.31</span><span class="p">,</span> <span class="n">O</span><span class="o">=</span><span class="mf">1.31</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="mf">1.58</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="mf">1.55</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="n">selection1</span><span class="o">=</span><span class="s1">&#39;protein&#39;</span><span class="p">,</span> <span class="n">selection2</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">selection1_type</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span>
                 <span class="n">update_selection1</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update_selection2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filter_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">distance_type</span><span class="o">=</span><span class="s1">&#39;hydrogen&#39;</span><span class="p">,</span>
                 <span class="n">distance</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mf">120.0</span><span class="p">,</span>
                 <span class="n">forcefield</span><span class="o">=</span><span class="s1">&#39;CHARMM27&#39;</span><span class="p">,</span> <span class="n">donors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">acceptors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">detect_hydrogens</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set up calculation of hydrogen bonds between two selections in a universe.</span>

<span class="sd">        The timeseries is accessible as the attribute :attr:`HydrogenBondAnalysis.timeseries`.</span>

<span class="sd">        Some initial checks are performed. If there are no atoms selected by</span>
<span class="sd">        `selection1` or `selection2` or if no donor hydrogens or acceptor atoms</span>
<span class="sd">        are found then a :exc:`SelectionError` is raised for any selection that</span>
<span class="sd">        does *not* update (`update_selection1` and `update_selection2`</span>
<span class="sd">        keywords). For selections that are set to update, only a warning is</span>
<span class="sd">        logged because it is assumed that the selection might contain atoms at</span>
<span class="sd">        a later frame (e.g. for distance based selections).</span>

<span class="sd">        If no hydrogen bonds are detected or if the initial check fails, look</span>
<span class="sd">        at the log output (enable with :func:`MDAnalysis.start_logging` and set</span>
<span class="sd">        `verbose` ``=True``). It is likely that the default names for donors</span>
<span class="sd">        and acceptors are not suitable (especially for non-standard</span>
<span class="sd">        ligands). In this case, either change the `forcefield` or use</span>
<span class="sd">        customized `donors` and/or `acceptors`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        universe : Universe</span>
<span class="sd">            Universe object</span>
<span class="sd">        selection1 : str (optional)</span>
<span class="sd">            Selection string for first selection [&#39;protein&#39;]</span>
<span class="sd">        selection2 : str (optional)</span>
<span class="sd">            Selection string for second selection [&#39;all&#39;]</span>
<span class="sd">        selection1_type : {&quot;donor&quot;, &quot;acceptor&quot;, &quot;both&quot;} (optional)</span>
<span class="sd">            Selection 1 can be &#39;donor&#39;, &#39;acceptor&#39; or &#39;both&#39;. Note that the</span>
<span class="sd">            value for `selection1_type` automatically determines how</span>
<span class="sd">            `selection2` handles donors and acceptors: If `selection1` contains</span>
<span class="sd">            &#39;both&#39; then `selection2` will also contain &#39;both&#39;. If `selection1`</span>
<span class="sd">            is set to &#39;donor&#39; then `selection2` is &#39;acceptor&#39; (and vice versa).</span>
<span class="sd">            [&#39;both&#39;].</span>
<span class="sd">        update_selection1 : bool (optional)</span>
<span class="sd">            Update selection 1 at each frame? Setting to ``False`` is recommended</span>
<span class="sd">            for any static selection to increase performance. [``True``]</span>
<span class="sd">        update_selection2 : bool (optional)</span>
<span class="sd">            Update selection 2 at each frame? Setting to ``False`` is recommended</span>
<span class="sd">            for any static selection to increase performance. [``True``]</span>
<span class="sd">        filter_first : bool (optional)</span>
<span class="sd">            Filter selection 2 first to only atoms 3 * `distance` away [``True``]</span>
<span class="sd">        distance : float (optional)</span>
<span class="sd">            Distance cutoff for hydrogen bonds; only interactions with a H-A distance</span>
<span class="sd">            &lt;= `distance` (and the appropriate D-H-A angle, see `angle`) are</span>
<span class="sd">            recorded. (Note: `distance_type` can change this to the D-A distance.) [3.0]</span>
<span class="sd">        angle : float (optional)</span>
<span class="sd">            Angle cutoff for hydrogen bonds; an ideal H-bond has an angle of</span>
<span class="sd">            180º.  A hydrogen bond is only recorded if the D-H-A angle is</span>
<span class="sd">            &gt;=  `angle`. The default of 120º also finds fairly non-specific</span>
<span class="sd">            hydrogen interactions and a possibly better value is 150º. [120.0]</span>
<span class="sd">        forcefield : {&quot;CHARMM27&quot;, &quot;GLYCAM06&quot;, &quot;other&quot;} (optional)</span>
<span class="sd">            Name of the forcefield used. Switches between different</span>
<span class="sd">            :attr:`~HydrogenBondAnalysis.DEFAULT_DONORS` and</span>
<span class="sd">            :attr:`~HydrogenBondAnalysis.DEFAULT_ACCEPTORS` values.</span>
<span class="sd">            [&quot;CHARMM27&quot;]</span>
<span class="sd">        donors : sequence (optional)</span>
<span class="sd">            Extra H donor atom types (in addition to those in</span>
<span class="sd">            :attr:`~HydrogenBondAnalysis.DEFAULT_DONORS`), must be a sequence.</span>
<span class="sd">        acceptors : sequence (optional)</span>
<span class="sd">            Extra H acceptor atom types (in addition to those in</span>
<span class="sd">            :attr:`~HydrogenBondAnalysis.DEFAULT_ACCEPTORS`), must be a sequence.</span>
<span class="sd">        detect_hydrogens : {&quot;distance&quot;, &quot;heuristic&quot;} (optional)</span>
<span class="sd">            Determine the algorithm to find hydrogens connected to donor</span>
<span class="sd">            atoms. Can be &quot;distance&quot; (default; finds all hydrogens in the</span>
<span class="sd">            donor&#39;s residue within a cutoff of the donor) or &quot;heuristic&quot;</span>
<span class="sd">            (looks for the next few atoms in the atom list). &quot;distance&quot; should</span>
<span class="sd">            always give the correct answer but &quot;heuristic&quot; is faster,</span>
<span class="sd">            especially when the donor list is updated each</span>
<span class="sd">            for each frame. [&quot;distance&quot;]</span>
<span class="sd">        distance_type : {&quot;hydrogen&quot;, &quot;heavy&quot;} (optional)</span>
<span class="sd">            Measure hydrogen bond lengths between donor and acceptor heavy</span>
<span class="sd">            attoms (&quot;heavy&quot;) or between donor hydrogen and acceptor heavy</span>
<span class="sd">            atom (&quot;hydrogen&quot;). If using &quot;heavy&quot; then one should set the *distance*</span>
<span class="sd">            cutoff to a higher value such as 3.5 Å. [&quot;hydrogen&quot;]</span>
<span class="sd">        debug : bool (optional)</span>
<span class="sd">            If set to ``True`` enables per-frame debug logging. This is disabled</span>
<span class="sd">            by default because it generates a very large amount of output in</span>
<span class="sd">            the log file. (Note that a logger must have been started to see</span>
<span class="sd">            the output, e.g. using :func:`MDAnalysis.start_logging`.) [``False``]</span>
<span class="sd">        verbose : bool (optional)</span>
<span class="sd">            Toggle progress output. (Can also be given as keyword argument to</span>
<span class="sd">            :meth:`run`.)</span>
<span class="sd">        pbc : bool (optional)</span>
<span class="sd">            Whether to consider periodic boundaries in calculations [``False``]</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        :exc:`SelectionError`</span>
<span class="sd">            is raised for each static selection without the required</span>
<span class="sd">            donors and/or acceptors.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In order to speed up processing, atoms are filtered by a coarse</span>
<span class="sd">        distance criterion before a detailed hydrogen bonding analysis is</span>
<span class="sd">        performed (`filter_first` = ``True``). If one of your selections is</span>
<span class="sd">        e.g. the solvent then `update_selection1` (or `update_selection2`) must</span>
<span class="sd">        also be ``True`` so that the list of candidate atoms is updated at each</span>
<span class="sd">        step: this is now the default.</span>

<span class="sd">        If your selections will essentially remain the same for all time steps</span>
<span class="sd">        (i.e. residues are not moving farther than 3 x `distance`), for</span>
<span class="sd">        instance, if neither water nor large conformational changes are</span>
<span class="sd">        involved or if the optimization is disabled (`filter_first` =</span>
<span class="sd">        ``False``) then you can improve performance by setting the</span>
<span class="sd">        `update_selection1` and/or `update_selection2` keywords to ``False``.</span>


<span class="sd">        .. versionchanged:: 0.7.6</span>
<span class="sd">           New `verbose` keyword (and per-frame debug logging disabled by</span>
<span class="sd">           default).</span>

<span class="sd">           New `detect_hydrogens` keyword to switch between two different</span>
<span class="sd">           algorithms to detect hydrogens bonded to donor. &quot;distance&quot; is a new,</span>
<span class="sd">           rigorous distance search within the residue of the donor atom,</span>
<span class="sd">           &quot;heuristic&quot; is the previous list scan (improved with an additional</span>
<span class="sd">           distance check).</span>

<span class="sd">           New `forcefield` keyword to switch between different values of</span>
<span class="sd">           DEFAULT_DONORS/ACCEPTORS to accomodate different force fields.</span>
<span class="sd">           Also has an option &quot;other&quot; for no default values.</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           The new default for `update_selection1` and `update_selection2` is now</span>
<span class="sd">           ``True`` (see `Issue 138`_). Set to ``False`` if your selections only</span>
<span class="sd">           need to be determined once (will increase performance).</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           New keyword `distance_type` to select between calculation between</span>
<span class="sd">           heavy atoms or hydrogen-acceptor. It defaults to the previous</span>
<span class="sd">           behavior (i.e. &quot;hydrogen&quot;).</span>

<span class="sd">        .. versionchanged:: 0.11.0</span>
<span class="sd">           Initial checks for selections that potentially raise :exc:`SelectionError`.</span>

<span class="sd">        .. versionchanged:: 0.17.0</span>
<span class="sd">           use 0-based indexing</span>

<span class="sd">        .. deprecated:: 0.16</span>
<span class="sd">           The previous `verbose` keyword argument was replaced by</span>
<span class="sd">           `debug`. Note that the `verbose` keyword argument is now</span>
<span class="sd">           consistently used to toggle progress meters throughout the library.</span>

<span class="sd">        .. _`Issue 138`: https://github.com/MDAnalysis/mdanalysis/issues/138</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">HydrogenBondAnalysis</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;This class is deprecated as of MDAnalysis version 1.0 and will &quot;</span>
            <span class="s2">&quot;be removed in version 2.0.&quot;</span>
            <span class="s2">&quot;Please use MDAnalysis.analysis.hydrogenbonds.hbond_analysis.HydrogenBondAnalysis instead.&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span>
        <span class="p">)</span>

        <span class="c1"># per-frame debugging output?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens_algorithms</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;distance&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens_dist</span><span class="p">,</span>  <span class="c1"># 0.7.6 default</span>
            <span class="s2">&quot;heuristic&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens_list</span><span class="p">,</span>  <span class="c1"># pre 0.7.6</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">detect_hydrogens</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens_algorithms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;detect_hydrogens must be one of </span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens_algorithms</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detect_hydrogens</span> <span class="o">=</span> <span class="n">detect_hydrogens</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection1</span> <span class="o">=</span> <span class="n">selection1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span> <span class="o">=</span> <span class="n">selection2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="o">=</span> <span class="n">selection1_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection1</span> <span class="o">=</span> <span class="n">update_selection1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection2</span> <span class="o">=</span> <span class="n">update_selection2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_first</span> <span class="o">=</span> <span class="n">filter_first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span> <span class="o">=</span> <span class="n">distance_type</span>  <span class="c1"># note: everything except &#39;heavy&#39; will give the default behavior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>

        <span class="c1"># set up the donors/acceptors lists</span>
        <span class="k">if</span> <span class="n">donors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">donors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">acceptors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">acceptors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcefield</span> <span class="o">=</span> <span class="n">forcefield</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">donors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_DONORS</span><span class="p">[</span><span class="n">forcefield</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">donors</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_ACCEPTORS</span><span class="p">[</span><span class="n">forcefield</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">acceptors</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;HydrogenBondAnalysis: invalid selections&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;HydrogenBondAnalysis: Invalid selection type </span><span class="si">{0!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_timeseries</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># final result accessed as self.timeseries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># time for each frame</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># placeholder for output table</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_selection_1</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_selection_2</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log_parameters</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="o">==</span> <span class="s1">&#39;donor&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;donors&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;acceptors&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="o">==</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;acceptors&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;donors&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># both</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;donors&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;acceptors&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;acceptors&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;donors&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;HBond analysis: initial checks passed.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="n">htype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;sanity check the selections 1 and 2</span>

<span class="sd">        *selection* is 1 or 2, *htype* is &quot;donors&quot; or &quot;acceptors&quot;</span>

<span class="sd">        If selections do not update and the required donor and acceptor</span>
<span class="sd">        selections are empty then a :exc:`SelectionError` is immediately</span>
<span class="sd">        raised.</span>

<span class="sd">        If selections update dynamically then it is possible that the selection</span>
<span class="sd">        will yield donors/acceptors at a later step and we only issue a</span>
<span class="sd">        warning.</span>

<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">selection</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">htype</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;donors&quot;</span><span class="p">,</span> <span class="s2">&quot;acceptors&quot;</span><span class="p">)</span>
        <span class="c1"># horrible data organization:  _s1_donors, _s2_acceptors, etc, update_selection1, ...</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_s</span><span class="si">{0}</span><span class="s2">_</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">htype</span><span class="p">))</span>
        <span class="n">update</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;update_selection</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">selection</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;No </span><span class="si">{1}</span><span class="s2"> found in selection </span><span class="si">{0}</span><span class="s2">. &quot;</span> \
                <span class="s2">&quot;You might have to specify a custom &#39;</span><span class="si">{1}</span><span class="s2">&#39; keyword.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">selection</span><span class="p">,</span> <span class="n">htype</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">update</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="s2">&quot; Selection will update so continuing with fingers crossed.&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">errmsg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">SelectionWarning</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_log_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Log important parameters to the logfile.&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;HBond analysis: selection1 = </span><span class="si">%r</span><span class="s2"> (update: </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_selection1</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;HBond analysis: selection2 = </span><span class="si">%r</span><span class="s2"> (update: </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_selection2</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;HBond analysis: criterion: donor </span><span class="si">%s</span><span class="s2"> atom and acceptor atom distance &lt;= </span><span class="si">%.3f</span><span class="s2"> A&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;HBond analysis: criterion: angle D-H-A &gt;= </span><span class="si">%.3f</span><span class="s2"> degrees&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;HBond analysis: force field </span><span class="si">%s</span><span class="s2"> to guess donor and acceptor names&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcefield</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;HBond analysis: bonded hydrogen detection algorithm: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">detect_hydrogens</span><span class="p">)</span>

<div class="viewcode-block" id="HydrogenBondAnalysis._get_bonded_hydrogens"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis._get_bonded_hydrogens">[docs]</a>    <span class="k">def</span> <span class="nf">_get_bonded_hydrogens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find hydrogens bonded to `atom`.</span>

<span class="sd">        This method is typically not called by a user but it is documented to</span>
<span class="sd">        facilitate understanding of the internals of</span>
<span class="sd">        :class:`HydrogenBondAnalysis`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : groups.Atom</span>
<span class="sd">             heavy atom</span>
<span class="sd">        **kwargs</span>
<span class="sd">             passed through to the calculation method that was selected with</span>
<span class="sd">             the `detect_hydrogens` kwarg of :class:`HydrogenBondAnalysis`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hydrogen_atoms : AtomGroup or []</span>
<span class="sd">            list of hydrogens (can be a :class:`~MDAnalysis.core.groups.AtomGroup`)</span>
<span class="sd">            or empty list ``[]`` if none were found.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`_get_bonded_hydrogens_dist`</span>
<span class="sd">        :meth:`_get_bonded_hydrogens_list`</span>


<span class="sd">        .. versionchanged:: 0.7.6</span>
<span class="sd">           Can switch algorithm by using the `detect_hydrogens` keyword to the</span>
<span class="sd">           constructor. *kwargs* can be used to supply arguments for algorithm.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens_algorithms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">detect_hydrogens</span><span class="p">](</span><span class="n">atom</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="HydrogenBondAnalysis._get_bonded_hydrogens_dist"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis._get_bonded_hydrogens_dist">[docs]</a>    <span class="k">def</span> <span class="nf">_get_bonded_hydrogens_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find hydrogens bonded within cutoff to `atom`.</span>

<span class="sd">        Hydrogens are detected by either name (&quot;H*&quot;, &quot;[123]H*&quot;) or type (&quot;H&quot;);</span>
<span class="sd">        this is not fool-proof as the atom type is not always a character but</span>
<span class="sd">        the name pattern should catch most typical occurrences.</span>

<span class="sd">        The distance from `atom` is calculated for all hydrogens in the residue</span>
<span class="sd">        and only those within a cutoff are kept. The cutoff depends on the</span>
<span class="sd">        heavy atom (more precisely, on its element, which is taken as the first</span>
<span class="sd">        letter of its name ``atom.name[0]``) and is parameterized in</span>
<span class="sd">        :attr:`HydrogenBondAnalysis.r_cov`. If no match is found then the</span>
<span class="sd">        default of 1.5 Å is used.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : groups.Atom</span>
<span class="sd">             heavy atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hydrogen_atoms : AtomGroup or []</span>
<span class="sd">            list of hydrogens (can be a :class:`~MDAnalysis.core.groups.AtomGroup`)</span>
<span class="sd">            or empty list ``[]`` if none were found.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The performance of this implementation could be improved once the</span>
<span class="sd">        topology always contains bonded information; it currently uses the</span>
<span class="sd">        selection parser with an &quot;around&quot; selection.</span>


<span class="sd">        .. versionadded:: 0.7.6</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s2">&quot;(name H* 1H* 2H* 3H* or type H) and around </span><span class="si">{0:f}</span><span class="s2"> name </span><span class="si">{1!s}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r_cov</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">NoDataError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="HydrogenBondAnalysis._get_bonded_hydrogens_list"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis._get_bonded_hydrogens_list">[docs]</a>    <span class="k">def</span> <span class="nf">_get_bonded_hydrogens_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find &quot;bonded&quot; hydrogens to the donor *atom*.</span>

<span class="sd">        At the moment this relies on the **assumption** that the</span>
<span class="sd">        hydrogens are listed directly after the heavy atom in the</span>
<span class="sd">        topology. If this is not the case then this function will</span>
<span class="sd">        fail.</span>

<span class="sd">        Hydrogens are detected by name ``H*``, ``[123]H*`` and they have to be</span>
<span class="sd">        within a maximum distance from the heavy atom. The cutoff distance</span>
<span class="sd">        depends on the heavy atom and is parameterized in</span>
<span class="sd">        :attr:`HydrogenBondAnalysis.r_cov`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : groups.Atom</span>
<span class="sd">             heavy atom</span>
<span class="sd">        **kwargs</span>
<span class="sd">             ignored</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hydrogen_atoms : AtomGroup or []</span>
<span class="sd">            list of hydrogens (can be a :class:`~MDAnalysis.core.groups.AtomGroup`)</span>
<span class="sd">            or empty list ``[]`` if none were found.</span>


<span class="sd">        .. versionchanged:: 0.7.6</span>

<span class="sd">           Added detection of ``[123]H`` and additional check that a</span>
<span class="sd">           selected hydrogen is bonded to the donor atom (i.e. its</span>
<span class="sd">           distance to the donor is less than the covalent radius</span>
<span class="sd">           stored in :attr:`HydrogenBondAnalysis.r_cov` or the default</span>
<span class="sd">           1.5 Å).</span>

<span class="sd">           Changed name to</span>
<span class="sd">           :meth:`~HydrogenBondAnalysis._get_bonded_hydrogens_list`</span>
<span class="sd">           and added *kwargs* so that it can be used instead of</span>
<span class="sd">           :meth:`~HydrogenBondAnalysis._get_bonded_hydrogens_dist`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;_get_bonded_hydrogens_list() (heuristic detection) does &quot;</span>
                      <span class="s2">&quot;not always find &quot;</span>
                      <span class="s2">&quot;all hydrogens; Using detect_hydrogens=&#39;distance&#39;, when &quot;</span>
                      <span class="s2">&quot;constructing the HydrogenBondAnalysis class is safer. &quot;</span>
                      <span class="s2">&quot;Removal of this feature is targeted for 1.0&quot;</span><span class="p">,</span>
                      <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hydrogens</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;1H&#39;</span><span class="p">,</span> <span class="s1">&#39;2H&#39;</span><span class="p">,</span> <span class="s1">&#39;3H&#39;</span><span class="p">))</span> <span class="ow">and</span>
                    <span class="n">distances</span><span class="o">.</span><span class="n">calc_bonds</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_cov</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">hydrogens</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># weird corner case that atom is the last one in universe</span>
        <span class="k">return</span> <span class="n">hydrogens</span></div>

    <span class="k">def</span> <span class="nf">_update_selection_1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Size of selection 1: </span><span class="si">{0}</span><span class="s2"> atoms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Selection 1 &#39;</span><span class="si">{0}</span><span class="s2">&#39; did not select any atoms.&quot;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">)[:</span><span class="mi">80</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tmp</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 donors: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 donor hydrogens: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 acceptors: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_update_selection_2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_first</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s1">&#39;Size of selection 2 before filtering:&#39;</span>
                              <span class="s1">&#39; </span><span class="si">{}</span><span class="s1"> atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)))</span>
            <span class="n">ns_selection_2</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span> <span class="o">=</span> <span class="n">ns_selection_2</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">,</span> <span class="mf">3.</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s1">&#39;Size of selection 2: </span><span class="si">{0}</span><span class="s1"> atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Selection 2 &quot;</span><span class="si">{0}</span><span class="s1">&quot; did not select any atoms.&#39;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">)[:</span><span class="mi">80</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 acceptors: </span><span class="si">{0:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tmp</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 donors: </span><span class="si">{0:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 donor hydrogens: </span><span class="si">{0:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">logger_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<div class="viewcode-block" id="HydrogenBondAnalysis.run"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyze trajectory and produce timeseries.</span>

<span class="sd">        Stores the hydrogen bond data per frame as</span>
<span class="sd">        :attr:`HydrogenBondAnalysis.timeseries` (see there for output</span>
<span class="sd">        format).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int (optional)</span>
<span class="sd">            starting frame-index for analysis, ``None`` is the first one, 0.</span>
<span class="sd">            `start` and `stop` are 0-based frame indices and are used to slice</span>
<span class="sd">            the trajectory (if supported) [``None``]</span>
<span class="sd">        stop : int (optional)</span>
<span class="sd">            last trajectory frame for analysis, ``None`` is the last one [``None``]</span>
<span class="sd">        step : int (optional)</span>
<span class="sd">            read every `step` between `start` (included) and `stop` (excluded),</span>
<span class="sd">            ``None`` selects 1. [``None``]</span>
<span class="sd">        verbose : bool (optional)</span>
<span class="sd">             toggle progress meter output :class:`~MDAnalysis.lib.log.ProgressMeter`</span>
<span class="sd">             [``True``]</span>
<span class="sd">        debug : bool (optional)</span>
<span class="sd">             enable detailed logging of debugging information; this can create</span>
<span class="sd">             *very big* log files so it is disabled (``False``) by default; setting</span>
<span class="sd">             `debug` toggles the debug status for :class:`HydrogenBondAnalysis`,</span>
<span class="sd">             namely the value of :attr:`HydrogenBondAnalysis.debug`.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        remove_duplicates : bool (optional)</span>
<span class="sd">             duplicate hydrogen bonds are removed from output if set to the</span>
<span class="sd">             default value ``True``; normally, this should not be changed.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`HydrogenBondAnalysis.generate_table` :</span>
<span class="sd">               processing the data into a different format.</span>


<span class="sd">        .. versionchanged:: 0.7.6</span>
<span class="sd">           Results are not returned, only stored in</span>
<span class="sd">           :attr:`~HydrogenBondAnalysis.timeseries` and duplicate hydrogen bonds</span>
<span class="sd">           are removed from output (can be suppressed with `remove_duplicates` =</span>
<span class="sd">           ``False``)</span>

<span class="sd">        .. versionchanged:: 0.11.0</span>
<span class="sd">           Accept `quiet` keyword. Analysis will now proceed through frames even if</span>
<span class="sd">           no donors or acceptors were found in a particular frame.</span>

<span class="sd">        .. deprecated:: 0.16</span>
<span class="sd">           The `quiet` keyword argument is deprecated in favor of the `verbose`</span>
<span class="sd">           one. Previous use of `verbose` now corresponds to the new keyword</span>
<span class="sd">           argument `debug`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sets self.start/stop/step and _pm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_frames</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trajectory</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;HBond analysis: starting&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;HBond analysis: donors    </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;HBond analysis: acceptors </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)</span>

        <span class="n">remove_duplicates</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;remove_duplicates&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>  <span class="c1"># False: old behaviour</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">remove_duplicates</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Hidden feature remove_duplicates=False activated: you will probably get duplicate H-bonds.&quot;</span><span class="p">)</span>

        <span class="n">debug</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">debug</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Toggling debug to </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;HBond analysis: For full step-by-step debugging output use debug=True&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_timeseries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">time</span>
            <span class="k">def</span> <span class="nf">_get_timestep</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">time</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;HBond analysis is recording time step&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="c1"># chained reader or xyz(?) cannot do time yet</span>
            <span class="k">def</span> <span class="nf">_get_timestep</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">frame</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;HBond analysis is recording frame number instead of time step&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting analysis (frame index start=</span><span class="si">%d</span><span class="s2"> stop=</span><span class="si">%d</span><span class="s2">, step=</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">ProgressBar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">],</span>
                              <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;HBond analysis&quot;</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
            <span class="c1"># all bonds for this timestep</span>
            <span class="n">frame_results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># dict of tuples (atom.index, atom.index) for quick check if</span>
            <span class="c1"># we already have the bond (to avoid duplicates)</span>
            <span class="n">already_found</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">frame</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
            <span class="n">timestep</span> <span class="o">=</span> <span class="n">_get_timestep</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timestep</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Analyzing frame </span><span class="si">%(frame)d</span><span class="s2">, timestep </span><span class="si">%(timestep)f</span><span class="s2"> ps&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_selection1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_selection_1</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_selection2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_selection_2</span><span class="p">()</span>

            <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 Donors &lt;-&gt; Acceptors&quot;</span><span class="p">)</span>
                <span class="n">ns_acceptors</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">donor_h_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">donor_h_set</span><span class="p">:</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">ns_acceptors</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                            <span class="n">angle</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                                                          <span class="n">h</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                                                          <span class="n">a</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
                            <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
                            <span class="n">donor_atom</span> <span class="o">=</span> <span class="n">h</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span> <span class="o">!=</span> <span class="s1">&#39;heavy&#39;</span> <span class="k">else</span> <span class="n">d</span>
                            <span class="n">dist</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_bonds</span><span class="p">(</span><span class="n">donor_atom</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="ow">and</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span>
                                    <span class="s2">&quot;S1-D: </span><span class="si">{0!s}</span><span class="s2"> &lt;-&gt; S2-A: </span><span class="si">{1!s}</span><span class="s2"> </span><span class="si">{2:f}</span><span class="s2"> A, </span><span class="si">{3:f}</span><span class="s2"> DEG&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                                <span class="n">frame_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                    <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                                    <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                                    <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">])</span>

                                <span class="n">already_found</span><span class="p">[(</span><span class="n">h</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 Acceptors &lt;-&gt; Donors&quot;</span><span class="p">)</span>
                <span class="n">ns_acceptors</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">donor_h_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">donor_h_set</span><span class="p">:</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">ns_acceptors</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">remove_duplicates</span> <span class="ow">and</span> <span class="p">(</span>
                                    <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="n">already_found</span> <span class="ow">or</span>
                                    <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="n">already_found</span><span class="p">):</span>
                                <span class="k">continue</span>
                            <span class="n">angle</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                                                          <span class="n">h</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                                                          <span class="n">a</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
                            <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
                            <span class="n">donor_atom</span> <span class="o">=</span> <span class="n">h</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span> <span class="o">!=</span> <span class="s1">&#39;heavy&#39;</span> <span class="k">else</span> <span class="n">d</span>
                            <span class="n">dist</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_bonds</span><span class="p">(</span><span class="n">donor_atom</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="ow">and</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span>
                                    <span class="s2">&quot;S1-A: </span><span class="si">{0!s}</span><span class="s2"> &lt;-&gt; S2-D: </span><span class="si">{1!s}</span><span class="s2"> </span><span class="si">{2:f}</span><span class="s2"> A, </span><span class="si">{3:f}</span><span class="s2"> DEG&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                                <span class="n">frame_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                     <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                                     <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                                    <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_results</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;HBond analysis: complete; timeseries  </span><span class="si">%s</span><span class="s2">.timeseries&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Time series of hydrogen bonds.</span>

<span class="sd">        The results of the hydrogen bond analysis can be accessed as a `list` of `list` of `list`:</span>

<span class="sd">        1. `timeseries[i]`: data for the i-th trajectory frame (at time</span>
<span class="sd">           `timesteps[i]`, see :attr:`timesteps`)</span>
<span class="sd">        2. `timeseries[i][j]`: j-th hydrogen bond that was detected at the i-th</span>
<span class="sd">           frame.</span>
<span class="sd">        3. ``donor_index, acceptor_index,</span>
<span class="sd">           donor_name_str, acceptor_name_str, distance, angle =</span>
<span class="sd">           timeseries[i][j]``: structure of one hydrogen bond data item</span>


<span class="sd">        In the following description, ``#`` indicates comments that are not</span>
<span class="sd">        part of the output::</span>

<span class="sd">          results = [</span>
<span class="sd">              [ # frame 1</span>
<span class="sd">                 [ # hbond 1</span>
<span class="sd">                    &lt;donor index (0-based)&gt;, &lt;acceptor index (0-based)&gt;,</span>
<span class="sd">                    &lt;donor string&gt;, &lt;acceptor string&gt;, &lt;distance&gt;, &lt;angle&gt;</span>
<span class="sd">                 ],</span>
<span class="sd">                 [ # hbond 2</span>
<span class="sd">                    &lt;donor index (0-based)&gt;, &lt;acceptor index (0-based)&gt;,</span>
<span class="sd">                    &lt;donor string&gt;, &lt;acceptor string&gt;, &lt;distance&gt;, &lt;angle&gt;</span>
<span class="sd">                 ],</span>
<span class="sd">                 ....</span>
<span class="sd">              ],</span>
<span class="sd">              [ # frame 2</span>
<span class="sd">                [ ... ], [ ... ], ...</span>
<span class="sd">              ],</span>
<span class="sd">              ...</span>
<span class="sd">          ]</span>

<span class="sd">        The time of each step is not stored with each hydrogen bond frame but in</span>
<span class="sd">        :attr:`~HydrogenBondAnalysis.timesteps`.</span>


<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        For instance, to find an acceptor atom in :attr:`Universe.atoms` by</span>
<span class="sd">        *index* one would use ``u.atoms[acceptor_index]``.</span>

<span class="sd">        The :attr:`timeseries` is a managed attribute and it is generated</span>
<span class="sd">        from the underlying data in :attr:`_timeseries` every time the</span>
<span class="sd">        attribute is accessed. It is therefore costly to call and if</span>
<span class="sd">        :attr:`timeseries` is needed repeatedly it is recommended that you</span>
<span class="sd">        assign to a variable::</span>

<span class="sd">           h = HydrogenBondAnalysis(u)</span>
<span class="sd">           h.run()</span>
<span class="sd">           timeseries = h.timeseries</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :attr:`table` : structured array of the data</span>


<span class="sd">        .. versionchanged:: 0.16.1</span>
<span class="sd">           :attr:`timeseries` has become a managed attribute and is generated from the stored</span>
<span class="sd">           :attr:`_timeseries` when needed. :attr:`_timeseries` contains the donor atom and</span>
<span class="sd">           acceptor atom specifiers as tuples `(resname, resid, atomid)` instead of strings.</span>

<span class="sd">        .. versionchanged:: 0.17.0</span>
<span class="sd">           The 1-based indices &quot;donor_idx&quot; and &quot;acceptor_idx&quot; are being</span>
<span class="sd">           removed in favor of the 0-based indices &quot;donor_index&quot; and</span>
<span class="sd">           &quot;acceptor_index&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">_reformat_hb</span><span class="p">(</span><span class="n">hb</span><span class="p">)</span> <span class="k">for</span> <span class="n">hb</span> <span class="ow">in</span> <span class="n">hframe</span><span class="p">]</span> <span class="k">for</span> <span class="n">hframe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeseries</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_reformat_hb</span><span class="p">(</span><span class="n">hb</span><span class="p">,</span> <span class="n">atomformat</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{0[0]!s}{0[1]!s}</span><span class="s2">:</span><span class="si">{0[2]!s}</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert 0.16.1 _timeseries hbond item to 0.16.0 hbond item.</span>

<span class="sd">        In 0.16.1, donor and acceptor are stored as a tuple(resname,</span>
<span class="sd">        resid, atomid). In 0.16.0 and earlier they were stored as a string.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">hb</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                <span class="o">+</span> <span class="p">[</span><span class="n">atomformat</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hb</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">atomformat</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hb</span><span class="p">[</span><span class="mi">3</span><span class="p">])]</span>
                <span class="o">+</span> <span class="n">hb</span><span class="p">[</span><span class="mi">4</span><span class="p">:])</span>

<div class="viewcode-block" id="HydrogenBondAnalysis.generate_table"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.generate_table">[docs]</a>    <span class="k">def</span> <span class="nf">generate_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a normalised table of the results.</span>

<span class="sd">        The table is stored as a :class:`numpy.recarray` in the</span>
<span class="sd">        attribute :attr:`~HydrogenBondAnalysis.table`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        HydrogenBondAnalysis.table</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeseries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No timeseries computed, do run() first.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">MissingDataWarning</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">num_records</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">hframe</span><span class="p">)</span> <span class="k">for</span> <span class="n">hframe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeseries</span><span class="p">])</span>
        <span class="c1"># build empty output table</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;donor_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>  <span class="p">(</span><span class="s2">&quot;acceptor_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;donor_resnm&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;donor_resid&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;donor_atom&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;acceptor_resnm&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;acceptor_resid&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;acceptor_atom&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;angle&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)]</span>
        <span class="c1"># according to Lukas&#39; notes below, using a recarray at this stage is ineffective</span>
        <span class="c1"># and speedups of ~x10 can be achieved by filling a standard array, like this:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_records</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># current row</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">hframe</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeseries</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">donor_index</span><span class="p">,</span> <span class="n">acceptor_index</span><span class="p">,</span> <span class="n">donor</span><span class="p">,</span>
                 <span class="n">acceptor</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span> <span class="ow">in</span> <span class="n">hframe</span><span class="p">:</span>
                <span class="c1"># donor|acceptor = (resname, resid, atomid)</span>
                <span class="n">out</span><span class="p">[</span><span class="n">cursor</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">donor_index</span><span class="p">,</span> <span class="n">acceptor_index</span><span class="p">)</span> <span class="o">+</span> \
                <span class="n">donor</span> <span class="o">+</span> <span class="n">acceptor</span> <span class="o">+</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
                <span class="n">cursor</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">cursor</span> <span class="o">==</span> <span class="n">num_records</span><span class="p">,</span> <span class="s2">&quot;Internal Error: Not all HB records stored&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;HBond: Stored results as table with </span><span class="si">%(num_records)d</span><span class="s2"> entries.&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_has_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">has_timeseries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeseries</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_timeseries</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No timeseries computed, do run() first.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">MissingDataWarning</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">has_timeseries</span>

<div class="viewcode-block" id="HydrogenBondAnalysis.count_by_time"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.count_by_time">[docs]</a>    <span class="k">def</span> <span class="nf">count_by_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Counts the number of hydrogen bonds per timestep.</span>

<span class="sd">        Processes :attr:`HydrogenBondAnalysis._timeseries` into the time series</span>
<span class="sd">        ``N(t)`` where ``N`` is the total number of observed hydrogen bonds at</span>
<span class="sd">        time ``t``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        counts : numpy.recarray</span>
<span class="sd">             The resulting array can be thought of as rows ``(time, N)`` where</span>
<span class="sd">             ``time`` is the time (in ps) of the time step and ``N`` is the</span>
<span class="sd">             total number of hydrogen bonds.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_timeseries</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">time_count</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span>
                                               <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)</span> <span class="k">for</span> <span class="n">series</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeseries</span><span class="p">))):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">cursor</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_count</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span></div>

<div class="viewcode-block" id="HydrogenBondAnalysis.count_by_type"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.count_by_type">[docs]</a>    <span class="k">def</span> <span class="nf">count_by_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Counts the frequency of hydrogen bonds of a specific type.</span>

<span class="sd">        Processes :attr:`HydrogenBondAnalysis._timeseries` and returns a</span>
<span class="sd">        :class:`numpy.recarray` containing atom indices, residue names, residue</span>
<span class="sd">        numbers (for donors and acceptors) and the fraction of the total time</span>
<span class="sd">        during which the hydrogen bond was detected.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        counts : numpy.recarray</span>
<span class="sd">             Each row of the array contains data to define a unique hydrogen</span>
<span class="sd">             bond together with the frequency (fraction of the total time) that</span>
<span class="sd">             it has been observed.</span>


<span class="sd">        .. versionchanged:: 0.17.0</span>
<span class="sd">           The 1-based indices &quot;donor_idx&quot; and &quot;acceptor_idx&quot; are being</span>
<span class="sd">           deprecated in favor of zero-based indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_timeseries</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="n">hbonds</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hframe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeseries</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">donor_index</span><span class="p">,</span> <span class="n">acceptor_index</span><span class="p">,</span> <span class="n">donor</span><span class="p">,</span>
                 <span class="n">acceptor</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span> <span class="ow">in</span> <span class="n">hframe</span><span class="p">:</span>
                <span class="n">donor_resnm</span><span class="p">,</span> <span class="n">donor_resid</span><span class="p">,</span> <span class="n">donor_atom</span> <span class="o">=</span> <span class="n">donor</span>
                <span class="n">acceptor_resnm</span><span class="p">,</span> <span class="n">acceptor_resid</span><span class="p">,</span> <span class="n">acceptor_atom</span> <span class="o">=</span> <span class="n">acceptor</span>
                <span class="c1"># generate unambigous key for current hbond \</span>
                <span class="c1"># (the donor_heavy_atom placeholder &#39;?&#39; is added later)</span>
                <span class="c1"># idx_zero is redundant for an unambigous key, but included for</span>
                <span class="c1"># consistency.</span>
                <span class="n">hb_key</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">donor_index</span><span class="p">,</span> <span class="n">acceptor_index</span><span class="p">,</span>
                    <span class="n">donor_resnm</span><span class="p">,</span> <span class="n">donor_resid</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="n">donor_atom</span><span class="p">,</span>
                    <span class="n">acceptor_resnm</span><span class="p">,</span> <span class="n">acceptor_resid</span><span class="p">,</span> <span class="n">acceptor_atom</span><span class="p">)</span>

                <span class="n">hbonds</span><span class="p">[</span><span class="n">hb_key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># build empty output table</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;donor_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;acceptor_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;donor_resnm&#39;</span><span class="p">,</span> <span class="s1">&#39;U4&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;donor_resid&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;donor_heavy_atom&#39;</span><span class="p">,</span> <span class="s1">&#39;U4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;donor_atom&#39;</span><span class="p">,</span> <span class="s1">&#39;U4&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;acceptor_resnm&#39;</span><span class="p">,</span> <span class="s1">&#39;U4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;acceptor_resid&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;acceptor_atom&#39;</span><span class="p">,</span> <span class="s1">&#39;U4&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">hbonds</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># float because of division later</span>
        <span class="n">tsteps</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">cursor</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">hbonds</span><span class="p">)):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">cursor</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="p">(</span><span class="n">count</span> <span class="o">/</span> <span class="n">tsteps</span><span class="p">,)</span>

        <span class="c1"># return array as recarray</span>
        <span class="c1"># The recarray has not been used within the function, because accessing the</span>
        <span class="c1"># the elements of a recarray (3.65 us) is much slower then accessing those</span>
        <span class="c1"># of a ndarray (287 ns).</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>

        <span class="c1"># patch in donor heavy atom names (replaces &#39;?&#39; in the key)</span>
        <span class="n">h2donor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor_lookup_table_byindex</span><span class="p">()</span>
        <span class="n">r</span><span class="o">.</span><span class="n">donor_heavy_atom</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">h2donor</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">donor_index</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">r</span></div>

<div class="viewcode-block" id="HydrogenBondAnalysis.timesteps_by_type"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.timesteps_by_type">[docs]</a>    <span class="k">def</span> <span class="nf">timesteps_by_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Frames during which each hydrogen bond existed, sorted by hydrogen bond.</span>

<span class="sd">        Processes :attr:`HydrogenBondAnalysis._timeseries` and returns a</span>
<span class="sd">        :class:`numpy.recarray` containing atom indices, residue names, residue</span>
<span class="sd">        numbers (for donors and acceptors) and each timestep at which the</span>
<span class="sd">        hydrogen bond was detected.</span>

<span class="sd">        In principle, this is the same as :attr:`~HydrogenBondAnalysis.table`</span>
<span class="sd">        but sorted by hydrogen bond and with additional data for the</span>
<span class="sd">        *donor_heavy_atom* and angle and distance omitted.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : numpy.recarray</span>


<span class="sd">        .. versionchanged:: 0.17.0</span>
<span class="sd">           The 1-based indices &quot;donor_idx&quot; and &quot;acceptor_idx&quot; are being</span>
<span class="sd">           replaced in favor of zero-based indices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_timeseries</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="n">hbonds</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hframe</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeseries</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">donor_index</span><span class="p">,</span> <span class="n">acceptor_index</span><span class="p">,</span> <span class="n">donor</span><span class="p">,</span>
                 <span class="n">acceptor</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span> <span class="ow">in</span> <span class="n">hframe</span><span class="p">:</span>
                <span class="n">donor_resnm</span><span class="p">,</span> <span class="n">donor_resid</span><span class="p">,</span> <span class="n">donor_atom</span> <span class="o">=</span> <span class="n">donor</span>
                <span class="n">acceptor_resnm</span><span class="p">,</span> <span class="n">acceptor_resid</span><span class="p">,</span> <span class="n">acceptor_atom</span> <span class="o">=</span> <span class="n">acceptor</span>
                <span class="c1"># generate unambigous key for current hbond</span>
                <span class="c1"># (the donor_heavy_atom placeholder &#39;?&#39; is added later)</span>
                <span class="c1"># idx_zero is redundant for key but added for consistency</span>
                <span class="n">hb_key</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">donor_index</span><span class="p">,</span> <span class="n">acceptor_index</span><span class="p">,</span>
                    <span class="n">donor_resnm</span><span class="p">,</span> <span class="n">donor_resid</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="n">donor_atom</span><span class="p">,</span>
                    <span class="n">acceptor_resnm</span><span class="p">,</span> <span class="n">acceptor_resid</span><span class="p">,</span> <span class="n">acceptor_atom</span><span class="p">)</span>
                <span class="n">hbonds</span><span class="p">[</span><span class="n">hb_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="n">out_nrows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># count number of timesteps per key to get length of output table</span>
        <span class="k">for</span> <span class="n">ts_list</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">hbonds</span><span class="p">):</span>
            <span class="n">out_nrows</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts_list</span><span class="p">)</span>

        <span class="c1"># build empty output table</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;donor_index&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;acceptor_index&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;donor_resnm&#39;</span><span class="p">,</span> <span class="s1">&#39;U4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;donor_resid&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;donor_heavy_atom&#39;</span><span class="p">,</span> <span class="s1">&#39;U4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;donor_atom&#39;</span><span class="p">,</span> <span class="s1">&#39;U4&#39;</span><span class="p">),(</span><span class="s1">&#39;acceptor_resnm&#39;</span><span class="p">,</span> <span class="s1">&#39;U4&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;acceptor_resid&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;acceptor_atom&#39;</span><span class="p">,</span> <span class="s1">&#39;U4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">out_nrows</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">out_row</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">hbonds</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">tstep</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">out_row</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="p">(</span><span class="n">tstep</span><span class="p">,)</span>
                <span class="n">out_row</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># return array as recarray</span>
        <span class="c1"># The recarray has not been used within the function, because accessing the</span>
        <span class="c1"># the elements of a recarray (3.65 us) is much slower then accessing those</span>
        <span class="c1"># of a ndarray (287 ns).</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>

        <span class="c1"># patch in donor heavy atom names (replaces &#39;?&#39; in the key)</span>
        <span class="n">h2donor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor_lookup_table_byindex</span><span class="p">()</span>
        <span class="n">r</span><span class="o">.</span><span class="n">donor_heavy_atom</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">h2donor</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">donor_index</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">r</span></div>

    <span class="k">def</span> <span class="nf">_donor_lookup_table_byres</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Look-up table to identify the donor heavy atom from resid and hydrogen name.</span>

<span class="sd">        Assumptions:</span>
<span class="sd">        * resids are unique</span>
<span class="sd">        * hydrogen atom names are unique within a residue</span>
<span class="sd">        * selections have not changed (because we are simply looking at the last content</span>
<span class="sd">          of the donors and donor hydrogen lists)</span>

<span class="sd">        Donors from `selection1` and `selection2` are merged.</span>

<span class="sd">        Output dictionary ``h2donor`` can be used as::</span>

<span class="sd">           heavy_atom_name = h2donor[resid][hydrogen_name]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span>  <span class="c1"># list of donor Atom instances</span>
        <span class="n">s1h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span>  <span class="c1"># dict indexed by donor position in donor list, containg AtomGroups of H</span>
        <span class="n">s2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span>
        <span class="n">s2h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span>

        <span class="k">def</span> <span class="nf">_make_dict</span><span class="p">(</span><span class="n">donors</span><span class="p">,</span> <span class="n">hydrogens</span><span class="p">):</span>
            <span class="c1"># two steps so that entry for one residue can be UPDATED for multiple donors</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">donors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="p">{})</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">donors</span><span class="p">))</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">donors</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">donors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">resid</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">donors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">d</span>

        <span class="n">h2donor</span> <span class="o">=</span> <span class="n">_make_dict</span><span class="p">(</span><span class="n">s2d</span><span class="p">,</span> <span class="n">s2h</span><span class="p">)</span>  <span class="c1"># 2 is typically the larger group</span>
        <span class="c1"># merge (in principle h2donor.update(_make_dict(s1d, s1h) should be sufficient</span>
        <span class="c1"># with our assumptions but the following should be really safe)</span>
        <span class="k">for</span> <span class="n">resid</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">_make_dict</span><span class="p">(</span><span class="n">s1d</span><span class="p">,</span> <span class="n">s1h</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">resid</span> <span class="ow">in</span> <span class="n">h2donor</span><span class="p">:</span>
                <span class="n">h2donor</span><span class="p">[</span><span class="n">resid</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h2donor</span><span class="p">[</span><span class="n">resid</span><span class="p">]</span> <span class="o">=</span> <span class="n">names</span>

        <span class="k">return</span> <span class="n">h2donor</span>

    <span class="k">def</span> <span class="nf">_donor_lookup_table_byindex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Look-up table to identify the donor heavy atom from hydrogen atom index.</span>

<span class="sd">        Assumptions:</span>
<span class="sd">        * selections have not changed (because we are simply looking at the last content</span>
<span class="sd">          of the donors and donor hydrogen lists)</span>

<span class="sd">        Donors from `selection1` and `selection2` are merged.</span>

<span class="sd">        Output dictionary ``h2donor`` can be used as::</span>

<span class="sd">           heavy_atom_name = h2donor[index]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span>  <span class="c1"># list of donor Atom instances</span>
        <span class="n">s1h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span>  <span class="c1"># dict indexed by donor position in donor list, containg AtomGroups of H</span>
        <span class="n">s2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span>
        <span class="n">s2h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span>

        <span class="k">def</span> <span class="nf">_make_dict</span><span class="p">(</span><span class="n">donors</span><span class="p">,</span> <span class="n">hydrogens</span><span class="p">):</span>
            <span class="c1">#return dict(flatten_1([(atom.id, donors[k].name) for atom in hydrogens[k]] for k in range(len(donors))</span>
            <span class="c1"># if k in hydrogens))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">donors</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">:</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">donors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">h2donor</span> <span class="o">=</span> <span class="n">_make_dict</span><span class="p">(</span><span class="n">s2d</span><span class="p">,</span> <span class="n">s2h</span><span class="p">)</span>  <span class="c1"># 2 is typically the larger group</span>
        <span class="n">h2donor</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_make_dict</span><span class="p">(</span><span class="n">s1d</span><span class="p">,</span> <span class="n">s1h</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">h2donor</span>


<div class="viewcode-block" id="HydrogenBondAnalysis.autocorrelation"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.autocorrelation">[docs]</a>    <span class="k">def</span> <span class="nf">autocorrelation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau_max</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">window_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">intermittency</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes and returns the autocorrelation (HydrogenBondLifetimes ) on the computed hydrogen bonds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        window_step : int, optional</span>
<span class="sd">            Jump every `step`-th frame. This is compatible but independant of the taus used.</span>
<span class="sd">            Note that `step` and `tau_max` work consistently with intermittency.</span>
<span class="sd">        tau_max : int, optional</span>
<span class="sd">            Survival probability is calculated for the range 1 &lt;= `tau` &lt;= `tau_max`</span>
<span class="sd">        intermittency : int, optional</span>
<span class="sd">            The maximum number of consecutive frames for which a bond can disappear but be counted as present if it</span>
<span class="sd">            returns at the next frame. An intermittency of `0` is equivalent to a continuous autocorrelation, which does</span>
<span class="sd">            not allow for the hydrogen bond disappearance. For example, for `intermittency=2`, any given hbond may</span>
<span class="sd">            disappear for up to two consecutive frames yet be treated as being present at all frames.</span>
<span class="sd">            The default is continuous (0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tau_timeseries : list</span>
<span class="sd">            tau from 1 to `tau_max`. Saved in the field tau_timeseries.</span>
<span class="sd">        timeseries : list</span>
<span class="sd">            autcorrelation value for each value of `tau`. Saved in the field timeseries.</span>
<span class="sd">        timeseries_data: list</span>
<span class="sd">            raw datapoints from which the average is taken (timeseries).</span>
<span class="sd">            Time dependancy and distribution can be extracted.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeseries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Autocorrelation analysis of hydrogen bonds cannot be done before the hydrogen bonds are found&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Autocorrelation: Please use the .run() before calling this function&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Autocorrelation function should be carried out on consecutive frames. &quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Autocorrelation: if you would like to allow bonds to break and reform, please use &#39;intermittency&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># Extract the hydrogen bonds IDs only in the format [set(superset(x1,x2), superset(x3,x4)), ..]</span>
        <span class="n">hydrogen_bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span>
        <span class="n">found_hydrogen_bonds</span> <span class="o">=</span> <span class="p">[{</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">frame</span><span class="p">}</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">hydrogen_bonds</span><span class="p">]</span>

        <span class="n">intermittent_hbonds</span> <span class="o">=</span> <span class="n">correct_intermittency</span><span class="p">(</span><span class="n">found_hydrogen_bonds</span><span class="p">,</span> <span class="n">intermittency</span><span class="o">=</span><span class="n">intermittency</span><span class="p">)</span>
        <span class="n">tau_timeseries</span><span class="p">,</span> <span class="n">timeseries</span><span class="p">,</span> <span class="n">timeseries_data</span> <span class="o">=</span> <span class="n">autocorrelation</span><span class="p">(</span><span class="n">intermittent_hbonds</span><span class="p">,</span> <span class="n">tau_max</span><span class="p">,</span>
                                                                      <span class="n">window_step</span><span class="o">=</span><span class="n">window_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acf_tau_timeseries</span> <span class="o">=</span> <span class="n">tau_timeseries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acf_timeseries</span> <span class="o">=</span> <span class="n">timeseries</span>
        <span class="c1"># user can investigate the distribution and sample size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acf_timeseries_data</span> <span class="o">=</span> <span class="n">timeseries_data</span>

        <span class="k">return</span> <span class="bp">self</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2005-2021, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Shobhit Agarwal, Irfan Alibay, Anshul Angaria, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Jonathan Barnoud, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Wouter Boomsma, Jose Borreguero, Cédric Bouysset, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, David Caplan, Yuanyu Chang, Matthieu Chavent, Haochuan Chen, Kathleen Clark, Charlie Cook, Ruggero Cortini, Nicholas Craven, Ramon Crehuet, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Ali Ehlen, Shujie Fan, Lennard van der Feltz, Philip Fowler, Guillaume Fraux, William Glass, Joseph Goose, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Benjamin Hall, Ameya Harmalkar, Ivan Hristov, Eugen Hruska, Kyle J. Huston, Siddharth Jain, Joe Jordan, Jon Kapla, Navya Khare, Andrew William King, Abhishek A. Kognole, Max Linke, Philip Loche, Jinju Lu, Hugo MacDermott-Opeskin, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Rocco Meli, Manuel Nuno Melo, Dominik &#39;Rathann&#39; Mierzejewski, Henry Mull, Morgan L. Nance, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Danny Parton, Shakul Pathak, Joshua L. Phillips, Kashish Punjani, Michael Quevillon, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Andrea Rizzi, Carlos Yanez S., Utkarsh Saxena, Marcello Sega, Sean L. Seyler, Faraaz Shah, Abhishek Shandilya, Shubham Sharma, Paul Smith, Andy Somogyi, Caio S. Souza, Shantanu Srivastava, Lukas Stelzl, Gorman Stock, Fenil Suchak, Ayush Suhane, Matthijs Tadema, Joao Miguel Correia Teixeira, Xiki Tempula, Matthew W. Thompson, Hao Tian, Matteo Tiberti, Wiep van der Toorn, Isaac Virshup, Lily Wang, Nestor Wendt, Zhiyi Wu, Zhuyi Xue, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, Yuxuan Zhuang, and Oliver Beckstein.

    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  <script>
    var versions_json_url = 'https://docs.mdanalysis.org/versions.json'
</script>

<div class="rst-versions" data-toggle="rst-versions" role="note"
     aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
        1.1.0
      <span class="fa fa-caret-down"></span>
    </span>

    <div class="rst-other-versions">
        <dl id="versionselector">
            <dt>Other Versions</dt>
        </dl>

    </div>
</div>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>