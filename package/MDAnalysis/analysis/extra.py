def rotation_matrix(a, b, weights=None):
    r"""Returns the 3x3 rotation matrix `R` for RMSD fitting coordinate
    sets `a` and `b`.

    The rotation matrix `R` transforms vector `a` to overlap with
    vector `b` (i.e., `b` is the reference structure):

    .. math::
       \mathbf{b} = \mathsf{R} \cdot \mathbf{a}

    Parameters
    ----------
    a : array_like
          coordinates that are to be rotated ("mobile set"); array of N atoms
          of shape N*3 as generated by, e.g.,
          :attr:`MDAnalysis.core.groups.AtomGroup.positions`.
    b : array_like
          reference coordinates; array of N atoms of shape N*3 as generated by,
          e.g., :attr:`MDAnalysis.core.groups.AtomGroup.positions`.
    weights : array_like (optional)
          array of floats of size N for doing weighted RMSD fitting (e.g. the
          masses of the atoms)

    Returns
    -------
    R : ndarray
        rotation matrix
    rmsd : float
        RMSD between `a` and `b` before rotation
    ``(R, rmsd)`` rmsd and rotation matrix *R*

    Example
    -------
    `R` can be used as an argument for
    :meth:`MDAnalysis.core.groups.AtomGroup.rotate` to generate a rotated
    selection, e.g. ::

    >>> import MDAnalysis as mda
    >>> from MDAnalysisTests.datafiles import TPR, TRR
    >>> from MDAnalysis.analysis import align
    >>> A = mda.Universe(TPR, TRR)
    >>> B = mda.Universe(TPR, TRR)
    >>> R = align.rotation_matrix(A.select_atoms('backbone').positions,
    ...                           B.select_atoms('backbone').positions)[0]
    >>> A.atoms.rotate(R)
    <AtomGroup with 47681 atoms>
    >>> A.atoms.write("rotated.pdb")

    Notes
    -----
    The function does *not* shift the centers of mass or geometry;
    this needs to be done by the user.

    See Also
    --------
    MDAnalysis.analysis.rms.rmsd: Calculates the RMSD between *a* and *b*.
    alignto: A complete fit of two structures.
    AlignTraj: Fit a whole trajectory.
    """

    ###217 logger