# -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-
# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 
#
# MDAnalysis --- http://www.MDAnalysis.org
# Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver
# Beckstein and contributors (see AUTHORS for the full list)
#
# Released under the GNU Public Licence, v2 or any higher version
#
# Please cite your use of MDAnalysis in published work:
#
# N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.
# MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.
# J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787
#

from six.moves import range
import numpy as np
import warnings
import os

import datreant.core as dtr

## TODO - ARGS are all over the place at the moment; need to move bits around
## so not needing to list them all out in multiple places...

## TODO - NAMING. Currently named in line with docs for Grossfield wham, but
## some of these aren't very clear/nice so likely to change...
def wham(bundle, spring='spring', loc_win_min='loc_win_min', 
         temperature='temperature', correl_time=None, 
         timeseries_data='timeseries_data', energy='energy',
         timeseries_type='coord', calc_temperature=None,
         run_bootstrap=True, hist_max=None, hist_min=None,
         start_time=None, end_time=None, 
         energy_units='kcal', keep_files=False, file_root='./', **wham_args):
    """ Wrapper for the Grossfield implementation of WHAM.

    [link documentation]

    Each simulation must have the appropriate metadata (spring constant,
    restrained value, temperature) and auxiliary data (timeseries data as
    either reaction coordinate value, difference from restrained value, or
    value of the restraining force). If using MC bootstrap error analysis,
    can also specify a correlation time for each window. If simulations were
    performed at different temperatures, a potential energy auxiliary must also
    be provided. If any names differ from the default values they must be 
    specified.

    Various wham paramaters, etc etc [TBA]

    [[ ARGS NEED SORTING ]]

    Parameters
    ----------
    bundle : datreant Bundle
        Bundle of the simulations WHAM is to be performed for.
    spring : str, optional
        Name of metadata storing the spring constant that each simulation uses,
        assuming biasing potential has form 1/2 k(x-x0)^2. [[<--format]]
        [[Some simulation packages don't use the 1/2 - so have to pass 2*the 
        restraint const instead?]].
        Must match the units used for energy + the reaction coordinate. [examples?].
    loc_win_min : str, optional
        Name of metadata field storing the reaction coordinate value that is
        the minimum of the biasing potential in each window, ie x0 above.
    temperature : str, optional
        Name of metadata field storing each window's temperature (in Kelvin)
    correl_time : str, optional
        Name of metadata field storing decorrelation time for each window, in 
        time step units. Only used for boostrap error; will be set to 1 for 
        each window if not provided.
    timeseries_data : str, optional
        Name of the auxiliary containing the force/reaction coordinate value 
        throughout simulation.
    timeseries_type : str, optional
        What value is recorded in timeseries_data; for available options see
        ``calc_reaction_cood``.
    energy : str, optional
        Name of the auxiliary containing potential energy. [Currently must be
        at exactly the same same steps as timeseries above (ie same dt and 
        initial time)]. [I assume units must match energy_units?]. Only
        required if simulations performed at different temperatures.
    calc_temperature : float, optional
        Temperature at which to perform wham calculation (in Kelvin). If not 
        specified, assume simulation are performed at the same temperature and 
        set to that.
    hist_min, hist_max : float, optional
        Min/max values of reaction coordinate to use in calculation. If None 
        (default), will set to the lowest/highest value of the reaction 
        coordinate.
    run_boostrap : bool, optional
        Whether to run Monte Carlo bootstrap error analysis.
    start_time, end_time : float, optional
        Start/end time (in ps) to use when calculating profile; data outside
        of this time range will be ignored. 
    energy_units : str, optional
        Free energy units to use [[kcal, kJ, ...]]
    keep_files : bool, optional
        Whether to keep files generated by wham
    file_root : str
        [[ directory/prefix for input/output files ]]
    **wham_args
        Other arguments to pass to run_grossfield_wham
    """
    if not isinstance(bundle, dtr.Bundle):
        TypeError('{} is not a bundle'.format(bundle))
    
    # check the bundle has all the specified auxiliaries/metadata
    check_bundle_metadata(bundle, [spring, loc_win_min, temperature])
    if correl_time:
        check_bundle_metadata(bundle, correl_time)
    check_bundle_auxiliaries(bundle, [timeseries_data])
    multi_temp, calc_temperature = _check_temperatures(bundle, temperature,
                                                       calc_temperature)
    if multi_temp:
        check_bundle_auxiliaries(bundle, [energy])

    calc_reaction_coord(1, timeseries_type, 1 ,1)    # TODO - make this nicer

    # check start/end time values
    _check_number(start_time, "start time")
    _check_number(end_time, "end time")
    if not None in [start_time, end_time] and start_time >= end_time:
        raise ValueError('start time {} is greater than end time {}'.format(
                                                          start_time, end_time))

    # TODO - UNITS. Check option is valid. Then change somehow? Would adjusting
    # temperature work?
    # TODO - check file_root?

    # set all out file names
    metafile_name = file_root+'metafile.dat'
    timeseriesfile_name = file_root+'timeseries_{}.dat'
    outfile_name = file_root+'output.dat'

    # check all our wham parameters are valid before we start writing files
    run_grossfield_wham(check_only=True, calc_temperature=calc_temperature,
                        hist_max=hist_max, hist_min=hist_min, 
                        outfile=outfile_name, metafile=metafile_name,
                        **wham_args)

    # write input files
    hist_min, hist_max = write_grossfield_input(multi_temp=multi_temp, 
                                        energy=energy, hist_max=hist_max, 
                                        hist_min=hist_min, bundle=bundle,
                                        timeseries_data=timeseries_data, 
                                        timeseries_type=timeseries_type,
                                        metafile_name=metafile_name,
                                        timeseriesfile_name=timeseriesfile_name,
                                        spring=spring, loc_win_min=loc_win_min,
                                        start_time=start_time, end_time=end_time,
                                        temperature=temperature,
                                        correl_time=correl_time)
    # run!
    run_grossfield_wham(calc_temperature=calc_temperature, hist_max=hist_max, 
                        hist_min=hist_min, metafile=metafile_name,
                        outfile=outfile_name, **wham_args)
    # read the output    
    profile = read_grossfield_output(outfile_name)

    # clear our files
    if not keep_files:
        # TODO - best way to remove files? 
          # keep a list of all files we write?
        os.remove(metafile_name)
        os.remove(outfile_name)
        for sim in bundle:
            os.remove(timeseriesfile_name.format(sim.name)) # or use a wildcard
            # TODO - may not write all!

    return profile
    # TODO - in the outfile we also get the probability + it's error in [:,3] 
    # and [:,4]; and the 'F-values' for each simulation (that we didn't skip);
    # option to get prob instead of PMF? option to return Fvalues as well (tuple?)



def run_grossfield_wham(periodicity='', hist_min=None, 
                        hist_max=None, num_bins=200, tol=1e-6, 
                        calc_temperature=None, numpad=0, metafile=None, 
                        outfile=None, num_MC_trials=200, check_only=False, 
                        run_bootstrap=True):
    """
    Check the arguments for running WHAM w/ Grossfield implementation,
    then run command.

    [[ ARGS NEED SORTING ]]

    Parameters
    ----------
    perodicity : str, optional
        Periodicity of system. Default ('') indicates a nonperiodic reaction
        coordiante.
    num_bins : int, optional
        Number of bins to use in histogram (= number of points in final profile).
    tol : float, optional
        Reference value to assess convergence (will stop iteration when the 
        biggest change in F-value is less than this).
    numpad : int, optional
        ['padding' values, for periodic PMFs; for nonperiodic use 0 (default)]
    num_MC_trials : int, optional
        Number of 'fake' data sets to create, if running bootstrap error analysis
    metafile : str
        [[ filename for writting metadata file ]]
    outfile : str
        [[ filename for writting final output ]]
    check_only : bool
        [[ (Default False). If True, only check values are valid; exit before 
         running wham command ]]
    calc_temperature, hist_min, hist_max, run_bootstrap
        [[ TBA?, see wham above ]]
    """
    wham_args = locals()
    ## TODO - need to provide path to runfile? where best to do this? (check
    ## it's actually wham...)
    wham_command = '~/wham/wham/wham'

    # check everything here to catch issues before launching the command (and
    # so we don't run something we don't want...)
    _check_number(hist_min, 'hist_min')
    _check_number(hist_max, 'hist_max')        
    _check_number(num_bins, 'number of bins', positive=True, integer=True)
    _check_number(tol, 'tolerance', positive=True)
    _check_number(calc_temperature, 'calculation temperature', positive=True)
    _check_number(numpad, 'numpad', integer=True)
    _check_number(num_MC_trials, 'num_MC_trials', positive=True, integer=True)
    if hist_min is not None and hist_max is not None:
        if hist_min >= hist_max:
            raise ValueError('hist_min {} is greater than hist_max {}'.format(
                                                            hist_min, hist_max))
    if periodicity not in ['', 'P', 'Ppi']: # OR 'P<val>'!
        raise ValueError('Periodicity not valid...') ###
        ## TODO - pass as something else? + Sort out P<val>
    ## TODO - check files?

    if not check_only:
        # we should have a value for all args to run...
        for key, item in wham_args.items():
            if item is None:
                raise TypeError("Must provide {}".format(key))
        run_command = [wham_command, periodicity, hist_min, hist_max, num_bins, 
                       tol, calc_temperature, numpad, metafile, outfile]
        randSeed = 1 # TODO - how to deal with random seed - should make an argument?
        if run_bootstrap:
            run_command = run_command+[num_MC_trials, randSeed]
        os.system(list_to_string(run_command))
        ## TODO - switch to subprocess; [+ catch any errors etc]



def write_grossfield_input(metafile_name='metadatafile.dat', 
                           timeseriesfile_name='timeseries_{}.dat', 
                           multi_temp=False, energy='energy',
                           timeseries_data='timeseries_data', 
                           timeseries_type='coord', 
                           hist_max=None, hist_min=None, bundle=None,
                           spring='spring', loc_win_min='loc_win_min',
                           start_time=None, end_time=None, correl_time=None,
                           temperature='temperature'):
    """
    [[ Write the appropriate metafile + timeseries files to run Grossfield wham
    implementation on *bundle*.

    Returns the min and max reaction coordinate values, set to the lowest/highest
    value in the timeseries data if not set in args. ]]

    [[ ARGS NEED SORTING ]]

    """
    # TODO - check metafile/timeseries are valid here?
    with open(metafile_name, 'w') as metafile:
        global_min_val = None
        global_max_val = None
        passed_sims=[] #keep track of which simulations we actually feed through
                       # to wham (so we don't try run with none...)
        for sim in bundle:
            k = sim.categories[spring]
            x0 = sim.categories[loc_win_min]
            try:
                start, end = _get_start_end_step(sim, timeseries_data, 
                                                 start_time, end_time)
            except TypeError:
                # TODO - will this come up in other circumstances? 
                # might need something more specific
                continue
            filename = timeseriesfile_name.format(sim.name)

            min_val, max_val = write_timeseries_file(sim, filename=filename, 
                                                multi_temp=multi_temp, 
                                                start=start, 
                                                end=end, energy=energy,
                                                timeseries_data=timeseries_data, 
                                                timeseries_type=timeseries_type,
                                                k=k, x0=x0)
            if (hist_max is not None and min_val > hist_max or
                hist_min is not None and max_val < hist_min):
                warnings.warn('Reaction coordinate range of simulation {} '
                              '({}-{}) does not fall within WHAM range ({}-{}); '
                              'will be skipped'.format(sim.name, min_val, max_val,
                                      hist_min if hist_min is not None else '_', 
                                      hist_max if hist_max is not None else '_'))
                continue
            # write to metafile
            if correl_time:
                correl = sim.categories[correl_time]
            else:
                # only used if doing bootstrap but need as a placeholder if
                # specifying temperatures; this seems to be the default
                # value used in wham so should be fine here too
                correl = 1
            metafile_info = [filename, x0, k, correl]
            if multi_temp:
                metafile_info.append(sim.categories[temperature])
            metafile.write(list_to_string(metafile_info)+'\n')
            passed_sims.append(sim.name)
            global_min_val = update_min(min_val, global_min_val)
            global_max_val = update_max(max_val, global_max_val)

        if len(passed_sims) == 0:
            raise ValueError('Aborting (all simulations skipped). Try increasing '
                             'time or reaction coordinate range.')
    return (hist_min if hist_min is not None else global_min_val, 
           hist_max if hist_max is not None else global_max_val)



def write_timeseries_file(sim, filename=None, multi_temp=False, start=0, 
                          end=-1, energy='energy', timeseries_type='coord',
                          timeseries_data='timeseries_data', k=None, x0=None):
    """
    [[ Write timeseries file for *sim*. Will return min/max value of reaction
    coordinate for *sim* (in the specified range) ]]

    [[ ARGS NEED SORTING ]]
    """
    max_val = None
    min_val = None
    with open(filename, 'w') as timeseriesfile:
        traj = sim.universe.trajectory
        if multi_temp:
            ## TODO - remember still assuming energy/timeseries points directly match...
            ## TODO - find a way to do this as we're looping timeseries so we're not
            ## storing this big list?
            energies = [i.data[0] for i in traj.iter_auxiliary(energy, 
                                                         start=start, stop=end)]
        timeseries_iter = traj.iter_auxiliary(timeseries_data, start=start, stop=end)
        for i, auxstep in enumerate(timeseries_iter):
            x = calc_reaction_coord(auxstep.data[0], timeseries_type, k, x0)
            min_val = update_min(x, min_val)
            max_val = update_max(x, max_val)
            line = [auxstep.time, x]
            if multi_temp:
                line.append(energies[i])
            timeseriesfile.write(list_to_string(line)+'\n')
    return min_val, max_val


def read_grossfield_output(outfile, bootstrap=True):
    outfiledata = np.genfromtxt(outfile)
    if not bootstrap:
        profile = outfiledata[:,:2]
    if bootstrap:
        profile = outfiledata[:,:3]
    return profile


def calc_reaction_coord(value, value_type, k, x0):
    """ Calculate value of reaction coordinate corresponding to *value*.

    Calculate the reaction coordinate at a particular time point from *value*,
    depending on *value_type*. Currently allowed types are:
        - coord: reaction coordinate value
        - force: value of the restraining force; harmonic potential is assumed
                 so x = -F/k + x0
        - delta: difference in reaction coord value and minimum of restraining
                 potential; x = delta_x + x0
    [...]
    """
    if value_type == 'coord':
        x = value
    elif value_type == 'force':
        # F = -k delta_x; does the missing 1/2 factor matter here?
        x = -value/k + x0
    elif value_type == 'delta':
        # delta_x = x-x0
        x = value + x0
    else:
        raise ValueError('{} is not a valid timeseries data type'.format(value_type))
    return x




def _get_start_end_step(sim, timeseries_data, start_time, end_time):
    """ Given start_time and end_time, return the start_step and end_step of
    the slice of *sim* this corresponds to. Return None and warn if this is
    out of range """
    step_to_time = sim.universe.trajectory.get_aux_attribute(timeseries_data, 'step_to_time')
    n_steps = sim.universe.trajectory.get_aux_attribute(timeseries_data, 'n_steps')
    start_step = 0 if start_time is None else None
    end_step = n_steps if end_time is None else None
    for i in range(n_steps):
        if start_step is None and step_to_time(i) > start_time:
            start_step = i
        if end_step is None and step_to_time(i) > end_time:
            end_step = i
        if end_step is not None:
            break
    end_step = end_step if end_step is not None else n_steps
    if start_step is None or end_step == 0:
        warnings.warn("Time range of simulation {} ({}-{}ps) does not fall "
                      "within timerange for WHAM ({}-{}ps); will be skipped."
                      "".format(sim.name, step_to_time(0),
                                step_to_time(n_steps-1),
                                start_time if start_time is not None else '_', 
                                end_time if end_time is not None else '_'))
        return
    return start_step, end_step    




def check_bundle_metadata(bundle, expected):
    """ check each simulation in bundle has the expected metadata """
    common_metadata = bundle.categories.keys()
    for meta in expected:
        if meta not in common_metadata:
            raise ValueError("Not all simulations contain metadata {}."
                             "(Common metadata: {})".format(meta, common_metadata))
        ## TODO - also check if all the values are of the expected type?


def check_bundle_auxiliaries(bundle, expected):
    """ check each simulation in bundle has expected auxiliary """
    # when auxiliaries added to mdsynthesis, this might become more direct
    for aux in expected:
        for sim in bundle:
            if aux not in sim.universe.trajectory.aux_list:
                raise ValueError("Simulation {} does not contain auxiliary data"
                                 " {}".format(sim.name, aux))
            ## TODO - also check it's got the right length/type?


def _check_temperatures(bundle, metaname, calc_temperature):
    """
    Check if simulations in *bundle* were all performed at the same temperature
    or different temperatures. If same, raise ValueError if this disagrees with
    *calc_temperature* and set calc_temperature otherwise; if different, 
    raise TypeError if we haven't provided a *calc_temperature*.

    Returns
    -------
    multi_temp : bool
        whether simulations are at different temperatures or not
    calc_temperature : float
        temperature to perform WHAM at, possibly updated from input
    """
    temps = bundle.categories[metaname]
    if all(t == temps[0] for t in temps):
        # all same temperature. This'll be the temperature we calculate at
        multi_temp = False
        if calc_temperature is None:
            calc_temperature = temps[0]
        elif float(calc_temperature) != temps[0]:
            ## would there be a situation where we want them to be different?
            raise ValueError('Simulations all have temperature {} but calc_temperature '
                             '{} does not match'.format(temps[0], calc_temperature))
    else:
        # different temperatures. Will need a run temperature and a potential 
        # energy for every step
        multi_temp = True
        if calc_temperature is None:
            raise TypeError('Must provide a calc_temperature if simulations are '
                            'performed at different temperatures')
    return multi_temp, calc_temperature


def _check_number(value, name, integer=False, positive=False):
    if value is not None:
        types = (int) if integer else (int, float)
        if not isinstance(value, types) or (positive and not value > 0):
            raise TypeError("Invalid {} ({})".format(name, value))

def list_to_string(lst):
    return ' '.join([str(i) for i in lst])

def update_min(new, curr):
    return new if curr is None else new if new < curr else curr

def update_max(new, curr):
    return new if curr is None else new if new > curr else curr
