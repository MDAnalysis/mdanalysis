<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.analysis.hbonds.hbond_autocorrel &mdash; MDAnalysis 0.11.0 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.11.0 documentation"
          href="../../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.11.0 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.analysis.hbonds.hbond_autocorrel</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Hydrogen bond autocorrelation --- :mod:`MDAnalysis.analysis.hbonds.hbond_autocorrel`</span>
<span class="sd">====================================================================================</span>

<span class="sd">:Author: Richard J. Gowers</span>
<span class="sd">:Year: 2014</span>
<span class="sd">:Copyright: GNU Public License v3</span>

<span class="sd">.. versionadded:: 0.9.0</span>

<span class="sd">Description</span>
<span class="sd">---------------</span>

<span class="sd">Calculates the time autocorrelation function, :math:`C_x(t)`, for the hydrogen</span>
<span class="sd">bonds in the selections passed to it.  The population of hydrogen bonds at a</span>
<span class="sd">given startpoint, :math:`t_0`, is evaluated based on geometric criteria and</span>
<span class="sd">then the lifetime of these bonds is monitored over time.  Multiple passes</span>
<span class="sd">through the trajectory are used to build an average of the behaviour.</span>

<span class="sd">    :math:`C_x(t) = \\left \\langle \\frac{h_{ij}(t_0) h_{ij}(t_0 + t)}{h_{ij}(t_0)^2} \\right\\rangle`</span>

<span class="sd">The subscript :math:`x` refers to the definition of lifetime being used, either</span>
<span class="sd">continuous or intermittent.  The continuous definition measures the time that</span>
<span class="sd">a particular hydrogen bond remains continuously attached, whilst the</span>
<span class="sd">intermittent definition allows a bond to break and then subsequently reform and</span>
<span class="sd">be counted again.  The relevent lifetime, :math:`\\tau_x`, can then be found</span>
<span class="sd">via integration of this function</span>

<span class="sd">    :math:`\\tau_x = \\int_0^\\infty C_x(t) dt`</span>

<span class="sd">For this, the observed behaviour is fitted to a multi exponential function,</span>
<span class="sd">using 2 exponents for the continuous lifetime and 3 for the intermittent</span>
<span class="sd">lifetime.</span>

<span class="sd">    :math:`C_x(t) = A_1 \\exp( - t / \\tau_1)</span>
<span class="sd">    + A_2 \\exp( - t / \\tau_2)</span>
<span class="sd">    [+ A_3 \\exp( - t / \\tau_3)]`</span>

<span class="sd">Where the final pre expoential factor :math:`A_n` is subject to the condition:</span>

<span class="sd">    :math:`A_n = 1 - \\sum\\limits_{i=1}^{n-1} A_i`</span>

<span class="sd">.. rubric:: References</span>

<span class="sd">.. [notsure]  Multiscale modelling of polymeric systems with hydrogen bonding: Selective removal of degrees of freedom</span>

<span class="sd">Input</span>
<span class="sd">---------------</span>

<span class="sd">Three AtomGroup selections representing the **hydrogens**, **donors** and</span>
<span class="sd">**acceptors** that you wish to analyse.  Note that the **hydrogens** and</span>
<span class="sd">**donors** selections must be aligned, that is **hydrogens[0]** and</span>
<span class="sd">**donors[0]** must represent a bonded pair.  If a single donor therefore has</span>
<span class="sd">two hydrogens, it must feature twice in the **donors** AtomGroup.</span>

<span class="sd">The keyword **exclusions** allows a tuple of array addresses to be provided,</span>
<span class="sd">(Hidx, Aidx),these pairs of hydrogen-acceptor are then not permitted to be</span>
<span class="sd">counted as part of the analysis.  This could be used to exclude the</span>
<span class="sd">consideration of hydrogen bonds within the same functional group, or to perform</span>
<span class="sd">analysis on strictly intermolecular hydrogen bonding.</span>

<span class="sd">Hydrogen bonds are defined on the basis of geometric criteria; a</span>
<span class="sd">Hydrogen-Acceptor distance of less then **dist_crit** and a</span>
<span class="sd">Donor-Hydrogen-Acceptor angle of greater than **angle_crit**.</span>

<span class="sd">The length of trajectory to analyse in ps, **sample_time**, is used to choose</span>
<span class="sd">what length to analyse.</span>

<span class="sd">Multiple passes, controlled by the keyword **nruns**, through the trajectory</span>
<span class="sd">are performed and an average calculated.  For each pass, **nsamples** number</span>
<span class="sd">of points along the run are calculated.</span>


<span class="sd">Output</span>
<span class="sd">---------------</span>

<span class="sd">All results of the analysis are available through the *solution* attribute.</span>
<span class="sd">This is a dictionary with the following keys</span>

<span class="sd">- *results*  The raw results of the time autocorrelation function.</span>
<span class="sd">- *time*     Time axis, in ps, for the results.</span>
<span class="sd">- *fit*      Results of the exponential curve fitting procedure. For the</span>
<span class="sd">             *continuous* lifetime these are (A1, tau1, tau2), for the</span>
<span class="sd">             *intermittent* lifetime these are (A1, A2, tau1, tau2, tau3).</span>
<span class="sd">- *tau*      Calculated time constant from the fit.</span>
<span class="sd">- *estimate* Estimated values generated by the calculated fit.</span>

<span class="sd">The *results* and *time* values are only filled after the :meth:`run` method,</span>
<span class="sd">*fit*, *tau* and *estimate* are filled after the :meth:`solve` method has been</span>
<span class="sd">used.</span>


<span class="sd">Examples</span>
<span class="sd">---------------</span>

<span class="sd">::</span>

<span class="sd">  from MDAnalysis.analysis import hbonds</span>
<span class="sd">  import matplotlib.pyplot as plt</span>
<span class="sd">  H = u.select_atoms(&#39;name Hn&#39;)</span>
<span class="sd">  O = u.select_atoms(&#39;name O&#39;)</span>
<span class="sd">  N = u.select_atoms(&#39;name N&#39;)</span>
<span class="sd">  hb_ac = hbonds.HydrogenBondAutoCorrel(u, acceptors = u.atoms.O,</span>
<span class="sd">              hydrogens = u.atoms.Hn, donors = u.atoms.N,bond_type=&#39;continuous&#39;,</span>
<span class="sd">              sample_time = 2, nruns = 20, nsamples = 1000)</span>
<span class="sd">  hb_ac.run()</span>
<span class="sd">  hb_ac.solve()</span>
<span class="sd">  tau = hb_ac.solution[&#39;tau&#39;]</span>
<span class="sd">  time = hb_ac.solution[&#39;time&#39;]</span>
<span class="sd">  results = hb_ac.solution[&#39;results&#39;]</span>
<span class="sd">  estimate = hb_ac.solution[&#39;estimate&#39;]</span>
<span class="sd">  plt.plot(time, results, &#39;ro&#39;)</span>
<span class="sd">  plt.plot(time, estimate)</span>
<span class="sd">  plt.show()</span>


<span class="sd">.. autoclass:: HydrogenBondAutoCorrel</span>

<span class="sd">   .. automethod:: run</span>

<span class="sd">   .. automethod:: solve</span>

<span class="sd">   .. automethod:: save_results</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">exp</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span>

<span class="kn">from</span> <span class="nn">MDAnalysis.lib.log</span> <span class="kn">import</span> <span class="n">ProgressMeter</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.distances</span> <span class="kn">import</span> <span class="n">distance_array</span><span class="p">,</span> <span class="n">calc_angles</span><span class="p">,</span> <span class="n">calc_bonds</span>


<div class="viewcode-block" id="HydrogenBondAutoCorrel"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_autocorrel.html#MDAnalysis.analysis.hbonds.hbond_autocorrel.HydrogenBondAutoCorrel">[docs]</a><span class="k">class</span> <span class="nc">HydrogenBondAutoCorrel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a time autocorrelation of the hydrogen bonds in the system. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span>
                 <span class="n">hydrogens</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">acceptors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">donors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">bond_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">exclusions</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">angle_crit</span><span class="o">=</span><span class="mf">130.0</span><span class="p">,</span> <span class="n">dist_crit</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>  <span class="c"># geometric criteria</span>
                 <span class="n">sample_time</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>  <span class="c"># expected length of the decay in ps</span>
                 <span class="n">time_cut</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>  <span class="c"># cutoff time for intermittent hbonds</span>
                 <span class="n">nruns</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c"># number of times to iterate through the trajectory</span>
                 <span class="n">nsamples</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>  <span class="c"># number of different points to sample in a run</span>
                 <span class="n">pbc</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :Arguments:</span>
<span class="sd">          *universe*</span>
<span class="sd">            The MDA universe</span>
<span class="sd">          *hydrogens*</span>
<span class="sd">            AtomGroup of Hydrogens which can form hydrogen bonds</span>
<span class="sd">          *acceptors*</span>
<span class="sd">            AtomGroup of all Acceptor atoms</span>
<span class="sd">          *donors*</span>
<span class="sd">            The atoms which are connected to the hydrogens.  This group</span>
<span class="sd">            must be identical in length to the hydrogen group and matched,</span>
<span class="sd">            ie hydrogens[1] is bonded to donors[0].</span>
<span class="sd">            For many cases, this will mean a donor appears twice in this</span>
<span class="sd">            group.</span>
<span class="sd">          *bond_type*</span>
<span class="sd">            Which definition of hydrogen bond lifetime to consider, either</span>
<span class="sd">            &#39;continuous&#39; or &#39;intermittent&#39;.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *exclusions*</span>
<span class="sd">            Indices of Hydrogen-Acceptor pairs to be excluded.</span>
<span class="sd">            With nH and nA Hydrogens and Acceptors, a (nH x nA) array of distances</span>
<span class="sd">            is calculated, *exclusions* is used as a mask on this array to exclude</span>
<span class="sd">            some pairs.</span>
<span class="sd">          *angle_crit*</span>
<span class="sd">            The angle (in degrees) which all bonds must be greater than [130.0]</span>
<span class="sd">          *dist_crit*</span>
<span class="sd">            The maximum distance (in Angstroms) for a hydrogen bond [3.0]</span>
<span class="sd">          *sample_time*</span>
<span class="sd">            The amount of time, in ps, that you wish to observe hydrogen</span>
<span class="sd">            bonds for [100]</span>
<span class="sd">          *nruns*</span>
<span class="sd">            The number of different start points within the trajectory</span>
<span class="sd">            to use [1]</span>
<span class="sd">          *nsamples*</span>
<span class="sd">            Within each run, the number of frames to analyse [50]</span>
<span class="sd">          *pbc*</span>
<span class="sd">            Whether to consider periodic boundaries in calculations [``True``]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="c"># check that slicing is possible</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Trajectory must support slicing&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">hydrogens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">acceptors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">donors</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Donors and Hydrogen groups must be matched&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span> <span class="o">=</span> <span class="n">exclusions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&quot;&#39;exclusion&#39; must be two arrays of identical length&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bond_type</span> <span class="o">=</span> <span class="n">bond_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;continuous&#39;</span><span class="p">,</span> <span class="s">&#39;intermittent&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&quot;bond_type must be either &#39;continuous&#39; or &#39;intermittent&#39;&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a_crit</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angle_crit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_crit</span> <span class="o">=</span> <span class="n">dist_crit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_time</span> <span class="o">=</span> <span class="n">sample_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nruns</span> <span class="o">=</span> <span class="n">nruns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slice_traj</span><span class="p">(</span><span class="n">sample_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_cut</span> <span class="o">=</span> <span class="n">time_cut</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;results&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>  <span class="c"># Raw results</span>
            <span class="s">&#39;time&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>  <span class="c"># Time axis of raw results</span>
            <span class="s">&#39;fit&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>  <span class="c"># coefficients for fit</span>
            <span class="s">&#39;tau&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>  <span class="c"># integral of exponential fit</span>
            <span class="s">&#39;estimate&#39;</span><span class="p">:</span> <span class="bp">None</span>  <span class="c"># y values of fit against time</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_slice_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set up start and end points in the trajectory for the</span>
<span class="sd">        different passes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">dt</span>  <span class="c"># frame step size in time</span>
        <span class="n">req_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_time</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>  <span class="c"># the number of frames required</span>

        <span class="n">n_frames</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">req_frames</span> <span class="o">&gt;</span> <span class="n">n_frames</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Number of required frames ({}) greater than the&quot;</span>
                          <span class="s">&quot; number of frames in trajectory ({})&quot;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">req_frames</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="n">numruns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nruns</span>
        <span class="k">if</span> <span class="n">numruns</span> <span class="o">&gt;</span> <span class="n">n_frames</span><span class="p">:</span>
            <span class="n">numruns</span> <span class="o">=</span> <span class="n">n_frames</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Number of runs ({}) greater than the number of&quot;</span>
                          <span class="s">&quot; frames in trajectory ({})&quot;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nruns</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_starts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">,</span> <span class="n">n_frames</span> <span class="o">/</span> <span class="n">numruns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c"># limit stop points using clip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stops</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_starts</span> <span class="o">+</span> <span class="n">req_frames</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="n">req_frames</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># If nsamples &gt; req_frames</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Desired number of sample points too high, using {}&quot;</span>
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">req_frames</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="HydrogenBondAutoCorrel.run"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_autocorrel.html#MDAnalysis.analysis.hbonds.hbond_autocorrel.HydrogenBondAutoCorrel.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run all the required passes</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *force*</span>
<span class="sd">            Will overwrite previous results if they exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># if results exist, don&#39;t waste any time</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;results&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">master_results</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_starts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">_stops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span><span class="p">),</span>
                                          <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c"># for normalising later</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">master_results</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">pm</span> <span class="o">=</span> <span class="n">ProgressMeter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nruns</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">format</span><span class="o">=</span><span class="s">&quot;Performing run </span><span class="si">%(step)5d</span><span class="s">/</span><span class="si">%(numsteps)d</span><span class="s">&quot;</span>
                                  <span class="s">&quot;[</span><span class="si">%(percentage)5.1f%%</span><span class="s">]</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_starts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stops</span><span class="p">)):</span>
            <span class="n">pm</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c"># needed else trj seek thinks a numpy.int64 isn&#39;t an int?</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_run</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">stop</span><span class="p">))</span>

            <span class="n">nresults</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nresults</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">master_results</span><span class="p">):</span>
                <span class="n">master_results</span> <span class="o">+=</span> <span class="n">results</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">master_results</span><span class="p">[:</span><span class="n">nresults</span><span class="p">]</span> <span class="o">+=</span> <span class="n">results</span>
                <span class="n">counter</span><span class="p">[:</span><span class="n">nresults</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>

        <span class="n">master_results</span> <span class="o">/=</span> <span class="n">counter</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">master_results</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">dt</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;results&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">master_results</span>
</div>
    <span class="k">def</span> <span class="nf">_single_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a single pass of the trajectory&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>

        <span class="c"># Calculate partners at t=0</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="k">else</span> <span class="bp">None</span>

        <span class="c"># 2d array of all distances</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">distance_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span><span class="p">:</span>
            <span class="c"># set to above dist crit to exclude</span>
            <span class="n">d</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_crit</span> <span class="o">+</span> <span class="mf">1.0</span>

        <span class="c"># find which partners satisfy distance criteria</span>
        <span class="n">hidx</span><span class="p">,</span> <span class="n">aidx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_crit</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">calc_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">hidx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">hidx</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">aidx</span><span class="p">],</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
        <span class="c"># from amongst those, who also satisfiess angle crit</span>
        <span class="n">idx2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_crit</span><span class="p">)</span>
        <span class="n">hidx</span> <span class="o">=</span> <span class="n">hidx</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>
        <span class="n">aidx</span> <span class="o">=</span> <span class="n">aidx</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>

        <span class="n">nbonds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hidx</span><span class="p">)</span>  <span class="c"># number of hbonds at t=0</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span><span class="p">),</span>
                                   <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_cut</span><span class="p">:</span>
            <span class="c"># counter for time criteria</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbonds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_skip</span><span class="p">]):</span>
            <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="k">else</span> <span class="bp">None</span>

            <span class="n">d</span> <span class="o">=</span> <span class="n">calc_bonds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">hidx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">aidx</span><span class="p">],</span>
                           <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">calc_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">hidx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">hidx</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">aidx</span><span class="p">],</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>

            <span class="n">winners</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_crit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_crit</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">winners</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_type</span> <span class="ow">is</span> <span class="s">&#39;continuous&#39;</span><span class="p">:</span>
                <span class="c"># Remove losers for continuous definition</span>
                <span class="n">hidx</span> <span class="o">=</span> <span class="n">hidx</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">winners</span><span class="p">)]</span>
                <span class="n">aidx</span> <span class="o">=</span> <span class="n">aidx</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">winners</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_type</span> <span class="ow">is</span> <span class="s">&#39;intermittent&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_cut</span><span class="p">:</span>
                    <span class="c"># Add to counter of where losers are</span>
                    <span class="n">count</span><span class="p">[</span><span class="o">~</span> <span class="n">winners</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">dt</span>
                    <span class="n">count</span><span class="p">[</span><span class="n">winners</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># Reset timer for winners</span>

                    <span class="c"># Remove if you&#39;ve lost too many times</span>
                    <span class="c"># New arrays contain everything but removals</span>
                    <span class="n">hidx</span> <span class="o">=</span> <span class="n">hidx</span><span class="p">[</span><span class="n">count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_cut</span><span class="p">]</span>
                    <span class="n">aidx</span> <span class="o">=</span> <span class="n">aidx</span><span class="p">[</span><span class="n">count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_cut</span><span class="p">]</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_cut</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hidx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># Once everyone has lost, the fun stops</span>
                <span class="k">break</span>

        <span class="n">results</span> <span class="o">/=</span> <span class="n">nbonds</span>

        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="HydrogenBondAutoCorrel.save_results"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_autocorrel.html#MDAnalysis.analysis.hbonds.hbond_autocorrel.HydrogenBondAutoCorrel.save_results">[docs]</a>    <span class="k">def</span> <span class="nf">save_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;hbond_autocorrel&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves the results to a numpy zipped array (.npz, see numpy.savez)</span>

<span class="sd">        This can be loaded using numpy.load(filename)</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *filename*</span>
<span class="sd">            The desired filename [hbond_autocorrel]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;results&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">],</span>
                        <span class="n">results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;results&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&quot;Results have not been generated, use the run method first&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="HydrogenBondAutoCorrel.solve"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_autocorrel.html#MDAnalysis.analysis.hbonds.hbond_autocorrel.HydrogenBondAutoCorrel.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_guess</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit results to an multi exponential decay and integrate to find</span>
<span class="sd">        characteristic time</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *p_guess*</span>
<span class="sd">            Initial guess for the leastsq fit, must match the shape of the</span>
<span class="sd">            expected coefficients</span>

<span class="sd">        Continuous defition results are fitted to a double exponential,</span>
<span class="sd">        intermittent definition are fit to a triple exponential.</span>

<span class="sd">        The results of this fitting procedure are saved into the *fit*,</span>
<span class="sd">        *tau* and *estimate* keywords in the solution dict.</span>

<span class="sd">         - *fit* contains the coefficients, (A1, tau1, tau2) or</span>
<span class="sd">           (A1, A2, tau1, tau2, tau3)</span>
<span class="sd">         - *tau* contains the calculated lifetime in ps for the hydrogen</span>
<span class="sd">           bonding</span>
<span class="sd">         - *estimate* contains the estimate provided by the fit of the time</span>
<span class="sd">           autocorrelation function</span>

<span class="sd">        In addition, the output of the leastsq function is saved into the</span>
<span class="sd">        solution dict</span>

<span class="sd">         - *infodict*</span>
<span class="sd">         - *mesg*</span>
<span class="sd">         - *ier*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">leastsq</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;results&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&quot;Results have not been generated use, the run method first&quot;</span><span class="p">)</span>

        <span class="c"># Prevents an odd bug with leastsq where it expects</span>
        <span class="c"># double precision data sometimes...</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;results&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">within_bounds</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Returns True/False if boundary conditions are met or not.</span>
<span class="sd">            Uses length of p to detect whether it&#39;s handling continuous /</span>
<span class="sd">            intermittent</span>

<span class="sd">            Boundary conditions are:</span>
<span class="sd">             0 &lt; A_x &lt; 1</span>
<span class="sd">             sum(A_x) &lt; 1</span>
<span class="sd">             0 &lt; tau_x</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">A1</span><span class="p">,</span> <span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span> <span class="o">=</span> <span class="n">p</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">A1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A1</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">tau1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tau2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span><span class="p">,</span> <span class="n">tau3</span> <span class="o">=</span> <span class="n">p</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">A1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A1</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">A2</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">A1</span> <span class="o">+</span> <span class="n">A2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">tau1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tau2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tau3</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">err</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Custom residual function, returns real residual if all</span>
<span class="sd">            boundaries are met, else returns a large number to trick the</span>
<span class="sd">            leastsq algorithm</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">within_bounds</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_my_solve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">100000</span>

        <span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> <span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Sum of two exponential functions &quot;&quot;&quot;</span>
            <span class="n">A2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">A1</span>
            <span class="k">return</span> <span class="n">A1</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">tau1</span><span class="p">)</span> <span class="o">+</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">tau2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">triple</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span><span class="p">,</span> <span class="n">tau3</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Sum of three exponential functions &quot;&quot;&quot;</span>
            <span class="n">A3</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">A1</span> <span class="o">+</span> <span class="n">A2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">A1</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">tau1</span><span class="p">)</span> <span class="o">+</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">tau2</span><span class="p">)</span> <span class="o">+</span> <span class="n">A3</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">tau3</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_type</span> <span class="ow">is</span> <span class="s">&#39;continuous&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_my_solve</span> <span class="o">=</span> <span class="n">double</span>

            <span class="k">if</span> <span class="n">p_guess</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">p_guess</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_time</span><span class="p">)</span>

            <span class="n">p</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">infodict</span><span class="p">,</span> <span class="n">mesg</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">leastsq</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">p_guess</span><span class="p">,</span>
                                                  <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">results</span><span class="p">),</span>
                                                  <span class="n">full_output</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;fit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">A1</span><span class="p">,</span> <span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">A2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">A1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;tau&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A1</span> <span class="o">*</span> <span class="n">tau1</span> <span class="o">+</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">tau2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_my_solve</span> <span class="o">=</span> <span class="n">triple</span>

            <span class="k">if</span> <span class="n">p_guess</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">p_guess</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.33</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_time</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_time</span><span class="p">)</span>

            <span class="n">p</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">infodict</span><span class="p">,</span> <span class="n">mesg</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">leastsq</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">p_guess</span><span class="p">,</span>
                                                  <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">results</span><span class="p">),</span>
                                                  <span class="n">full_output</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;fit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">tau1</span><span class="p">,</span> <span class="n">tau2</span><span class="p">,</span> <span class="n">tau3</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">A3</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">A1</span> <span class="o">-</span> <span class="n">A2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;tau&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A1</span> <span class="o">*</span> <span class="n">tau1</span> <span class="o">+</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">tau2</span> <span class="o">+</span> <span class="n">A3</span> <span class="o">*</span> <span class="n">tau3</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;infodict&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">infodict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;mesg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;ier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ier</span>

        <span class="k">if</span> <span class="n">ier</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>  <span class="c"># solution found if ier is one of these values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;estimate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_my_solve</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">],</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Solution to results not found&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt; MDAnalysis HydrogenBondAutoCorrel analysis measuring the &quot;</span> <span class="o">+</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">bond_type</span> <span class="o">+</span> \
               <span class="s">&quot; lifetime of {0} different hydrogens &gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">))</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sbastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domaski, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac Virshup,
    Zhuyi Xue, Carlos Yez S.,
    and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>