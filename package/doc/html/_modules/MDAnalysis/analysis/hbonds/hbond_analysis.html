<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.analysis.hbonds.hbond_analysis &mdash; MDAnalysis 0.11.0 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.11.0 documentation"
          href="../../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.11.0 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.analysis.hbonds.hbond_analysis</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="c"># Hydrogen Bonding Analysis</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Hydrogen Bond analysis --- :mod:`MDAnalysis.analysis.hbonds.hbond_analysis`</span>
<span class="sd">===========================================================================</span>

<span class="sd">:Author: David Caplan, Lukas Grossar, Oliver Beckstein</span>
<span class="sd">:Year: 2010-2012</span>
<span class="sd">:Copyright: GNU Public License v3</span>


<span class="sd">Given a :class:`~MDAnalysis.core.AtomGroup.Universe` (simulation</span>
<span class="sd">trajectory with 1 or more frames) measure all hydrogen bonds for each</span>
<span class="sd">frame between selections 1 and 2.</span>

<span class="sd">The :class:`HydrogenBondAnalysis` class is modeled after the `VMD</span>
<span class="sd">HBONDS plugin`_.</span>

<span class="sd">.. _`VMD HBONDS plugin`: http://www.ks.uiuc.edu/Research/vmd/plugins/hbonds/</span>

<span class="sd">Options:</span>
<span class="sd">  - *update_selections* (``True``): update selections at each frame?</span>
<span class="sd">  - *selection_1_type* (&quot;both&quot;): selection 1 is the: &quot;donor&quot;, &quot;acceptor&quot;, &quot;both&quot;</span>
<span class="sd">  - donor-acceptor *distance* (Å): 3.0</span>
<span class="sd">  - Angle *cutoff* (degrees): 120.0</span>
<span class="sd">  - *forcefield* to switch between default values for different force fields</span>
<span class="sd">  - *donors* and *acceptors* atom types (to add additional atom names)</span>

<span class="sd">.. _Analysis Output:</span>

<span class="sd">Output</span>
<span class="sd">------</span>

<span class="sd">The results are</span>
<span class="sd">  - the **identities** of donor and acceptor heavy-atoms,</span>
<span class="sd">  - the **distance** between the heavy atom acceptor atom and the hydrogen atom</span>
<span class="sd">    that is bonded to the heavy atom donor,</span>
<span class="sd">  - the **angle** donor-hydrogen-acceptor angle (180º is linear).</span>

<span class="sd">Hydrogen bond data are returned per frame, which is stored in</span>
<span class="sd">:attr:`HydrogenBondAnalysis.timeseries` (In the following description, ``#``</span>
<span class="sd">indicates comments that are not part of the output.)::</span>

<span class="sd">    results = [</span>
<span class="sd">        [ # frame 1</span>
<span class="sd">           [ # hbond 1</span>
<span class="sd">              &lt;donor index&gt;, &lt;acceptor index&gt;, &lt;donor string&gt;, &lt;acceptor string&gt;, &lt;distance&gt;, &lt;angle&gt;</span>
<span class="sd">           ],</span>
<span class="sd">           [ # hbond 2</span>
<span class="sd">              &lt;donor index&gt;, &lt;acceptor index&gt;, &lt;donor string&gt;, &lt;acceptor string&gt;, &lt;distance&gt;, &lt;angle&gt;</span>
<span class="sd">           ],</span>
<span class="sd">           ....</span>
<span class="sd">        ],</span>
<span class="sd">        [ # frame 2</span>
<span class="sd">          [ ... ], [ ... ], ...</span>
<span class="sd">        ],</span>
<span class="sd">        ...</span>
<span class="sd">    ]</span>

<span class="sd">.. Note::</span>

<span class="sd">   For historic reasons, the *donor index* and *acceptor index* are a 1-based</span>
<span class="sd">   indices. To get the :attr:`Atom.index` (the 0-based index typically used in</span>
<span class="sd">   MDAnalysis simply subtract 1. For instance, to find an atom in</span>
<span class="sd">   :attr:`Universe.atoms` by *index* from the output one would use</span>
<span class="sd">   ``u.atoms[index-1]``.</span>


<span class="sd">Using the :meth:`HydrogenBondAnalysis.generate_table` method one can reformat</span>
<span class="sd">the results as a flat &quot;normalised&quot; table that is easier to import into a</span>
<span class="sd">database for further processing. :meth:`HydrogenBondAnalysis.save_table` saves</span>
<span class="sd">the table to a pickled file. The table itself is a :class:`numpy.recarray`.</span>


<span class="sd">Detection of hydrogen bonds</span>
<span class="sd">---------------------------</span>

<span class="sd">Hydrogen bonds are recorded based on a geometric criterion:</span>

<span class="sd">1. The distance between acceptor and hydrogen is less than or equal to</span>
<span class="sd">   *distance* (default is 3 Å).</span>

<span class="sd">2. The angle between donor-hydrogen-acceptor is greater than or equal to</span>
<span class="sd">   *angle* (default is 120º).</span>

<span class="sd">The cut-off values *angle* and *distance* can be set as keywords to</span>
<span class="sd">:class:`HydrogenBondAnalysis`.</span>

<span class="sd">Donor and acceptor heavy atoms are detected from atom names. The current</span>
<span class="sd">defaults are appropriate for the CHARMM27 and GLYCAM06 force fields as defined</span>
<span class="sd">in Table `Default atom names for hydrogen bonding analysis`_.</span>

<span class="sd">Hydrogen atoms bonded to a donor are searched with one of two algorithms,</span>
<span class="sd">selected with the *detect_hydrogens* keyword.</span>

<span class="sd">*distance*</span>

<span class="sd">   Searches for all hydrogens (name &quot;H*&quot; or name &quot;[123]H&quot; or type &quot;H&quot;) in the</span>
<span class="sd">   same residue as the donor atom within a cut-off distance of 1.2 Å.</span>

<span class="sd">*heuristic*</span>

<span class="sd">   Looks at the next three atoms in the list of atoms following the donor and</span>
<span class="sd">   selects any atom whose name matches (name &quot;H*&quot; or name &quot;[123]H&quot;). For</span>

<span class="sd">The *distance* search is more rigorous but slower and is set as the</span>
<span class="sd">default. Until release 0.7.6, only the heuristic search was implemented.</span>

<span class="sd">.. versionchanged:: 0.7.6</span>
<span class="sd">   Distance search added (see</span>
<span class="sd">   :meth:`HydrogenBondAnalysis._get_bonded_hydrogens_dist`) and heuristic</span>
<span class="sd">   search improved (:meth:`HydrogenBondAnalysis._get_bonded_hydrogens_list`)</span>

<span class="sd">.. _Default atom names for hydrogen bonding analysis:</span>

<span class="sd">.. table:: Default heavy atom names for CHARMM27 force field.</span>

<span class="sd">   =========== ==============  =========== ====================================</span>
<span class="sd">   group       donor           acceptor    comments</span>
<span class="sd">   =========== ==============  =========== ====================================</span>
<span class="sd">   main chain  N               O</span>
<span class="sd">   water       OH2, OW         OH2, OW     SPC, TIP3P, TIP4P (CHARMM27,Gromacs)</span>

<span class="sd">   ARG         NE, NH1, NH2</span>
<span class="sd">   ASN         ND2             OD1</span>
<span class="sd">   ASP                         OD1, OD2</span>
<span class="sd">   CYS         SG</span>
<span class="sd">   CYH                         SG          possible false positives for CYS</span>
<span class="sd">   GLN         NE2             OE1</span>
<span class="sd">   GLU                         OE1, OE2</span>
<span class="sd">   HIS         ND1, NE2        ND1, NE2    presence of H determines if donor</span>
<span class="sd">   HSD         ND1             NE2</span>
<span class="sd">   HSE         NE2             ND1</span>
<span class="sd">   HSP         ND1, NE2</span>
<span class="sd">   LYS         NZ</span>
<span class="sd">   MET                         SD          see e.g. [Gregoret1991]_</span>
<span class="sd">   SER         OG              OG</span>
<span class="sd">   THR         OG1             OG1</span>
<span class="sd">   TRP         NE1</span>
<span class="sd">   TYR         OH              OH</span>
<span class="sd">   =========== ==============  =========== ====================================</span>

<span class="sd">.. table:: Heavy atom types for GLYCAM06 force field.</span>

<span class="sd">   =========== =========== ==================</span>
<span class="sd">   element     donor       acceptor</span>
<span class="sd">   =========== =========== ==================</span>
<span class="sd">   N           N,NT,N3     N,NT</span>
<span class="sd">   O           OH,OW       O,O2,OH,OS,OW,OY</span>
<span class="sd">   S                       SM</span>
<span class="sd">   =========== =========== ==================</span>

<span class="sd">Donor and acceptor names for the CHARMM27 force field will also work for e.g.</span>
<span class="sd">OPLS/AA (tested in Gromacs). Residue names in the table are for information</span>
<span class="sd">only and are not taken into account when determining acceptors and donors.</span>
<span class="sd">This can potentially lead to some ambiguity in the assignment of</span>
<span class="sd">donors/acceptors for residues such as histidine or cytosine.</span>

<span class="sd">For more information about the naming convention in GLYCAM06 have a look at the</span>
<span class="sd">`Carbohydrate Naming Convention in Glycam`.</span>

<span class="sd">.. _`Carbohydrate Naming Convention in Glycam`:</span>
<span class="sd">   http://glycam.ccrc.uga.edu/documents/FutureNomenclature.htm</span>

<span class="sd">The lists of donor and acceptor names can be extended by providing lists of</span>
<span class="sd">atom names in the *donors* and *acceptors* keywords to</span>
<span class="sd">:class:`HydrogenBondAnalysis`. If the lists are entirely inappropriate</span>
<span class="sd">(e.g. when analysing simulations done with a force field that uses very</span>
<span class="sd">different atom names) then one should either use the value &quot;other&quot; for *forcefield*</span>
<span class="sd">to set no default values, or derive a new class and set the default list oneself::</span>

<span class="sd"> class HydrogenBondAnalysis_OtherFF(HydrogenBondAnalysis):</span>
<span class="sd">       DEFAULT_DONORS = {&quot;OtherFF&quot;: tuple(set([...]))}</span>
<span class="sd">       DEFAULT_ACCEPTORS = {&quot;OtherFF&quot;: tuple(set([...]))}</span>

<span class="sd">Then simply use the new class instead of the parent class and call it with</span>
<span class="sd">*forcefield* = &quot;OtherFF&quot;. Please also consider to contribute the list of heavy</span>
<span class="sd">atom names to MDAnalysis.</span>

<span class="sd">.. rubric:: References</span>

<span class="sd">.. [Gregoret1991] L.M. Gregoret, S.D. Rader, R.J. Fletterick, and</span>
<span class="sd">   F.E. Cohen. Hydrogen bonds involving sulfur atoms in proteins. Proteins,</span>
<span class="sd">   9(2):99–107, 1991. `10.1002/prot.340090204`_.</span>

<span class="sd">.. _`10.1002/prot.340090204`: http://dx.doi.org/10.1002/prot.340090204</span>


<span class="sd">Example</span>
<span class="sd">-------</span>

<span class="sd">All protein-water hydrogen bonds can be analysed with ::</span>

<span class="sd">  import MDAnalysis.analysis.hbonds</span>

<span class="sd">  u = MDAnalysis.Universe(PSF, PDB, permissive=True)</span>
<span class="sd">  h = MDAnalysis.analysis.hbonds.HydrogenBondAnalysis(u, &#39;protein&#39;, &#39;resname TIP3&#39;, distance=3.0, angle=120.0)</span>
<span class="sd">  h.run()</span>

<span class="sd">The results are stored as the attribute</span>
<span class="sd">:attr:`HydrogenBondAnalysis.timeseries`; see :ref:`Analysis Output`</span>
<span class="sd">for the format and further options.</span>

<span class="sd">.. Note::</span>

<span class="sd">   Due to the way :class:`HydrogenBondAnalysis` is implemented, it is</span>
<span class="sd">   more efficient to have the second selection (*selection2*) be the</span>
<span class="sd">   *larger* group, e.g. the water when looking at water-protein</span>
<span class="sd">   H-bonds or the whole protein when looking at ligand-protein</span>
<span class="sd">   interactions.</span>

<span class="sd">.. TODO: how to analyse the ouput and notes on selection updating</span>


<span class="sd">Classes</span>
<span class="sd">-------</span>

<span class="sd">.. autoclass:: HydrogenBondAnalysis</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: timesteps</span>

<span class="sd">      List of the times of each timestep. This can be used together with</span>
<span class="sd">      :attr:`~HydrogenBondAnalysis.timeseries` to find the specific time point</span>
<span class="sd">      of a hydrogen bond existence, or see :attr:`~HydrogenBondAnalysis.table`.</span>

<span class="sd">   .. attribute:: timeseries</span>

<span class="sd">      Results of the hydrogen bond analysis, stored for each frame. In</span>
<span class="sd">      the following description, # indicates comments that are not</span>
<span class="sd">      part of the output::</span>

<span class="sd">        results = [</span>
<span class="sd">            [ # frame 1</span>
<span class="sd">               [ # hbond 1</span>
<span class="sd">                  &lt;donor index&gt;, &lt;acceptor index&gt;, &lt;donor string&gt;, &lt;acceptor string&gt;, &lt;distance&gt;, &lt;angle&gt;</span>
<span class="sd">               ],</span>
<span class="sd">               [ # hbond 2</span>
<span class="sd">                  &lt;donor index&gt;, &lt;acceptor index&gt;, &lt;donor string&gt;, &lt;acceptor string&gt;, &lt;distance&gt;, &lt;angle&gt;</span>
<span class="sd">               ],</span>
<span class="sd">               ....</span>
<span class="sd">            ],</span>
<span class="sd">            [ # frame 2</span>
<span class="sd">              [ ... ], [ ... ], ...</span>
<span class="sd">            ],</span>
<span class="sd">            ...</span>
<span class="sd">        ]</span>

<span class="sd">      The time of each step is not stored with each hydrogen bond frame but in</span>
<span class="sd">      :attr:`~HydrogenBondAnalysis.timesteps`.</span>

<span class="sd">      .. Note::</span>

<span class="sd">         The *index* is a 1-based index. To get the :attr:`Atom.index` (the</span>
<span class="sd">         0-based index typically used in MDAnalysis simply subtract 1. For</span>
<span class="sd">         instance, to find an atom in :attr:`Universe.atoms` by *index* one</span>
<span class="sd">         would use ``u.atoms[index-1]``.</span>

<span class="sd">   .. attribute:: table</span>

<span class="sd">      A normalised table of the data in</span>
<span class="sd">      :attr:`HydrogenBondAnalysis.timeseries`, generated by</span>
<span class="sd">      :meth:`HydrogenBondAnalysis.generate_table`. It is a</span>
<span class="sd">      :class:`numpy.recarray` with the following columns:</span>

<span class="sd">          0. &quot;time&quot;</span>
<span class="sd">          1. &quot;donor_idx&quot;</span>
<span class="sd">          2. &quot;acceptor_idx&quot;</span>
<span class="sd">          3. &quot;donor_resnm&quot;</span>
<span class="sd">          4. &quot;donor_resid&quot;</span>
<span class="sd">          5. &quot;donor_atom&quot;</span>
<span class="sd">          6. &quot;acceptor_resnm&quot;</span>
<span class="sd">          7. &quot;acceptor_resid&quot;</span>
<span class="sd">          8. &quot;acceptor_atom&quot;</span>
<span class="sd">          9. &quot;distance&quot;</span>
<span class="sd">          10. &quot;angle&quot;</span>

<span class="sd">      It takes up more space than</span>
<span class="sd">      :attr:`~HydrogenBondAnalysis.timeseries` but it is easier to</span>
<span class="sd">      analyze and to import into databases (e.g. using recsql_).</span>

<span class="sd">      .. Note::</span>

<span class="sd">         The *index* is a 1-based index. To get the :attr:`Atom.index` (the</span>
<span class="sd">         0-based index typically used in MDAnalysis simply subtract 1. For</span>
<span class="sd">         instance, to find an atom in :attr:`Universe.atoms` by *index* one</span>
<span class="sd">         would use ``u.atoms[index-1]``.</span>


<span class="sd">   .. automethod:: _get_bonded_hydrogens</span>

<span class="sd">   .. automethod:: _get_bonded_hydrogens_dist</span>

<span class="sd">   .. automethod:: _get_bonded_hydrogens_list</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">MissingDataWarning</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">,</span> <span class="n">SelectionError</span><span class="p">,</span> <span class="n">SelectionWarning</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.core.AtomGroup</span> <span class="kn">import</span> <span class="n">AtomGroup</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.util</span> <span class="kn">import</span> <span class="n">parse_residue</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.mdamath</span> <span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">angle</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.log</span> <span class="kn">import</span> <span class="n">ProgressMeter</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.NeighborSearch</span> <span class="kn">import</span> <span class="n">AtomNeighborSearch</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&#39;MDAnalysis.analysis.hbonds&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="HydrogenBondAnalysis"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis">[docs]</a><span class="k">class</span> <span class="nc">HydrogenBondAnalysis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a hydrogen bond analysis</span>

<span class="sd">    The analysis of the trajectory is performed with the</span>
<span class="sd">    :meth:`HydrogenBondAnalysis.run` method. The result is stored in</span>
<span class="sd">    :attr:`HydrogenBondAnalysis.timeseries`. See</span>
<span class="sd">    :meth:`~HydrogenBondAnalysis.run` for the format.</span>

<span class="sd">    The default atom names are taken from the CHARMM 27 force field files, which</span>
<span class="sd">    will also work for e.g. OPLS/AA in Gromacs, and GLYCAM06.</span>

<span class="sd">    *Donors* (associated hydrogens are deduced from topology)</span>
<span class="sd">      *CHARMM 27*</span>
<span class="sd">        N of the main chain, water OH2/OW, ARG NE/NH1/NH2, ASN ND2, HIS ND1/NE2,</span>
<span class="sd">        SER OG, TYR OH, CYS SG, THR OG1, GLN NE2, LYS NZ, TRP NE1</span>
<span class="sd">      *GLYCAM06*</span>
<span class="sd">        N,NT,N3,OH,OW</span>

<span class="sd">    *Acceptors*</span>
<span class="sd">      *CHARMM 27*</span>
<span class="sd">        O of the main chain, water OH2/OW, ASN OD1, ASP OD1/OD2, CYH SG, GLN OE1,</span>
<span class="sd">        GLU OE1/OE2, HIS ND1/NE2, MET SD, SER OG, THR OG1, TYR OH</span>
<span class="sd">      *GLYCAM06*</span>
<span class="sd">        N,NT,O,O2,OH,OS,OW,OY,P,S,SM</span>

<span class="sd">    .. SeeAlso:: Table :ref:`Default atom names for hydrogen bonding analysis`</span>

<span class="sd">    .. versionchanged:: 0.7.6</span>
<span class="sd">       DEFAULT_DONORS/ACCEPTORS is now embedded in a dict to switch between</span>
<span class="sd">       default values for different force fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># use tuple(set()) here so that one can just copy&amp;paste names from the</span>
    <span class="c"># table; set() takes care for removing duplicates. At the end the</span>
    <span class="c"># DEFAULT_DONORS and DEFAULT_ACCEPTORS should simply be tuples.</span>

    <span class="c"># : default heavy atom names whose hydrogens are treated as *donors*</span>
    <span class="c"># : (see :ref:`Default atom names for hydrogen bonding analysis`)</span>
    <span class="c">#: Use the keyword *donors* to add a list of additional donor names.</span>
    <span class="n">DEFAULT_DONORS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;CHARMM27&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span>
            <span class="s">&#39;N&#39;</span><span class="p">,</span> <span class="s">&#39;OH2&#39;</span><span class="p">,</span> <span class="s">&#39;OW&#39;</span><span class="p">,</span> <span class="s">&#39;NE&#39;</span><span class="p">,</span> <span class="s">&#39;NH1&#39;</span><span class="p">,</span> <span class="s">&#39;NH2&#39;</span><span class="p">,</span> <span class="s">&#39;ND2&#39;</span><span class="p">,</span> <span class="s">&#39;SG&#39;</span><span class="p">,</span> <span class="s">&#39;NE2&#39;</span><span class="p">,</span> <span class="s">&#39;ND1&#39;</span><span class="p">,</span> <span class="s">&#39;NZ&#39;</span><span class="p">,</span> <span class="s">&#39;OG&#39;</span><span class="p">,</span> <span class="s">&#39;OG1&#39;</span><span class="p">,</span> <span class="s">&#39;NE1&#39;</span><span class="p">,</span> <span class="s">&#39;OH&#39;</span><span class="p">])),</span>
        <span class="s">&#39;GLYCAM06&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="s">&#39;N&#39;</span><span class="p">,</span> <span class="s">&#39;NT&#39;</span><span class="p">,</span> <span class="s">&#39;N3&#39;</span><span class="p">,</span> <span class="s">&#39;OH&#39;</span><span class="p">,</span> <span class="s">&#39;OW&#39;</span><span class="p">])),</span>
        <span class="s">&#39;other&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([]))}</span>

    <span class="c">#: default atom names that are treated as hydrogen *acceptors*</span>
    <span class="c">#: (see :ref:`Default atom names for hydrogen bonding analysis`)</span>
    <span class="c">#: Use the keyword *acceptors* to add a list of additional acceptor names.</span>
    <span class="n">DEFAULT_ACCEPTORS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;CHARMM27&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span>
            <span class="s">&#39;O&#39;</span><span class="p">,</span> <span class="s">&#39;OH2&#39;</span><span class="p">,</span> <span class="s">&#39;OW&#39;</span><span class="p">,</span> <span class="s">&#39;OD1&#39;</span><span class="p">,</span> <span class="s">&#39;OD2&#39;</span><span class="p">,</span> <span class="s">&#39;SG&#39;</span><span class="p">,</span> <span class="s">&#39;OE1&#39;</span><span class="p">,</span> <span class="s">&#39;OE1&#39;</span><span class="p">,</span> <span class="s">&#39;OE2&#39;</span><span class="p">,</span> <span class="s">&#39;ND1&#39;</span><span class="p">,</span> <span class="s">&#39;NE2&#39;</span><span class="p">,</span> <span class="s">&#39;SD&#39;</span><span class="p">,</span> <span class="s">&#39;OG&#39;</span><span class="p">,</span> <span class="s">&#39;OG1&#39;</span><span class="p">,</span> <span class="s">&#39;OH&#39;</span><span class="p">])),</span>
        <span class="s">&#39;GLYCAM06&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="s">&#39;N&#39;</span><span class="p">,</span> <span class="s">&#39;NT&#39;</span><span class="p">,</span> <span class="s">&#39;O&#39;</span><span class="p">,</span> <span class="s">&#39;O2&#39;</span><span class="p">,</span> <span class="s">&#39;OH&#39;</span><span class="p">,</span> <span class="s">&#39;OS&#39;</span><span class="p">,</span> <span class="s">&#39;OW&#39;</span><span class="p">,</span> <span class="s">&#39;OY&#39;</span><span class="p">,</span> <span class="s">&#39;SM&#39;</span><span class="p">])),</span>
        <span class="s">&#39;other&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([]))}</span>

    <span class="c">#: A :class:`collections.defaultdict` of covalent radii of common donors</span>
    <span class="c">#: (used in :meth`_get_bonded_hydrogens_list` to check if a hydrogen is</span>
    <span class="c">#: sufficiently close to its donor heavy atom). Values are stored for</span>
    <span class="c">#: N, O, P, and S. Any other heavy atoms are assumed to have hydrogens</span>
    <span class="c">#: covalently bound at a maximum distance of 1.5 Å.</span>
    <span class="n">r_cov</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">,</span>  <span class="c"># default value</span>
                        <span class="n">N</span><span class="o">=</span><span class="mf">1.31</span><span class="p">,</span> <span class="n">O</span><span class="o">=</span><span class="mf">1.31</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="mf">1.58</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="mf">1.55</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="n">selection1</span><span class="o">=</span><span class="s">&#39;protein&#39;</span><span class="p">,</span> <span class="n">selection2</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="n">selection1_type</span><span class="o">=</span><span class="s">&#39;both&#39;</span><span class="p">,</span>
                 <span class="n">update_selection1</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">update_selection2</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">filter_first</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">distance_type</span><span class="o">=</span><span class="s">&#39;hydrogen&#39;</span><span class="p">,</span>
                 <span class="n">distance</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mf">120.0</span><span class="p">,</span>
                 <span class="n">forcefield</span><span class="o">=</span><span class="s">&#39;CHARMM27&#39;</span><span class="p">,</span> <span class="n">donors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">acceptors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">detect_hydrogens</span><span class="o">=</span><span class="s">&#39;distance&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set up calculation of hydrogen bonds between two selections in a universe.</span>

<span class="sd">        The timeseries is accessible as the attribute :attr:`HydrogenBondAnalysis.timeseries`.</span>

<span class="sd">        Some initial checks are performed. If there are no atoms selected by</span>
<span class="sd">        *selection1* or *selection2* or if no donor hydrogens or acceptor atoms</span>
<span class="sd">        are found then a :exc:`SelectionError` is raised for any selection that</span>
<span class="sd">        does *not* update (*update_selection1* and *update_selection2*</span>
<span class="sd">        keywords). For selections that are set to update, only a warning is</span>
<span class="sd">        logged because it is assumed that the selection might contain atoms at</span>
<span class="sd">        a later frame (e.g. for distance based selections).</span>

<span class="sd">        If no hydrogen bonds are detected or if the initial check fails, look</span>
<span class="sd">        at the log output (enable with :func:`MDAnalysis.start_logging` and set</span>
<span class="sd">        *verbose* = ``True``). It is likely that the default names for donors</span>
<span class="sd">        and acceptors are not suitable (especially for non-standard</span>
<span class="sd">        ligands). In this case, either change the *forcefield* or use</span>
<span class="sd">        customized *donors* and/or *acceptors*.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           In order to speed up processing, atoms are filtered by a coarse</span>
<span class="sd">           distance criterion before a detailed hydrogen bonding analysis is</span>
<span class="sd">           performed (*filter_first* = ``True``). If one of your selections is</span>
<span class="sd">           e.g. the solvent then *update_selection1* (or *update_selection2*)</span>
<span class="sd">           must also be ``True`` so that the list of candidate atoms is updated</span>
<span class="sd">           at each step: this is now the default.</span>

<span class="sd">           If your selections will essentially remain the same for all time</span>
<span class="sd">           steps (i.e. residues are not moving farther than 3 x *distance*), for</span>
<span class="sd">           instance, if no water or large conformational changes are involved</span>
<span class="sd">           or if the optimization is disabled (*filter_first* = ``False``) then</span>
<span class="sd">           you can improve performance by setting the *update_selection*</span>
<span class="sd">           keywords to ``False``.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *universe*</span>
<span class="sd">            Universe object</span>
<span class="sd">          *selection1*</span>
<span class="sd">            Selection string for first selection [&#39;protein&#39;]</span>
<span class="sd">          *selection2*</span>
<span class="sd">            Selection string for second selection [&#39;all&#39;]</span>
<span class="sd">          *selection1_type*</span>
<span class="sd">            Selection 1 can be &#39;donor&#39;, &#39;acceptor&#39; or &#39;both&#39;. Note that the</span>
<span class="sd">            value for *selection1_type* automatically determines how</span>
<span class="sd">            *selection2* handles donors and acceptors: If *selection1* contains</span>
<span class="sd">            &#39;both&#39; then *selection2* will also contain *both*. If *selection1*</span>
<span class="sd">            is set to &#39;donor&#39; then *selection2* is &#39;acceptor&#39; (and vice versa).</span>
<span class="sd">            [&#39;both&#39;].</span>
<span class="sd">          *update_selection1*</span>
<span class="sd">            Update selection 1 at each frame? [``False``]</span>
<span class="sd">          *update_selection2*</span>
<span class="sd">            Update selection 2 at each frame? [``False``]</span>
<span class="sd">          *filter_first*</span>
<span class="sd">            Filter selection 2 first to only atoms 3*distance away [``True``]</span>
<span class="sd">          *distance*</span>
<span class="sd">            Distance cutoff for hydrogen bonds; only interactions with a H-A distance</span>
<span class="sd">            &lt;= *distance* (and the appropriate D-H-A angle, see *angle*) are</span>
<span class="sd">            recorded. (Note: *distance_type* can change this to the D-A distance.) [3.0]</span>
<span class="sd">          *angle*</span>
<span class="sd">            Angle cutoff for hydrogen bonds; an ideal H-bond has an angle of</span>
<span class="sd">            180º.  A hydrogen bond is only recorded if the D-H-A angle is</span>
<span class="sd">            &gt;=  *angle*. The default of 120º also finds fairly non-specific</span>
<span class="sd">            hydrogen interactions and a possibly better value is 150º. [120.0]</span>
<span class="sd">          *forcefield*</span>
<span class="sd">            Name of the forcefield used. Switches between different</span>
<span class="sd">            :attr:`~HydrogenBondAnalysis.DEFAULT_DONORS` and</span>
<span class="sd">            :attr:`~HydrogenBondAnalysis.DEFAULT_ACCEPTORS` values.</span>
<span class="sd">            Available values: &quot;CHARMM27&quot;, &quot;GLYCAM06&quot;, &quot;other&quot; [&quot;CHARMM27&quot;]</span>
<span class="sd">          *donors*</span>
<span class="sd">            Extra H donor atom types (in addition to those in</span>
<span class="sd">            :attr:`~HydrogenBondAnalysis.DEFAULT_DONORS`), must be a sequence.</span>
<span class="sd">          *acceptors*</span>
<span class="sd">            Extra H acceptor atom types (in addition to those in</span>
<span class="sd">            :attr:`~HydrogenBondAnalysis.DEFAULT_ACCEPTORS`), must be a sequence.</span>
<span class="sd">          *start*</span>
<span class="sd">            starting frame-index for analysis, ``None`` is the first one, 0.</span>
<span class="sd">            *start* and *stop* are 0-based frame indices and are used to slice</span>
<span class="sd">            the trajectory (if supported) [``None``]</span>
<span class="sd">          *stop*</span>
<span class="sd">            last trajectory frame for analysis, ``None`` is the last one [``None``]</span>
<span class="sd">          *step*</span>
<span class="sd">            read every *step* between *start* and *stop*, ``None`` selects 1.</span>
<span class="sd">            Note that not all trajectory readers perform well with a step different</span>
<span class="sd">            from 1 [``None``]</span>
<span class="sd">          *verbose*</span>
<span class="sd">            If set to ``True`` enables per-frame debug logging. This is disabled</span>
<span class="sd">            by default because it generates a very large amount of output in</span>
<span class="sd">            the log file. (Note that a logger must have been started to see</span>
<span class="sd">            the output, e.g. using :func:`MDAnalysis.start_logging`.)</span>
<span class="sd">          *detect_hydrogens*</span>
<span class="sd">            Determine the algorithm to find hydrogens connected to donor</span>
<span class="sd">            atoms. Can be &quot;distance&quot; (default; finds all hydrogens in the</span>
<span class="sd">            donor&#39;s residue within a cutoff of the donor) or &quot;heuristic&quot;</span>
<span class="sd">            (looks for the next few atoms in the atom list). &quot;distance&quot; should</span>
<span class="sd">            always give the correct answer but &quot;heuristic&quot; is faster,</span>
<span class="sd">            especially when the donor list is updated each</span>
<span class="sd">            for each frame. [&quot;distance&quot;]</span>
<span class="sd">          *distance_type*</span>
<span class="sd">            Measure hydrogen bond lengths between donor and acceptor heavy</span>
<span class="sd">            attoms (&quot;heavy&quot;) or between donor hydrogen and acceptor heavy</span>
<span class="sd">            atom (&quot;hydrogen&quot;). If using &quot;heavy&quot; then one should set the *distance*</span>
<span class="sd">            cutoff to a higher value such as 3.5 Å. [&quot;hydrogen&quot;]</span>

<span class="sd">        :Raises: :exc:`SelectionError` is raised for each static selection without</span>
<span class="sd">                 the required donors and/or acceptors.</span>

<span class="sd">        .. versionchanged:: 0.7.6</span>
<span class="sd">           New *verbose* keyword (and per-frame debug logging disabled by</span>
<span class="sd">           default).</span>

<span class="sd">           New *detect_hydrogens* keyword to switch between two different</span>
<span class="sd">           algorithms to detect hydrogens bonded to donor. &quot;distance&quot; is a new,</span>
<span class="sd">           rigorous distance search within the residue of the donor atom,</span>
<span class="sd">           &quot;heuristic&quot; is the previous list scan (improved with an additional</span>
<span class="sd">           distance check).</span>

<span class="sd">           New *forcefield* keyword to switch between different values of</span>
<span class="sd">           DEFAULT_DONORS/ACCEPTORS to accomodate different force fields.</span>
<span class="sd">           Also has an option &quot;other&quot; for no default values.</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           The new default for *update_selection1* and *update_selection2* is now</span>
<span class="sd">           ``True`` (see `Issue 138`_). Set to ``False`` if your selections only</span>
<span class="sd">           need to be determined once (will increase performance).</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           New keyword *distance_type* to select between calculation between</span>
<span class="sd">           heavy atoms or hydrogen-acceptor. It defaults to the previous</span>
<span class="sd">           behavior (i.e. &quot;hydrogen&quot;).</span>

<span class="sd">        .. versionchanged:: 0.11.0</span>
<span class="sd">           Initial checks for selections that potentially raise :exc:`SelectionError`.</span>

<span class="sd">        .. _`Issue 138`: https://github.com/MDAnalysis/mdanalysis/issues/138</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens_algorithms</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&quot;distance&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens_dist</span><span class="p">,</span>  <span class="c"># 0.7.6 default</span>
            <span class="s">&quot;heuristic&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens_list</span><span class="p">,</span>  <span class="c"># pre 0.7.6</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">detect_hydrogens</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens_algorithms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;detect_hydrogens must be one of </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens_algorithms</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detect_hydrogens</span> <span class="o">=</span> <span class="n">detect_hydrogens</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection1</span> <span class="o">=</span> <span class="n">selection1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span> <span class="o">=</span> <span class="n">selection2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="o">=</span> <span class="n">selection1_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection1</span> <span class="o">=</span> <span class="n">update_selection1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection2</span> <span class="o">=</span> <span class="n">update_selection2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_first</span> <span class="o">=</span> <span class="n">filter_first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span> <span class="o">=</span> <span class="n">distance_type</span>  <span class="c"># note: everything except &#39;heavy&#39; will give the default behavior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="bp">None</span><span class="p">,</span>  <span class="c"># internal frames are 0 based</span>
                                <span class="n">stop</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="bp">None</span><span class="p">,</span>
                                <span class="n">step</span><span class="p">)</span>

        <span class="c"># set up the donors/acceptors lists</span>
        <span class="k">if</span> <span class="n">donors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">donors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">acceptors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">acceptors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcefield</span> <span class="o">=</span> <span class="n">forcefield</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">donors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_DONORS</span><span class="p">[</span><span class="n">forcefield</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">donors</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_ACCEPTORS</span><span class="p">[</span><span class="n">forcefield</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">acceptors</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;HydrogenBondAnalysis: invalid selections&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;both&#39;</span><span class="p">,</span> <span class="s">&#39;donor&#39;</span><span class="p">,</span> <span class="s">&#39;acceptor&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;HydrogenBondAnalysis: Invalid selection type </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># final result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># time for each frame</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># placeholder for output table</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c"># always enable debug output for initial selection update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_selection_1</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_selection_2</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>  <span class="c"># per-frame debugging output?</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log_parameters</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="o">==</span> <span class="s">&#39;donor&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;donors&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;acceptors&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="o">==</span> <span class="s">&#39;acceptor&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;acceptors&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;donors&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># both</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;donors&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;acceptors&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;acceptors&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;donors&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;HBond analysis: initial checks passed.&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="n">htype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;sanity check the selections 1 and 2</span>

<span class="sd">        *selection* is 1 or 2, *htype* is &quot;donors&quot; or &quot;acceptors&quot;</span>

<span class="sd">        If selections do not update and the required donor and acceptor</span>
<span class="sd">        selections are empty then a :exc:`SelectionError` is immediately</span>
<span class="sd">        raised.</span>

<span class="sd">        If selections update dynamically then it is possible that the selection</span>
<span class="sd">        will yield donors/acceptors at a later step and we only issue a</span>
<span class="sd">        warning.</span>

<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">selection</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">htype</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;donors&quot;</span><span class="p">,</span> <span class="s">&quot;acceptors&quot;</span><span class="p">)</span>
        <span class="c"># horrible data organization:  _s1_donors, _s2_acceptors, etc, update_selection1, ...</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_s{0}_{1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">htype</span><span class="p">))</span>
        <span class="n">update</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;update_selection{0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">selection</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s">&quot;No {1} found in selection {0}. &quot;</span> \
                <span class="s">&quot;You might have to specify a custom &#39;{1}&#39; keyword.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">selection</span><span class="p">,</span> <span class="n">htype</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">update</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">+=</span> <span class="s">&quot; Selection will update so continuing with fingers crossed.&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">errmsg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">SelectionWarning</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_log_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Log important parameters to the logfile.&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;HBond analysis: selection1 = </span><span class="si">%r</span><span class="s"> (update: </span><span class="si">%r</span><span class="s">)&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_selection1</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;HBond analysis: selection2 = </span><span class="si">%r</span><span class="s"> (update: </span><span class="si">%r</span><span class="s">)&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_selection2</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;HBond analysis: criterion: donor </span><span class="si">%s</span><span class="s"> atom and acceptor atom distance &lt;= </span><span class="si">%.3f</span><span class="s"> A&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;HBond analysis: criterion: angle D-H-A &gt;= </span><span class="si">%.3f</span><span class="s"> degrees&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;HBond analysis: force field </span><span class="si">%s</span><span class="s"> to guess donor and acceptor names&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcefield</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;HBond analysis: bonded hydrogen detection algorithm: </span><span class="si">%r</span><span class="s">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">detect_hydrogens</span><span class="p">)</span>

<div class="viewcode-block" id="HydrogenBondAnalysis._get_bonded_hydrogens"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis._get_bonded_hydrogens">[docs]</a>    <span class="k">def</span> <span class="nf">_get_bonded_hydrogens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find hydrogens bonded to *atom*.</span>

<span class="sd">        This method is typically not called by a user but it is documented to</span>
<span class="sd">        facilitate understanding of the internals of</span>
<span class="sd">        :class:`HydrogenBondAnalysis`.</span>

<span class="sd">        :Returns: list of hydrogens (can be a</span>
<span class="sd">                  :class:`~MDAnalysis.core.AtomGroup.AtomGroup`) or empty list</span>
<span class="sd">                  ``[]`` if none were found.</span>

<span class="sd">        .. SeeAlso::</span>

<span class="sd">           :meth:`_get_bonded_hydrogens_dist` and :meth:`_get_bonded_hydrogens_list`</span>

<span class="sd">        .. versionchanged:: 0.7.6</span>
<span class="sd">           Can switch algorithm by using the *detect_hydrogens* keyword to the</span>
<span class="sd">           constructor. *kwargs* can be used to supply arguments for algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens_algorithms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">detect_hydrogens</span><span class="p">](</span><span class="n">atom</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="HydrogenBondAnalysis._get_bonded_hydrogens_dist"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis._get_bonded_hydrogens_dist">[docs]</a>    <span class="k">def</span> <span class="nf">_get_bonded_hydrogens_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find hydrogens bonded within *cutoff* to *atom*.</span>

<span class="sd">        * hydrogens are detected by either name (&quot;H*&quot;, &quot;[123]H*&quot;) or type</span>
<span class="sd">          (&quot;H&quot;); this is not fool-proof as the atom type is not always a</span>
<span class="sd">          character but the name pattern should catch most typical occurrences.</span>

<span class="sd">        * The distance from *atom* is calculated for all hydrogens in the</span>
<span class="sd">          residue and only those within a cutoff are kept. The cutoff depends</span>
<span class="sd">          on the heavy atom (more precisely, on its element, which is taken as</span>
<span class="sd">          the first letter of its name ``atom.name[0]``) and is parameterized</span>
<span class="sd">          in :attr:`HydrogenBondAnalysis.r_cov`. If no match is found then the</span>
<span class="sd">          default of 1.5 Å is used.</span>

<span class="sd">        The performance of this implementation could be improved once the</span>
<span class="sd">        topology always contains bonded information; it currently uses the</span>
<span class="sd">        selection parser with an &quot;around&quot; selection.</span>

<span class="sd">        .. versionadded:: 0.7.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s">&quot;(name H* or name 1H* or name 2H* or name 3H* or type H) and around </span><span class="si">%f</span><span class="s"> name </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r_cov</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">NoDataError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
</div>
<div class="viewcode-block" id="HydrogenBondAnalysis._get_bonded_hydrogens_list"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis._get_bonded_hydrogens_list">[docs]</a>    <span class="k">def</span> <span class="nf">_get_bonded_hydrogens_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find &quot;bonded&quot; hydrogens to the donor *atom*.</span>

<span class="sd">        At the moment this relies on the **assumption** that the</span>
<span class="sd">        hydrogens are listed directly after the heavy atom in the</span>
<span class="sd">        topology. If this is not the case then this function will</span>
<span class="sd">        fail.</span>

<span class="sd">        Hydrogens are detected by name ``H*``, ``[123]H*`` and they have to be</span>
<span class="sd">        within a maximum distance from the heavy atom. The cutoff distance</span>
<span class="sd">        depends on the heavy atom and is parameterized in</span>
<span class="sd">        :attr:`HydrogenBondAnalysis.r_cov`.</span>

<span class="sd">        .. versionchanged:: 0.7.6</span>

<span class="sd">           Added detection of ``[123]H`` and additional check that a</span>
<span class="sd">           selected hydrogen is bonded to the donor atom (i.e. its</span>
<span class="sd">           distance to the donor is less than the covalent radius</span>
<span class="sd">           stored in :attr:`HydrogenBondAnalysis.r_cov` or the default</span>
<span class="sd">           1.5 Å).</span>

<span class="sd">           Changed name to</span>
<span class="sd">           :meth:`~HydrogenBondAnalysis._get_bonded_hydrogens_list`</span>
<span class="sd">           and added *kwargs* so that it can be used instead of</span>
<span class="sd">           :meth:`~HydrogenBondAnalysis._get_bonded_hydrogens_dist`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;_get_bonded_hydrogens_list() does not always find &quot;</span>
                      <span class="s">&quot;all hydrogens; detect_hydrogens=&#39;distance&#39; is safer.&quot;</span><span class="p">,</span>
                      <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hydrogens</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;1H&#39;</span><span class="p">,</span> <span class="s">&#39;2H&#39;</span><span class="p">,</span> <span class="s">&#39;3H&#39;</span><span class="p">))</span> \
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_eucl_distance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_cov</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">hydrogens</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># weird corner case that atom is the last one in universe</span>
        <span class="k">return</span> <span class="n">hydrogens</span>
</div>
    <span class="k">def</span> <span class="nf">_update_selection_1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s">&quot;Size of selection 1: {0} atoms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Selection 1 &#39;{0}&#39; did not select any atoms.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">)[:</span><span class="mi">80</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;donor&#39;</span><span class="p">,</span> <span class="s">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s">&#39; or &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;name {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tmp</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s">&quot;Selection 1 donors: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s">&quot;Selection 1 donor hydrogens: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s">&#39; or &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;name {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s">&quot;Selection 1 acceptors: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_update_selection_2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_first</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s">&#39;Size of selection 2 before filtering:&#39;</span>
                              <span class="s">&#39; {} atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)))</span>
            <span class="n">ns_selection_2</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span> <span class="o">=</span> <span class="n">ns_selection_2</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">,</span> <span class="mf">3.</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s">&#39;Size of selection 2: {0} atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Selection 2 &quot;{}&quot; did not select any atoms.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">)[:</span><span class="mi">80</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;donor&#39;</span><span class="p">,</span> <span class="s">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s">&#39; or &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;name </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s">&quot;Selection 2 acceptors: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s">&#39; or &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;name </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tmp</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s">&quot;Selection 2 donors: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s">&quot;Selection 2 donor hydrogens: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">logger_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<div class="viewcode-block" id="HydrogenBondAnalysis.run"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyze trajectory and produce timeseries.</span>

<span class="sd">        Stores the hydrogen bond data per frame as</span>
<span class="sd">        :attr:`HydrogenBondAnalysis.timeseries` (see there for output</span>
<span class="sd">        format).</span>

<span class="sd">        The method accepts a number of keywords, amongst them *quiet* (default</span>
<span class="sd">        ``False``), which silences the porgress output (see</span>
<span class="sd">        :class:`~MDAnalysis.lib.log.ProgressMeter`) and *verbose* (which can</span>
<span class="sd">        be used to change the value provided with the class constructor).</span>

<span class="sd">        .. SeeAlso:: :meth:`HydrogenBondAnalysis.generate_table` for processing</span>
<span class="sd">                     the data into a different format.</span>

<span class="sd">        .. versionchanged:: 0.7.6</span>
<span class="sd">           Results are not returned, only stored in</span>
<span class="sd">           :attr:`~HydrogenBondAnalysis.timeseries` and duplicate hydrogen bonds</span>
<span class="sd">           are removed from output (can be suppressed with *remove_duplicates* =</span>
<span class="sd">           ``False``)</span>

<span class="sd">        .. versionchanged:: 0.11.0</span>
<span class="sd">           Accept *quiet* keyword. Analysis will now proceed through frames even if</span>
<span class="sd">           no donors or acceptors were found in a particular frame.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;HBond analysis: starting&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;HBond analysis: donors    </span><span class="si">%r</span><span class="s">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;HBond analysis: acceptors </span><span class="si">%r</span><span class="s">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)</span>

        <span class="n">remove_duplicates</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;remove_duplicates&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>  <span class="c"># False: old behaviour</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">remove_duplicates</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Hidden feature remove_duplicates=False activated: you will probably get duplicate H-bonds.&quot;</span><span class="p">)</span>

        <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;verbose&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">verbose</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Toggling verbose to </span><span class="si">%r</span><span class="s">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;HBond analysis: For full step-by-step debugging output use verbose=True&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;checking trajectory...&quot;</span><span class="p">)</span>  <span class="c"># n_frames can take a while!</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">traj_slice</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Problem reading trajectory or trajectory slice incompatible.&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span>
            <span class="k">raise</span>
        <span class="n">pm</span> <span class="o">=</span> <span class="n">ProgressMeter</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">),</span>
                           <span class="n">format</span><span class="o">=</span><span class="s">&quot;HBonds frame </span><span class="si">%(step)5d</span><span class="s">/</span><span class="si">%(numsteps)d</span><span class="s"> [</span><span class="si">%(percentage)5.1f%%</span><span class="s">]</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span>
                           <span class="n">quiet</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;quiet&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">time</span>

            <span class="k">def</span> <span class="nf">_get_timestep</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">time</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;HBond analysis is recording time step&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="c"># chained reader or xyz(?) cannot do time yet</span>
            <span class="k">def</span> <span class="nf">_get_timestep</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">frame</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;HBond analysis is recording frame number instead of time step&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Starting analysis (frame index start=</span><span class="si">%d</span><span class="s"> stop=</span><span class="si">%d</span><span class="s">, step=</span><span class="si">%d</span><span class="s">)&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj_slice</span><span class="o">.</span><span class="n">start</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj_slice</span><span class="o">.</span><span class="n">stop</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_slice</span><span class="o">.</span><span class="n">step</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">traj_slice</span><span class="p">]:</span>
            <span class="c"># all bonds for this timestep</span>
            <span class="n">frame_results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c"># dict of tuples (atomid, atomid) for quick check if</span>
            <span class="c"># we already have the bond (to avoid duplicates)</span>
            <span class="n">already_found</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">frame</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
            <span class="n">timestep</span> <span class="o">=</span> <span class="n">_get_timestep</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timestep</span><span class="p">)</span>

            <span class="n">pm</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s">&quot;Analyzing frame </span><span class="si">%(frame)d</span><span class="s">, timestep </span><span class="si">%(timestep)f</span><span class="s"> ps&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_selection1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_selection_1</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_selection2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_selection_2</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;donor&#39;</span><span class="p">,</span> <span class="s">&#39;both&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s">&quot;Selection 1 Donors &lt;-&gt; Acceptors&quot;</span><span class="p">)</span>
                <span class="n">ns_acceptors</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">donor_h_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">donor_h_set</span><span class="p">:</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">ns_acceptors</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">AtomGroup</span><span class="p">([</span><span class="n">h</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                            <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_angle</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                            <span class="n">donor_atom</span> <span class="o">=</span> <span class="n">h</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span> <span class="o">!=</span> <span class="s">&#39;heavy&#39;</span> <span class="k">else</span> <span class="n">d</span>
                            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_eucl_distance</span><span class="p">(</span><span class="n">donor_atom</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="ow">and</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span>
                                    <span class="s">&quot;S1-D: </span><span class="si">%s</span><span class="s"> &lt;-&gt; S2-A: </span><span class="si">%s</span><span class="s"> </span><span class="si">%f</span><span class="s"> A, </span><span class="si">%f</span><span class="s"> DEG&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                                <span class="c">#self.logger_debug(&quot;S1-D: %r &lt;-&gt; S2-A: %r %f A, %f DEG&quot; % (h, a, dist, angle))</span>
                                <span class="n">frame_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">:</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">resid</span><span class="p">),</span> <span class="n">h</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                                        <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">:</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">resid</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">])</span>
                                <span class="n">already_found</span><span class="p">[(</span><span class="n">h</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s">&#39;both&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s">&quot;Selection 1 Acceptors &lt;-&gt; Donors&quot;</span><span class="p">)</span>
                <span class="n">ns_acceptors</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">donor_h_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">donor_h_set</span><span class="p">:</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">ns_acceptors</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">AtomGroup</span><span class="p">([</span><span class="n">h</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">remove_duplicates</span> <span class="ow">and</span> <span class="p">(</span>
                                    <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">already_found</span>
                                    <span class="ow">or</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">already_found</span><span class="p">):</span>
                                <span class="k">continue</span>
                            <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_angle</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                            <span class="n">donor_atom</span> <span class="o">=</span> <span class="n">h</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span> <span class="o">!=</span> <span class="s">&#39;heavy&#39;</span> <span class="k">else</span> <span class="n">d</span>
                            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_eucl_distance</span><span class="p">(</span><span class="n">donor_atom</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="ow">and</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span>
                                    <span class="s">&quot;S1-A: </span><span class="si">%s</span><span class="s"> &lt;-&gt; S2-D: </span><span class="si">%s</span><span class="s"> </span><span class="si">%f</span><span class="s"> A, </span><span class="si">%f</span><span class="s"> DEG&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                                <span class="c">#self.logger_debug(&quot;S1-A: %r &lt;-&gt; S2-D: %r %f A, %f DEG&quot; % (a, h, dist, angle))</span>
                                <span class="n">frame_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">:</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">resid</span><span class="p">),</span> <span class="n">h</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                                        <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">:</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">resid</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_results</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;HBond analysis: complete; timeseries with </span><span class="si">%d</span><span class="s"> hbonds in </span><span class="si">%s</span><span class="s">.timeseries&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">count_by_time</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="HydrogenBondAnalysis.calc_angle"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.calc_angle">[docs]</a>    <span class="k">def</span> <span class="nf">calc_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the angle (in degrees) between two atoms with H at apex.&quot;&quot;&quot;</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">d</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angle</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="HydrogenBondAnalysis.calc_eucl_distance"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.calc_eucl_distance">[docs]</a>    <span class="k">def</span> <span class="nf">calc_eucl_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the Euclidean distance between two atoms. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">norm</span><span class="p">(</span><span class="n">a2</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">a1</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="HydrogenBondAnalysis.generate_table"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.generate_table">[docs]</a>    <span class="k">def</span> <span class="nf">generate_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a normalised table of the results.</span>

<span class="sd">        The table is stored as a :class:`numpy.recarray` in the</span>
<span class="sd">        attribute :attr:`~HydrogenBondAnalysis.table` and can be used</span>
<span class="sd">        with e.g. `recsql`_.</span>

<span class="sd">        Columns:</span>
<span class="sd">          0. &quot;time&quot;</span>
<span class="sd">          1. &quot;donor_idx&quot;</span>
<span class="sd">          2. &quot;acceptor_idx&quot;</span>
<span class="sd">          3. &quot;donor_resnm&quot;</span>
<span class="sd">          4. &quot;donor_resid&quot;</span>
<span class="sd">          5. &quot;donor_atom&quot;</span>
<span class="sd">          6. &quot;acceptor_resnm&quot;</span>
<span class="sd">          7. &quot;acceptor_resid&quot;</span>
<span class="sd">          8. &quot;acceptor_atom&quot;</span>
<span class="sd">          9. &quot;distance&quot;</span>
<span class="sd">          10. &quot;angle&quot;</span>

<span class="sd">        .. _recsql: http://pypi.python.org/pypi/RecSQL</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;No timeseries computed, do run() first.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">MissingDataWarning</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">num_records</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">hframe</span><span class="p">)</span> <span class="k">for</span> <span class="n">hframe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="p">])</span>
        <span class="c"># build empty output table</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s">&quot;time&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;donor_idx&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;acceptor_idx&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&quot;donor_resnm&quot;</span><span class="p">,</span> <span class="s">&quot;|S4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;donor_resid&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;donor_atom&quot;</span><span class="p">,</span> <span class="s">&quot;|S4&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&quot;acceptor_resnm&quot;</span><span class="p">,</span> <span class="s">&quot;|S4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;acceptor_resid&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;acceptor_atom&quot;</span><span class="p">,</span> <span class="s">&quot;|S4&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&quot;distance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;angle&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)]</span>
        <span class="c"># according to Lukas&#39; notes below, using a recarray at this stage is ineffective</span>
        <span class="c"># and speedups of ~x10 can be achieved by filling a standard array, like this:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_records</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># current row</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">hframe</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">donor_idx</span><span class="p">,</span> <span class="n">acceptor_idx</span><span class="p">,</span> <span class="n">donor</span><span class="p">,</span> <span class="n">acceptor</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">hframe</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">cursor</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">donor_idx</span><span class="p">,</span> <span class="n">acceptor_idx</span><span class="p">)</span> <span class="o">+</span> <span class="n">parse_residue</span><span class="p">(</span><span class="n">donor</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="n">parse_residue</span><span class="p">(</span><span class="n">acceptor</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
                <span class="n">cursor</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">cursor</span> <span class="o">==</span> <span class="n">num_records</span><span class="p">,</span> <span class="s">&quot;Internal Error: Not all HB records stored&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;HBond: Stored results as table with </span><span class="si">%(num_records)d</span><span class="s"> entries.&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="HydrogenBondAnalysis.save_table"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.save_table">[docs]</a>    <span class="k">def</span> <span class="nf">save_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&quot;hbond_table.pickle&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves :attr:`~HydrogenBondAnalysis.table` to a pickled file.</span>

<span class="sd">        Load with ::</span>

<span class="sd">           import cPickle</span>
<span class="sd">           table = cPickle.load(open(filename))</span>

<span class="sd">        .. SeeAlso:: :mod:`cPickle` module and :class:`numpy.recarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">cPickle</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generate_table</span><span class="p">()</span>
        <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">),</span> <span class="n">protocol</span><span class="o">=</span><span class="n">cPickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="HydrogenBondAnalysis.count_by_time"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.count_by_time">[docs]</a>    <span class="k">def</span> <span class="nf">count_by_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Counts the number of hydrogen bonds per timestep.</span>

<span class="sd">        :Returns: a class:`numpy.recarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;No timeseries computed, do run() first.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">MissingDataWarning</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;count&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">time_count</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span>
                                                           <span class="n">itertools</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="p">))):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">cursor</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_count</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="HydrogenBondAnalysis.count_by_type"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.count_by_type">[docs]</a>    <span class="k">def</span> <span class="nf">count_by_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Counts the frequency of hydrogen bonds of a specific type.</span>

<span class="sd">        Processes :attr:`HydrogenBondAnalysis.timeseries` and returns</span>
<span class="sd">        a :class:`numpy.recarray` containing atom indices, residue</span>
<span class="sd">        names, residue numbers (for donors and acceptors) and the</span>
<span class="sd">        fraction of the total time during which the hydrogen bond was</span>
<span class="sd">        detected.</span>

<span class="sd">        :Returns: a class:`numpy.recarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;No timeseries computed, do run() first.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">MissingDataWarning</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">hbonds</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hframe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">donor_idx</span><span class="p">,</span> <span class="n">acceptor_idx</span><span class="p">,</span> <span class="n">donor</span><span class="p">,</span> <span class="n">acceptor</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">hframe</span><span class="p">:</span>
                <span class="n">donor_resnm</span><span class="p">,</span> <span class="n">donor_resid</span><span class="p">,</span> <span class="n">donor_atom</span> <span class="o">=</span> <span class="n">parse_residue</span><span class="p">(</span><span class="n">donor</span><span class="p">)</span>
                <span class="n">acceptor_resnm</span><span class="p">,</span> <span class="n">acceptor_resid</span><span class="p">,</span> <span class="n">acceptor_atom</span> <span class="o">=</span> <span class="n">parse_residue</span><span class="p">(</span><span class="n">acceptor</span><span class="p">)</span>
                <span class="c"># generate unambigous key for current hbond</span>
                <span class="c"># (the donor_heavy_atom placeholder &#39;?&#39; is added later)</span>
                <span class="n">hb_key</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">donor_idx</span><span class="p">,</span> <span class="n">acceptor_idx</span><span class="p">,</span>
                    <span class="n">donor_resnm</span><span class="p">,</span> <span class="n">donor_resid</span><span class="p">,</span> <span class="s">&quot;?&quot;</span><span class="p">,</span> <span class="n">donor_atom</span><span class="p">,</span>
                    <span class="n">acceptor_resnm</span><span class="p">,</span> <span class="n">acceptor_resid</span><span class="p">,</span> <span class="n">acceptor_atom</span><span class="p">)</span>

                <span class="n">hbonds</span><span class="p">[</span><span class="n">hb_key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># build empty output table</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s">&#39;donor_idx&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;acceptor_idx&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;donor_resnm&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;donor_resid&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;donor_heavy_atom&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;donor_atom&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;acceptor_resnm&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;acceptor_resid&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;acceptor_atom&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;frequency&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">hbonds</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c"># float because of division later</span>
        <span class="n">tsteps</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">cursor</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hbonds</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">cursor</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="p">(</span><span class="n">count</span> <span class="o">/</span> <span class="n">tsteps</span><span class="p">,)</span>

        <span class="c"># return array as recarray</span>
        <span class="c"># The recarray has not been used within the function, because accessing the</span>
        <span class="c"># the elements of a recarray (3.65 us) is much slower then accessing those</span>
        <span class="c"># of a ndarray (287 ns).</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>

        <span class="c"># patch in donor heavy atom names (replaces &#39;?&#39; in the key)</span>
        <span class="n">h2donor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor_lookup_table_byindex</span><span class="p">()</span>
        <span class="n">r</span><span class="o">.</span><span class="n">donor_heavy_atom</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">h2donor</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">donor_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">r</span>
</div>
<div class="viewcode-block" id="HydrogenBondAnalysis.timesteps_by_type"><a class="viewcode-back" href="../../../../documentation_pages/analysis/hbond_analysis.html#MDAnalysis.analysis.hbonds.hbond_analysis.HydrogenBondAnalysis.timesteps_by_type">[docs]</a>    <span class="k">def</span> <span class="nf">timesteps_by_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Frames during which each hydrogen bond existed, sorted by hydrogen bond.</span>

<span class="sd">        Processes :attr:`HydrogenBondAnalysis.timeseries` and returns</span>
<span class="sd">        a :class:`numpy.recarray` containing atom indices, residue</span>
<span class="sd">        names, residue numbers (for donors and acceptors) and a list</span>
<span class="sd">        of timesteps at which the hydrogen bond was detected.</span>

<span class="sd">        :Returns: a class:`numpy.recarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;No timeseries computed, do run() first.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">MissingDataWarning</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">hbonds</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hframe</span><span class="p">)</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">donor_idx</span><span class="p">,</span> <span class="n">acceptor_idx</span><span class="p">,</span> <span class="n">donor</span><span class="p">,</span> <span class="n">acceptor</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">hframe</span><span class="p">:</span>
                <span class="n">donor_resnm</span><span class="p">,</span> <span class="n">donor_resid</span><span class="p">,</span> <span class="n">donor_atom</span> <span class="o">=</span> <span class="n">parse_residue</span><span class="p">(</span><span class="n">donor</span><span class="p">)</span>
                <span class="n">acceptor_resnm</span><span class="p">,</span> <span class="n">acceptor_resid</span><span class="p">,</span> <span class="n">acceptor_atom</span> <span class="o">=</span> <span class="n">parse_residue</span><span class="p">(</span><span class="n">acceptor</span><span class="p">)</span>
                <span class="c"># generate unambigous key for current hbond</span>
                <span class="c"># (the donor_heavy_atom placeholder &#39;?&#39; is added later)</span>
                <span class="n">hb_key</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">donor_idx</span><span class="p">,</span> <span class="n">acceptor_idx</span><span class="p">,</span>
                    <span class="n">donor_resnm</span><span class="p">,</span> <span class="n">donor_resid</span><span class="p">,</span> <span class="s">&quot;?&quot;</span><span class="p">,</span> <span class="n">donor_atom</span><span class="p">,</span>
                    <span class="n">acceptor_resnm</span><span class="p">,</span> <span class="n">acceptor_resid</span><span class="p">,</span> <span class="n">acceptor_atom</span><span class="p">)</span>
                <span class="n">hbonds</span><span class="p">[</span><span class="n">hb_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="n">out_nrows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># count number of timesteps per key to get length of output table</span>
        <span class="k">for</span> <span class="n">ts_list</span> <span class="ow">in</span> <span class="n">hbonds</span><span class="o">.</span><span class="n">itervalues</span><span class="p">():</span>
            <span class="n">out_nrows</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts_list</span><span class="p">)</span>

        <span class="c"># build empty output table</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s">&#39;donor_idx&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;acceptor_idx&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;donor_resnm&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;donor_resid&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;donor_heavy_atom&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;donor_atom&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;acceptor_resnm&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;acceptor_resid&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;acceptor_atom&#39;</span><span class="p">,</span> <span class="s">&#39;S4&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">out_nrows</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">out_row</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span> <span class="ow">in</span> <span class="n">hbonds</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">tstep</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">out_row</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="p">(</span><span class="n">tstep</span><span class="p">,)</span>
                <span class="n">out_row</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># return array as recarray</span>
        <span class="c"># The recarray has not been used within the function, because accessing the</span>
        <span class="c"># the elements of a recarray (3.65 us) is much slower then accessing those</span>
        <span class="c"># of a ndarray (287 ns).</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>

        <span class="c"># patch in donor heavy atom names (replaces &#39;?&#39; in the key)</span>
        <span class="n">h2donor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor_lookup_table_byindex</span><span class="p">()</span>
        <span class="n">r</span><span class="o">.</span><span class="n">donor_heavy_atom</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">h2donor</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">donor_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">r</span>
</div>
    <span class="k">def</span> <span class="nf">_donor_lookup_table_byres</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Look-up table to identify the donor heavy atom from resid and hydrogen name.</span>

<span class="sd">        Assumptions:</span>
<span class="sd">        * resids are unique</span>
<span class="sd">        * hydrogen atom names are unique within a residue</span>
<span class="sd">        * selections have not changed (because we are simply looking at the last content</span>
<span class="sd">          of the donors and donor hydrogen lists)</span>

<span class="sd">        Donors from *selection1* and *selection2* are merged.</span>

<span class="sd">        Output dictionary ``h2donor`` can be used as::</span>

<span class="sd">           heavy_atom_name = h2donor[resid][hydrogen_name]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span>  <span class="c"># list of donor Atom instances</span>
        <span class="n">s1h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span>  <span class="c"># dict indexed by donor position in donor list, containg AtomGroups of H</span>
        <span class="n">s2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span>
        <span class="n">s2h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span>

        <span class="k">def</span> <span class="nf">_make_dict</span><span class="p">(</span><span class="n">donors</span><span class="p">,</span> <span class="n">hydrogens</span><span class="p">):</span>
            <span class="c"># two steps so that entry for one residue can be UPDATED for multiple donors</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">donors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="p">{})</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">donors</span><span class="p">))</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">donors</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">donors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">resid</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">donors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">d</span>

        <span class="n">h2donor</span> <span class="o">=</span> <span class="n">_make_dict</span><span class="p">(</span><span class="n">s2d</span><span class="p">,</span> <span class="n">s2h</span><span class="p">)</span>  <span class="c"># 2 is typically the larger group</span>
        <span class="c"># merge (in principle h2donor.update(_make_dict(s1d, s1h) should be sufficient</span>
        <span class="c"># with our assumptions but the following should be really safe)</span>
        <span class="k">for</span> <span class="n">resid</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">_make_dict</span><span class="p">(</span><span class="n">s1d</span><span class="p">,</span> <span class="n">s1h</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">resid</span> <span class="ow">in</span> <span class="n">h2donor</span><span class="p">:</span>
                <span class="n">h2donor</span><span class="p">[</span><span class="n">resid</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h2donor</span><span class="p">[</span><span class="n">resid</span><span class="p">]</span> <span class="o">=</span> <span class="n">names</span>

        <span class="k">return</span> <span class="n">h2donor</span>

    <span class="k">def</span> <span class="nf">_donor_lookup_table_byindex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Look-up table to identify the donor heavy atom from hydrogen atom index.</span>

<span class="sd">        Assumptions:</span>
<span class="sd">        * selections have not changed (because we are simply looking at the last content</span>
<span class="sd">          of the donors and donor hydrogen lists)</span>

<span class="sd">        Donors from *selection1* and *selection2* are merged.</span>

<span class="sd">        Output dictionary ``h2donor`` can be used as::</span>

<span class="sd">           heavy_atom_name = h2donor[index]</span>

<span class="sd">        .. Note::</span>

<span class="sd">           *index* is the 0-based MDAnalysis index</span>
<span class="sd">           (:attr:`MDAnalysis.core.AtomGroup.Atom.index`).  The</span>
<span class="sd">           tables generated by :class:`HydrogenBondAnalysis` contain</span>
<span class="sd">           1-based indices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span>  <span class="c"># list of donor Atom instances</span>
        <span class="n">s1h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span>  <span class="c"># dict indexed by donor position in donor list, containg AtomGroups of H</span>
        <span class="n">s2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span>
        <span class="n">s2h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span>

        <span class="k">def</span> <span class="nf">_make_dict</span><span class="p">(</span><span class="n">donors</span><span class="p">,</span> <span class="n">hydrogens</span><span class="p">):</span>
            <span class="c">#return dict(flatten_1([(atom.id, donors[k].name) for atom in hydrogens[k]] for k in xrange(len(donors))</span>
            <span class="c"># if k in hydrogens))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">donors</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">:</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">donors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">h2donor</span> <span class="o">=</span> <span class="n">_make_dict</span><span class="p">(</span><span class="n">s2d</span><span class="p">,</span> <span class="n">s2h</span><span class="p">)</span>  <span class="c"># 2 is typically the larger group</span>
        <span class="n">h2donor</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_make_dict</span><span class="p">(</span><span class="n">s1d</span><span class="p">,</span> <span class="n">s1h</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">h2donor</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sébastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domański, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac Virshup,
    Zhuyi Xue, Carlos Yáñez S.,
    and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>