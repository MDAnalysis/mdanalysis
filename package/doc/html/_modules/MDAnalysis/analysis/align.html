<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.analysis.align &mdash; MDAnalysis 0.11.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.11.0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.11.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.analysis.align</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Coordinate fitting and alignment --- :mod:`MDAnalysis.analysis.align`</span>
<span class="sd">=====================================================================</span>

<span class="sd">:Author: Oliver Beckstein, Joshua Adelman</span>
<span class="sd">:Year: 2010--2013</span>
<span class="sd">:Copyright: GNU Public License v3</span>

<span class="sd">The module contains functions to fit a target structure to a reference</span>
<span class="sd">structure. They use the fast QCP algorithm to calculate the root mean</span>
<span class="sd">square distance (RMSD) between two coordinate sets [Theobald2005]_ and</span>
<span class="sd">the rotation matrix *R* that minimizes the RMSD [Liu2010]_. (Please</span>
<span class="sd">cite these references when using this module.).</span>

<span class="sd">Typically, one selects a group of atoms (such as the C-alphas),</span>
<span class="sd">calculates the RMSD and transformation matrix, and applys the</span>
<span class="sd">transformation to the current frame of a trajectory to obtain the</span>
<span class="sd">rotated structure. The :func:`alignto` and :func:`rms_fit_trj`</span>
<span class="sd">functions can be used to do this for individual frames and</span>
<span class="sd">trajectories respectively.</span>

<span class="sd">The :ref:`RMS-fitting-tutorial` shows how to do the individual steps</span>
<span class="sd">manually and explains the intermediate steps.</span>

<span class="sd">.. SeeAlso::</span>

<span class="sd">   :mod:`MDAnalysis.analysis.rms`</span>
<span class="sd">        contains functions to compute RMSD (when structural alignment is not</span>
<span class="sd">        required)</span>
<span class="sd">   :mod:`MDAnalysis.lib.qcprot`</span>
<span class="sd">        implements the fast RMSD algorithm.</span>


<span class="sd">.. _RMS-fitting-tutorial:</span>

<span class="sd">RMS-fitting tutorial</span>
<span class="sd">--------------------</span>

<span class="sd">The example uses files provided as part of the MDAnalysis test suite</span>
<span class="sd">(in the variables :data:`~MDAnalysis.tests.datafiles.PSF`,</span>
<span class="sd">:data:`~MDAnalysis.tests.datafiles.DCD`, and</span>
<span class="sd">:data:`~MDAnalysis.tests.datafiles.PDB_small`). For all further</span>
<span class="sd">examples execute first ::</span>

<span class="sd">   &gt;&gt;&gt; from MDAnalysis import *</span>
<span class="sd">   &gt;&gt;&gt; from MDAnalysis.analysis.align import *</span>
<span class="sd">   &gt;&gt;&gt; from MDAnalysis.analysis.rms import rmsd</span>
<span class="sd">   &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF, DCD, PDB_small</span>


<span class="sd">In the simplest case, we can simply calculate the C-alpha RMSD between</span>
<span class="sd">two structures, using :func:`rmsd`::</span>

<span class="sd">   &gt;&gt;&gt; ref = Universe(PDB_small)</span>
<span class="sd">   &gt;&gt;&gt; mobile = Universe(PSF,DCD)</span>
<span class="sd">   &gt;&gt;&gt; rmsd(mobile.atoms.CA.positions, ref.atoms.CA.positions)</span>
<span class="sd">   18.858259026820352</span>

<span class="sd">Note that in this example translations have not been removed. In order</span>
<span class="sd">to look at the pure rotation one needs to superimpose the centres of</span>
<span class="sd">mass (or geometry) first:</span>

<span class="sd">   &gt;&gt;&gt; ref0 =  ref.atoms.CA.positions - ref.atoms.CA.center_of_mass()</span>
<span class="sd">   &gt;&gt;&gt; mobile0 = mobile.atoms.CA.positions - mobile.atoms.CA.center_of_mass()</span>
<span class="sd">   &gt;&gt;&gt; rmsd(mobile0, ref0)</span>
<span class="sd">    6.8093965864717951</span>

<span class="sd">The rotation matrix that superimposes *mobile* on *ref* while</span>
<span class="sd">minimizing the CA-RMSD is obtained with the :func:`rotation_matrix`</span>
<span class="sd">function ::</span>

<span class="sd">   &gt;&gt;&gt; R, rmsd = rotation_matrix(mobile0, ref0)</span>
<span class="sd">   &gt;&gt;&gt; print rmsd</span>
<span class="sd">   6.8093965864717951</span>
<span class="sd">   &gt;&gt;&gt; print R</span>
<span class="sd">   [[ 0.14514539 -0.27259113  0.95111876]</span>
<span class="sd">    [ 0.88652593  0.46267112 -0.00268642]</span>
<span class="sd">    [-0.43932289  0.84358136  0.30881368]]</span>

<span class="sd">Putting all this together one can superimpose all of *mobile* onto *ref*::</span>

<span class="sd">   &gt;&gt;&gt; mobile.atoms.translate(-mobile.atoms.CA.center_of_mass())</span>
<span class="sd">   &gt;&gt;&gt; mobile.atoms.rotate(R)</span>
<span class="sd">   &gt;&gt;&gt; mobile.atoms.translate(ref.atoms.CA.center_of_mass())</span>
<span class="sd">   &gt;&gt;&gt; mobile.atoms.write(&quot;mobile_on_ref.pdb&quot;)</span>


<span class="sd">Common usage</span>
<span class="sd">------------</span>

<span class="sd">To **fit a single structure** with :func:`alignto`::</span>

<span class="sd">   &gt;&gt;&gt; ref = Universe(PSF, PDB_small)</span>
<span class="sd">   &gt;&gt;&gt; mobile = Universe(PSF, DCD)     # we use the first frame</span>
<span class="sd">   &gt;&gt;&gt; alignto(mobile, ref, select=&quot;protein and name CA&quot;, mass_weighted=True)</span>

<span class="sd">This will change *all* coordinates in *mobile* so that the protein</span>
<span class="sd">C-alpha atoms are optimally superimposed (translation and rotation).</span>

<span class="sd">To **fit a whole trajectory** to a reference structure with the</span>
<span class="sd">:func:`rms_fit_trj` function::</span>

<span class="sd">   &gt;&gt;&gt; ref = Universe(PSF, PDB_small)   # reference structure 1AKE</span>
<span class="sd">   &gt;&gt;&gt; trj = Universe(PSF, DCD)         # trajectory of change 1AKE-&gt;4AKE</span>
<span class="sd">   &gt;&gt;&gt; rms_fit_trj(trj, ref, filename=&#39;rmsfit.dcd&#39;)</span>

<span class="sd">It is also possible to align two arbitrary structures by providing a</span>
<span class="sd">mapping between atoms based on a sequence alignment. This allows</span>
<span class="sd">fitting of structural homologs or wild type and mutant.</span>

<span class="sd">If a alignment was provided as &quot;sequences.aln&quot; one would first produce</span>
<span class="sd">the appropriate MDAnalysis selections with the :func:`fasta2select`</span>
<span class="sd">function and then feed the resulting dictionary to :func:`rms_fit_trj`::</span>

<span class="sd">   &gt;&gt;&gt; seldict = fasta2select(&#39;sequences.aln&#39;)</span>
<span class="sd">   &gt;&gt;&gt; rms_fit_trj(trj, ref, filename=&#39;rmsfit.dcd&#39;, select=seldict)</span>

<span class="sd">(See the documentation of the functions for this advanced usage.)</span>


<span class="sd">Functions</span>
<span class="sd">---------</span>

<span class="sd">.. autofunction:: alignto</span>
<span class="sd">.. autofunction:: rms_fit_trj</span>
<span class="sd">.. autofunction:: rotation_matrix</span>

<span class="sd">.. versionchanged:: 0.10.0</span>
<span class="sd">   Function :func:`~MDAnalysis.analysis.rms.rmsd` was removed from</span>
<span class="sd">   this module and is now exclusively accessible as</span>
<span class="sd">   :func:`~MDAnalysis.analysis.rms.rmsd`.</span>

<span class="sd">Helper functions</span>
<span class="sd">----------------</span>

<span class="sd">The following functions are used by the other functions in this</span>
<span class="sd">module. They are probably of more interest to developers than to</span>
<span class="sd">normal users.</span>

<span class="sd">.. autofunction:: fasta2select</span>
<span class="sd">.. autofunction:: get_matching_atoms</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">MDAnalysis.lib.qcprot</span> <span class="kn">as</span> <span class="nn">qcp</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.exceptions</span> <span class="kn">import</span> <span class="n">SelectionError</span><span class="p">,</span> <span class="n">SelectionWarning</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.log</span> <span class="kn">import</span> <span class="n">ProgressMeter</span>

<span class="kn">import</span> <span class="nn">MDAnalysis.analysis.rms</span> <span class="kn">as</span> <span class="nn">rms</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&#39;MDAnalysis.analysis.align&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="rotation_matrix"><a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align.rotation_matrix">[docs]</a><span class="k">def</span> <span class="nf">rotation_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the 3x3 rotation matrix for RMSD fitting coordinate sets *a* and *b*.</span>

<span class="sd">    The rotation matrix *R* transforms *a* to overlap with *b* (i.e. *b* is the</span>
<span class="sd">    reference structure):</span>

<span class="sd">       *b* = *R* . *a*</span>

<span class="sd">    :Arguments:</span>
<span class="sd">       *a*</span>
<span class="sd">          coordinates that are to be rotated (&quot;mobile set&quot;); array of N atoms</span>
<span class="sd">          of shape N*3 as generated by, e.g.,</span>
<span class="sd">          :meth:`MDAnalysis.core.AtomGroup.AtomGroup.coordinates`.</span>
<span class="sd">       *b*</span>
<span class="sd">          reference coordinates; array of N atoms of shape N*3 as generated by,</span>
<span class="sd">          e.g., :meth:`MDAnalysis.core.AtomGroup.AtomGroup.coordinates`.</span>
<span class="sd">       *weights*</span>
<span class="sd">          array of floats of size N for doing weighted RMSD fitting (e.g. the</span>
<span class="sd">          masses of the atoms)</span>

<span class="sd">    :Returns: ``(R, rmsd)`` rmsd and rotation matrix *R*</span>


<span class="sd">    *R* can be used as an argument for</span>
<span class="sd">    :meth:`MDAnalysis.core.AtomGroup.AtomGroup.rotate` to generate a rotated</span>
<span class="sd">    selection, e.g. ::</span>

<span class="sd">      &gt;&gt;&gt; R = rotation_matrix(A.select_atoms(&#39;backbone&#39;).coordinates(), B.select_atoms(&#39;backbone&#39;).coordinates())</span>
<span class="sd">      &gt;&gt;&gt; A.atoms.rotate(R)</span>
<span class="sd">      &gt;&gt;&gt; A.atoms.write(&quot;rotated.pdb&quot;)</span>

<span class="sd">    Note that the function does *not* shift the centers of mass or geometry;</span>
<span class="sd">    this needs to be done by the user.</span>

<span class="sd">    .. SeeAlso:: :func:`rmsd` calculates the RMSD between *a* and *b*; for</span>
<span class="sd">                 fitting a whole trajectory it is more efficient to use</span>
<span class="sd">                 :func:`rms_fit_trj`. A complete fit of two structures can be</span>
<span class="sd">                 done with :func:`alignto`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">weights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># weights are constructed as relative to the mean</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">rmsd</span> <span class="o">=</span> <span class="n">qcp</span><span class="o">.</span><span class="n">CalcRMSDRotationalMatrix</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                                        <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rot</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">rmsd</span>

</div>
<div class="viewcode-block" id="alignto"><a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align.alignto">[docs]</a><span class="k">def</span> <span class="nf">alignto</span><span class="p">(</span><span class="n">mobile</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s">&quot;all&quot;</span><span class="p">,</span> <span class="n">mass_weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">subselection</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Spatially align *mobile* to *reference* by doing a RMSD fit on *select* atoms.</span>

<span class="sd">    The superposition is done in the following way:</span>

<span class="sd">    1. A rotation matrix is computed that minimizes the RMSD between</span>
<span class="sd">       the coordinates of `mobile.select_atoms(sel1)` and</span>
<span class="sd">       `reference.select_atoms(sel2)`; before the rotation, *mobile* is</span>
<span class="sd">       translated so that its center of geometry (or center of mass)</span>
<span class="sd">       coincides with the one of *reference*. (See below for explanation of</span>
<span class="sd">       how *sel1* and *sel2* are derived from *select*.)</span>

<span class="sd">    2. All atoms in :class:`~MDAnalysis.core.AtomGroup.Universe` that</span>
<span class="sd">       contains *mobile* are shifted and rotated. (See below for how</span>
<span class="sd">       to change this behavior through the *subselection* keyword.)</span>

<span class="sd">    The *mobile* and *reference* atom groups can be constructed so that they</span>
<span class="sd">    already match atom by atom. In this case, *select* should be set to &quot;all&quot;</span>
<span class="sd">    (or ``None``) so that no further selections are applied to *mobile* and</span>
<span class="sd">    *reference*, therefore preserving the exact atom ordering (see</span>
<span class="sd">    :ref:`ordered-selections-label`).</span>

<span class="sd">    .. Warning:: The atom order for *mobile* and *reference* is *only*</span>
<span class="sd">       preserved when *select* is either &quot;all&quot; or ``None``. In any other case,</span>
<span class="sd">       a new selection will be made that will sort the resulting AtomGroup by</span>
<span class="sd">       index and therefore destroy the correspondence between the two groups. **It</span>
<span class="sd">       is safest not to mix ordered AtomGroups with selection strings.**</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *mobile*</span>
<span class="sd">         structure to be aligned, a :class:`~MDAnalysis.core.AtomGroup.AtomGroup`</span>
<span class="sd">         or a whole :class:`~MDAnalysis.core.AtomGroup.Universe`</span>
<span class="sd">      *reference*</span>
<span class="sd">         reference structure, a :class:`~MDAnalysis.core.AtomGroup.AtomGroup`</span>
<span class="sd">         or a whole :class:`~MDAnalysis.core.AtomGroup.Universe`</span>
<span class="sd">      *select*</span>
<span class="sd">         1. any valid selection string for</span>
<span class="sd">            :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.select_atoms` that produces identical</span>
<span class="sd">            selections in *mobile* and *reference*; or</span>
<span class="sd">         2. dictionary ``{&#39;mobile&#39;:sel1, &#39;reference&#39;:sel2}``.</span>
<span class="sd">            (the :func:`fasta2select` function returns such a</span>
<span class="sd">            dictionary based on a ClustalW_ or STAMP_ sequence alignment); or</span>
<span class="sd">         3.  tuple ``(sel1, sel2)``</span>

<span class="sd">         When using 2. or 3. with *sel1* and *sel2* then these selections can also each be</span>
<span class="sd">         a list of selection strings (to generate a AtomGroup with defined atom order as</span>
<span class="sd">         described under :ref:`ordered-selections-label`).</span>
<span class="sd">      *mass_weighted* : boolean</span>
<span class="sd">         ``True`` uses the masses :meth:`reference.masses` as weights for the</span>
<span class="sd">         RMSD fit.</span>
<span class="sd">      *tol_mass*</span>
<span class="sd">         Reject match if the atomic masses for matched atoms differ by more than</span>
<span class="sd">         *tol_mass* [0.1]</span>
<span class="sd">      *strict*</span>
<span class="sd">         ``True``</span>
<span class="sd">             Will raise :exc:`SelectioError` if a single atom does not</span>
<span class="sd">             match between the two selections.</span>
<span class="sd">         ``False`` [default]</span>
<span class="sd">             Will try to prepare a matching selection by dropping</span>
<span class="sd">             residues with non-matching atoms. See :func:`get_matching_atoms`</span>
<span class="sd">             for details.</span>
<span class="sd">      *subselection*</span>
<span class="sd">         Apply the transformation only to this selection.</span>

<span class="sd">         ``None`` [default]</span>
<span class="sd">             Apply to `mobile.universe.atoms` (i.e. all atoms in the</span>
<span class="sd">             context of the selection from *mobile* such as the rest of a</span>
<span class="sd">             protein, ligands and the surrounding water)</span>
<span class="sd">         *selection-string*</span>
<span class="sd">             Apply to `mobile.select_atoms(selection-string)`</span>
<span class="sd">         :class:`~MDAnalysis.core.AtomGroup.AtomGroup`</span>
<span class="sd">             Apply to the arbitrary group of atoms</span>

<span class="sd">    :Returns: RMSD before and after spatial alignment.</span>

<span class="sd">    .. SeeAlso:: For RMSD-fitting trajectories it is more efficient to</span>
<span class="sd">                 use :func:`rms_fit_trj`.</span>

<span class="sd">    .. versionchanged:: 0.8</span>
<span class="sd">       Added check that the two groups describe the same atoms including</span>
<span class="sd">       the new *tol_mass* keyword.</span>

<span class="sd">    .. versionchanged:: 0.10.0</span>
<span class="sd">       Uses :func:`get_matching_atoms` to work with incomplete selections</span>
<span class="sd">       and new *strict* keyword. The new default is to be lenient whereas</span>
<span class="sd">       the old behavior was the equivalent of *strict* = ``True``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">select</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
        <span class="c"># keep the EXACT order in the input AtomGroups; select_atoms(&#39;all&#39;)</span>
        <span class="c"># orders them by index, which can lead to wrong results if the user</span>
        <span class="c"># has crafted mobile and reference to match atom by atom</span>
        <span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">mobile</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">ref_atoms</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">atoms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">rms</span><span class="o">.</span><span class="n">_process_selection</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">mobile</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">select</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">])</span>
        <span class="n">ref_atoms</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">select</span><span class="p">[</span><span class="s">&#39;reference&#39;</span><span class="p">])</span>

    <span class="n">ref_atoms</span><span class="p">,</span> <span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">get_matching_atoms</span><span class="p">(</span><span class="n">ref_atoms</span><span class="p">,</span> <span class="n">mobile_atoms</span><span class="p">,</span>
                                                 <span class="n">tol_mass</span><span class="o">=</span><span class="n">tol_mass</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mass_weighted</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">ref_atoms</span><span class="o">.</span><span class="n">masses</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">masses</span><span class="p">)</span>
        <span class="n">ref_com</span> <span class="o">=</span> <span class="n">ref_atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span>
        <span class="n">mobile_com</span> <span class="o">=</span> <span class="n">mobile_atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">ref_com</span> <span class="o">=</span> <span class="n">ref_atoms</span><span class="o">.</span><span class="n">center_of_geometry</span><span class="p">()</span>
        <span class="n">mobile_com</span> <span class="o">=</span> <span class="n">mobile_atoms</span><span class="o">.</span><span class="n">center_of_geometry</span><span class="p">()</span>

    <span class="n">ref_coordinates</span> <span class="o">=</span> <span class="n">ref_atoms</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="n">ref_com</span>
    <span class="n">mobile_coordinates</span> <span class="o">=</span> <span class="n">mobile_atoms</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="n">mobile_com</span>

    <span class="n">old_rmsd</span> <span class="o">=</span> <span class="n">rms</span><span class="o">.</span><span class="n">rmsd</span><span class="p">(</span><span class="n">mobile_atoms</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span> <span class="n">ref_atoms</span><span class="o">.</span><span class="n">coordinates</span><span class="p">())</span>

    <span class="n">R</span><span class="p">,</span> <span class="n">new_rmsd</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">mobile_coordinates</span><span class="p">,</span> <span class="n">ref_coordinates</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">subselection</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">mobile</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">subselection</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">mobile</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">subselection</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">subselection</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;subselection must be a selection string, a AtomGroup or Universe or None&quot;</span><span class="p">)</span>

    <span class="n">atoms</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">mobile_com</span><span class="p">)</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="n">atoms</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">ref_com</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">old_rmsd</span><span class="p">,</span> <span class="n">new_rmsd</span>

</div>
<div class="viewcode-block" id="rms_fit_trj"><a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align.rms_fit_trj">[docs]</a><span class="k">def</span> <span class="nf">rms_fit_trj</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rmsdfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s">&#39;rmsfit_&#39;</span><span class="p">,</span>
                <span class="n">mass_weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RMS-fit trajectory to a reference structure using a selection.</span>

<span class="sd">    Both reference *ref* and trajectory *traj* must be</span>
<span class="sd">    :class:`MDAnalysis.Universe` instances. If they contain a</span>
<span class="sd">    trajectory then it is used. The output file format is determined</span>
<span class="sd">    by the file extension of *filename*. One can also use the same</span>
<span class="sd">    universe if one wants to fit to the current frame.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *traj*</span>
<span class="sd">         trajectory, :class:`MDAnalysis.Universe` object</span>
<span class="sd">      *reference*</span>
<span class="sd">         reference coordinates; :class:`MDAnalysis.Universe` object</span>
<span class="sd">         (uses the current time step of the object)</span>
<span class="sd">      *select*</span>
<span class="sd">         1. any valid selection string for</span>
<span class="sd">            :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.select_atoms` that produces identical</span>
<span class="sd">            selections in *mobile* and *reference*; or</span>
<span class="sd">         2. a dictionary ``{&#39;mobile&#39;:sel1, &#39;reference&#39;:sel2}`` (the</span>
<span class="sd">            :func:`fasta2select` function returns such a</span>
<span class="sd">            dictionary based on a ClustalW_ or STAMP_ sequence alignment); or</span>
<span class="sd">         3. a tuple ``(sel1, sel2)``</span>

<span class="sd">         When using 2. or 3. with *sel1* and *sel2* then these selections can also each be</span>
<span class="sd">         a list of selection strings (to generate a AtomGroup with defined atom order as</span>
<span class="sd">         described under :ref:`ordered-selections-label`).</span>
<span class="sd">      *filename*</span>
<span class="sd">         file name for the RMS-fitted trajectory or pdb; defaults to the</span>
<span class="sd">         original trajectory filename (from *traj*) with *prefix* prepended</span>
<span class="sd">      *rmsdfile*</span>
<span class="sd">         file name for writing the RMSD timeseries [``None``]</span>
<span class="sd">      *prefix*</span>
<span class="sd">         prefix for autogenerating the new output filename</span>
<span class="sd">      *mass_weighted*</span>
<span class="sd">         do a mass-weighted RMSD fit</span>
<span class="sd">      *tol_mass*</span>
<span class="sd">         Reject match if the atomic masses for matched atoms differ by more than</span>
<span class="sd">         *tol_mass* [0.1]</span>
<span class="sd">      *strict*</span>
<span class="sd">         Default: ``False``</span>
<span class="sd">         - ``True``: Will raise :exc:`SelectioError` if a single atom does not</span>
<span class="sd">           match between the two selections.</span>
<span class="sd">         - ``False``: Will try to prepare a matching selection by dropping</span>
<span class="sd">           residues with non-matching atoms. See :func:`get_matching_atoms`</span>
<span class="sd">           for details.</span>
<span class="sd">      *force*</span>
<span class="sd">         - ``True``: Overwrite an existing output trajectory (default)</span>
<span class="sd">         - ``False``: simply return if the file already exists</span>
<span class="sd">      *quiet*</span>
<span class="sd">         - ``True``: suppress progress and logging for levels INFO and below.</span>
<span class="sd">         - ``False``: show all status messages and do not change the the logging</span>
<span class="sd">           level (default)</span>

<span class="sd">         .. Note:: If</span>


<span class="sd">      *kwargs*</span>
<span class="sd">         All other keyword arguments are passed on the trajectory</span>
<span class="sd">         :class:`~MDAnalysis.coordinates.base.Writer`; this allows manipulating/fixing</span>
<span class="sd">         trajectories on the fly (e.g. change the output format by changing the extension of *filename*</span>
<span class="sd">         and setting different parameters as described for the corresponding writer).</span>

<span class="sd">    :Returns: *filename* (either provided or auto-generated)</span>

<span class="sd">    .. _ClustalW: http://www.clustal.org/</span>
<span class="sd">    .. _STAMP: http://www.compbio.dundee.ac.uk/manuals/stamp.4.2/</span>

<span class="sd">    .. versionchanged:: 0.8</span>
<span class="sd">       Added *kwargs* to be passed to the trajectory :class:`~MDAnalysis.coordinates.base.Writer` and</span>
<span class="sd">       *filename* is returned.</span>

<span class="sd">    .. versionchanged:: 0.10.0</span>
<span class="sd">       Uses :func:`get_matching_atoms` to work with incomplete selections</span>
<span class="sd">       and new *strict* keyword. The new default is to be lenient whereas</span>
<span class="sd">       the old behavior was the equivalent of *strict* = ``True``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">trajectory</span>
    <span class="k">if</span> <span class="n">quiet</span><span class="p">:</span>
        <span class="c"># should be part of a try ... finally to guarantee restoring the log level</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">disable</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">WARN</span><span class="p">)</span>

    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;remarks&#39;</span><span class="p">,</span> <span class="s">&#39;RMS fitted trajectory to reference&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">fn</span><span class="p">)</span>
        <span class="n">_Writer</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">Writer</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_Writer</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">OtherWriter</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;{0} already exists and will NOT be overwritten; use force=True if you want this&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">filename</span>
    <span class="n">writer</span> <span class="o">=</span> <span class="n">_Writer</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">_Writer</span>

    <span class="n">select</span> <span class="o">=</span> <span class="n">rms</span><span class="o">.</span><span class="n">_process_selection</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
    <span class="n">ref_atoms</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">select</span><span class="p">[</span><span class="s">&#39;reference&#39;</span><span class="p">])</span>
    <span class="n">traj_atoms</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">select</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">])</span>
    <span class="n">natoms</span> <span class="o">=</span> <span class="n">traj_atoms</span><span class="o">.</span><span class="n">n_atoms</span>

    <span class="n">ref_atoms</span><span class="p">,</span> <span class="n">traj_atoms</span> <span class="o">=</span> <span class="n">get_matching_atoms</span><span class="p">(</span><span class="n">ref_atoms</span><span class="p">,</span> <span class="n">traj_atoms</span><span class="p">,</span>
                                                 <span class="n">tol_mass</span><span class="o">=</span><span class="n">tol_mass</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;RMS-fitting on </span><span class="si">%d</span><span class="s"> atoms.&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_atoms</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">mass_weighted</span><span class="p">:</span>
        <span class="c"># if performing a mass-weighted alignment/rmsd calculation</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">ref_atoms</span><span class="o">.</span><span class="n">masses</span> <span class="o">/</span> <span class="n">ref_atoms</span><span class="o">.</span><span class="n">masses</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c"># reference centre of mass system</span>
    <span class="c"># (compatibility with pre 1.0 numpy: explicitly cast coords to float32)</span>
    <span class="n">ref_com</span> <span class="o">=</span> <span class="n">ref_atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">ref_coordinates</span> <span class="o">=</span> <span class="n">ref_atoms</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="n">ref_com</span>

    <span class="c"># allocate the array for selection atom coords</span>
    <span class="n">traj_coordinates</span> <span class="o">=</span> <span class="n">traj_atoms</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c"># RMSD timeseries</span>
    <span class="n">nframes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
    <span class="n">rmsd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nframes</span><span class="p">,))</span>

    <span class="c"># R: rotation matrix that aligns r-r_com, x~-x~com</span>
    <span class="c">#    (x~: selected coordinates, x: all coordinates)</span>
    <span class="c"># Final transformed traj coordinates: x&#39; = (x-x~_com)*R + ref_com</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c"># allocate space for calculation</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="n">percentage</span> <span class="o">=</span> <span class="n">ProgressMeter</span><span class="p">(</span><span class="n">nframes</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">,</span>
                               <span class="n">format</span><span class="o">=</span><span class="s">&quot;Fitted frame </span><span class="si">%(step)5d</span><span class="s">/</span><span class="si">%(numsteps)d</span><span class="s">  [</span><span class="si">%(percentage)5.1f%%</span><span class="s">]</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
        <span class="c"># shift coordinates for rotation fitting</span>
        <span class="c"># selection is updated with the time frame</span>
        <span class="n">x_com</span> <span class="o">=</span> <span class="n">traj_atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">traj_coordinates</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">traj_atoms</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="n">x_com</span>

        <span class="c"># Need to transpose coordinates such that the coordinate array is</span>
        <span class="c"># 3xN instead of Nx3. Also qcp requires that the dtype be float64</span>
        <span class="c"># (I think we swapped the position of ref and traj in CalcRMSDRotationalMatrix</span>
        <span class="c"># so that R acts **to the left** and can be broadcasted; we&#39;re saving</span>
        <span class="c"># one transpose. [orbeckst])</span>
        <span class="n">rmsd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">qcp</span><span class="o">.</span><span class="n">CalcRMSDRotationalMatrix</span><span class="p">(</span><span class="n">ref_coordinates</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                                               <span class="n">traj_coordinates</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                                               <span class="n">natoms</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
        <span class="n">R</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c"># Transform each atom in the trajectory (use inplace ops to avoid copying arrays)</span>
        <span class="c"># (Marginally (~3%) faster than &quot;ts.positions[:] = (ts.positions - x_com) * R + ref_com&quot;.)</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">positions</span> <span class="o">-=</span> <span class="n">x_com</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">positions</span> <span class="o">*</span> <span class="n">R</span>  <span class="c"># R acts to the left &amp; is broadcasted N times.</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">positions</span> <span class="o">+=</span> <span class="n">ref_com</span>

        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>  <span class="c"># write whole input trajectory system</span>
        <span class="n">percentage</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Wrote </span><span class="si">%d</span><span class="s"> RMS-fitted coordinate frames to file </span><span class="si">%r</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="n">frames</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rmsdfile</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">rmsdfile</span><span class="p">,</span> <span class="n">rmsd</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Wrote RMSD timeseries  to file </span><span class="si">%r</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rmsdfile</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">quiet</span><span class="p">:</span>
        <span class="c"># should be part of a try ... finally to guarantee restoring the log level</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">disable</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NOTSET</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filename</span>

</div>
<span class="k">def</span> <span class="nf">sequence_alignment</span><span class="p">(</span><span class="n">mobile</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a global sequence alignment between residues in *reference* and *mobile*.</span>

<span class="sd">    The global alignment uses the Needleman-Wunsch algorith as</span>
<span class="sd">    implemented in :mod:`Bio.pairwise2`. The parameters of the dynamic</span>
<span class="sd">    programming algorithm can be tuned with the keywords. The defaults</span>
<span class="sd">    should be suitable for two similar sequences. For sequences with</span>
<span class="sd">    low sequence identity, more specialized tools such as clustalw,</span>
<span class="sd">    muscle, tcoffee, or similar should be used.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">       *mobile*</span>
<span class="sd">          protein atom group</span>
<span class="sd">       *reference*</span>
<span class="sd">          protein atom group</span>

<span class="sd">    :Keywords:</span>
<span class="sd">      *match_score*</span>
<span class="sd">         score for matching residues [2]</span>
<span class="sd">      *mismatch_penalty*</span>
<span class="sd">         penalty for residues that do not match [-1]</span>
<span class="sd">      *gap_penalty*</span>
<span class="sd">         penalty for opening a gap; the high default value creates compact</span>
<span class="sd">         alignments for highly identical sequences but might not be suitable</span>
<span class="sd">         for sequences with low identity [-2]</span>
<span class="sd">      *gapextension_penalty*</span>
<span class="sd">         penalty for extending a gap [-0.1]</span>

<span class="sd">    .. versionadded:: 0.10.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">Bio.pairwise2</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;match_score&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;mismatch_penalty&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;gap_penalty&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;gapextension_penalty&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="n">aln</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">pairwise2</span><span class="o">.</span><span class="n">align</span><span class="o">.</span><span class="n">globalms</span><span class="p">(</span>
        <span class="n">reference</span><span class="o">.</span><span class="n">sequence</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;string&quot;</span><span class="p">),</span> <span class="n">mobile</span><span class="o">.</span><span class="n">sequence</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;string&quot;</span><span class="p">),</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;match_score&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;mismatch_penalty&#39;</span><span class="p">],</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;gap_penalty&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;gapextension_penalty&#39;</span><span class="p">])</span>
    <span class="c"># choose top alignment</span>
    <span class="k">return</span> <span class="n">aln</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<div class="viewcode-block" id="fasta2select"><a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align.fasta2select">[docs]</a><span class="k">def</span> <span class="nf">fasta2select</span><span class="p">(</span><span class="n">fastafilename</span><span class="p">,</span> <span class="n">is_aligned</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">ref_resids</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">target_resids</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">ref_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">target_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">alnfilename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">treefilename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">clustalw</span><span class="o">=</span><span class="s">&quot;clustalw2&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return selection strings that will select equivalent residues.</span>

<span class="sd">    The function aligns two sequences provided in a FASTA file and</span>
<span class="sd">    constructs MDAnalysis selection strings of the common atoms. When</span>
<span class="sd">    these two strings are applied to the two different proteins they</span>
<span class="sd">    will generate AtomGroups of the aligned residues.</span>

<span class="sd">    *fastafilename* contains the two un-aligned sequences in FASTA</span>
<span class="sd">    format. The reference is assumed to be the first sequence, the</span>
<span class="sd">    target the second. ClustalW_ produces a pairwise</span>
<span class="sd">    alignment (which is written to a file with suffix .aln).  The</span>
<span class="sd">    output contains atom selection strings that select the same atoms</span>
<span class="sd">    in the two structures.</span>

<span class="sd">    Unless *ref_offset* and/or *target_offset* are specified, the resids</span>
<span class="sd">    in the structure are assumed to correspond to the positions in the</span>
<span class="sd">    un-aligned sequence, namely the first residue has resid == 1.</span>

<span class="sd">    In more complicated cases (e.g. when the resid numbering in the</span>
<span class="sd">    structure/psf has gaps due to missing parts), simply provide the</span>
<span class="sd">    sequence of resids as they appear in the psf in *ref_resids* or</span>
<span class="sd">    *target_resids*, e.g. ::</span>

<span class="sd">       target_resids = [a.resid for a in trj.select_atoms(&#39;name CA&#39;)]</span>

<span class="sd">    (This translation table *is* combined with any value for *xxx_offset*!)</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *fastafilename*</span>
<span class="sd">         FASTA file with first sequence as reference and</span>
<span class="sd">         second the one to be aligned (ORDER IS IMPORTANT!)</span>
<span class="sd">      *is_aligned*</span>
<span class="sd">         False: run clustalw for sequence alignment; True: use</span>
<span class="sd">         the alignment in the file (e.g. from STAMP) [``False``]</span>
<span class="sd">      *ref_offset*</span>
<span class="sd">         add this number to the column number in the FASTA file</span>
<span class="sd">         to get the original residue number</span>
<span class="sd">      *target_offset*</span>
<span class="sd">         same for the target</span>
<span class="sd">      *ref_resids*</span>
<span class="sd">         sequence of resids as they appear in the reference structure</span>
<span class="sd">      *target_resids*</span>
<span class="sd">         sequence of resids as they appear in the target</span>
<span class="sd">      *alnfilename*</span>
<span class="sd">         filename of ClustalW alignment (clustal format) that is</span>
<span class="sd">         produced by *clustalw* when *is_aligned* = ``False``.</span>
<span class="sd">         ``None`` uses the name and path of *fastafilename* and</span>
<span class="sd">         subsititutes the suffix with &#39;.aln&#39;.[``None``]</span>
<span class="sd">      *treefilename*</span>
<span class="sd">         filename of ClustalW guide tree (Newick format);</span>
<span class="sd">         if ``None``  the the filename is generated from *alnfilename*</span>
<span class="sd">         with the suffix &#39;.dnd&#39; instead of &#39;.aln&#39; [``None``]</span>
<span class="sd">      *clustalw*</span>
<span class="sd">         path to the ClustalW (or ClustalW2) binary; only</span>
<span class="sd">         needed for *is_aligned* = ``False`` [&quot;clustalw2&quot;]</span>

<span class="sd">    :Returns:</span>
<span class="sd">      *select_dict*</span>
<span class="sd">          dictionary with &#39;reference&#39; and &#39;mobile&#39; selection string</span>
<span class="sd">          that can be used immediately in :func:`rms_fit_trj` as</span>
<span class="sd">          ``select=select_dict``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">Bio.SeqIO</span>
    <span class="kn">import</span> <span class="nn">Bio.AlignIO</span>
    <span class="kn">import</span> <span class="nn">Bio.Alphabet</span>
    <span class="kn">import</span> <span class="nn">numpy</span>

    <span class="n">protein_gapped</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">Alphabet</span><span class="o">.</span><span class="n">Gapped</span><span class="p">(</span><span class="n">Bio</span><span class="o">.</span><span class="n">Alphabet</span><span class="o">.</span><span class="n">IUPAC</span><span class="o">.</span><span class="n">protein</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_aligned</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Using provided alignment </span><span class="si">%r</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fastafilename</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fastafilename</span><span class="p">)</span> <span class="k">as</span> <span class="n">fasta</span><span class="p">:</span>
            <span class="n">alignment</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fasta</span><span class="p">,</span> <span class="s">&quot;fasta&quot;</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="n">protein_gapped</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">Bio.Align.Applications</span> <span class="kn">import</span> <span class="n">ClustalwCommandline</span>
        <span class="kn">import</span> <span class="nn">os.path</span>

        <span class="k">if</span> <span class="n">alnfilename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">filepath</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fastafilename</span><span class="p">)</span>
            <span class="n">alnfilename</span> <span class="o">=</span> <span class="n">filepath</span> <span class="o">+</span> <span class="s">&#39;.aln&#39;</span>
        <span class="k">if</span> <span class="n">treefilename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">filepath</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">alnfilename</span><span class="p">)</span>
            <span class="n">treefilename</span> <span class="o">=</span> <span class="n">filepath</span> <span class="o">+</span> <span class="s">&#39;.dnd&#39;</span>
        <span class="n">run_clustalw</span> <span class="o">=</span> <span class="n">ClustalwCommandline</span><span class="p">(</span><span class="n">clustalw</span><span class="p">,</span> <span class="n">infile</span><span class="o">=</span><span class="n">fastafilename</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;protein&quot;</span><span class="p">,</span>
                                           <span class="n">align</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="n">alnfilename</span><span class="p">,</span> <span class="n">newtree</span><span class="o">=</span><span class="n">treefilename</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Aligning sequences in </span><span class="si">%(fastafilename)r</span><span class="s"> with </span><span class="si">%(clustalw)r</span><span class="s">.&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">())</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;ClustalW commandline: </span><span class="si">%r</span><span class="s">&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">run_clustalw</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="n">run_clustalw</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s">&quot;ClustalW </span><span class="si">%(clustalw)r</span><span class="s"> failed&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">())</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;(You can get clustalw2 from http://www.clustal.org/clustal2/)&quot;</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">alnfilename</span><span class="p">)</span> <span class="k">as</span> <span class="n">aln</span><span class="p">:</span>
            <span class="n">alignment</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">aln</span><span class="p">,</span> <span class="s">&quot;clustal&quot;</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="n">protein_gapped</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Using clustalw sequence alignment </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">alnfilename</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;ClustalW Newick guide tree was also produced: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">treefilename</span><span class="p">)</span>

    <span class="n">nseq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nseq</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Only two sequences in the alignment can be processed.&quot;</span><span class="p">)</span>

    <span class="n">orig_resids</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref_resids</span><span class="p">,</span> <span class="n">target_resids</span><span class="p">]</span>  <span class="c"># implict assertion that</span>
    <span class="c"># we only have two sequences in the alignment</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref_offset</span><span class="p">,</span> <span class="n">target_offset</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alignment</span><span class="p">):</span>  <span class="c"># need iseq index to change orig_resids</span>
        <span class="k">if</span> <span class="n">orig_resids</span><span class="p">[</span><span class="n">iseq</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># build default: assume consecutive numbering of all</span>
            <span class="c"># residues in the alignment</span>
            <span class="n">GAP</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">gap_char</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">GAP</span><span class="p">)</span>
            <span class="n">orig_resids</span><span class="p">[</span><span class="n">iseq</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">orig_resids</span><span class="p">[</span><span class="n">iseq</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orig_resids</span><span class="p">[</span><span class="n">iseq</span><span class="p">])</span>
    <span class="c"># add offsets to the sequence &lt;--&gt; resid translation table</span>
    <span class="n">seq2resids</span> <span class="o">=</span> <span class="p">[</span><span class="n">resids</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">resids</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">orig_resids</span><span class="p">,</span> <span class="n">offsets</span><span class="p">)]</span>
    <span class="k">del</span> <span class="n">orig_resids</span>
    <span class="k">del</span> <span class="n">offsets</span>

    <span class="k">def</span> <span class="nf">resid_factory</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">seq2resids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a function that gives the resid for a position ipos in</span>
<span class="sd">        the nseq&#39;th alignment.</span>

<span class="sd">        resid = resid_factory(alignment,seq2resids)</span>
<span class="sd">        r = resid(nseq,ipos)</span>

<span class="sd">        It is based on a look up table that translates position in the</span>
<span class="sd">        alignment to the residue number in the original</span>
<span class="sd">        sequence/structure.</span>

<span class="sd">        The first index of resid() is the alignmment number, the</span>
<span class="sd">        second the position in the alignment.</span>

<span class="sd">        seq2resids translates the residues in the sequence to resid</span>
<span class="sd">        numbers in the psf. In the simplest case this is a linear map</span>
<span class="sd">        but if whole parts such as loops are ommitted from the protein</span>
<span class="sd">        the seq2resids may have big gaps.</span>

<span class="sd">        Format: a tuple of two numpy arrays; the first array is for</span>
<span class="sd">        the reference, the second for the target, The index in each</span>
<span class="sd">        array gives the consecutive number of the amino acid in the</span>
<span class="sd">        sequence, the value the resid in the structure/psf.</span>

<span class="sd">        Note: assumes that alignments have same length and are padded if</span>
<span class="sd">        necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># could maybe use Bio.PDB.StructureAlignment instead?</span>
        <span class="n">nseq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nseq</span><span class="p">,</span> <span class="n">alignment</span><span class="o">.</span><span class="n">get_alignment_length</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alignment</span><span class="p">):</span>
            <span class="n">GAP</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">gap_char</span>
            <span class="n">t</span><span class="p">[</span><span class="n">iseq</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">seq2resids</span><span class="p">[</span><span class="n">iseq</span><span class="p">][</span><span class="n">numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">seq</span><span class="p">))</span> <span class="o">==</span> <span class="n">GAP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c"># -1 because seq2resid is index-1 based (resids start at 1)</span>

        <span class="k">def</span> <span class="nf">resid</span><span class="p">(</span><span class="n">nseq</span><span class="p">,</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">nseq</span><span class="p">,</span> <span class="n">ipos</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">resid</span>

    <span class="n">resid</span> <span class="o">=</span> <span class="n">resid_factory</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">seq2resids</span><span class="p">)</span>

    <span class="n">res_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># collect individual selection string</span>
    <span class="c"># could collect just resid and type (with/without CB) and</span>
    <span class="c"># then post-process and use ranges for continuous stretches, eg</span>
    <span class="c"># ( resid 1:35 and ( backbone or name CB ) ) or ( resid 36 and backbone ) ...</span>

    <span class="n">GAP</span> <span class="o">=</span> <span class="n">alignment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">gap_char</span>  <span class="c"># should be the same for both seqs</span>
    <span class="k">if</span> <span class="n">GAP</span> <span class="o">!=</span> <span class="n">alignment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">gap_char</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Different gap characters in sequence &#39;target&#39; and &#39;mobile&#39;.&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ipos</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">alignment</span><span class="o">.</span><span class="n">get_alignment_length</span><span class="p">()):</span>
        <span class="n">aligned</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">alignment</span><span class="p">[:,</span> <span class="n">ipos</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">GAP</span> <span class="ow">in</span> <span class="n">aligned</span><span class="p">:</span>
            <span class="k">continue</span>  <span class="c"># skip residue</span>
        <span class="n">template</span> <span class="o">=</span> <span class="s">&quot;resid </span><span class="si">%i</span><span class="s">&quot;</span>
        <span class="k">if</span> <span class="s">&#39;G&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">aligned</span><span class="p">:</span>
            <span class="c"># can use CB</span>
            <span class="n">template</span> <span class="o">+=</span> <span class="s">&quot; and ( backbone or name CB )&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">template</span> <span class="o">+=</span> <span class="s">&quot; and backbone&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="s">&quot;( &quot;</span> <span class="o">+</span> <span class="n">template</span> <span class="o">+</span> <span class="s">&quot; )&quot;</span>

        <span class="n">res_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">template</span> <span class="o">%</span> <span class="n">resid</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="n">ipos</span><span class="p">)</span> <span class="k">for</span> <span class="n">iseq</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nseq</span><span class="p">)])</span>

    <span class="n">sel</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res_list</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="n">ref_selection</span> <span class="o">=</span> <span class="s">&quot; or &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sel</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">target_selection</span> <span class="o">=</span> <span class="s">&quot; or &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">&#39;reference&#39;</span><span class="p">:</span> <span class="n">ref_selection</span><span class="p">,</span> <span class="s">&#39;mobile&#39;</span><span class="p">:</span> <span class="n">target_selection</span><span class="p">}</span>

</div>
<div class="viewcode-block" id="get_matching_atoms"><a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align.get_matching_atoms">[docs]</a><span class="k">def</span> <span class="nf">get_matching_atoms</span><span class="p">(</span><span class="n">ag1</span><span class="p">,</span> <span class="n">ag2</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return two atom groups with one-to-one matched atoms.</span>

<span class="sd">    The function takes two :class:`~MDAnalysis.core.AtomGroup.AtomGroup`</span>
<span class="sd">    instances *ag1* and *ag2* and returns two atom groups *g1* and *g2* that</span>
<span class="sd">    consist of atoms so that the mass of atom ``g1[0]`` is the same as the mass</span>
<span class="sd">    of atom ``g2[0]``, ``g1[1]`` and ``g2[1]`` etc.</span>

<span class="sd">    The current implementation is very simplistic and works on a per-residue basis:</span>

<span class="sd">    1. The two groups must contain the same number of residues.</span>
<span class="sd">    2. Any residues in each group that have differing number of atoms are discarded.</span>
<span class="sd">    3. The masses of corresponding atoms are compared. and if any masses differ</span>
<span class="sd">       by more than *tol_mass* the test is considered failed and a</span>
<span class="sd">       :exc:`SelectionError` is raised.</span>

<span class="sd">    The log file (see :func:`MDAnalysis.start_logging`) will contain detailed</span>
<span class="sd">    information about mismatches.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *ag1*, *ag2*</span>
<span class="sd">         :class:`~MDAnalysis.core.AtomGroup.AtomGroup` instances that are compared</span>
<span class="sd">    :Keywords:</span>
<span class="sd">      *tol_mass*</span>
<span class="sd">         Reject if the atomic masses for matched atoms differ by more than</span>
<span class="sd">         *tol_mass* [0.1]</span>
<span class="sd">      *strict*</span>
<span class="sd">         ``True``</span>
<span class="sd">             Will raise :exc:`SelectioError` if a single atom does not</span>
<span class="sd">             match between the two selections.</span>
<span class="sd">         ``False`` [default]</span>
<span class="sd">             Will try to prepare a matching selection by dropping</span>
<span class="sd">             residues with non-matching atoms. See :func:`get_matching_atoms`</span>
<span class="sd">             for details.</span>

<span class="sd">    :Returns: Tuple ``(g1, g2)`` with :class:`~MDAnalysis.core.AtomGroup.AtomGroup` instances</span>
<span class="sd">              that match, atom by atom. The groups are either the original groups if all matches</span>
<span class="sd">              or slices of the original groups.</span>

<span class="sd">    :Raises: :exc:`SelectionError` if the number of residues does not match or if in the final</span>
<span class="sd">             matching masses differ by more than *tol*.</span>

<span class="sd">    The algorithm could be improved by using e.g. the Needleman-Wunsch</span>
<span class="sd">    algorithm in :mod:`Bio.profile2` to align atoms in each residue (doing a</span>
<span class="sd">    global alignment is too expensive).</span>

<span class="sd">    .. versionadded:: 0.8</span>

<span class="sd">    .. versionchanged:: 0.10.0</span>
<span class="sd">       Renamed from :func:`check_same_atoms` to :func:`get_matching_atoms` and now returns</span>
<span class="sd">       matching atomgroups (possibly with residues removed)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">ag1</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">!=</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ag1</span><span class="o">.</span><span class="n">n_residues</span> <span class="o">!=</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_residues</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s">&quot;Reference and trajectory atom selections do not contain &quot;</span>
            <span class="s">&quot;the same number of atoms: </span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="s">&quot;atoms:    N_ref={0}, N_traj={1}</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="s">&quot;and also not the same number of residues:</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="s">&quot;residues: N_ref={2}, N_traj={3}</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="s">&quot;(More details can be found in the log file &quot;</span>
            <span class="s">&quot;which can be enabled with &#39;MDAnalysis.start_logging()&#39;)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">ag1</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span>
                <span class="n">ag1</span><span class="o">.</span><span class="n">n_residues</span><span class="p">,</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_residues</span><span class="p">)</span>
            <span class="n">dbgmsg</span> <span class="o">=</span> <span class="s">&quot;mismatched residue numbers</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span> \
                <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&quot;{0} | {1}&quot;</span>  <span class="k">for</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="ow">in</span>
                           <span class="n">itertools</span><span class="o">.</span><span class="n">izip_longest</span><span class="p">(</span><span class="n">ag1</span><span class="o">.</span><span class="n">resids</span><span class="p">,</span> <span class="n">ag2</span><span class="o">.</span><span class="n">resids</span><span class="p">)])</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">dbgmsg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;Reference and trajectory atom selections do not contain &quot;</span>
                   <span class="s">&quot;the same number of atoms: </span><span class="se">\n</span><span class="s">&quot;</span>
                   <span class="s">&quot;atoms:    N_ref={0}, N_traj={1}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">ag1</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c"># continue with trying to creating a valid selection</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">but we attempt to create a valid selection.&quot;</span><span class="p">,</span>
                          <span class="n">category</span><span class="o">=</span><span class="n">SelectionWarning</span><span class="p">)</span>

        <span class="c"># continue with trying to salvage the selection:</span>
        <span class="c"># - number of atoms is different</span>
        <span class="c"># - number of residues is the same</span>
        <span class="c"># We will remove residues with mismatching number of atoms (e.g. not resolved</span>
        <span class="c"># in an X-ray structure)</span>
        <span class="k">assert</span> <span class="n">ag1</span><span class="o">.</span><span class="n">n_residues</span> <span class="o">==</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_residues</span>

        <span class="c"># Alternatively, we could align all atoms but Needleman-Wunsch</span>
        <span class="c"># pairwise2 consumes too much memory for thousands of characters in</span>
        <span class="c"># each sequence. Perhaps a solution would be pairwise alignment per residue.</span>
        <span class="c">#</span>
        <span class="c"># aln_elem = Bio.pairwise2.align.globalms(&quot;&quot;.join([MDAnalysis.topology.core.guess_atom_element(n) for n in gref.atoms.names]),</span>
        <span class="c">#    &quot;&quot;.join([MDAnalysis.topology.core.guess_atom_element(n) for n in models[0].atoms.names]),</span>
        <span class="c">#                               2, -1, -1, -0.1,</span>
        <span class="c">#                               one_alignment_only=True)</span>

        <span class="c"># For now, just remove the residues that don&#39;t have matching numbers</span>
        <span class="n">rsize1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">n_atoms</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ag1</span><span class="o">.</span><span class="n">residues</span><span class="p">])</span>
        <span class="n">rsize2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">n_atoms</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ag2</span><span class="o">.</span><span class="n">residues</span><span class="p">])</span>
        <span class="n">rsize_mismatches</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">rsize1</span> <span class="o">-</span> <span class="n">rsize2</span><span class="p">)</span>
        <span class="n">mismatch_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">rsize_mismatches</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mismatch_mask</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="c"># diagnostics</span>
                <span class="n">mismatch_resindex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ag1</span><span class="o">.</span><span class="n">n_residues</span><span class="p">)[</span><span class="n">mismatch_mask</span><span class="p">]</span>
                <span class="k">def</span> <span class="nf">log_mismatch</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">rsize</span><span class="p">,</span> <span class="n">mismatch_resindex</span><span class="o">=</span><span class="n">mismatch_resindex</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Offending residues: group {0}: {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">number</span><span class="p">,</span>
                            <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&quot;{0[0]}{0[1]} ({0[2]})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span>
                                       <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">resnames</span><span class="p">[</span><span class="n">mismatch_resindex</span><span class="p">],</span>
                                                      <span class="n">ag</span><span class="o">.</span><span class="n">resids</span><span class="p">[</span><span class="n">mismatch_resindex</span><span class="p">],</span>
                                                      <span class="n">rsize</span><span class="p">[</span><span class="n">mismatch_resindex</span><span class="p">]</span>
                                                      <span class="p">)])))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Found {0} residues with non-matching numbers of atoms (#)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">mismatch_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>
                <span class="n">log_mismatch</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ag1</span><span class="p">,</span> <span class="n">rsize1</span><span class="p">)</span>
                <span class="n">log_mismatch</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ag2</span><span class="p">,</span> <span class="n">rsize2</span><span class="p">)</span>

                <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="s">&quot;Different number of atoms in some residues. &quot;</span>
                                     <span class="s">&quot;(Use strict=False to attempt using matching atoms only.)&quot;</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">get_atoms_byres</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">match_mask</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">mismatch_mask</span><span class="p">)):</span>
                <span class="c"># not pretty... but need to do things on a per-atom basis in order</span>
                <span class="c"># to preserve original selection</span>
                <span class="n">ag</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">atoms</span>
                <span class="n">good</span> <span class="o">=</span> <span class="n">ag</span><span class="o">.</span><span class="n">resids</span><span class="p">[</span><span class="n">match_mask</span><span class="p">]</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">resid</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ag</span><span class="p">])</span>  <span class="c"># resid for each atom</span>
                <span class="n">ix_good</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">resids</span><span class="p">,</span> <span class="n">good</span><span class="p">)</span>   <span class="c"># boolean array for all matching atoms</span>
                <span class="k">return</span> <span class="n">ag</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ag</span><span class="p">))[</span><span class="n">ix_good</span><span class="p">]]</span>   <span class="c"># workaround for missing boolean indexing</span>
            <span class="n">_ag1</span> <span class="o">=</span> <span class="n">get_atoms_byres</span><span class="p">(</span><span class="n">ag1</span><span class="p">)</span>
            <span class="n">_ag2</span> <span class="o">=</span> <span class="n">get_atoms_byres</span><span class="p">(</span><span class="n">ag2</span><span class="p">)</span>

            <span class="c"># diagnostics</span>
            <span class="c"># (ugly workaround for missing boolean indexing of AtomGroup)</span>
            <span class="c"># note: ag[arange(len(ag))[boolean]] is ~2x faster than ag[where[boolean]]</span>
            <span class="n">mismatch_resindex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ag1</span><span class="o">.</span><span class="n">n_residues</span><span class="p">)[</span><span class="n">mismatch_mask</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Removed {0} residues with non-matching numbers of atoms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">mismatch_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Removed residue ids: group 1: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ag1</span><span class="o">.</span><span class="n">resids</span><span class="p">[</span><span class="n">mismatch_resindex</span><span class="p">]))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Removed residue ids: group 2: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ag2</span><span class="o">.</span><span class="n">resids</span><span class="p">[</span><span class="n">mismatch_resindex</span><span class="p">]))</span>
            <span class="c"># replace after logging (still need old ag1 and ag2 for diagnostics)</span>
            <span class="n">ag1</span> <span class="o">=</span> <span class="n">_ag1</span>
            <span class="n">ag2</span> <span class="o">=</span> <span class="n">_ag2</span>
            <span class="k">del</span> <span class="n">_ag1</span><span class="p">,</span> <span class="n">_ag2</span>

    <span class="n">mass_mismatches</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">ag1</span><span class="o">.</span><span class="n">masses</span> <span class="o">-</span> <span class="n">ag2</span><span class="o">.</span><span class="n">masses</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_mass</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mass_mismatches</span><span class="p">):</span>
        <span class="c"># Test 2 failed.</span>
        <span class="c"># diagnostic output:</span>
        <span class="c"># (ugly workaround because boolean indexing is not yet working for atomgroups)</span>
        <span class="k">assert</span> <span class="n">ag1</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">==</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_atoms</span>
        <span class="n">mismatch_atomindex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ag1</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)[</span><span class="n">mass_mismatches</span><span class="p">]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Atoms: reference | trajectory&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ar</span><span class="p">,</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="n">ag1</span><span class="p">[</span><span class="n">mismatch_atomindex</span><span class="p">],</span> <span class="n">ag2</span><span class="p">[</span><span class="n">mismatch_atomindex</span><span class="p">]):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%4s</span><span class="s"> </span><span class="si">%3d</span><span class="s"> </span><span class="si">%3s</span><span class="s"> </span><span class="si">%3s</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">  |  </span><span class="si">%4s</span><span class="s"> </span><span class="si">%3d</span><span class="s"> </span><span class="si">%3s</span><span class="s"> </span><span class="si">%3s</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">&quot;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">ar</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">mass</span><span class="p">,</span>
                          <span class="n">at</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">mass</span><span class="p">,))</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;Inconsistent selections, masses differ by more than {0}; &quot;</span> <span class="o">+</span> \
            <span class="s">&quot;mis-matching atoms are shown above.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tol_mass</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ag1</span><span class="p">,</span> <span class="n">ag2</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sbastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domaski, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac Virshup,
    Zhuyi Xue, Carlos Yez S.,
    and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>