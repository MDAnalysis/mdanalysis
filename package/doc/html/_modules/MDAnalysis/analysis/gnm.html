<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.analysis.gnm &mdash; MDAnalysis 0.11.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.11.0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.11.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.analysis.gnm</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="c">#Analyse a trajectory using elastic network models, following the approach of Hall et al (JACS 2007)</span>
<span class="c">#Ben Hall (benjamin.a.hall@ucl.ac.uk) is to blame</span>
<span class="c">#Copyright 2011; Consider under GPL v2 or later</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Elastic network analysis of MD trajectories --- :mod:`MDAnalysis.analysis.gnm`</span>
<span class="sd">==============================================================================</span>

<span class="sd">:Author: Benjamin Hall &lt;benjamin.a.hall@ucl.ac.uk&gt;</span>
<span class="sd">:Year: 2011</span>
<span class="sd">:Copyright: GNU Public License v2 or later</span>


<span class="sd">Analyse a trajectory using elastic network models, following the approach of [Hall2007]_.</span>

<span class="sd">An example is provided in :file:`examples/GNMExample.py`. The basic</span>
<span class="sd">approach is to pass a trajectory to :class:`GNMAnalysis` and then run</span>
<span class="sd">the analysis::</span>

<span class="sd">   u = MDAnalysis.Universe(PSF,DCD)</span>
<span class="sd">   C = MDAnalysis.analysis.gnm.GNMAnalysis(u,ReportVector=&quot;output.txt&quot;)</span>

<span class="sd">   C.run()</span>
<span class="sd">   output = zip(*C.results)</span>

<span class="sd">   outputfile = open(&quot;eigenvalues.dat&quot;,&quot;w&quot;)</span>
<span class="sd">   for item in output[1]:</span>
<span class="sd">      print &gt;&gt; outputfile, item</span>
<span class="sd">   outputfile.close()</span>

<span class="sd">The results are found in :attr:`GNMAnalysis.results`, which can be</span>
<span class="sd">used for further processing (see [Hall2007]_).</span>

<span class="sd">.. rubric:: References</span>

<span class="sd">.. [Hall2007]  Benjamin A. Hall, Samantha L. Kaye, Andy Pang, Rafael Perera, and</span>
<span class="sd">               Philip C. Biggin. Characterization of Protein Conformational</span>
<span class="sd">               States by Normal-Mode Frequencies. *JACS* 129 (2007), 11394--11401.</span>


<span class="sd">Analysis tasks</span>
<span class="sd">--------------</span>

<span class="sd">.. autoclass:: GNMAnalysis</span>
<span class="sd">   :members:</span>
<span class="sd">.. autoclass:: closeContactGNMAnalysis</span>
<span class="sd">   :members:</span>

<span class="sd">Utility functions</span>
<span class="sd">-----------------</span>

<span class="sd">The following functions are used internally and are typically not</span>
<span class="sd">directly needed to perform the analysis.</span>

<span class="sd">.. autofunction:: backup_file</span>
<span class="sd">.. autofunction:: generate_grid</span>
<span class="sd">.. autofunction:: order_list</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># import copy #unused</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span>

<span class="kn">import</span> <span class="nn">os</span>

<span class="c">#import warnings #unused</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&#39;MDAnalysis.analysis.GNM&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="backup_file"><a class="viewcode-back" href="../../../documentation_pages/analysis/gnm.html#MDAnalysis.analysis.gnm.backup_file">[docs]</a><span class="k">def</span> <span class="nf">backup_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function helps prevent overwriting default named files</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="n">target_name</span> <span class="o">=</span> <span class="s">&quot;#&quot;</span> <span class="o">+</span> <span class="n">filename</span>
        <span class="n">failure</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">target_name</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">target_name</span><span class="p">)</span>
            <span class="n">failure</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
                <span class="n">alt_target_name</span> <span class="o">=</span> <span class="n">target_name</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">alt_target_name</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">alt_target_name</span><span class="p">)</span>
                    <span class="n">failure</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">failure</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Too many backups. Clean up and try again&quot;</span>
            <span class="nb">exit</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="generate_grid"><a class="viewcode-back" href="../../../documentation_pages/analysis/gnm.html#MDAnalysis.analysis.gnm.generate_grid">[docs]</a><span class="k">def</span> <span class="nf">generate_grid</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    An alternative to searching the entire list of each atom; divide the structure into cutoff sized boxes</span>
<span class="sd">    This way, for each particle you only need to search the neighbouring boxes to find the particles within the cutoff</span>
<span class="sd">    Observed a 6x speed up for a smallish protein with ~300 residues; this should get better with bigger systems.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">positions</span><span class="p">)</span>
    <span class="n">high_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">high_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">high_z</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">low_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">low_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">low_z</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
    <span class="c">#Ok now generate a list with 3 dimensions representing boxes in x, y and z</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="p">[[[</span>
        <span class="p">[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">high_z</span> <span class="o">-</span> <span class="n">low_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">high_y</span> <span class="o">-</span> <span class="n">low_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">high_x</span> <span class="o">-</span> <span class="n">low_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">res_positions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natoms</span><span class="p">):</span>
        <span class="n">x_pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">low_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">cutoff</span><span class="p">)</span>
        <span class="n">y_pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">low_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">cutoff</span><span class="p">)</span>
        <span class="n">z_pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">low_z</span><span class="p">)</span> <span class="o">/</span> <span class="n">cutoff</span><span class="p">)</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">x_pos</span><span class="p">][</span><span class="n">y_pos</span><span class="p">][</span><span class="n">z_pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">res_positions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">z_pos</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">low_x</span><span class="p">,</span> <span class="n">low_y</span><span class="p">,</span> <span class="n">low_z</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="order_list"><a class="viewcode-back" href="../../../documentation_pages/analysis/gnm.html#MDAnalysis.analysis.gnm.order_list">[docs]</a><span class="k">def</span> <span class="nf">order_list</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns a dictionary showing the order of eigenvalues (which are reported scrambled normally)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ordered</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">unordered</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">ordered</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">list_map</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)):</span>
        <span class="n">list_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">unordered</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ordered</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">list_map</span>

</div>
<div class="viewcode-block" id="GNMAnalysis"><a class="viewcode-back" href="../../../documentation_pages/analysis/gnm.html#MDAnalysis.analysis.gnm.GNMAnalysis">[docs]</a><span class="k">class</span> <span class="nc">GNMAnalysis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Basic tool for GNM analysis.</span>

<span class="sd">    Each frame is treated as a novel structure and the GNM</span>
<span class="sd">    calculated.  By default, this stores the dominant eigenvector</span>
<span class="sd">    and its associated eigenvalue; either can be used to monitor</span>
<span class="sd">    conformational change in a simulation.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="n">selection</span><span class="o">=</span><span class="s">&#39;protein and name CA&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">ReportVector</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Bonus_groups</span><span class="o">=</span><span class="p">()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># final result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timesteps</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># time for each frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ReportVector</span> <span class="o">=</span> <span class="n">ReportVector</span>
        <span class="c"># this is a tuple of selection groups, the com of each which will be added as a single point in the ENM</span>
        <span class="c"># (its a popular way of treating small ligands eg drugs)</span>
        <span class="c"># be careful that it doesn&#39;t have any atoms which can be caught by the global selection as this could lead to</span>
        <span class="c">#  double counting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Bonus_groups</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">Bonus_groups</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>

<div class="viewcode-block" id="GNMAnalysis.generate_output"><a class="viewcode-back" href="../../../documentation_pages/analysis/gnm.html#MDAnalysis.analysis.gnm.GNMAnalysis.generate_output">[docs]</a>    <span class="k">def</span> <span class="nf">generate_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">outputobject</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">nmodes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ReportVector</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">counter</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Appends eigenvalues and eigenvectors to results.</span>

<span class="sd">        This generates the output by adding eigenvalue and</span>
<span class="sd">        eigenvector data to an appendable object and optionally</span>
<span class="sd">        printing some of the results to file. This is the function</span>
<span class="sd">        to replace if you want to generate a more complex set of</span>
<span class="sd">        outputs</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">list_map</span> <span class="o">=</span> <span class="n">order_list</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="c">#print round(time), w[list_map[1]]</span>
        <span class="k">if</span> <span class="n">ReportVector</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">ReportVector</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">oup</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">list_map</span><span class="p">[</span><span class="mi">1</span><span class="p">]]):</span>
                    <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="n">oup</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="p">[</span><span class="n">list_map</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">outputobject</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="n">w</span><span class="p">[</span><span class="n">list_map</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">v</span><span class="p">[</span><span class="n">list_map</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
        <span class="c">#outputobject.append((time, [ w[list_map[i]] for i in range(nmodes) ], [ v[list_map[i]] for i in range(</span>
        <span class="c"># nmodes) ] ))</span>
</div>
<div class="viewcode-block" id="GNMAnalysis.generate_kirchoff"><a class="viewcode-back" href="../../../documentation_pages/analysis/gnm.html#MDAnalysis.analysis.gnm.GNMAnalysis.generate_kirchoff">[docs]</a>    <span class="k">def</span> <span class="nf">generate_kirchoff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Generate the Kirchhoff matrix of contacts.</span>

<span class="sd">        This generates the neighbour matrix by generating a grid of</span>
<span class="sd">        near-neighbours and then calculating which are are within</span>
<span class="sd">        the cutoff. Returns the resulting matrix</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c">#ca = self.u.select_atoms(self.selection)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>

        <span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="c">#add the com from each bonus group to the ca_positions list</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bonus_groups</span><span class="p">:</span>
            <span class="c">#bonus = self.u.select_atoms(item)</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">positions</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()))</span>
            <span class="n">natoms</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">matrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">natoms</span><span class="p">,</span> <span class="n">natoms</span><span class="p">),</span> <span class="s">&quot;float&quot;</span><span class="p">)</span>
        <span class="p">[</span><span class="n">res_positions</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">low_x</span><span class="p">,</span> <span class="n">low_y</span><span class="p">,</span> <span class="n">low_z</span><span class="p">]</span> <span class="o">=</span> <span class="n">generate_grid</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span>
        <span class="n">icounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">icounter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natoms</span><span class="p">):</span>
            <span class="c">#find neighbours from the grid</span>
            <span class="n">neighbour_atoms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c">#print icounter, natoms, len(positions), len(res_positions)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
                                        <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                                    <span class="n">neighbour_atoms</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span>
                                        <span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">][</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                                                                        <span class="o">+</span> <span class="n">y</span><span class="p">][</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">]</span>
            <span class="c">#for jcounter in range(icounter+1,natoms):</span>
            <span class="k">for</span> <span class="n">jcounter</span> <span class="ow">in</span> <span class="n">neighbour_atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">jcounter</span> <span class="o">&gt;</span> <span class="n">icounter</span> <span class="ow">and</span> <span class="p">((</span><span class="n">positions</span><span class="p">[</span>
                    <span class="n">icounter</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="n">jcounter</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                        <span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="n">jcounter</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                        <span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="n">jcounter</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">**</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="n">jcounter</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">jcounter</span><span class="p">][</span><span class="n">icounter</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="n">icounter</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="n">icounter</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">jcounter</span><span class="p">][</span><span class="n">jcounter</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">jcounter</span><span class="p">][</span><span class="n">jcounter</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="GNMAnalysis.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/gnm.html#MDAnalysis.analysis.gnm.GNMAnalysis.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Analyze trajectory and produce timeseries.</span>

<span class="sd">        Returns GNM results per frame::</span>

<span class="sd">          results = [(time,eigenvalues[1],eigenvectors[1]),(time,eigenvalues[1],eigenvectors[1])... ]</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;GNM analysis: starting&quot;</span><span class="p">)</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timesteps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">time</span>

            <span class="k">def</span> <span class="nf">_get_timestep</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">time</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;GNM analysis is recording time step&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="c"># chained reader or xyz(?) cannot do time yet</span>
            <span class="k">def</span> <span class="nf">_get_timestep</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">frame</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;GNM analysis is recording frame number instead of time step&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">counter</span> <span class="o">%</span> <span class="n">skip</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
            <span class="n">timestep</span> <span class="o">=</span> <span class="n">_get_timestep</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timesteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timestep</span><span class="p">)</span>

            <span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_kirchoff</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Frame skip at&quot;</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="s">&quot;(SVD failed to converge). Cutoff&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>
                <span class="k">continue</span>
            <span class="c">#Save the results somewhere useful in some useful format. Usefully.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generate_output</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">ReportVector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ReportVector</span><span class="p">,</span> <span class="n">counter</span><span class="o">=</span><span class="n">counter</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="closeContactGNMAnalysis"><a class="viewcode-back" href="../../../documentation_pages/analysis/gnm.html#MDAnalysis.analysis.gnm.closeContactGNMAnalysis">[docs]</a><span class="k">class</span> <span class="nc">closeContactGNMAnalysis</span><span class="p">(</span><span class="n">GNMAnalysis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;GNMAnalysis only using close contacts.</span>

<span class="sd">    This is a version of the GNM where the Kirchoff matrix is</span>
<span class="sd">    constructed from the close contacts between individual atoms</span>
<span class="sd">    in different residues</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="n">selection</span><span class="o">=</span><span class="s">&#39;protein&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">4.5</span><span class="p">,</span> <span class="n">ReportVector</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">MassWeight</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># final result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timesteps</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># time for each frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ReportVector</span> <span class="o">=</span> <span class="n">ReportVector</span>
        <span class="c"># no bonus groups in this version of the GNM analysis tool; this is because this version doesn&#39;t use CA atoms</span>
        <span class="c">#  or centroids, and so doesn&#39;t need them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MassWeight</span> <span class="o">=</span> <span class="n">MassWeight</span>

    <span class="k">def</span> <span class="nf">generate_kirchoff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">nresidues</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="p">[</span><span class="n">res_positions</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">low_x</span><span class="p">,</span> <span class="n">low_y</span><span class="p">,</span> <span class="n">low_z</span><span class="p">]</span> <span class="o">=</span> <span class="n">generate_grid</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span>
        <span class="n">residue_index_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">resnum</span> <span class="k">for</span> <span class="p">[</span><span class="n">resnum</span><span class="p">,</span> <span class="n">residue</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="p">]</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nresidues</span><span class="p">,</span> <span class="n">nresidues</span><span class="p">),</span> <span class="s">&quot;float&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">icounter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natoms</span><span class="p">):</span>
            <span class="n">neighbour_atoms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
                                        <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                                    <span class="n">neighbour_atoms</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">][</span>
                                        <span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">][</span><span class="n">res_positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">jcounter</span> <span class="ow">in</span> <span class="n">neighbour_atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">jcounter</span> <span class="o">&gt;</span> <span class="n">icounter</span> <span class="ow">and</span> <span class="p">((</span><span class="n">positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span>
                    <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="n">jcounter</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                        <span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="n">jcounter</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                        <span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">icounter</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="n">jcounter</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">**</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="p">[</span><span class="n">iresidue</span><span class="p">,</span> <span class="n">jresidue</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">residue_index_map</span><span class="p">[</span><span class="n">icounter</span><span class="p">],</span> <span class="n">residue_index_map</span><span class="p">[</span><span class="n">jcounter</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MassWeight</span><span class="p">:</span>
                        <span class="n">contact</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">iresidue</span><span class="p">]))</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">jresidue</span><span class="p">])))</span> <span class="o">**</span> <span class="mf">0.5</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">contact</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">iresidue</span><span class="p">][</span><span class="n">jresidue</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">iresidue</span><span class="p">][</span><span class="n">jresidue</span><span class="p">]</span> <span class="o">-</span> <span class="n">contact</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">jresidue</span><span class="p">][</span><span class="n">iresidue</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">jresidue</span><span class="p">][</span><span class="n">iresidue</span><span class="p">]</span> <span class="o">-</span> <span class="n">contact</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">iresidue</span><span class="p">][</span><span class="n">iresidue</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">iresidue</span><span class="p">][</span><span class="n">iresidue</span><span class="p">]</span> <span class="o">+</span> <span class="n">contact</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">jresidue</span><span class="p">][</span><span class="n">jresidue</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">jresidue</span><span class="p">][</span><span class="n">jresidue</span><span class="p">]</span> <span class="o">+</span> <span class="n">contact</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">matrix</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sbastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domaski, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac Virshup,
    Zhuyi Xue, Carlos Yez S.,
    and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>