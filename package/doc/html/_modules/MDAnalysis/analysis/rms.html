<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.analysis.rms &mdash; MDAnalysis 0.11.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.11.0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.11.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.analysis.rms</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Calculating root mean square quantities --- :mod:`MDAnalysis.analysis.rms`</span>
<span class="sd">==========================================================================</span>

<span class="sd">:Author: Oliver Beckstein, David L. Dotson</span>
<span class="sd">:Year: 2012</span>
<span class="sd">:Copyright: GNU Public License v2</span>

<span class="sd">.. versionadded:: 0.7.7</span>
<span class="sd">.. versionchanged:: 0.11.0</span>
<span class="sd">   Added :class:`RMSF` analysis.</span>

<span class="sd">The module contains code to analyze root mean square quantities such</span>
<span class="sd">as the coordinat root mean square distance (:class:`RMSD`) or the</span>
<span class="sd">per-residue root mean square fluctuations (:class:`RMSF`).</span>

<span class="sd">This module uses the fast QCP algorithm [Theobald2005]_ to calculate</span>
<span class="sd">the root mean square distance (RMSD) between two coordinate sets (as</span>
<span class="sd">implemented in</span>
<span class="sd">:func:`MDAnalysis.lib.qcprot.CalcRMSDRotationalMatrix`).</span>

<span class="sd">When using this module in published work please cite [Theobald2005]_.</span>

<span class="sd">.. SeeAlso::</span>

<span class="sd">   :mod:`MDAnalysis.analysis.align`</span>
<span class="sd">       aligning structures based on RMSD</span>
<span class="sd">   :mod:`MDAnalysis.lib.qcprot`</span>
<span class="sd">        implements the fast RMSD algorithm.</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>

<span class="sd">Calculating RMSD for multiple domains</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">In this example we will globally fit a protein to a reference</span>
<span class="sd">structure and investigate the relative movements of domains by</span>
<span class="sd">computing the RMSD of the domains to the reference. The example is a</span>
<span class="sd">DIMS trajectory of adenylate kinase, which samples a large</span>
<span class="sd">closed-to-open transition. The protein consists of the CORE, LID, and</span>
<span class="sd">NMP domain.</span>

<span class="sd">* superimpose on the closed structure (frame 0 of the trajectory),</span>
<span class="sd">  using backbone atoms</span>

<span class="sd">* calculate the backbone RMSD and RMSD for CORE, LID, NMP (backbone atoms)</span>

<span class="sd">The trajectory is included with the test data files. The data in</span>
<span class="sd">:attr:`RMSD.rmsd` is plotted with :func:`matplotlib.pyplot.plot`::</span>

<span class="sd">   import MDAnalysis</span>
<span class="sd">   from MDAnalysis.tests.datafiles import PSF,DCD,CRD</span>
<span class="sd">   u = MDAnalysis.Universe(PSF,DCD)</span>
<span class="sd">   ref = MDAnalysis.Universe(PSF,DCD)     # reference closed AdK (1AKE) (with the default ref_frame=0)</span>
<span class="sd">   #ref = MDAnalysis.Universe(PSF,CRD)    # reference open AdK (4AKE)</span>

<span class="sd">   import MDAnalysis.analysis.rms</span>

<span class="sd">   R = MDAnalysis.analysis.rms.RMSD(u, ref,</span>
<span class="sd">              select=&quot;backbone&quot;,             # superimpose on whole backbone of the whole protein</span>
<span class="sd">              groupselections=[&quot;backbone and (resid 1-29 or resid 60-121 or resid 160-214)&quot;,   # CORE</span>
<span class="sd">                               &quot;backbone and resid 122-159&quot;,                                   # LID</span>
<span class="sd">                               &quot;backbone and resid 30-59&quot;],                                    # NMP</span>
<span class="sd">              filename=&quot;rmsd_all_CORE_LID_NMP.dat&quot;)</span>
<span class="sd">   R.run()</span>
<span class="sd">   R.save()</span>

<span class="sd">   import matplotlib.pyplot as plt</span>
<span class="sd">   rmsd = R.rmsd.T   # transpose makes it easier for plotting</span>
<span class="sd">   time = rmsd[1]</span>
<span class="sd">   fig = plt.figure(figsize=(4,4))</span>
<span class="sd">   ax = fig.add_subplot(111)</span>
<span class="sd">   ax.plot(time, rmsd[2], &#39;k-&#39;,  label=&quot;all&quot;)</span>
<span class="sd">   ax.plot(time, rmsd[3], &#39;k--&#39;, label=&quot;CORE&quot;)</span>
<span class="sd">   ax.plot(time, rmsd[4], &#39;r--&#39;, label=&quot;LID&quot;)</span>
<span class="sd">   ax.plot(time, rmsd[5], &#39;b--&#39;, label=&quot;NMP&quot;)</span>
<span class="sd">   ax.legend(loc=&quot;best&quot;)</span>
<span class="sd">   ax.set_xlabel(&quot;time (ps)&quot;)</span>
<span class="sd">   ax.set_ylabel(r&quot;RMSD ($\AA$)&quot;)</span>
<span class="sd">   fig.savefig(&quot;rmsd_all_CORE_LID_NMP_ref1AKE.pdf&quot;)</span>



<span class="sd">Functions</span>
<span class="sd">---------</span>

<span class="sd">.. autofunction:: rmsd</span>

<span class="sd">Analysis classes</span>
<span class="sd">----------------</span>

<span class="sd">.. autoclass:: RMSD</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: rmsd</span>

<span class="sd">      Results are stored in this N×3 :class:`numpy.ndarray` array,</span>
<span class="sd">      (frame, time (ps), RMSD (Å)).</span>

<span class="sd">.. autoclass:: RMSF</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: rmsf</span>

<span class="sd">      Results are stored in this N-length :class:`numpy.ndarray` array,</span>
<span class="sd">      giving RMSFs for each of the given atoms.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">import</span> <span class="nn">MDAnalysis.lib.qcprot</span> <span class="kn">as</span> <span class="nn">qcp</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.exceptions</span> <span class="kn">import</span> <span class="n">SelectionError</span><span class="p">,</span> <span class="n">NoDataError</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.log</span> <span class="kn">import</span> <span class="n">ProgressMeter</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.util</span> <span class="kn">import</span> <span class="n">asiterable</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&#39;MDAnalysis.analysis.rmsd&#39;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">warnings</span>


<div class="viewcode-block" id="rmsd"><a class="viewcode-back" href="../../../documentation_pages/analysis/rms.html#MDAnalysis.analysis.rms.rmsd">[docs]</a><span class="k">def</span> <span class="nf">rmsd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns RMSD between two coordinate sets *a* and *b*.</span>

<span class="sd">    *a* and *b* are arrays of the coordinates of N atoms of shape N*3</span>
<span class="sd">    as generated by, e.g.,</span>
<span class="sd">    :meth:`MDAnalysis.core.AtomGroup.AtomGroup.coordinates`.</span>

<span class="sd">    An implicit optimal superposition is performed, which minimizes</span>
<span class="sd">    the RMSD between *a* and *b* although both *a* and *b* must be</span>
<span class="sd">    centered on the origin before performing the RMSD calculation so</span>
<span class="sd">    that translations are removed.</span>

<span class="sd">    One can use the *center* = ``True`` keyword, which subtracts the</span>
<span class="sd">    center of geometry (for *weights* = ``None``) before the</span>
<span class="sd">    superposition. With *weights*, a weighted average is computed as</span>
<span class="sd">    the center.</span>

<span class="sd">    The *weights* can be an array of length N, containing e.g. masses</span>
<span class="sd">    for a weighted RMSD calculation.</span>

<span class="sd">    The function uses Douglas Theobald&#39;s fast QCP algorithm</span>
<span class="sd">    [Theobald2005]_ to calculate the RMSD.</span>

<span class="sd">    Example::</span>
<span class="sd">     &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">     &gt;&gt;&gt; bb = u.select_atoms(&#39;backbone&#39;)</span>
<span class="sd">     &gt;&gt;&gt; A = bb.coordinates()  # coordinates of first frame</span>
<span class="sd">     &gt;&gt;&gt; u.trajectory[-1]      # forward to last frame</span>
<span class="sd">     &gt;&gt;&gt; B = bb.coordinates()  # coordinates of last frame</span>
<span class="sd">     &gt;&gt;&gt; rmsd(A,B)</span>
<span class="sd">     6.8342494129169804</span>

<span class="sd">     .. versionchanged: 0.8.1</span>
<span class="sd">        *center* keyword added</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># weights are constructed as relative to the mean</span>
        <span class="n">relative_weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">relative_weights</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="c"># make copies (do not change the user data!)</span>
        <span class="c"># weights=None is equivalent to all weights 1</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qcp</span><span class="o">.</span><span class="n">CalcRMSDRotationalMatrix</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                                        <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> <span class="n">relative_weights</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_process_selection</span><span class="p">(</span><span class="n">select</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a canonical selection dictionary.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *select*</span>
<span class="sd">         - any valid selection string for</span>
<span class="sd">           :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.select_atoms` that produces identical</span>
<span class="sd">           selections in *mobile* and *reference*; or</span>
<span class="sd">         - dictionary ``{&#39;mobile&#39;:sel1, &#39;reference&#39;:sel2}``.</span>
<span class="sd">           The :func:`fasta2select` function returns such a</span>
<span class="sd">           dictionary based on a ClustalW_ or STAMP_ sequence alignment.</span>
<span class="sd">         - tuple ``(sel1, sel2)``</span>

<span class="sd">    :Returns: dict with keys `reference` and `mobile`; the values are guaranteed to</span>
<span class="sd">              be iterable (so that one can provide selections that retain order)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">select</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">select</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;reference&#39;</span><span class="p">:</span> <span class="n">select</span><span class="p">,</span> <span class="s">&#39;mobile&#39;</span><span class="p">:</span> <span class="n">select</span><span class="p">}</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">select</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">select</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;mobile&#39;</span><span class="p">:</span> <span class="n">select</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;reference&#39;</span><span class="p">:</span> <span class="n">select</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&quot;select must contain two selection strings &quot;</span>
                             <span class="s">&quot;(reference, mobile)&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">select</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c"># compatability hack to use new nomenclature</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">select</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">select</span><span class="p">[</span><span class="s">&#39;target&#39;</span><span class="p">]</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;use key &#39;mobile&#39; instead of deprecated &#39;target&#39;; &quot;</span>
                          <span class="s">&quot;&#39;target&#39; will be removed in 0.8&quot;</span><span class="p">,</span>
                          <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">select</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">]</span>
            <span class="n">select</span><span class="p">[</span><span class="s">&#39;reference&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;select dictionary must contain entries for keys &quot;</span>
                           <span class="s">&quot;&#39;mobile&#39; and &#39;reference&#39;.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;&#39;select&#39; must be either a string, 2-tuple, or dict&quot;</span><span class="p">)</span>
    <span class="n">select</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">asiterable</span><span class="p">(</span><span class="n">select</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">])</span>
    <span class="n">select</span><span class="p">[</span><span class="s">&#39;reference&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">asiterable</span><span class="p">(</span><span class="n">select</span><span class="p">[</span><span class="s">&#39;reference&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">select</span>


<div class="viewcode-block" id="RMSD"><a class="viewcode-back" href="../../../documentation_pages/analysis/rms.html#MDAnalysis.analysis.rms.RMSD">[docs]</a><span class="k">class</span> <span class="nc">RMSD</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to perform RMSD analysis on a trajectory.</span>

<span class="sd">    Run the analysis with :meth:`RMSD.run`, which stores the results</span>
<span class="sd">    in the array :attr:`RMSD.rmsd`::</span>

<span class="sd">       frame    time (ps)    RMSD (A)</span>

<span class="sd">    This class uses Douglas Theobald&#39;s fast QCP algorithm</span>
<span class="sd">    [Theobald2005]_ to calculate the RMSD.</span>

<span class="sd">    .. versionadded:: 0.7.7</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traj</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="n">groupselections</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&quot;rmsd.dat&quot;</span><span class="p">,</span>
                 <span class="n">mass_weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">ref_frame</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setting up the RMSD analysis.</span>

<span class="sd">        The RMSD will be computed between *select* and *reference* for</span>
<span class="sd">        all frames in the trajectory in *universe*.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *traj*</span>
<span class="sd">             universe (:class:`MDAnalysis.Universe` object) that contains a</span>
<span class="sd">             trajectory</span>
<span class="sd">          *reference*</span>
<span class="sd">             reference coordinates; :class:`MDAnalysis.Universe` object; if ``None``</span>
<span class="sd">             the *traj* is used (uses the current time step of the object) [``None``]</span>
<span class="sd">          *select*</span>
<span class="sd">             The selection to operate on; can be one of:</span>

<span class="sd">             1. any valid selection string for</span>
<span class="sd">                :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.select_atoms` that produces identical</span>
<span class="sd">                selections in *mobile* and *reference*; or</span>
<span class="sd">             2. a dictionary ``{&#39;mobile&#39;:sel1, &#39;reference&#39;:sel2}`` (the</span>
<span class="sd">                :func:`MDAnalysis.analysis.align.fasta2select` function returns such a</span>
<span class="sd">                dictionary based on a ClustalW_ or STAMP_ sequence alignment); or</span>
<span class="sd">             3. a tuple ``(sel1, sel2)``</span>

<span class="sd">             When using 2. or 3. with *sel1* and *sel2* then these selections can also each be</span>
<span class="sd">             a list of selection strings (to generate a AtomGroup with defined atom order as</span>
<span class="sd">             described under :ref:`ordered-selections-label`).</span>
<span class="sd">          *groupselections*</span>
<span class="sd">             A list of selections as described for *select*. Each selection describes additional</span>
<span class="sd">             RMSDs to be computed *after the structures have be superpositioned* according to *select*.</span>
<span class="sd">             The output contains one additional column for each selection. [``None``]</span>

<span class="sd">             .. Note:: Experimental feature. Only limited error checking implemented.</span>
<span class="sd">          *filename*</span>
<span class="sd">             If set, *filename* can be used to write the results with :meth:`RMSD.save` [``None``]</span>
<span class="sd">          *mass_weighted*</span>
<span class="sd">             do a mass-weighted RMSD fit</span>
<span class="sd">          *tol_mass*</span>
<span class="sd">             Reject match if the atomic masses for matched atoms differ by more than</span>
<span class="sd">             *tol_mass* [0.1]</span>
<span class="sd">          *ref_frame*</span>
<span class="sd">             frame index to select frame from *reference* [0]</span>

<span class="sd">        .. _ClustalW: http://www.clustal.org/</span>
<span class="sd">        .. _STAMP: http://www.compbio.dundee.ac.uk/manuals/stamp.4.2/</span>

<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           *groupselections* added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="n">_process_selection</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">groupselections</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groupselections</span> <span class="o">=</span> <span class="p">[</span><span class="n">_process_selection</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">groupselections</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groupselections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass_weighted</span> <span class="o">=</span> <span class="n">mass_weighted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol_mass</span> <span class="o">=</span> <span class="n">tol_mass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">=</span> <span class="n">ref_frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">[</span><span class="s">&#39;reference&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">])</span>
        <span class="n">natoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span><span class="o">.</span><span class="n">n_atoms</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="s">&quot;Reference and trajectory atom selections do not contain &quot;</span> <span class="o">+</span>
                                 <span class="s">&quot;the same number of atoms: N_ref=</span><span class="si">%d</span><span class="s">, N_traj=</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span><span class="p">)))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;RMS calculation for </span><span class="si">%d</span><span class="s"> atoms.&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">))</span>
        <span class="n">mass_mismatches</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">masses</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span><span class="o">.</span><span class="n">masses</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol_mass</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mass_mismatches</span><span class="p">):</span>
            <span class="c"># diagnostic output:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Atoms: reference | trajectory&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ar</span><span class="p">,</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ar</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">at</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%4s</span><span class="s"> </span><span class="si">%3d</span><span class="s"> </span><span class="si">%3s</span><span class="s"> </span><span class="si">%3s</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">  |  </span><span class="si">%4s</span><span class="s"> </span><span class="si">%3d</span><span class="s"> </span><span class="si">%3s</span><span class="s"> </span><span class="si">%3s</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">ar</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">mass</span><span class="p">,</span>
                                 <span class="n">at</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">mass</span><span class="p">,))</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s">&quot;Inconsistent selections, masses differ by more than </span><span class="si">%f</span><span class="s">; mis-matching atoms are shown above.&quot;</span> <span class="o">%</span> \
                     <span class="bp">self</span><span class="o">.</span><span class="n">tol_mass</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">mass_mismatches</span>

        <span class="c"># TODO:</span>
        <span class="c"># - make a group comparison a class that contains the checks above</span>
        <span class="c"># - use this class for the *select* group and the additional *groupselections* groups</span>
        <span class="c"># each a dict with reference/mobile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s">&#39;reference&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="s">&#39;reference&#39;</span><span class="p">]),</span>
                <span class="s">&#39;mobile&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">]),</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupselections</span><span class="p">]</span>
        <span class="c"># sanity check</span>
        <span class="k">for</span> <span class="n">igroup</span><span class="p">,</span> <span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groupselections</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="s">&#39;reference&#39;</span><span class="p">]):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span>
                <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span>
                    <span class="s">&quot;Group selection {0}: {1} | {2}: Reference and trajectory atom selections do not contain &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;the same number of atoms: N_ref={3}, N_traj={4}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">igroup</span><span class="p">,</span> <span class="n">sel</span><span class="p">[</span><span class="s">&#39;reference&#39;</span><span class="p">],</span> <span class="n">sel</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="s">&#39;reference&#39;</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">])))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rmsd</span> <span class="o">=</span> <span class="bp">None</span>

<div class="viewcode-block" id="RMSD.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/rms.html#MDAnalysis.analysis.rms.RMSD.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform RMSD analysis on the trajectory.</span>

<span class="sd">        A number of parameters can be changed from the defaults. The</span>
<span class="sd">        result is stored as the array :attr:`RMSD.rmsd`.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *start*, *stop*, *step*</span>
<span class="sd">             start and stop frame index with step size: analyse</span>
<span class="sd">             ``trajectory[start:stop:step]`` [``None``]</span>
<span class="sd">          *mass_weighted*</span>
<span class="sd">             do a mass-weighted RMSD fit</span>
<span class="sd">          *tol_mass*</span>
<span class="sd">             Reject match if the atomic masses for matched atoms differ by more than</span>
<span class="sd">             *tol_mass*</span>
<span class="sd">          *ref_frame*</span>
<span class="sd">             frame index to select frame from *reference*</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;start&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;stop&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">mass_weighted</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;mass_weighted&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass_weighted</span><span class="p">)</span>
        <span class="n">ref_frame</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;ref_frame&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span><span class="p">)</span>

        <span class="n">natoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span><span class="o">.</span><span class="n">n_atoms</span>
        <span class="n">trajectory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span>
        <span class="n">traj_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span>

        <span class="k">if</span> <span class="n">mass_weighted</span><span class="p">:</span>
            <span class="c"># if performing a mass-weighted alignment/rmsd calculation</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">masses</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">masses</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># reference centre of mass system</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># Move to the ref_frame</span>
            <span class="c"># (coordinates MUST be stored in case the ref traj is advanced elsewhere or if ref == mobile universe)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">ref_frame</span><span class="p">]</span>
            <span class="n">ref_com</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span>
            <span class="n">ref_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">ref_com</span>  <span class="c"># makes a copy</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span><span class="p">:</span>
                <span class="n">groupselections_ref_coords_T_64</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="s">&#39;reference&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">groupselections</span><span class="p">]</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c"># Move back to the original frame</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">current_frame</span><span class="p">]</span>
        <span class="n">ref_coordinates_T_64</span> <span class="o">=</span> <span class="n">ref_coordinates</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c"># allocate the array for selection atom coords</span>
        <span class="n">traj_coordinates</span> <span class="o">=</span> <span class="n">traj_atoms</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span><span class="p">:</span>
            <span class="c"># Only carry out a rotation if we want to calculate secondary RMSDs.</span>
            <span class="c"># R: rotation matrix that aligns r-r_com, x~-x~com</span>
            <span class="c">#    (x~: selected coordinates, x: all coordinates)</span>
            <span class="c"># Final transformed traj coordinates: x&#39; = (x-x~_com)*R + ref_com</span>
            <span class="n">rot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c"># allocate space for calculation</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rot</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># RMSD timeseries</span>
        <span class="n">nframes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectory</span><span class="p">))[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">])</span>
        <span class="n">rmsd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nframes</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span><span class="p">)))</span>

        <span class="n">percentage</span> <span class="o">=</span> <span class="n">ProgressMeter</span><span class="p">(</span><span class="n">nframes</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                   <span class="n">format</span><span class="o">=</span><span class="s">&quot;RMSD </span><span class="si">%(rmsd)5.2f</span><span class="s"> A at frame </span><span class="si">%(step)5d</span><span class="s">/</span><span class="si">%(numsteps)d</span><span class="s">  [</span><span class="si">%(percentage)5.1f%%</span><span class="s">]</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trajectory</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]):</span>
            <span class="c"># shift coordinates for rotation fitting</span>
            <span class="c"># selection is updated with the time frame</span>
            <span class="n">x_com</span> <span class="o">=</span> <span class="n">traj_atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">traj_coordinates</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">traj_atoms</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="n">x_com</span>

            <span class="n">rmsd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">time</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span><span class="p">:</span>
                <span class="c"># 1) superposition structures</span>
                <span class="c"># Need to transpose coordinates such that the coordinate array is</span>
                <span class="c"># 3xN instead of Nx3. Also qcp requires that the dtype be float64</span>
                <span class="c"># (I think we swapped the position of ref and traj in CalcRMSDRotationalMatrix</span>
                <span class="c"># so that R acts **to the left** and can be broadcasted; we&#39;re saving</span>
                <span class="c"># one transpose. [orbeckst])</span>
                <span class="n">rmsd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qcp</span><span class="o">.</span><span class="n">CalcRMSDRotationalMatrix</span><span class="p">(</span><span class="n">ref_coordinates_T_64</span><span class="p">,</span>
                                                          <span class="n">traj_coordinates</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                                                          <span class="n">natoms</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
                <span class="n">R</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

                <span class="c"># Transform each atom in the trajectory (use inplace ops to avoid copying arrays)</span>
                <span class="c"># (Marginally (~3%) faster than &quot;ts.positions[:] = (ts.positions - x_com) * R + ref_com&quot;.)</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">positions</span> <span class="o">-=</span> <span class="n">x_com</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">positions</span> <span class="o">*</span> <span class="n">R</span>  <span class="c"># R acts to the left &amp; is broadcasted N times.</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">positions</span> <span class="o">+=</span> <span class="n">ref_com</span>

                <span class="c"># 2) calculate secondary RMSDs</span>
                <span class="k">for</span> <span class="n">igroup</span><span class="p">,</span> <span class="p">(</span><span class="n">refpos</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                        <span class="n">izip</span><span class="p">(</span><span class="n">groupselections_ref_coords_T_64</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span><span class="p">),</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">rmsd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">igroup</span><span class="p">]</span> <span class="o">=</span> <span class="n">qcp</span><span class="o">.</span><span class="n">CalcRMSDRotationalMatrix</span><span class="p">(</span><span class="n">refpos</span><span class="p">,</span>
                                                                   <span class="n">atoms</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                                                                   <span class="n">atoms</span><span class="p">[</span><span class="s">&#39;mobile&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># only calculate RMSD by setting the Rmatrix to None</span>
                <span class="c"># (no need to carry out the rotation as we already get the optimum RMSD)</span>
                <span class="n">rmsd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qcp</span><span class="o">.</span><span class="n">CalcRMSDRotationalMatrix</span><span class="p">(</span><span class="n">ref_coordinates_T_64</span><span class="p">,</span>
                                                          <span class="n">traj_coordinates</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                                                          <span class="n">natoms</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>

            <span class="n">percentage</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">rmsd</span><span class="o">=</span><span class="n">rmsd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rmsd</span> <span class="o">=</span> <span class="n">rmsd</span>
</div>
<div class="viewcode-block" id="RMSD.save"><a class="viewcode-back" href="../../../documentation_pages/analysis/rms.html#MDAnalysis.analysis.rms.RMSD.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save RMSD from :attr:`RMSD.rmsd` to text file *filename*.</span>

<span class="sd">        If *filename* is not supplied then the default provided to the</span>
<span class="sd">        constructor is used.</span>

<span class="sd">        The data are saved with :func:`numpy.savetxt`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmsd</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;rmsd has not been calculated yet&quot;</span><span class="p">)</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmsd</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Wrote RMSD timeseries  to file </span><span class="si">%r</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filename</span>

</div></div>
<div class="viewcode-block" id="RMSF"><a class="viewcode-back" href="../../../documentation_pages/analysis/rms.html#MDAnalysis.analysis.rms.RMSF">[docs]</a><span class="k">class</span> <span class="nc">RMSF</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to perform RMSF analysis on a set of atoms across a trajectory.</span>

<span class="sd">    Run the analysis with :meth:`RMSF.run`, which stores the results</span>
<span class="sd">    in the array :attr:`RMSF.rmsf`.</span>

<span class="sd">    This class performs no coordinate transforms; RMSFs are obtained from atom</span>
<span class="sd">    coordinates as-is.</span>

<span class="sd">    .. versionadded:: 0.11.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomgroup</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate RMSF of given atoms across a trajectory.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">            *atomgroup*</span>
<span class="sd">                AtomGroup to obtain RMSF for</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span> <span class="o">=</span> <span class="n">atomgroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rmsf</span> <span class="o">=</span> <span class="bp">None</span>

<div class="viewcode-block" id="RMSF.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/rms.html#MDAnalysis.analysis.rms.RMSF.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">progout</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate RMSF of given atoms across a trajectory.</span>

<span class="sd">        This method implements an algorithm for computing sums of squares while</span>
<span class="sd">        avoiding overflows and underflows; please reference:</span>

<span class="sd">        .. [Welford1962] B. P. Welford (1962). &quot;Note on a Method for</span>
<span class="sd">           Calculating Corrected Sums of Squares and Products.&quot;  Technometrics</span>
<span class="sd">           4(3):419-420.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">            *start*</span>
<span class="sd">                starting frame [0]</span>
<span class="sd">            *stop*</span>
<span class="sd">                stopping frame [-1]</span>
<span class="sd">            *step*</span>
<span class="sd">                step between frames [1]</span>
<span class="sd">            *progout*</span>
<span class="sd">                number of frames to iterate through between updates to progress</span>
<span class="sd">                output; ``None`` for no updates [10]</span>
<span class="sd">            *quiet*</span>
<span class="sd">                if ``True``, suppress all output (implies *progout* = ``None``)</span>
<span class="sd">                [``False``]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sumsquares</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sumsquares</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="n">progout</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># set up progress output</span>
        <span class="k">if</span> <span class="n">progout</span><span class="p">:</span>
            <span class="n">percentage</span> <span class="o">=</span> <span class="n">ProgressMeter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span>
                                       <span class="n">interval</span><span class="o">=</span><span class="n">progout</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">percentage</span> <span class="o">=</span> <span class="n">ProgressMeter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span>
                                       <span class="n">quiet</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]):</span>
            <span class="n">sumsquares</span> <span class="o">+=</span> <span class="p">(</span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">means</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">means</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">means</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">percentage</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>

        <span class="n">rmsf</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sumsquares</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rmsf</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Some RMSF values negative; overflow &quot;</span> <span class="o">+</span>
                             <span class="s">&quot;or underflow occurred&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rmsf</span> <span class="o">=</span> <span class="n">rmsf</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rmsf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;RMSF data; only available after using :meth:`RMSF.run`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmsf</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sébastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domański, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac Virshup,
    Zhuyi Xue, Carlos Yáñez S.,
    and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>