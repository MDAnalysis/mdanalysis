<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.lib.mdamath &mdash; MDAnalysis 0.11.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.11.0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.11.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.lib.mdamath</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Mathematical helper functions --- :mod:`MDAnalysis.lib.mdamath`</span>
<span class="sd">===============================================================</span>

<span class="sd">Helper functions for common mathematical operations</span>

<span class="sd">.. autofunction:: normal</span>
<span class="sd">.. autofunction:: norm</span>
<span class="sd">.. autofunction:: angle</span>
<span class="sd">.. autofunction:: dihedral</span>
<span class="sd">.. autofunction:: stp</span>
<span class="sd">.. autofunction:: triclinic_box</span>
<span class="sd">.. autofunction:: triclinic_vectors</span>
<span class="sd">.. autofunction:: box_volume</span>
<span class="sd">.. autofunction:: make_whole</span>

<span class="sd">.. versionadded:: 0.11.0</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="kn">import</span> <span class="n">NoDataError</span>

<span class="c"># geometric functions</span>
<div class="viewcode-block" id="norm"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.norm">[docs]</a><span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Returns the length of a vector, ``sqrt(v.v)``.</span>

<span class="sd">    .. math::</span>

<span class="sd">       v = \sqrt{\mathbf{v}\cdot\mathbf{v}}</span>

<span class="sd">    Faster than :func:`numpy.linalg.norm` because no frills.</span>

<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Moved into lib.mdamath</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="normal"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.normal">[docs]</a><span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Returns the unit vector normal to two vectors.</span>

<span class="sd">    .. math::</span>

<span class="sd">       \hat{\mathbf{n}} = \frac{\mathbf{v}_1 \times \mathbf{v}_2}{|\mathbf{v}_1 \times \mathbf{v}_2|}</span>

<span class="sd">    If the two vectors are collinear, the vector :math:`\mathbf{0}` is returned.</span>

<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Moved into lib.mdamath</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">normal</span>  <span class="c"># returns [0,0,0] instead of [nan,nan,nan]</span>
    <span class="k">return</span> <span class="n">normal</span> <span class="o">/</span> <span class="n">n</span>  <span class="c"># ... could also use numpy.nan_to_num(normal/norm(normal))</span>

</div>
<div class="viewcode-block" id="angle"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.angle">[docs]</a><span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the angle between two vectors in radians</span>

<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Moved into lib.mdamath</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="c"># catch roundoffs that lead to nan otherwise</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="stp"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.stp">[docs]</a><span class="k">def</span> <span class="nf">stp</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">vec3</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Takes the scalar triple product of three vectors.</span>

<span class="sd">    Returns the volume *V* of the parallel epiped spanned by the three</span>
<span class="sd">    vectors</span>

<span class="sd">    .. math::</span>

<span class="sd">        V = \mathbf{v}_3 \cdot (\mathbf{v}_1 \times \mathbf{v}_2)</span>

<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Moved into lib.mdamath</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="dihedral"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.dihedral">[docs]</a><span class="k">def</span> <span class="nf">dihedral</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Returns the dihedral angle in radians between vectors connecting A,B,C,D.</span>

<span class="sd">    The dihedral measures the rotation around bc::</span>

<span class="sd">         ab</span>
<span class="sd">       A----&gt;B</span>
<span class="sd">              \ bc</span>
<span class="sd">              _\&#39;</span>
<span class="sd">                C----&gt;D</span>
<span class="sd">                  cd</span>

<span class="sd">    The dihedral angle is restricted to the range -π &lt;= x &lt;= π.</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Moved into lib.mdamath</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">normal</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">),</span> <span class="n">normal</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">stp</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_angle</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Angle between two vectors *a* and *b* in degrees.</span>

<span class="sd">    If one of the lengths is 0 then the angle is returned as 0</span>
<span class="sd">    (instead of `nan`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># This function has different limits than angle?</span>

    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>


<div class="viewcode-block" id="triclinic_box"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.triclinic_box">[docs]</a><span class="k">def</span> <span class="nf">triclinic_box</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert the three triclinic box vectors to [A,B,C,alpha,beta,gamma].</span>

<span class="sd">    Angles are in degrees.</span>

<span class="sd">    * alpha  = angle(y,z)</span>
<span class="sd">    * beta   = angle(x,z)</span>
<span class="sd">    * gamma  = angle(x,y)</span>

<span class="sd">    .. SeeAlso:: Definition of angles: http://en.wikipedia.org/wiki/Lattice_constant</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">_angle</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">_angle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">_angle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="triclinic_vectors"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.triclinic_vectors">[docs]</a><span class="k">def</span> <span class="nf">triclinic_vectors</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert `[A,B,C,alpha,beta,gamma]` to a triclinic box representation.</span>

<span class="sd">    Original `code by Tsjerk Wassenaar`_ posted on the Gromacs mailinglist.</span>

<span class="sd">    If *dimensions* indicates a non-periodic system (i.e. all lengths</span>
<span class="sd">    0) then null-vectors are returned.</span>

<span class="sd">    .. _code by Tsjerk Wassenaar:</span>
<span class="sd">       http://www.mail-archive.com/gmx-users@gromacs.org/msg28032.html</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *dimensions*</span>
<span class="sd">        list of box lengths and angles (in degrees) such as</span>
<span class="sd">        [A,B,C,alpha,beta,gamma]</span>

<span class="sd">    :Returns: numpy 3x3 array B, with B[0] = first box vector,</span>
<span class="sd">              B[1] = second vector, B[2] third box vector.</span>

<span class="sd">    .. note::</span>

<span class="sd">       The first vector is always pointing along the X-axis</span>
<span class="sd">       i.e. parallel to (1,0,0).</span>

<span class="sd">    .. versionchanged:: 0.7.6</span>
<span class="sd">       Null-vectors are returned for non-periodic (or missing) unit cell.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">B</span>

    <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mf">90.</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="mf">90.</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="mf">90.</span><span class="p">:</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">z</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">B</span>

</div>
<div class="viewcode-block" id="box_volume"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.box_volume">[docs]</a><span class="k">def</span> <span class="nf">box_volume</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the volume of the unitcell described by *dimensions*.</span>

<span class="sd">    The volume is computed as `det(x1,x2,x2)` where the xi are the</span>
<span class="sd">    triclinic box vectors from :func:`triclinic_vectors`.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">       *dimensions*</span>
<span class="sd">          list of box lengths and angles (in degrees) such as</span>
<span class="sd">          [A,B,C,alpha,beta,gamma]</span>

<span class="sd">    :Returns: numpy 3x3 array B, with B[0] = first box vector,</span>
<span class="sd">              B[1] = second vector, B[2] third box vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">triclinic_vectors</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>

</div>
<span class="k">def</span> <span class="nf">_is_contiguous</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Walk through atomgroup, starting with atom.</span>

<span class="sd">    :Returns:</span>
<span class="sd">       ``True`` if all of *atomgroup* is accessible through walking</span>
<span class="sd">        along bonds.</span>
<span class="sd">       ``False`` otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">atom</span><span class="p">])</span>
    <span class="n">walked</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="n">nloops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">seen</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">):</span>
        <span class="n">nloops</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">nloops</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">todo</span> <span class="o">=</span> <span class="n">seen</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">walked</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonded_atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">atomgroup</span><span class="p">:</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">walked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">True</span>


<div class="viewcode-block" id="make_whole"><a class="viewcode-back" href="../../../documentation_pages/lib/mdamath.html#MDAnalysis.lib.mdamath.make_whole">[docs]</a><span class="k">def</span> <span class="nf">make_whole</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">,</span> <span class="n">reference_atom</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Move all atoms in a single molecule so that bonds don&#39;t split over images</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *atomgroup*</span>
<span class="sd">        The :class:`MDAnalysis.core.AtomGroup.AtomGroup` to work with.</span>
<span class="sd">        The positions of this are modified in place.  All these atoms</span>
<span class="sd">        must belong in the same molecule.</span>

<span class="sd">    :Keywords:</span>
<span class="sd">      *reference_atom*</span>
<span class="sd">        The atom around which all other atoms will be moved.</span>
<span class="sd">        Defaults to atom 0 in the atomgroup.</span>

<span class="sd">    :Returns:</span>
<span class="sd">       ``None``.  Atom positions are modified in place</span>

<span class="sd">    :Raises:</span>
<span class="sd">      `NoDataError`</span>
<span class="sd">         if there are no bonds present.</span>
<span class="sd">         (See :func:`~MDAnalysis.topology.core.guess_bonds`)</span>

<span class="sd">      `ValueError`</span>
<span class="sd">         if the algorithm fails to work.  This is usually</span>
<span class="sd">         caused by the atomgroup not being a single fragment.</span>
<span class="sd">         (ie the molecule can&#39;t be traversed by following bonds)</span>

<span class="sd">    This function is most useful when atoms have been packed into the primary</span>
<span class="sd">    unit cell, causing breaks mid molecule, with the molecule then appearing</span>
<span class="sd">    on either side of the unit cell. This is problematic for operations</span>
<span class="sd">    such as calculating the center of mass of the molecule. ::</span>

<span class="sd">       +-----------+     +-----------+</span>
<span class="sd">       |           |     |           |</span>
<span class="sd">       | 6       3 |     |         3 | 6</span>
<span class="sd">       | !       ! |     |         ! | !</span>
<span class="sd">       |-5-8   1-2-| -&gt;  |       1-2-|-5-8</span>
<span class="sd">       | !       ! |     |         ! | !</span>
<span class="sd">       | 7       4 |     |         4 | 7</span>
<span class="sd">       |           |     |           |</span>
<span class="sd">       +-----------+     +-----------+</span>

<span class="sd">    Usage::</span>

<span class="sd">      from MDAnalysis.util.mdamath import make_whole</span>

<span class="sd">      # This algorithm requires bonds, these can be guessed!</span>
<span class="sd">      u = mda.Universe(......, guess_bonds=True)</span>

<span class="sd">      # MDAnalysis can split molecules into their fragments</span>
<span class="sd">      # based on bonding information.</span>
<span class="sd">      # Note that this function will only handle a single fragment</span>
<span class="sd">      # at a time, necessitating a loop.</span>
<span class="sd">      for frag in u.fragments:</span>
<span class="sd">          make_whole(frag)</span>

<span class="sd">    Alternatively, to keep a single atom in place as the anchor::</span>

<span class="sd">      # This will mean that atomgroup[10] will NOT get moved,</span>
<span class="sd">      # and all other atoms will move (if necessary).</span>
<span class="sd">      make_whole(atomgroup, reference_atom=atomgroup[10])</span>

<span class="sd">    .. Note::</span>

<span class="sd">       Only orthogonal boxes are currently supported</span>

<span class="sd">    .. versionadded:: 0.11.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;The atomgroup is required to have bonds&quot;</span><span class="p">)</span>

    <span class="c"># Not sure if this is actually a requirement...</span>
    <span class="c"># I think application of pbc would need to be changed for triclinic boxes</span>
    <span class="c"># but that&#39;s all?  How does minimum bond length criteria change?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="mf">90.0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Non orthogonal boxes are not supported&quot;</span><span class="p">)</span>
    <span class="n">box</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">box</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Supplied box had zero size&quot;</span><span class="p">)</span>

    <span class="n">box_length</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="n">bondlengths</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">bonds</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bondlengths</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1.4</span> <span class="o">&gt;</span> <span class="n">box_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Box lengths are too small relative to bond lengths&quot;</span><span class="p">)</span>

    <span class="c"># If bond lengths don&#39;t change after pbc applied, then no bonds</span>
    <span class="c"># straddle the box boundaries</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">bonds</span><span class="p">(),</span> <span class="n">bondlengths</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="c"># Can&#39;t reuse this calculation of bond lengths as we&#39;re changing</span>
    <span class="c"># stuff as we go.</span>

    <span class="k">if</span> <span class="n">reference_atom</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">reference_atom</span>
        <span class="c"># Sanity check</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">atomgroup</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Reference atom not in atomgroup&quot;</span><span class="p">)</span>

    <span class="c"># Check all of atomgroup is accessible from ref</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_contiguous</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;atomgroup not contiguous from bonds&quot;</span><span class="p">)</span>

    <span class="n">processed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c"># Who have I already done?</span>
    <span class="n">ref_points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">ref</span><span class="p">])</span>  <span class="c"># Who is safe to use as reference point?</span>

    <span class="n">nres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">)</span>  <span class="c"># total size of the problem</span>
    <span class="n">nloops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nres</span><span class="p">:</span>  <span class="c"># While all atoms aren&#39;t correct</span>
        <span class="n">nloops</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">nloops</span> <span class="o">&gt;</span> <span class="n">nres</span><span class="p">:</span>  <span class="c"># To prevent infinite loop</span>
            <span class="c"># This point probable isn&#39;t reachable with the above _is_contiguous</span>
            <span class="c"># check, but better safe than sorry.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Algorithm couldn&#39;t traverse atomgroup. &quot;</span>
                             <span class="s">&quot;Perhaps the atomgroup isn&#39;t fully connected&quot;</span><span class="p">)</span>

        <span class="c"># We want to iterate over atoms that are good to use as reference</span>
        <span class="c"># points, but haven&#39;t been processed yet.</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="n">ref_points</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                <span class="c"># Avoid atoms not in our scope</span>
                <span class="k">if</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atomgroup</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">ref_points</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">box_length</span><span class="p">:</span>
                    <span class="c"># Vector from ref atom to other</span>
                    <span class="n">vec</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">ref</span><span class="o">.</span><span class="n">position</span>
                    <span class="c"># Apply pbc to this vector</span>
                    <span class="n">vec</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">vec</span><span class="o">/</span><span class="n">box</span><span class="p">)</span> <span class="o">*</span> <span class="n">box</span>
                    <span class="c"># Define the position of other based on this vector</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">vec</span>
                <span class="c"># This atom can now be used as a reference point</span>
                <span class="n">ref_points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sébastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domański, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac Virshup,
    Zhuyi Xue, Carlos Yáñez S.,
    and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>