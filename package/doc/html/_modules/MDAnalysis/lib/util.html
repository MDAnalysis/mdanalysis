<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.lib.util &mdash; MDAnalysis 0.11.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.11.0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.11.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.lib.util</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Helper functions --- :mod:`MDAnalysis.lib.util`</span>
<span class="sd">====================================================</span>

<span class="sd">Small helper functions that don&#39;t fit anywhere else.</span>

<span class="sd">Files and directories</span>
<span class="sd">---------------------</span>

<span class="sd">.. autofunction:: filename</span>
<span class="sd">.. function:: openany(directory[,mode=&#39;r&#39;])</span>

<span class="sd">   Context manager to open a compressed (bzip2, gzip) or plain file</span>
<span class="sd">   (uses :func:`anyopen`).</span>

<span class="sd">.. autofunction:: anyopen</span>
<span class="sd">.. autofunction:: greedy_splitext</span>
<span class="sd">.. autofunction:: which</span>
<span class="sd">.. autofunction:: realpath</span>
<span class="sd">.. autofunction:: guess_format</span>

<span class="sd">Streams</span>
<span class="sd">-------</span>

<span class="sd">Many of the readers are not restricted to just reading files. They can</span>
<span class="sd">also use gzip-compressed or bzip2-compressed files (through the</span>
<span class="sd">internal use of :func:`openany`). It is also possible to provide more</span>
<span class="sd">general streams as inputs, such as a :func:`cStringIO.StringIO`</span>
<span class="sd">instances (essentially, a memory buffer) by wrapping these instances</span>
<span class="sd">into a :class:`NamedStream`. This :class:`NamedStream` can then be</span>
<span class="sd">used in place of an ordinary file name (typically, with a</span>
<span class="sd">class:`~MDAnalysis.core.AtomGroup.Universe` but it is also possible to</span>
<span class="sd">*write* to such a stream using :func:`MDAnalysis.Writer`).</span>

<span class="sd">.. rubric: Examples</span>

<span class="sd">In the following example, we use a PDB stored as a string ``pdb_s``::</span>

<span class="sd">   import MDAnalysis</span>
<span class="sd">   from MDAnalysis.lib.util import NamedStream</span>
<span class="sd">   import cStringIO</span>

<span class="sd">   pdb_s = &quot;TITLE     Lonely Ion\\nATOM      1  NA  NA+     1      81.260  64.982  10.926  1.00  0.00\\n&quot;</span>
<span class="sd">   u = MDAnalysis.Universe(NamedStream(cStringIO.StringIO(pdb_s), &quot;ion.pdb&quot;))</span>
<span class="sd">   print(u)</span>
<span class="sd">   #  &lt;Universe with 1 atoms&gt;</span>
<span class="sd">   print(u.atoms.positions)</span>
<span class="sd">   # [[ 81.26000214  64.98200226  10.92599964]]</span>

<span class="sd">It is important to provide a proper pseudo file name with the correct extension</span>
<span class="sd">(&quot;.pdb&quot;) to :class:`NamedStream` because the file type recognition uses the</span>
<span class="sd">extension of the file name to determine the file format or alternatively</span>
<span class="sd">provide the ``format=&quot;pdb&quot;`` keyword argument to the</span>
<span class="sd">:class:`~MDAnalysis.core.AtomGroup.Universe`.</span>

<span class="sd">The use of streams becomes more interesting when MDAnalysis is used as glue</span>
<span class="sd">between different analysis packages and when one can arrange things so that</span>
<span class="sd">intermediate frames (typically in the PDB format) are not written to disk but</span>
<span class="sd">remain in memory via e.g. :mod:`cStringIO` buffers.</span>


<span class="sd">.. The following does *not* work because most readers need to</span>
<span class="sd">.. reopen files, which is not possible with http streams. Might</span>
<span class="sd">.. need to implement a buffer.</span>
<span class="sd">..</span>
<span class="sd">.. Read a test LAMMPS data file from the MDAnalysis repository::</span>
<span class="sd">..</span>
<span class="sd">..   import MDAnalysis</span>
<span class="sd">..   from MDAnalysis.lib.util import NamedStream</span>
<span class="sd">..   import urllib2</span>
<span class="sd">..   URI = &quot;https://mdanalysis.googlecode.com/git-history/develop/testsuite/MDAnalysisTests/data/mini.data&quot;</span>
<span class="sd">..   urldata = NamedStream(urllib2.urlopen(URI), &quot;mini.data&quot;)</span>
<span class="sd">..   u = MDAnalysis.Universe(urldata)</span>

<span class="sd">.. Note::  A remote connection created by :func:`urllib2.urlopen` is not seekable</span>
<span class="sd">           and therefore will often not work as an input. But try it...</span>

<span class="sd">.. autoclass:: NamedStream</span>
<span class="sd">   :members:</span>

<span class="sd">.. autofunction:: isstream</span>

<span class="sd">Containers and lists</span>
<span class="sd">--------------------</span>

<span class="sd">.. autofunction:: iterable</span>
<span class="sd">.. autofunction:: asiterable</span>
<span class="sd">.. autofunction:: hasmethod</span>

<span class="sd">File parsing</span>
<span class="sd">------------</span>

<span class="sd">.. autoclass:: FORTRANReader</span>
<span class="sd">   :members:</span>
<span class="sd">.. autodata:: FORTRAN_format_regex</span>


<span class="sd">Data manipulation and handling</span>
<span class="sd">------------------------------</span>

<span class="sd">.. autofunction:: fixedwidth_bins</span>


<span class="sd">Strings</span>
<span class="sd">-------</span>

<span class="sd">.. autofunction:: convert_aa_code</span>
<span class="sd">.. autofunction:: parse_residue</span>
<span class="sd">.. autofunction:: conv_float</span>


<span class="sd">Class decorators</span>
<span class="sd">----------------</span>

<span class="sd">.. autofunction:: cached</span>

<span class="sd">.. Rubric:: Footnotes</span>

<span class="sd">.. [#NamedStreamClose] The reason why :meth:`NamedStream.close` does</span>
<span class="sd">   not close a stream by default (but just rewinds it to the</span>
<span class="sd">   beginning) is so that one can use the class :class:`NamedStream` as</span>
<span class="sd">   a drop-in replacement for file names, which are often re-opened</span>
<span class="sd">   (e.g. when the same file is used as a topology and coordinate file</span>
<span class="sd">   or when repeatedly iterating through a trajectory in some</span>
<span class="sd">   implementations). The ``close=True`` keyword can be supplied in</span>
<span class="sd">   order to make :meth:`NamedStream.close` actually close the</span>
<span class="sd">   underlying stream and ``NamedStream.close(force=True)`` will also</span>
<span class="sd">   close it.</span>


<span class="sd">.. versionchanged:: 0.11.0</span>
<span class="sd">   Moved mathematical functions into lib.mdamath</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s">&quot;restructuredtext en&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">import</span> <span class="nn">bz2</span>
<span class="kn">import</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="kn">import</span> <span class="n">StreamWarning</span>


<span class="c"># Python 3.0, 3.1 do not have the builtin callable()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="nb">callable</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="c"># http://bugs.python.org/issue10518</span>
    <span class="kn">import</span> <span class="nn">collections</span>

    <span class="k">def</span> <span class="nf">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Callable</span><span class="p">)</span>


<div class="viewcode-block" id="filename"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.filename">[docs]</a><span class="k">def</span> <span class="nf">filename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a new name that has suffix attached; replaces other extensions.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *name*</span>
<span class="sd">           filename; extension is replaced unless keep=True;</span>
<span class="sd">           *name* can also be a :class:`NamedStream` (and its</span>
<span class="sd">           :attr:`NamedStream.name` will be changed accordingly)</span>
<span class="sd">      *ext*</span>
<span class="sd">           extension</span>
<span class="sd">      *keep*</span>
<span class="sd">           - ``False``: replace existing extension with *ext*;</span>
<span class="sd">           - ``True``: keep old extension if one existed</span>

<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Also permits :class:`NamedStream` to pass through.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ext</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">extsep</span><span class="p">):</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">extsep</span> <span class="o">+</span> <span class="n">ext</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">origext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">origext</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">newname</span> <span class="o">=</span> <span class="n">root</span> <span class="o">+</span> <span class="n">ext</span>
            <span class="k">if</span> <span class="n">isstream</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="n">name</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">newname</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">newname</span>
    <span class="k">return</span> <span class="n">name</span> <span class="k">if</span> <span class="n">isstream</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

</div>
<span class="nd">@contextmanager</span>
<div class="viewcode-block" id="openany"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.openany">[docs]</a><span class="k">def</span> <span class="nf">openany</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Context manager for :func:`anyopen`.</span>

<span class="sd">    Open the *datasource* and close it when the context of the :keyword:`with`</span>
<span class="sd">    statement exits.</span>

<span class="sd">    *datasource* can be a filename or a stream (see :func:`isstream`). A stream</span>
<span class="sd">    is reset to its start if possible (via :meth:`~io.IOBase.seek` or</span>
<span class="sd">    :meth:`~cString.StringIO.reset`).</span>

<span class="sd">    The advantage of this function is that very different input sources</span>
<span class="sd">    (&quot;streams&quot;) can be used for a &quot;file&quot;, ranging from files on disk (including</span>
<span class="sd">    compressed files) to open file objects to sockets and strings---as long as</span>
<span class="sd">    they have a file-like interface.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">     *datasource*</span>
<span class="sd">        a file or a stream</span>
<span class="sd">     *mode*</span>
<span class="sd">        &#39;r&#39; or &#39;w&#39;</span>
<span class="sd">     *reset*</span>
<span class="sd">        try to read (*mode* &#39;r&#39;) the stream from the start [``True``]</span>

<span class="sd">    .. rubric:: Examples</span>

<span class="sd">    Open a gzipped file and process it line by line::</span>

<span class="sd">       with openany(&quot;input.pdb.gz&quot;) as pdb:</span>
<span class="sd">          for line in pdb:</span>
<span class="sd">              if line.startswith(&#39;ATOM&#39;): print(line)</span>

<span class="sd">    Open a URL and read it::</span>

<span class="sd">       import urllib2</span>
<span class="sd">       with openany(urllib2.urlopen(&quot;http://www.MDAnalysis.org/&quot;)) as html:</span>
<span class="sd">          print(html.read())</span>

<span class="sd">    .. SeeAlso:: :func:`anyopen`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">anyopen</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="n">reset</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">stream</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="anyopen"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.anyopen">[docs]</a><span class="k">def</span> <span class="nf">anyopen</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Open datasource (gzipped, bzipped, uncompressed) and return a stream.</span>

<span class="sd">    *datasource* can be a filename or a stream (see :func:`isstream`). By</span>
<span class="sd">    default, a stream is reset to its start if possible (via</span>
<span class="sd">    :meth:`~io.IOBase.seek` or :meth:`~cString.StringIO.reset`).</span>

<span class="sd">    If possible, the attribute ``stream.name`` is set to the filename or</span>
<span class="sd">    &quot;&lt;stream&gt;&quot; if no filename could be associated with the *datasource*.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">     *datasource*</span>
<span class="sd">        a file (from :class:`file` or :func:`open`) or a stream (e.g. from</span>
<span class="sd">        :func:`urllib2.urlopen` or :class:`cStringIO.StringIO`)</span>
<span class="sd">     *mode*</span>
<span class="sd">        &#39;r&#39; or &#39;w&#39; or &#39;a&#39;, more complicated modes (&#39;r+&#39;, &#39;w+&#39; are not supported because</span>
<span class="sd">        only the first letter is looked at) [``&#39;r&#39;``]</span>
<span class="sd">     *reset*</span>
<span class="sd">        try to read (*mode* &#39;r&#39;) the stream from the start [``True``]</span>

<span class="sd">    :Returns: tuple ``stream`` which is a file-like object</span>

<span class="sd">    .. SeeAlso:: :func:`openany` to be used with the :keyword:`with` statement.</span>

<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Only returns the ``stream`` and tries to set ``stream.name = filename`` instead of the previous</span>
<span class="sd">       behavior to return a tuple ``(stream, filename)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">handlers</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;bz2&#39;</span><span class="p">:</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">,</span> <span class="s">&#39;gz&#39;</span><span class="p">:</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">:</span> <span class="nb">file</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;r&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">isstream</span><span class="p">(</span><span class="n">datasource</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">datasource</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c"># maybe that does not always work?</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s">&quot;&lt;stream&gt;&quot;</span>
            <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">stream</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="il">0L</span><span class="p">)</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Stream {0}: not guaranteed to be at the beginning.&quot;</span>
                                      <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span>
                                      <span class="n">category</span><span class="o">=</span><span class="n">StreamWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">datasource</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;bz2&#39;</span><span class="p">,</span> <span class="s">&#39;gz&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">):</span>  <span class="c"># file == &#39;&#39; should be last</span>
                <span class="n">openfunc</span> <span class="o">=</span> <span class="n">handlers</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="n">_get_stream</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">openfunc</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stream</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">stream</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EIO</span><span class="p">,</span> <span class="s">&quot;Cannot open file or stream in mode=</span><span class="si">%(mode)r</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">(),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">):</span>  <span class="c"># append &#39;a&#39; not tested...</span>
        <span class="k">if</span> <span class="n">isstream</span><span class="p">(</span><span class="n">datasource</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">datasource</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c"># maybe that does not always work?</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s">&quot;&lt;stream&gt;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">datasource</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">):</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;bz2&#39;</span><span class="p">,</span> <span class="s">&#39;gz&#39;</span><span class="p">):</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># anything else but bz2 or gz is just a normal file</span>
            <span class="n">openfunc</span> <span class="o">=</span> <span class="n">handlers</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">openfunc</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stream</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EIO</span><span class="p">,</span> <span class="s">&quot;Cannot open file or stream in mode=</span><span class="si">%(mode)r</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">(),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Sorry, mode=</span><span class="si">%(mode)r</span><span class="s"> is not implemented for </span><span class="si">%(datasource)r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">filename</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">pass</span>  <span class="c"># can&#39;t set name (e.g. cStringIO.StringIO)</span>
    <span class="k">return</span> <span class="n">stream</span>

</div>
<span class="k">def</span> <span class="nf">_get_stream</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">openfunction</span><span class="o">=</span><span class="nb">file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return open stream if *filename* can be opened with *openfunction* or else ``None``.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">openfunction</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;r&#39;</span><span class="p">):</span>
        <span class="c"># additional check for reading (eg can we uncompress) --- is this needed?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">openfunction</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stream</span>


<div class="viewcode-block" id="greedy_splitext"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.greedy_splitext">[docs]</a><span class="k">def</span> <span class="nf">greedy_splitext</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Split extension in path *p* at the left-most separator.&quot;&quot;&quot;</span>
    <span class="n">path</span><span class="p">,</span> <span class="n">root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">extension</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">extension</span> <span class="o">=</span> <span class="n">ext</span> <span class="o">+</span> <span class="n">extension</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">,</span> <span class="n">extension</span>

</div>
<div class="viewcode-block" id="hasmethod"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.hasmethod">[docs]</a><span class="k">def</span> <span class="nf">hasmethod</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return ``True`` if object *obj* contains the method *m*.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="isstream"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.isstream">[docs]</a><span class="k">def</span> <span class="nf">isstream</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Detect if *obj* is a stream.</span>

<span class="sd">    We consider anything a stream that has the methods</span>

<span class="sd">    - ``close()``</span>

<span class="sd">    and either set of the following</span>

<span class="sd">    - ``read()``, ``readline()``, ``readlines()``</span>
<span class="sd">    - ``write()``, ``writeline()``, ``writelines()``</span>

<span class="sd">    .. SeeAlso:: :mod:`io`</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *obj*</span>
<span class="sd">          stream or string</span>

<span class="sd">    :Returns: ``True`` is *obj* is a stream, ``False`` otherwise</span>

<span class="sd">    .. versionadded:: 0.9.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature_methods</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;close&quot;</span><span class="p">,)</span>
    <span class="n">alternative_methods</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="s">&quot;read&quot;</span><span class="p">,</span> <span class="s">&quot;readline&quot;</span><span class="p">,</span> <span class="s">&quot;readlines&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">,</span> <span class="s">&quot;writeline&quot;</span><span class="p">,</span> <span class="s">&quot;writelines&quot;</span><span class="p">))</span>

    <span class="c"># Must have ALL the signature methods</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">signature_methods</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hasmethod</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="c"># Must have at least one complete set of alternative_methods</span>
    <span class="n">alternative_results</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">hasmethod</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">alternatives</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">alternatives</span> <span class="ow">in</span> <span class="n">alternative_methods</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">alternative_results</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="which"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.which">[docs]</a><span class="k">def</span> <span class="nf">which</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine full path of executable *program* on :envvar:`PATH`.</span>

<span class="sd">    (Jay at http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">is_exe</span><span class="p">(</span><span class="n">fpath</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">X_OK</span><span class="p">)</span>

    <span class="n">fpath</span><span class="p">,</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fpath</span><span class="p">:</span>
        <span class="n">real_program</span> <span class="o">=</span> <span class="n">realpath</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_exe</span><span class="p">(</span><span class="n">real_program</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">real_program</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&quot;PATH&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">pathsep</span><span class="p">):</span>
            <span class="n">exe_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">program</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_exe</span><span class="p">(</span><span class="n">exe_file</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exe_file</span>
    <span class="k">return</span> <span class="bp">None</span>

</div>
<div class="viewcode-block" id="NamedStream"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream">[docs]</a><span class="k">class</span> <span class="nc">NamedStream</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">IOBase</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stream that also provides a (fake) name.</span>

<span class="sd">    By wrapping a stream *stream* in this class, it can be passed to</span>
<span class="sd">    code that uses inspection of the filename to make decisions. For</span>
<span class="sd">    instance. :func:`os.path.split` will work correctly on a</span>
<span class="sd">    :class:`NamedStream`.</span>

<span class="sd">    The class can be used as a context manager.</span>

<span class="sd">    :class:`NamedStream` is derived from :class:`io.IOBase` (to indicate that</span>
<span class="sd">    it is a stream) *and* :class:`basestring` (that one can use</span>
<span class="sd">    :func:`iterable` in the same way as for strings).</span>

<span class="sd">    .. rubric:: Example</span>

<span class="sd">    Wrap a :func:`cStringIO.StringIO` instance to write to::</span>

<span class="sd">      import cStringIO</span>
<span class="sd">      import os.path</span>
<span class="sd">      stream = cStringIO.StringIO()</span>
<span class="sd">      f = NamedStream(stream, &quot;output.pdb&quot;)</span>
<span class="sd">      print(os.path.splitext(f))</span>

<span class="sd">    Wrap a :class:`file` instance to read from::</span>

<span class="sd">      stream = open(&quot;input.pdb&quot;)</span>
<span class="sd">      f = NamedStream(stream, stream.name)</span>

<span class="sd">    Use as a context manager (closes stream automatically when the</span>
<span class="sd">    :keyword:`with` block is left)::</span>

<span class="sd">      with NamedStream(open(&quot;input.pdb&quot;), &quot;input.pdb&quot;) as f:</span>
<span class="sd">         # use f</span>
<span class="sd">         print f.closed  # --&gt; False</span>
<span class="sd">         # ...</span>
<span class="sd">      print f.closed     # --&gt; True</span>

<span class="sd">    .. Note::</span>

<span class="sd">       This class uses its own :meth:`__getitem__` method so if *stream*</span>
<span class="sd">       implements :meth:`stream.__getitem__` then that will be masked and this</span>
<span class="sd">       class should not be used.</span>

<span class="sd">    .. Warning::</span>

<span class="sd">       By default, :meth:`NamedStream.close` will **not close the</span>
<span class="sd">       stream** but instead :meth:`~NamedStream.reset` it to the</span>
<span class="sd">       beginning. [#NamedStreamClose]_ Provide the ``force=True`` keyword</span>
<span class="sd">       to :meth:`NamedStream.close` to always close the stream.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">close</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the :class:`NamedStream` from a *stream* and give it a *name*.</span>

<span class="sd">        The constructor attempts to rewind the stream to the beginning unless</span>
<span class="sd">        the keyword *reset* is set to ``False``. If rewinding fails, a</span>
<span class="sd">        :class:`MDAnalysis.StreamWarning` is issued.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           By default, this stream will *not* be closed by :keyword:`with` and</span>
<span class="sd">           :meth:`close` (see there) unless the *close* keyword is set to</span>
<span class="sd">           ``True``.</span>

<span class="sd">        :Arguments:</span>

<span class="sd">           *stream*</span>
<span class="sd">               open stream (e.g. :class:`file` or :func:`cStringIO.StringIO`)</span>
<span class="sd">           *filename*</span>
<span class="sd">               the filename that should be associated with the stream</span>

<span class="sd">        :Keywords:</span>

<span class="sd">           *reset*</span>
<span class="sd">               start the stream from the beginning (either :meth:`reset` or :meth:`seek`)</span>
<span class="sd">               when the class instance is constructed [``True``]</span>
<span class="sd">           *close*</span>
<span class="sd">               close the stream when a :keyword:`with` block exits or when</span>
<span class="sd">               :meth:`close` is called; note that the default is **not to close</span>
<span class="sd">               the stream** [``False``]</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_stream</span> <span class="o">=</span> <span class="n">close</span>
        <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

<div class="viewcode-block" id="NamedStream.reset"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Move to the beginning of the stream&quot;&quot;&quot;</span>
        <span class="c"># try to rewind</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>  <span class="c"># e.g. StreamIO</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="il">0L</span><span class="p">)</span>  <span class="c"># typical file objects</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;NamedStream {0}: not guaranteed to be at the beginning.&quot;</span>
                              <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                              <span class="n">category</span><span class="o">=</span><span class="n">StreamWarning</span><span class="p">)</span>

    <span class="c"># access the stream</span></div>
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># do not call the stream __enter__ because the stream is already open</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c"># NOTE: By default (close=False) we only reset the stream and NOT close it; this makes</span>
        <span class="c">#       it easier to use it as a drop-in replacement for a filename that might</span>
        <span class="c">#       be opened repeatedly (at least in MDAnalysis)</span>
        <span class="c">#try:</span>
        <span class="c">#    return self.stream.__exit__(*args)</span>
        <span class="c">#except AttributeError:</span>
        <span class="c">#    super(NamedStream, self).__exit__(*args)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c"># override more IOBase methods, as these are provided by IOBase and are not</span>
    <span class="c"># caught with __getattr__ (ugly...)</span>
<div class="viewcode-block" id="NamedStream.close"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset or close the stream.</span>

<span class="sd">        If :attr:`NamedStream.close_stream` is set to ``False`` (the default)</span>
<span class="sd">        then this method will *not close the stream* and only :meth:`reset` it.</span>

<span class="sd">        If the *force* = ``True`` keyword is provided, the stream will be</span>
<span class="sd">        closed.</span>

<span class="sd">        .. Note:: This ``close()`` method is non-standard. ``del NamedStream``</span>
<span class="sd">                  always closes the underlying stream.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">close_stream</span> <span class="ow">or</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Always closes the stream.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``True`` if stream is closed.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">closed</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">closed</span>

<div class="viewcode-block" id="NamedStream.seek"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.seek">[docs]</a>    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">SEEK_SET</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the stream position to the given byte *offset* .</span>

<span class="sd">        *offset* is interpreted relative to the position indicated by</span>
<span class="sd">        *whence*. Values for *whence* are:</span>

<span class="sd">        - :data:`io.SEEK_SET` or 0  start of the stream (the default); *offset*</span>
<span class="sd">          should be zero or positive</span>
<span class="sd">        - :data:`io.SEEK_CUR` or 1  current stream position; *offset* may be</span>
<span class="sd">          negative</span>
<span class="sd">        - :data:`io.SEEK_END` or 2  end of the stream; *offset* is usually</span>
<span class="sd">          negative</span>

<span class="sd">        :Returns: the new absolute position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>  <span class="c"># file.seek: no kw</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NamedStream.tell"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.tell">[docs]</a>    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the current stream position.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="NamedStream.truncate"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.truncate">[docs]</a>    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Truncate the stream&#39;s size to *size*.</span>

<span class="sd">        The size defaults to the current position (if no *size* argument is</span>
<span class="sd">        supplied). The current file position is not changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NamedStream.seekable"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.seekable">[docs]</a>    <span class="k">def</span> <span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``True`` if the stream supports random access.</span>

<span class="sd">        If ``False``, :meth:`seek`, :meth:`tell` and :meth:`truncate` will raise :exc:`IOError`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seekable</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">seekable</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="NamedStream.readable"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.readable">[docs]</a>    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``True`` if the stream can be read from.</span>

<span class="sd">        If ``False``, :meth:`read` will raise :exc:`IOError`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">readable</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">readable</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="NamedStream.writable"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.writable">[docs]</a>    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``True`` if the stream can be written to.</span>

<span class="sd">        If ``False``, :meth:`write` will raise :exc:`IOError`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">writable</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">writable</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="NamedStream.flush"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.flush">[docs]</a>    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush the write buffers of the stream if applicable.</span>

<span class="sd">        This does nothing for read-only and non-blocking streams. For file</span>
<span class="sd">        objects one also needs to call :func:`os.fsync` to write contents to</span>
<span class="sd">        disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NamedStream</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="NamedStream.fileno"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.NamedStream.fileno">[docs]</a>    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the underlying file descriptor (an integer) of the stream if it exists.</span>

<span class="sd">        An :exc:`IOError` is raised if the IO object does not use a file descriptor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># IOBase.fileno does not raise IOError as advertised so we do this here</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;This NamedStream does not use a file descriptor.&quot;</span><span class="p">)</span>

    <span class="c"># fake the important parts of the string API</span>
    <span class="c"># (other methods such as rfind() are automatically dealt with via __getattr__)</span></div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">__neq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&gt;</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&gt;=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">format_spec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;NamedStream({0}, {1})&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="realpath"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.realpath">[docs]</a><span class="k">def</span> <span class="nf">realpath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Join all args and return the real path, rooted at /.</span>

<span class="sd">    Expands &#39;~&#39;, &#39;~user&#39;, and environment variables such as :envvar`$HOME`.</span>

<span class="sd">    Returns ``None`` if any of the args is ``None``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">None</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expandvars</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))))</span>

</div>
<span class="k">def</span> <span class="nf">get_ext</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the lower-cased extension of *filename* without a leading dot.</span>

<span class="sd">    :Returns: root, ext</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">extsep</span><span class="p">):</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">,</span> <span class="n">ext</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">check_compressed_format</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if this is a supported gzipped/bzip2ed file format and return UPPERCASE format.&quot;&quot;&quot;</span>
    <span class="c"># XYZReader&amp;others are setup to handle both plain and compressed (bzip2, gz) files</span>
    <span class="c"># ..so if the first file extension is bzip2 or gz, look at the one to the left of it</span>
    <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;bz2&quot;</span><span class="p">,</span> <span class="s">&quot;gz&quot;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">get_ext</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Cannot determine coordinate format for &#39;{0}.{1}&#39;&quot;</span>
                            <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ext</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">ext</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">format_from_filename_extension</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess file format from the file extension&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">get_ext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s">&quot;Cannot determine file format for file &#39;{0}&#39;.</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="s">&quot;           You can set the format explicitly with &quot;</span>
            <span class="s">&quot;&#39;Universe(..., format=FORMAT)&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
    <span class="n">format</span> <span class="o">=</span> <span class="n">check_compressed_format</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">format</span>


<div class="viewcode-block" id="guess_format"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.guess_format">[docs]</a><span class="k">def</span> <span class="nf">guess_format</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the format of *filename*</span>

<span class="sd">    The current heuristic simply looks at the filename extension</span>
<span class="sd">    and can work around compressed format extensions</span>

<span class="sd">    *filename* can also be a stream, in which case</span>
<span class="sd">    *filename.name* is looked at for a hint to the format</span>

<span class="sd">    :Raises:</span>
<span class="sd">       *ValueError*</span>

<span class="sd">    .. versionadded:: 0.11.0</span>
<span class="sd">       Moved into lib.util</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">isstream</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="c"># perhaps StringIO or open stream</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">format</span> <span class="o">=</span> <span class="n">format_from_filename_extension</span><span class="p">(</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># format is None so we need to complain:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;guess_format requires an explicit format specifier &quot;</span>
                             <span class="s">&quot;for stream {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># iterator, list, filename: simple extension checking... something more</span>
        <span class="c"># complicated is left for the ambitious.</span>
        <span class="c"># Note: at the moment the upper-case extension *is* the format specifier</span>
        <span class="c"># and list of filenames is handled by ChainReader</span>
        <span class="n">format</span> <span class="o">=</span> <span class="p">(</span><span class="n">format_from_filename_extension</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                  <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">else</span> <span class="s">&#39;CHAIN&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="iterable"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.iterable">[docs]</a><span class="k">def</span> <span class="nf">iterable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns ``True`` if *obj* can be iterated over and is *not* a  string.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>  <span class="c"># avoid iterating over characters of a string</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;next&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>  <span class="c"># any iterator will do</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c"># anything else that might work</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>

</div>
<div class="viewcode-block" id="asiterable"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.asiterable">[docs]</a><span class="k">def</span> <span class="nf">asiterable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns obj so that it can be iterated over; a string is *not* treated as iterable&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">obj</span>

<span class="c">#: Regular expresssion (see :mod:`re`) to parse a simple `FORTRAN edit descriptor`_.</span>
<span class="c">#: ``(?P&lt;repeat&gt;\d?)(?P&lt;format&gt;[IFELAX])(?P&lt;numfmt&gt;(?P&lt;length&gt;\d+)(\.(?P&lt;decimals&gt;\d+))?)?``</span>
<span class="c">#:</span>
<span class="c">#: .. _FORTRAN edit descriptor: http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/chap05/format.html</span></div>
<span class="n">FORTRAN_format_regex</span> <span class="o">=</span> <span class="s">&quot;(?P&lt;repeat&gt;\d+?)(?P&lt;format&gt;[IFEAX])(?P&lt;numfmt&gt;(?P&lt;length&gt;\d+)(\.(?P&lt;decimals&gt;\d+))?)?&quot;</span>
<span class="n">_FORTRAN_format_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">FORTRAN_format_regex</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert *s* to a string and return it white-space stripped.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">FixedcolumnEntry</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent an entry at specific fixed columns.</span>

<span class="sd">    Reads from line[start:stop] and converts according to</span>
<span class="sd">    typespecifier.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">convertors</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;I&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s">&#39;F&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s">&#39;E&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="n">strip</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">typespecifier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :Arguments:</span>
<span class="sd">         *start*</span>
<span class="sd">            first column</span>
<span class="sd">         *stop*</span>
<span class="sd">            last column + 1</span>
<span class="sd">         *typespecifier*</span>
<span class="sd">            &#39;I&#39;: int, &#39;F&#39;: float, &#39;E&#39;: float, &#39;A&#39;: stripped string</span>

<span class="sd">        The start/stop arguments follow standard Python convention in that</span>
<span class="sd">        they are 0-based and that the *stop* argument is not included.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typespecifier</span> <span class="o">=</span> <span class="n">typespecifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convertor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertors</span><span class="p">[</span><span class="n">typespecifier</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the entry from *line* and convert to appropriate type.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertor</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%r</span><span class="s">: Failed to read&amp;convert </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Length of the field in columns (stop - start)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;FixedcolumnEntry(</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">,</span><span class="si">%r</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typespecifier</span><span class="p">)</span>


<div class="viewcode-block" id="FORTRANReader"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.FORTRANReader">[docs]</a><span class="k">class</span> <span class="nc">FORTRANReader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;FORTRANReader provides a method to parse FORTRAN formatted lines in a file.</span>

<span class="sd">    Usage::</span>

<span class="sd">       atomformat = FORTRANReader(&#39;2I10,2X,A8,2X,A8,3F20.10,2X,A8,2X,A8,F20.10&#39;)</span>
<span class="sd">       for line in open(&#39;coordinates.crd&#39;):</span>
<span class="sd">           serial,TotRes,resName,name,x,y,z,chainID,resSeq,tempFactor = atomformat.read(line)</span>

<span class="sd">    Fortran format edit descriptors; see `Fortran Formats`_ for the syntax.</span>

<span class="sd">    Only simple one-character specifiers supported here: *I F E A X* (see</span>
<span class="sd">    :data:`FORTRAN_format_regex`).</span>

<span class="sd">    Strings are stripped of leading and trailing white space.</span>

<span class="sd">    .. _`Fortran Formats`: http://www.webcitation.org/5xbaWMV2x</span>
<span class="sd">    .. _`Fortran Formats (URL)`:</span>
<span class="sd">       http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/chap05/format.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set up the reader with the FORTRAN format string.</span>

<span class="sd">        The string *fmt* should look like &#39;2I10,2X,A8,2X,A8,3F20.10,2X,A8,2X,A8,F20.10&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
        <span class="n">descriptors</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_FORTRAN_format</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span> <span class="k">for</span> <span class="n">descriptor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">descriptors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;format&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;X&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;repeat&#39;</span><span class="p">]):</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;length&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FixedcolumnEntry</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;format&#39;</span><span class="p">]))</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;totallength&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="FORTRANReader.read"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.FORTRANReader.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse *line* according to the format string and return list of values.</span>

<span class="sd">        Values are converted to Python types according to the format specifier.</span>

<span class="sd">        :Returns: list of entries with appropriate types</span>
<span class="sd">        :Raises: :exc:`ValueError` if any of the conversions cannot be made</span>
<span class="sd">                 (e.g. space for an int)</span>

<span class="sd">        .. SeeAlso:: :meth:`FORTRANReader.number_of_matches`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="FORTRANReader.number_of_matches"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.FORTRANReader.number_of_matches">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return how many format entries could be populated with legal values.&quot;&quot;&quot;</span>
        <span class="c"># not optimal, I suppose...</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">matches</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">matches</span>
</div>
<div class="viewcode-block" id="FORTRANReader.parse_FORTRAN_format"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.FORTRANReader.parse_FORTRAN_format">[docs]</a>    <span class="k">def</span> <span class="nf">parse_FORTRAN_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edit_descriptor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the descriptor.</span>

<span class="sd">          parse_FORTRAN_format(edit_descriptor) --&gt; dict</span>

<span class="sd">        :Returns: dict with totallength (in chars), repeat, length,</span>
<span class="sd">                  format, decimals</span>
<span class="sd">        :Raises: :exc:`ValueError` if the *edit_descriptor* is not recognized</span>
<span class="sd">                 and cannot be parsed</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Specifiers: *L ES EN T TL TR / r S SP SS BN BZ* are *not*</span>
<span class="sd">           supported, and neither are the scientific notation *Ew.dEe*</span>
<span class="sd">           forms.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">_FORTRAN_format_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">edit_descriptor</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">_FORTRAN_format_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&quot;1&quot;</span> <span class="o">+</span> <span class="n">edit_descriptor</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>  <span class="c"># really no idea what the descriptor is supposed to mean</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unrecognized FORTRAN format </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">edit_descriptor</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;repeat&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s">&#39;repeat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;format&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;X&#39;</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s">&#39;length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;repeat&#39;</span><span class="p">,</span> <span class="s">&#39;length&#39;</span><span class="p">,</span> <span class="s">&#39;decimals&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c"># catches &#39;&#39;</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c"># keep None</span>
                <span class="k">pass</span>
        <span class="n">d</span><span class="p">[</span><span class="s">&#39;totallength&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;repeat&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;length&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of entries.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entries</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&quot;(&quot;</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span>

</div>
<div class="viewcode-block" id="fixedwidth_bins"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.fixedwidth_bins">[docs]</a><span class="k">def</span> <span class="nf">fixedwidth_bins</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return bins of width delta that cover xmin,xmax (or a larger range).</span>

<span class="sd">    dict = fixedwidth_bins(delta,xmin,xmax)</span>

<span class="sd">    The dict contains &#39;Nbins&#39;, &#39;delta&#39;, &#39;min&#39;, and &#39;max&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">xmin</span> <span class="o">&lt;</span> <span class="n">xmax</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Boundaries are not sane: should be xmin &lt; xmax.&#39;</span><span class="p">)</span>
    <span class="n">_delta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
    <span class="n">_xmin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
    <span class="n">_xmax</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
    <span class="n">_length</span> <span class="o">=</span> <span class="n">_xmax</span> <span class="o">-</span> <span class="n">_xmin</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">_length</span> <span class="o">/</span> <span class="n">_delta</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>  <span class="c"># number of bins</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">_delta</span> <span class="o">-</span> <span class="n">_length</span><span class="p">)</span>  <span class="c"># add half of the excess to each end</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">&#39;Nbins&#39;</span><span class="p">:</span> <span class="n">N</span><span class="p">,</span> <span class="s">&#39;delta&#39;</span><span class="p">:</span> <span class="n">_delta</span><span class="p">,</span> <span class="s">&#39;min&#39;</span><span class="p">:</span> <span class="n">_xmin</span> <span class="o">-</span> <span class="n">dx</span><span class="p">,</span> <span class="s">&#39;max&#39;</span><span class="p">:</span> <span class="n">_xmax</span> <span class="o">+</span> <span class="n">dx</span><span class="p">}</span>


<span class="c"># String functions</span>
<span class="c"># ----------------</span>

<span class="c">#: translation table for 3-letter codes --&gt; 1-letter codes</span>
<span class="c">#: .. SeeAlso:: :data:`alternative_inverse_aa_codes`</span></div>
<span class="n">canonical_inverse_aa_codes</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;ALA&#39;</span><span class="p">:</span> <span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;CYS&#39;</span><span class="p">:</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="s">&#39;ASP&#39;</span><span class="p">:</span> <span class="s">&#39;D&#39;</span><span class="p">,</span> <span class="s">&#39;GLU&#39;</span><span class="p">:</span> <span class="s">&#39;E&#39;</span><span class="p">,</span>
    <span class="s">&#39;PHE&#39;</span><span class="p">:</span> <span class="s">&#39;F&#39;</span><span class="p">,</span> <span class="s">&#39;GLY&#39;</span><span class="p">:</span> <span class="s">&#39;G&#39;</span><span class="p">,</span> <span class="s">&#39;HIS&#39;</span><span class="p">:</span> <span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;ILE&#39;</span><span class="p">:</span> <span class="s">&#39;I&#39;</span><span class="p">,</span>
    <span class="s">&#39;LYS&#39;</span><span class="p">:</span> <span class="s">&#39;K&#39;</span><span class="p">,</span> <span class="s">&#39;LEU&#39;</span><span class="p">:</span> <span class="s">&#39;L&#39;</span><span class="p">,</span> <span class="s">&#39;MET&#39;</span><span class="p">:</span> <span class="s">&#39;M&#39;</span><span class="p">,</span> <span class="s">&#39;ASN&#39;</span><span class="p">:</span> <span class="s">&#39;N&#39;</span><span class="p">,</span>
    <span class="s">&#39;PRO&#39;</span><span class="p">:</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="s">&#39;GLN&#39;</span><span class="p">:</span> <span class="s">&#39;Q&#39;</span><span class="p">,</span> <span class="s">&#39;ARG&#39;</span><span class="p">:</span> <span class="s">&#39;R&#39;</span><span class="p">,</span> <span class="s">&#39;SER&#39;</span><span class="p">:</span> <span class="s">&#39;S&#39;</span><span class="p">,</span>
    <span class="s">&#39;THR&#39;</span><span class="p">:</span> <span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="s">&#39;VAL&#39;</span><span class="p">:</span> <span class="s">&#39;V&#39;</span><span class="p">,</span> <span class="s">&#39;TRP&#39;</span><span class="p">:</span> <span class="s">&#39;W&#39;</span><span class="p">,</span> <span class="s">&#39;TYR&#39;</span><span class="p">:</span> <span class="s">&#39;Y&#39;</span><span class="p">}</span>
<span class="c">#: translation table for 1-letter codes --&gt; *canonical* 3-letter codes.</span>
<span class="c">#: The table is used for :func:`convert_aa_code`.</span>
<span class="n">amino_acid_codes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">one</span><span class="p">,</span> <span class="n">three</span><span class="p">)</span> <span class="k">for</span> <span class="n">three</span><span class="p">,</span> <span class="n">one</span> <span class="ow">in</span> <span class="n">canonical_inverse_aa_codes</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
<span class="c">#: non-default charge state amino acids or special charge state descriptions</span>
<span class="c">#: (Not fully synchronized with :class:`MDAnalysis.core.Selection.ProteinSelection`.)</span>
<span class="n">alternative_inverse_aa_codes</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;HISA&#39;</span><span class="p">:</span> <span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HISB&#39;</span><span class="p">:</span> <span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HSE&#39;</span><span class="p">:</span> <span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HSD&#39;</span><span class="p">:</span> <span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HID&#39;</span><span class="p">:</span> <span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HIE&#39;</span><span class="p">:</span> <span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HIS1&#39;</span><span class="p">:</span> <span class="s">&#39;H&#39;</span><span class="p">,</span>
    <span class="s">&#39;HIS2&#39;</span><span class="p">:</span> <span class="s">&#39;H&#39;</span><span class="p">,</span>
    <span class="s">&#39;ASPH&#39;</span><span class="p">:</span> <span class="s">&#39;D&#39;</span><span class="p">,</span> <span class="s">&#39;ASH&#39;</span><span class="p">:</span> <span class="s">&#39;D&#39;</span><span class="p">,</span>
    <span class="s">&#39;GLUH&#39;</span><span class="p">:</span> <span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="s">&#39;GLH&#39;</span><span class="p">:</span> <span class="s">&#39;E&#39;</span><span class="p">,</span>
    <span class="s">&#39;LYSH&#39;</span><span class="p">:</span> <span class="s">&#39;K&#39;</span><span class="p">,</span> <span class="s">&#39;LYN&#39;</span><span class="p">:</span> <span class="s">&#39;K&#39;</span><span class="p">,</span>
    <span class="s">&#39;ARGN&#39;</span><span class="p">:</span> <span class="s">&#39;R&#39;</span><span class="p">,</span>
    <span class="s">&#39;CYSH&#39;</span><span class="p">:</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="s">&#39;CYS1&#39;</span><span class="p">:</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="s">&#39;CYS2&#39;</span><span class="p">:</span> <span class="s">&#39;C&#39;</span><span class="p">}</span>
<span class="c">#: lookup table from 3/4 letter resnames to 1-letter codes. Note that non-standard residue names</span>
<span class="c">#: for tautomers or different protonation states such as HSE are converted to canonical 1-letter codes (&quot;H&quot;).</span>
<span class="c">#: The table is used for :func:`convert_aa_code`.</span>
<span class="c">#: .. SeeAlso:: :data:`canonical_inverse_aa_codes` and :data:`alternative_inverse_aa_codes`</span>
<span class="n">inverse_aa_codes</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">inverse_aa_codes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">canonical_inverse_aa_codes</span><span class="p">)</span>
<span class="n">inverse_aa_codes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">alternative_inverse_aa_codes</span><span class="p">)</span>


<div class="viewcode-block" id="convert_aa_code"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.convert_aa_code">[docs]</a><span class="k">def</span> <span class="nf">convert_aa_code</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts between 3-letter and 1-letter amino acid codes.</span>

<span class="sd">    .. SeeAlso:: Data are defined in :data:`amino_acid_codes` and :data:`inverse_aa_codes`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">amino_acid_codes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">inverse_aa_codes</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No conversion for {0} found (1 letter -&gt; 3 letter or 3/4 letter -&gt; 1 letter)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="c">#: Regular expression to match and parse a residue-atom selection; will match</span>
<span class="c">#: &quot;LYS300:HZ1&quot; or &quot;K300:HZ1&quot; or &quot;K300&quot; or &quot;4GB300:H6O&quot; or &quot;4GB300&quot; or &quot;YaA300&quot;.</span></div>
<span class="n">RESIDUE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">                 (?P&lt;aa&gt;([ACDEFGHIKLMNPQRSTVWY])   # 1-letter amino acid</span>
<span class="s">                        |                          #   or</span>
<span class="s">                        ([0-9A-Z][a-zA-Z][A-Z][A-Z]?)    # 3-letter or 4-letter residue name</span>
<span class="s">                 )</span>
<span class="s">                 \s*                               # white space allowed</span>
<span class="s">                 (?P&lt;resid&gt;\d+)                    # resid</span>
<span class="s">                 \s*</span>
<span class="s">                 (:                                # separator &#39;:&#39;</span>
<span class="s">                   \s*</span>
<span class="s">                   (?P&lt;atom&gt;\w+)                   # atom name</span>
<span class="s">                 )?                                # possibly one</span>
<span class="s">            &quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>


<span class="c"># from GromacsWrapper cbook.IndexBuilder</span>
<div class="viewcode-block" id="parse_residue"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.parse_residue">[docs]</a><span class="k">def</span> <span class="nf">parse_residue</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Process residue string.</span>

<span class="sd">    Examples:</span>
<span class="sd">     - &quot;LYS300:HZ1&quot; --&gt; (&quot;LYS&quot;, 300, &quot;HZ1&quot;)</span>
<span class="sd">     - &quot;K300:HZ1&quot; --&gt; (&quot;LYS&quot;, 300, &quot;HZ1&quot;)</span>
<span class="sd">     - &quot;K300&quot; --&gt; (&quot;LYS&quot;, 300, None)</span>
<span class="sd">     - &quot;4GB300:H6O&quot; --&gt; (&quot;4GB&quot;, 300, &quot;H6O&quot;)</span>
<span class="sd">     - &quot;4GB300&quot; --&gt; (&quot;4GB&quot;, 300, None)</span>

<span class="sd">    :Argument: The *residue* must contain a 1-letter or 3-letter or</span>
<span class="sd">               4-letter residue string, a number (the resid) and</span>
<span class="sd">               optionally an atom identifier, which must be separate</span>
<span class="sd">               from the residue with a colon (&quot;:&quot;). White space is</span>
<span class="sd">               allowed in between.</span>

<span class="sd">    :Returns: `(3-letter aa string, resid, atomname)`; known 1-letter</span>
<span class="sd">              aa codes are converted to 3-letter codes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># XXX: use _translate_residue() ....</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">RESIDUE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">residue</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Selection </span><span class="si">%(residue)r</span><span class="s"> is not valid (only 1/3/4 letter resnames, resid required).&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>
    <span class="n">resid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;resid&#39;</span><span class="p">))</span>
    <span class="n">residue</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;aa&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">resname</span> <span class="o">=</span> <span class="n">convert_aa_code</span><span class="p">(</span><span class="n">residue</span><span class="p">)</span>  <span class="c"># only works for AA</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">resname</span> <span class="o">=</span> <span class="n">residue</span>  <span class="c"># use 3-letter for any resname</span>
    <span class="n">atomname</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;atom&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">resname</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">atomname</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="conv_float"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.conv_float">[docs]</a><span class="k">def</span> <span class="nf">conv_float</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert an object *s* to float if possible.</span>

<span class="sd">    Function to be passed into :func:`map` or a list comprehension. If</span>
<span class="sd">    the argument can be interpreted as a float it is converted,</span>
<span class="sd">    otherwise the original object is passed back.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span>

</div>
<div class="viewcode-block" id="cached"><a class="viewcode-back" href="../../../documentation_pages/lib/util.html#MDAnalysis.lib.util.cached">[docs]</a><span class="k">def</span> <span class="nf">cached</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cache a property within a class</span>

<span class="sd">    Requires the Class to have a cache dict called ``_cache``.</span>

<span class="sd">    Usage::</span>

<span class="sd">       class A(object):</span>
<span class="sd">           def__init__(self):</span>
<span class="sd">               self._cache = dict()</span>

<span class="sd">           @property</span>
<span class="sd">           @cached(&#39;keyname&#39;)</span>
<span class="sd">           def size(self):</span>
<span class="sd">               # This code gets ran only if the lookup of keyname fails</span>
<span class="sd">               # After this code has been ran once, the result is stored in</span>
<span class="sd">               # _cache with the key: &#39;keyname&#39;</span>
<span class="sd">               size = 10.0</span>

<span class="sd">    .. versionadded:: 0.9.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">cached_lookup</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span>

        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="k">return</span> <span class="n">cached_lookup</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sbastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domaski, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac Virshup,
    Zhuyi Xue, Carlos Yez S.,
    and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>