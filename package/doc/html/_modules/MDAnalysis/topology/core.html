<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.topology.core &mdash; MDAnalysis 0.11.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.11.0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.11.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.topology.core</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Common functions for topology building --- :mod:`MDAnalysis.topology.core`</span>
<span class="sd">==========================================================================</span>

<span class="sd">The various topology parsers make use of functions and classes in this</span>
<span class="sd">module. They are mostly of use to developers.</span>

<span class="sd">.. SeeAlso:: :mod:`MDAnalysis.topology.tables` for some hard-coded atom</span>
<span class="sd">   information that is used by functions such as :func:`guess_atom_type` and</span>
<span class="sd">   :func:`guess_atom_mass`.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="c"># Global imports</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span>

<span class="c"># Local imports</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">tables</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">distances</span>
<span class="kn">from</span> <span class="nn">..lib.util</span> <span class="kn">import</span> <span class="n">cached</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..core</span> <span class="kn">import</span> <span class="n">AtomGroup</span>


<div class="viewcode-block" id="build_segments"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.build_segments">[docs]</a><span class="k">def</span> <span class="nf">build_segments</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create all :class:`~MDAnalysis.core.AtomGroup.Segment` instancess from</span>
<span class="sd">    a list of :class:`~MDAnalysis.core.AtomGroup.Atom` instances.</span>

<span class="sd">    The function also builds the :class:`~MDAnalysis.core.AtomGroup.Residue`</span>
<span class="sd">    instances by tracking residue numbers.</span>

<span class="sd">    Updating segments also changes the underlying</span>
<span class="sd">    :class:`~MDAnalysis.core.AtomGroup.Atom` instances, which record</span>
<span class="sd">    to which residue and segment an atom belongs.</span>

<span class="sd">    :Returns: List of :class:`~MDAnalysis.core.AtomGroup.Segment`</span>
<span class="sd">              instances</span>

<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now allows resids in a given :class:`Segment` to be given in non sequential order.</span>
<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Returns a list instead of a dict for consistency with the outputs of</span>
<span class="sd">       :func:`build_residues`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">struc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">resatomlist</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">curr_segname</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">segid</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">segid</span> <span class="o">==</span> <span class="n">curr_segname</span><span class="p">:</span>  <span class="c"># if still in same Segment</span>
            <span class="n">resatomlist</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">resid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># We&#39;ve come to a new segment</span>
            <span class="c"># Build the Segment we just left</span>
            <span class="n">residues</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="o">.</span><span class="n">Residue</span><span class="p">(</span><span class="n">ats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ats</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ats</span> <span class="ow">in</span> <span class="n">resatomlist</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>
            <span class="n">struc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AtomGroup</span><span class="o">.</span><span class="n">Segment</span><span class="p">(</span><span class="n">curr_segname</span><span class="p">,</span> <span class="n">residues</span><span class="p">))</span>

            <span class="c"># Reset things and start again</span>
            <span class="n">resatomlist</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="n">resatomlist</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">resid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">curr_segname</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">segid</span>

    <span class="c"># Add the last segment</span>
    <span class="n">residues</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="o">.</span><span class="n">Residue</span><span class="p">(</span><span class="n">ats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ats</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ats</span> <span class="ow">in</span> <span class="n">resatomlist</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>
    <span class="n">struc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AtomGroup</span><span class="o">.</span><span class="n">Segment</span><span class="p">(</span><span class="n">curr_segname</span><span class="p">,</span> <span class="n">residues</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">struc</span>

</div>
<div class="viewcode-block" id="build_residues"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.build_residues">[docs]</a><span class="k">def</span> <span class="nf">build_residues</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a list :class:`~MDAnalysis.core.AtomGroup.Residue` instances from</span>
<span class="sd">    a list of :class:`~MDAnalysis.core.AtomGroup.Atom` instances.</span>

<span class="sd">    Updating residues also changes the underlying</span>
<span class="sd">    :class:`~MDAnalysis.core.AtomGroup.Atom` instances, which record</span>
<span class="sd">    to which residue an atom belongs.</span>

<span class="sd">    :Returns: List of :class:`~MDAnalysis.core.AtomGroup.Residue` instances</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now allows resids to be given in non sequential order</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">resatomlist</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="n">resatomlist</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">resid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">residues</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="o">.</span><span class="n">Residue</span><span class="p">(</span><span class="n">ats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ats</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ats</span> <span class="ow">in</span> <span class="n">resatomlist</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>

    <span class="k">return</span> <span class="n">residues</span>

</div>
<div class="viewcode-block" id="get_parser_for"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.get_parser_for">[docs]</a><span class="k">def</span> <span class="nf">get_parser_for</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">permissive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the appropriate topology parser for *filename*.</span>

<span class="sd">    Automatic detection is disabled when an explicit *format* is</span>
<span class="sd">    provided.</span>

<span class="sd">    :Raises:</span>
<span class="sd">      *ValueError*</span>
<span class="sd">        If no appropriate parser could be found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_topology_parsers</span>

    <span class="k">if</span> <span class="n">format</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">format</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">guess_format</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">format</span> <span class="o">=</span> <span class="n">format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;PDB&#39;</span> <span class="ow">and</span> <span class="n">permissive</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_topology_parsers</span><span class="p">[</span><span class="s">&#39;Permissive_PDB&#39;</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_topology_parsers</span><span class="p">[</span><span class="n">format</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s">&quot;Cannot autodetect topology type for file &#39;{0}&#39; &quot;</span>
            <span class="s">&quot;(file extension could not be parsed).</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="s">&quot;           You can use &#39;Universe(topology, ..., topology_format=FORMAT)&#39; &quot;</span>
            <span class="s">&quot;to explicitly specify the format and</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="s">&quot;           override automatic detection. Known FORMATs are:</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="s">&quot;           {1}</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="s">&quot;           See http://docs.mdanalysis.org/documentation_pages/topology/init.html#supported-topology-formats</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="s">&quot;           For missing formats, raise an issue at &quot;</span>
            <span class="s">&quot;http://issues.mdanalysis.org&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">_topology_parsers</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>


<span class="c"># following guess_* used by PDB parser</span></div>
<div class="viewcode-block" id="guess_atom_type"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_atom_type">[docs]</a><span class="k">def</span> <span class="nf">guess_atom_type</span><span class="p">(</span><span class="n">atomname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess atom type from the name.</span>

<span class="sd">    At the moment, this function simply returns the element, as</span>
<span class="sd">    guessed by :func:`guess_atom_element`.</span>

<span class="sd">    .. SeeAlso:: :func:`guess_atom_element` and</span>
<span class="sd">                 :mod:`MDAnalysis.topology.tables`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">guess_atom_element</span><span class="p">(</span><span class="n">atomname</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="guess_atom_element"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_atom_element">[docs]</a><span class="k">def</span> <span class="nf">guess_atom_element</span><span class="p">(</span><span class="n">atomname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess the element of the atom from the name.</span>

<span class="sd">    Looks in dict to see if element is found, otherwise it uses the first</span>
<span class="sd">    character in the atomname. The table comes from CHARMM and AMBER atom</span>
<span class="sd">    types, where the first character is not sufficient to determine the atom</span>
<span class="sd">    type. Some GROMOS ions have also been added.</span>

<span class="sd">    .. Warning: The translation table is incomplete. This will probably result</span>
<span class="sd">                in some mistakes, but it still better than nothing!</span>

<span class="sd">    .. SeeAlso:: :func:`guess_atom_type` and</span>
<span class="sd">                 :mod:`MDAnalysis.topology.tables` (where the data are stored)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">atomelements</span><span class="p">[</span><span class="n">atomname</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">atomname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="c"># catch 1HH etc</span>
            <span class="k">return</span> <span class="n">atomname</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">atomname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="guess_bonds"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_bonds">[docs]</a><span class="k">def</span> <span class="nf">guess_bonds</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess if bonds exist between two atoms based on their distance.</span>

<span class="sd">    Bond between two atoms is created, if the two atoms are within</span>

<span class="sd">    .. math::</span>

<span class="sd">          d &lt; f * (R_1 + R_2)</span>

<span class="sd">    of each other, where :math:`R_1` and :math:`R_2` are the VdW radii</span>
<span class="sd">    of the atoms and :math:`f` is an ad-hoc *fudge_factor*. This is</span>
<span class="sd">    the `same algorithm that VMD uses`_.</span>

<span class="sd">    :Keywords:</span>

<span class="sd">      *fudge_factor*</span>
<span class="sd">        The factor by which atoms must overlap eachother to be considered a</span>
<span class="sd">        bond.  Larger values will increase the number of bonds found. [0.72]</span>

<span class="sd">      *vdwradii*</span>
<span class="sd">        To supply custom vdwradii for atoms in the algorithm. Must be a dict</span>
<span class="sd">        of format {type:radii}. The default table of van der Waals radii is</span>
<span class="sd">        hard-coded as :data:`MDAnalysis.topology.tables.vdwradii`.  Any user</span>
<span class="sd">        defined vdwradii passed as an argument will supercede the table</span>
<span class="sd">        values. [``None``]</span>

<span class="sd">      *lower_bound*</span>
<span class="sd">        The minimum bond length. All bonds found shorter than this length will</span>
<span class="sd">        be ignored. This is useful for parsing PDB with altloc records where</span>
<span class="sd">        atoms with altloc A and B maybe very close together and there should be</span>
<span class="sd">        no chemical bond between them. [0.1]</span>

<span class="sd">      *box*</span>
<span class="sd">        Bonds are found using a distance search, if unit cell information is</span>
<span class="sd">        given, periodic boundary conditions will be considered in the distance</span>
<span class="sd">        search. [``None``]</span>

<span class="sd">    :Returns:</span>
<span class="sd">       List of tuples suitable for use in Universe topology building.</span>

<span class="sd">    .. warning::</span>
<span class="sd">       No check is done after the bonds are guessed to see if Lewis</span>
<span class="sd">       structure is correct. This is wrong and will burn somebody.</span>

<span class="sd">    :Raises:</span>
<span class="sd">       ValueError if inputs are malformed or *vdwradii* data is missing.</span>

<span class="sd">    .. _`same algorithm that VMD uses`:</span>
<span class="sd">       http://www.ks.uiuc.edu/Research/vmd/vmd-1.9.1/ug/node26.html</span>

<span class="sd">    .. versionadded:: 0.7.7</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Updated method internally to use more :mod:`numpy`, should work</span>
<span class="sd">       faster.  Should also use less memory, previously scaled as</span>
<span class="sd">       :math:`O(n^2)`.  *vdwradii* argument now augments table list</span>
<span class="sd">       rather than replacing entirely.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># why not just use atom.positions?</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;&#39;atoms&#39; and &#39;coord&#39; must be the same length&quot;</span><span class="p">)</span>

    <span class="n">fudge_factor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;fudge_factor&#39;</span><span class="p">,</span> <span class="mf">0.72</span><span class="p">)</span>

    <span class="n">vdwradii</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">vdwradii</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c"># so I don&#39;t permanently change it</span>
    <span class="n">user_vdwradii</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;vdwradii&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user_vdwradii</span><span class="p">:</span>  <span class="c"># this should make algo use their values over defaults</span>
        <span class="n">vdwradii</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">user_vdwradii</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">atomtypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">types</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c"># sometimes atoms is just list of atoms not AG</span>
        <span class="n">atomtypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">])</span>
    <span class="c"># check that all types have a defined vdw</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">val</span> <span class="ow">in</span> <span class="n">vdwradii</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">atomtypes</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&quot;vdw radii for types: &quot;</span> <span class="o">+</span>
                          <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">atomtypes</span> <span class="k">if</span>
                                     <span class="ow">not</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">vdwradii</span><span class="p">])</span> <span class="o">+</span>
                          <span class="s">&quot;. These can be defined manually using the&quot;</span> <span class="o">+</span>
                          <span class="s">&quot; keyword &#39;vdwradii&#39;&quot;</span><span class="p">))</span>

    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;lower_bound&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>

    <span class="n">box</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;box&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="c"># to speed up checking, calculate what the largest possible bond</span>
    <span class="c"># atom that would warrant attention.</span>
    <span class="c"># then use this to quickly mask distance results later</span>
    <span class="n">max_vdw</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">vdwradii</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">atomtypes</span><span class="p">])</span>

    <span class="n">bonds</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">vdw_i</span> <span class="o">=</span> <span class="n">vdwradii</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
        <span class="n">max_d</span> <span class="o">=</span> <span class="p">(</span><span class="n">vdw_i</span> <span class="o">+</span> <span class="n">max_vdw</span><span class="p">)</span> <span class="o">*</span> <span class="n">fudge_factor</span>

        <span class="c"># using self_distance_array scales O(n^2)</span>
        <span class="c"># 20,000 atoms = 1.6 Gb memory</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">distance_array</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:],</span>
                                        <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">lower_bound</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">max_d</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
            <span class="n">atom_j</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">vdw_i</span> <span class="o">+</span> <span class="n">vdwradii</span><span class="p">[</span><span class="n">atom_j</span><span class="o">.</span><span class="n">type</span><span class="p">])</span> <span class="o">*</span> <span class="n">fudge_factor</span><span class="p">:</span>
                <span class="c"># because of method used, same bond won&#39;t be seen twice,</span>
                <span class="c"># so don&#39;t need to worry about duplicates</span>
                <span class="n">bonds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">atom_j</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="guess_angles"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_angles">[docs]</a><span class="k">def</span> <span class="nf">guess_angles</span><span class="p">(</span><span class="n">bonds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a list of Bonds, find all angles that exist between atoms.</span>

<span class="sd">    Works by assuming that if atoms 1 &amp; 2 are bonded, and 2 &amp; 3 are bonded,</span>
<span class="sd">    then (1,2,3) must be an angle.</span>

<span class="sd">    :Returns:</span>
<span class="sd">      List of tuples defining the angles.</span>
<span class="sd">      Suitable for use in u._topology</span>

<span class="sd">    .. seeAlso:: :meth:`guess_bonds`</span>

<span class="sd">    .. versionadded 0.9.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angles_found</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">other_a</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>  <span class="c"># who&#39;s my friend currently in Bond</span>
            <span class="k">for</span> <span class="n">other_b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other_b</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>  <span class="c"># if not the same bond I start as</span>
                    <span class="n">third_a</span> <span class="o">=</span> <span class="n">other_b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                    <span class="n">desc</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">other_a</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">third_a</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">desc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c"># first index always less than last</span>
                        <span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">angles_found</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">angles_found</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="guess_dihedrals"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_dihedrals">[docs]</a><span class="k">def</span> <span class="nf">guess_dihedrals</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a list of Angles, find all dihedrals that exist between atoms.</span>

<span class="sd">    Works by assuming that if (1,2,3) is an angle, and 3 &amp; 4 are bonded,</span>
<span class="sd">    then (1,2,3,4) must be a dihedral.</span>

<span class="sd">    :Returns:</span>
<span class="sd">      List of tuples defining the dihedrals.</span>
<span class="sd">      Suitable for use in u._topology</span>

<span class="sd">    .. versionadded 0.9.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dihedrals_found</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
        <span class="n">a_tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>  <span class="c"># angle as tuple of numbers</span>
        <span class="c"># if searching with b[0], want tuple of (b[2], b[1], b[0], +new)</span>
        <span class="c"># search the first and last atom of each angle</span>
        <span class="k">for</span> <span class="n">atom</span><span class="p">,</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                                <span class="p">[</span><span class="n">a_tup</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">a_tup</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">other_b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">other_b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">third_a</span> <span class="o">=</span> <span class="n">other_b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                    <span class="n">desc</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="p">(</span><span class="n">third_a</span><span class="o">.</span><span class="n">index</span><span class="p">,)</span>
                    <span class="k">if</span> <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">desc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">dihedrals_found</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dihedrals_found</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="guess_improper_dihedrals"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_improper_dihedrals">[docs]</a><span class="k">def</span> <span class="nf">guess_improper_dihedrals</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a list of Angles, find all improper dihedrals that exist between</span>
<span class="sd">    atoms.</span>

<span class="sd">    Works by assuming that if (1,2,3) is an angle, and 2 &amp; 4 are bonded,</span>
<span class="sd">    then (2, 1, 3, 4) must be an improper dihedral.</span>
<span class="sd">    ie the improper dihedral is the angle between the planes formed by</span>
<span class="sd">    (1, 2, 3) and (1, 3, 4)</span>

<span class="sd">    :Returns:</span>
<span class="sd">      List of tuples defining the improper dihedrals.</span>
<span class="sd">      Suitable for use in u._topology</span>

<span class="sd">    .. versionadded 0.9.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dihedrals_found</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># select middle atom in angle</span>
        <span class="c"># start of improper tuple</span>
        <span class="n">a_tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="c"># if searching with b[1], want tuple of (b[1], b[2], b[0], +new)</span>
        <span class="c"># search the first and last atom of each angle</span>
        <span class="k">for</span> <span class="n">other_b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">other_atom</span> <span class="o">=</span> <span class="n">other_b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="c"># if this atom isn&#39;t in the angle I started with</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">other_atom</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">desc</span> <span class="o">=</span> <span class="n">a_tup</span> <span class="o">+</span> <span class="p">(</span><span class="n">other_atom</span><span class="o">.</span><span class="n">index</span><span class="p">,)</span>
                <span class="k">if</span> <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">desc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">dihedrals_found</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dihedrals_found</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="get_atom_mass"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.get_atom_mass">[docs]</a><span class="k">def</span> <span class="nf">get_atom_mass</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the atomic mass in u for *element*.</span>

<span class="sd">    Masses are looked up in :data:`MDAnalysis.topology.tables.masses`.</span>

<span class="sd">    .. Warning:: Unknown masses are set to 0.00</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">element</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.000</span>

</div>
<div class="viewcode-block" id="guess_atom_mass"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_atom_mass">[docs]</a><span class="k">def</span> <span class="nf">guess_atom_mass</span><span class="p">(</span><span class="n">atomname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess a mass based on the atom name.</span>

<span class="sd">    :func:`guess_atom_element` is used to determine the kind of atom.</span>

<span class="sd">    .. warning:: Anything not recognized is simply set to 0; if you rely on the</span>
<span class="sd">                 masses you might want to double check.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">get_atom_mass</span><span class="p">(</span><span class="n">guess_atom_element</span><span class="p">(</span><span class="n">atomname</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="guess_atom_charge"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_atom_charge">[docs]</a><span class="k">def</span> <span class="nf">guess_atom_charge</span><span class="p">(</span><span class="n">atomname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess atom charge from the name.</span>

<span class="sd">    .. Warning:: Not implemented; simply returns 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO: do something slightly smarter, at least use name/element</span>
    <span class="k">return</span> <span class="mf">0.0</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sébastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domański, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac Virshup,
    Zhuyi Xue, Carlos Yáñez S.,
    and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>