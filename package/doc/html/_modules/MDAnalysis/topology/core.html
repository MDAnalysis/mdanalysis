<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.topology.core &mdash; MDAnalysis 0.9.2 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.9.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.9.2 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.9.2 documentation" href="../../../index.html" />
    <link rel="up" title="MDAnalysis" href="../../MDAnalysis.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.9.2 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../../MDAnalysis.html" accesskey="U">MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.topology.core</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Common functions for topology building --- :mod:`MDAnalysis.topology.core`</span>
<span class="sd">==========================================================================</span>

<span class="sd">The various topology parsers make use of functions and classes in this</span>
<span class="sd">module. They are mostly of use to developers.</span>

<span class="sd">.. SeeAlso:: :mod:`MDAnalysis.topology.tables` for some hard-coded atom</span>
<span class="sd">   information that is used by functions such as :func:`guess_atom_type` and</span>
<span class="sd">   :func:`guess_atom_mass`.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="c"># Global imports</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span>

<span class="c"># Local imports</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">tables</span>
<span class="kn">from</span> <span class="nn">..core</span> <span class="kn">import</span> <span class="n">distances</span>
<span class="kn">from</span> <span class="nn">..core.util</span> <span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">dihedral</span><span class="p">,</span> <span class="n">cached</span>
<span class="kn">from</span> <span class="nn">..core.util</span> <span class="kn">import</span> <span class="n">angle</span> <span class="k">as</span> <span class="n">slowang</span>
<span class="kn">from</span> <span class="nn">..core</span> <span class="kn">import</span> <span class="n">AtomGroup</span>


<div class="viewcode-block" id="build_segments"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.build_segments">[docs]</a><span class="k">def</span> <span class="nf">build_segments</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create all :class:`~MDAnalysis.core.AtomGroup.Segment` instancess from</span>
<span class="sd">    a list of :class:`~MDAnalysis.core.AtomGroup.Atom` instances.</span>

<span class="sd">    The function also builds the :class:`~MDAnalysis.core.AtomGroup.Residue`</span>
<span class="sd">    instances by tracking residue numbers.</span>

<span class="sd">    Updating segments also changes the underlying</span>
<span class="sd">    :class:`~MDAnalysis.core.AtomGroup.Atom` instances, which record</span>
<span class="sd">    to which residue and segment an atom belongs.</span>

<span class="sd">    :Returns: structure dict, which associates a segname with a</span>
<span class="sd">              :class:`~MDAnalysis.core.AtomGroup.Segment`</span>

<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now allows resids in a given :class:`Segment` to be given in non sequential order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">struc</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">resatomlist</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">curr_segname</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">segid</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">segid</span> <span class="o">==</span> <span class="n">curr_segname</span><span class="p">:</span>  <span class="c"># if still in same Segment</span>
            <span class="n">resatomlist</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">resid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># We&#39;ve come to a new segment</span>
            <span class="c"># Build the Segment we just left</span>
            <span class="n">residues</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="o">.</span><span class="n">Residue</span><span class="p">(</span><span class="n">ats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ats</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ats</span> <span class="ow">in</span> <span class="n">resatomlist</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>
            <span class="n">struc</span><span class="p">[</span><span class="n">curr_segname</span><span class="p">]</span> <span class="o">=</span> <span class="n">AtomGroup</span><span class="o">.</span><span class="n">Segment</span><span class="p">(</span><span class="n">curr_segname</span><span class="p">,</span> <span class="n">residues</span><span class="p">)</span>

            <span class="c"># Reset things and start again</span>
            <span class="n">resatomlist</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="n">resatomlist</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">resid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">curr_segname</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">segid</span>

    <span class="c"># Add the last segment</span>
    <span class="n">residues</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="o">.</span><span class="n">Residue</span><span class="p">(</span><span class="n">ats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ats</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ats</span> <span class="ow">in</span> <span class="n">resatomlist</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>
    <span class="n">struc</span><span class="p">[</span><span class="n">curr_segname</span><span class="p">]</span> <span class="o">=</span> <span class="n">AtomGroup</span><span class="o">.</span><span class="n">Segment</span><span class="p">(</span><span class="n">curr_segname</span><span class="p">,</span> <span class="n">residues</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">struc</span>

</div>
<div class="viewcode-block" id="build_residues"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.build_residues">[docs]</a><span class="k">def</span> <span class="nf">build_residues</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a list :class:`~MDAnalysis.core.AtomGroup.Residue` instances from</span>
<span class="sd">    a list of :class:`~MDAnalysis.core.AtomGroup.Atom` instances.</span>

<span class="sd">    Updating residues also changes the underlying</span>
<span class="sd">    :class:`~MDAnalysis.core.AtomGroup.Atom` instances, which record</span>
<span class="sd">    to which residue an atom belongs.</span>

<span class="sd">    :Returns: List of :class:`~MDAnalysis.core.AtomGroup.Residue` instances</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now allows resids to be given in non sequential order</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">resatomlist</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="n">resatomlist</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">resid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">residues</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="o">.</span><span class="n">Residue</span><span class="p">(</span><span class="n">ats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ats</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ats</span> <span class="ow">in</span> <span class="n">resatomlist</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>

    <span class="k">return</span> <span class="n">residues</span>

</div>
<div class="viewcode-block" id="TopologyObject"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.TopologyObject">[docs]</a><span class="k">class</span> <span class="nc">TopologyObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for all Topology items.</span>

<span class="sd">    Defines the behaviour by which Bonds/Angles/etc in MDAnalysis should</span>
<span class="sd">    behave.</span>

<span class="sd">    .. versionadded 0.9.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;atoms&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Type of the bond as a tuple</span>

<span class="sd">        When comparing types, it is important to consider the reverse</span>
<span class="sd">        of the type too, ie::</span>
<span class="sd">            a.type == b.type or a.type == b.type[::-1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;{cname} between: {conts}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">cname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
            <span class="n">conts</span> <span class="o">=</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
                <span class="s">&quot;Atom {} ({} of {}-{})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">number</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether an atom is in this :class:`TopologyObject`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether two bonds have identical contents&quot;&quot;&quot;</span>
        <span class="n">my_tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">number</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>
        <span class="n">ot_tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">number</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">my_tup</span> <span class="o">==</span> <span class="n">ot_tup</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">my_tup</span> <span class="o">==</span> <span class="n">ot_tup</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>  <span class="c"># so bondlists can be sorted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span>

    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Can retrieve a given Atom from within&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Bond"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.Bond">[docs]</a><span class="k">class</span> <span class="nc">Bond</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A bond between two :class:`~MDAnalysis.core.AtomGroup.Atom` instances.</span>

<span class="sd">    Two :class:`Bond` instances can be compared with the ``==`` and</span>
<span class="sd">    ``!=`` operators. A bond is equal to another if the same atom</span>
<span class="sd">    numbers are connected and they have the same bond order. The</span>
<span class="sd">    ordering of the two atom numbers is ignored as is the fact that a</span>
<span class="sd">    bond was guessed.</span>

<span class="sd">    The presence of a particular atom can also be queried::</span>
<span class="sd">       &gt;&gt;&gt; Atom in Bond</span>
<span class="sd">    will return either ``True`` or ``False``.</span>

<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now a subclass of :class:`TopologyObject`. Changed class to use</span>
<span class="sd">       :attr:`__slots__` and stores atoms in :attr:`atoms` attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;atoms&quot;</span><span class="p">,</span> <span class="s">&quot;order&quot;</span><span class="p">,</span> <span class="s">&quot;_is_guessed&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_guessed</span> <span class="o">=</span> <span class="bp">False</span>

<div class="viewcode-block" id="Bond.partner"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.Bond.partner">[docs]</a>    <span class="k">def</span> <span class="nf">partner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bond.partner(Atom)</span>

<span class="sd">        :Returns: the other :class:`~MDAnalysis.core.AtomGroup.Atom` in this</span>
<span class="sd">                  bond</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">atom</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unrecognised Atom&quot;</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_guessed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``True`` if the bond was guessed.</span>

<span class="sd">        .. SeeAlso:: :func:`guess_bonds`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_guessed</span>

    <span class="nd">@is_guessed.setter</span>
    <span class="k">def</span> <span class="nf">is_guessed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_guessed</span> <span class="o">=</span> <span class="n">b</span>

<div class="viewcode-block" id="Bond.length"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.Bond.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Length of the bond.&quot;&quot;&quot;</span>
        <span class="n">bond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">bond2</span> <span class="o">=</span> <span class="n">bond</span> <span class="o">*</span> <span class="n">bond</span>
        <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">bond2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">bond2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bond2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">s_id</span> <span class="o">=</span> <span class="s">&quot;&lt;Bond between: Atom {0:d} ({1.name} of {1.resname} {1.resid}&quot;</span>\
               <span class="s">&quot; {1.altLoc}) and Atom {2:d} ({3.name} of {3.resname}&quot;</span>\
               <span class="s">&quot;{3.resid} {3.altLoc})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">a1</span><span class="o">.</span><span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">s_length</span> <span class="o">=</span> <span class="s">&quot;, length {0:.2f} A&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">s_length</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>  <span class="c"># no trajectory/coordinates available</span>
        <span class="k">return</span> <span class="n">s_id</span> <span class="o">+</span> <span class="n">s_length</span> <span class="o">+</span> <span class="s">&quot;&gt;&quot;</span>

</div>
<div class="viewcode-block" id="Angle"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.Angle">[docs]</a><span class="k">class</span> <span class="nc">Angle</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An angle between three :class:`~MDAnalysis.core.AtomGroup.Atom` instances.</span>
<span class="sd">    Atom 2 is the apex of the angle</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now a subclass of :class:`TopologyObject`; now uses</span>
<span class="sd">       :attr:`__slots__` and stores atoms in :attr:`atoms` attribute</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Angle.angle"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.Angle.angle">[docs]</a>    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the angle in degrees of this Angle.</span>

<span class="sd">        Angle between atoms 0 and 2 with apex at 1::</span>

<span class="sd">              2</span>
<span class="sd">             /</span>
<span class="sd">            /</span>
<span class="sd">           1------0</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span>

</div></div>
<div class="viewcode-block" id="Torsion"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.Torsion">[docs]</a><span class="k">class</span> <span class="nc">Torsion</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Torsion (dihedral angle) between four</span>
<span class="sd">    :class:`~MDAnalysis.core.AtomGroup.Atom` instances.</span>

<span class="sd">    The torsion is defined as the angle between the planes formed by</span>
<span class="sd">    Atoms (1, 2, 3) and (2, 3, 4).</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now a subclass of :class:`TopologyObject`; now uses :attr:`__slots__` and</span>
<span class="sd">       stores atoms in :attr:`atoms` attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># http://cbio.bmt.tue.nl/pumma/uploads/Theory/dihedral.png</span>
<div class="viewcode-block" id="Torsion.torsion"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.Torsion.torsion">[docs]</a>    <span class="k">def</span> <span class="nf">torsion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the dihedral angle in degrees.</span>

<span class="sd">        Dihedral angle around axis connecting atoms 1 and 2 (i.e. the angle</span>
<span class="sd">        between the planes spanned by atoms (0,1,2) and (1,2,3))::</span>

<span class="sd">                  3</span>
<span class="sd">                  |</span>
<span class="sd">            1-----2</span>
<span class="sd">           /</span>
<span class="sd">          0</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">B</span><span class="o">.</span><span class="n">position</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">C</span><span class="o">.</span><span class="n">position</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">D</span><span class="o">.</span><span class="n">position</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dihedral</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">))</span>

</div></div>
<div class="viewcode-block" id="Improper_Torsion"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.Improper_Torsion">[docs]</a><span class="k">class</span> <span class="nc">Improper_Torsion</span><span class="p">(</span><span class="n">Torsion</span><span class="p">):</span>  <span class="c"># subclass Torsion to inherit torsion method</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Improper Torsion (improper dihedral angle) between four</span>
<span class="sd">    :class:`~MDAnalysis.core.AtomGroup.Atom` instances.</span>

<span class="sd">    MDAnalysis treats the improper torsion angle as the angle between</span>
<span class="sd">    the planes formed by Atoms (1, 2, 3) and (2, 3, 4).</span>

<span class="sd">    .. warning:: Definitions of Atom ordering in improper torsions</span>
<span class="sd">                 can change. Check the definitions here against</span>
<span class="sd">                 your software.</span>

<span class="sd">    .. versionadded 0.9.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># http://cbio.bmt.tue.nl/pumma/uploads/Theory/improper.png</span>
<div class="viewcode-block" id="Improper_Torsion.improper"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.Improper_Torsion.improper">[docs]</a>    <span class="k">def</span> <span class="nf">improper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Improper dihedral angle in degrees&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">torsion</span><span class="p">()</span>

</div></div>
<div class="viewcode-block" id="get_parser_for"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.get_parser_for">[docs]</a><span class="k">def</span> <span class="nf">get_parser_for</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">permissive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">tformat</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the appropriate topology parser for *filename*.</span>

<span class="sd">    Automatic detection is disabled when an explicit *format* is</span>
<span class="sd">    provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_topology_parsers</span>

    <span class="n">tformat</span> <span class="o">=</span> <span class="n">guess_format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="n">tformat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tformat</span> <span class="o">==</span> <span class="s">&#39;PDB&#39;</span> <span class="ow">and</span> <span class="n">permissive</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_topology_parsers</span><span class="p">[</span><span class="s">&#39;Permissive_PDB&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_topology_parsers</span><span class="p">[</span><span class="n">tformat</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="guess_format"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_format">[docs]</a><span class="k">def</span> <span class="nf">guess_format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the type of topology file *filename*.</span>

<span class="sd">    The current heuristic simply looks at the filename extension but</span>
<span class="sd">    more complicated probes could be implemented here or in the</span>
<span class="sd">    individual packages (e.g. as static methods).</span>

<span class="sd">    If *format* is supplied then it overrides the auto detection.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_topology_parsers</span>

    <span class="k">if</span> <span class="n">format</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># simple extension checking... something more complicated is left</span>
        <span class="c"># for the ambitious</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">):</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">format</span> <span class="o">=</span> <span class="n">ext</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Cannot determine topology type for </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># internally, formats are all uppercase</span>
        <span class="n">format</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">format</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

    <span class="c"># sanity check</span>
    <span class="k">if</span> <span class="n">format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_topology_parsers</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unknown topology format </span><span class="si">%r</span><span class="s"> for </span><span class="si">%r</span><span class="s">; &quot;</span>
                        <span class="s">&quot;only </span><span class="si">%r</span><span class="s"> are implemented in MDAnalysis.&quot;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">_topology_parsers</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">format</span>


<span class="c"># following guess_* used by PDB parser</span></div>
<div class="viewcode-block" id="guess_atom_type"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_atom_type">[docs]</a><span class="k">def</span> <span class="nf">guess_atom_type</span><span class="p">(</span><span class="n">atomname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess atom type from the name.</span>

<span class="sd">    At the moment, this function simply returns the element, as</span>
<span class="sd">    guessed by :func:`guess_atom_element`.</span>

<span class="sd">    .. SeeAlso:: :func:`guess_atom_element` and</span>
<span class="sd">                 :mod:`MDAnalysis.topology.tables`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">guess_atom_element</span><span class="p">(</span><span class="n">atomname</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="guess_atom_element"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_atom_element">[docs]</a><span class="k">def</span> <span class="nf">guess_atom_element</span><span class="p">(</span><span class="n">atomname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess the element of the atom from the name.</span>

<span class="sd">    Looks in dict to see if element is found, otherwise it uses the first</span>
<span class="sd">    character in the atomname. The table comes from CHARMM and AMBER atom</span>
<span class="sd">    types, where the first character is not sufficient to determine the atom</span>
<span class="sd">    type. Some GROMOS ions have also been added.</span>

<span class="sd">    .. Warning: The translation table is incomplete. This will probably result</span>
<span class="sd">                in some mistakes, but it still better than nothing!</span>

<span class="sd">    .. SeeAlso:: :func:`guess_atom_type` and</span>
<span class="sd">                 :mod:`MDAnalysis.topology.tables` (where the data are stored)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">atomelements</span><span class="p">[</span><span class="n">atomname</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">atomname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="c"># catch 1HH etc</span>
            <span class="k">return</span> <span class="n">atomname</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">atomname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="guess_bonds"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_bonds">[docs]</a><span class="k">def</span> <span class="nf">guess_bonds</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess if bonds exist between two atoms based on their distance.</span>

<span class="sd">    Bond between two atoms is created, if the two atoms are within</span>

<span class="sd">    .. math::</span>

<span class="sd">          d &lt; f * (R_1 + R_2)</span>

<span class="sd">    of each other, where :math:`R_1` and :math:`R_2` are the VdW radii</span>
<span class="sd">    of the atoms and :math:`f` is an ad-hoc *fudge_factor*. This is</span>
<span class="sd">    the `same algorithm that VMD uses`_.</span>

<span class="sd">    :Keywords:</span>

<span class="sd">      *fudge_factor*</span>
<span class="sd">        The factor by which atoms must overlap eachother to be considered a</span>
<span class="sd">        bond.  Larger values will increase the number of bonds found. [0.72]</span>

<span class="sd">      *vdwradii*</span>
<span class="sd">        To supply custom vdwradii for atoms in the algorithm. Must be a dict</span>
<span class="sd">        of format {type:radii}. The default table of van der Waals radii is</span>
<span class="sd">        hard-coded as :data:`MDAnalysis.topology.tables.vdwradii`.  Any user</span>
<span class="sd">        defined vdwradii passed as an argument will supercede the table</span>
<span class="sd">        values. [``None``]</span>

<span class="sd">      *lower_bound*</span>
<span class="sd">        The minimum bond length. All bonds found shorter than this length will</span>
<span class="sd">        be ignored. This is useful for parsing PDB with altloc records where</span>
<span class="sd">        atoms with altloc A and B maybe very close together and there should be</span>
<span class="sd">        no chemical bond between them. [0.1]</span>

<span class="sd">      *box*</span>
<span class="sd">        Bonds are found using a distance search, if unit cell information is</span>
<span class="sd">        given, periodic boundary conditions will be considered in the distance</span>
<span class="sd">        search. [``None``]</span>

<span class="sd">    :Returns:</span>
<span class="sd">       List of tuples suitable for use in Universe topology building.</span>

<span class="sd">    .. warning::</span>
<span class="sd">       No check is done after the bonds are guessed to see if Lewis</span>
<span class="sd">       structure is correct. This is wrong and will burn somebody.</span>

<span class="sd">    .. _`same algorithm that VMD uses`:</span>
<span class="sd">       http://www.ks.uiuc.edu/Research/vmd/vmd-1.9.1/ug/node26.html</span>

<span class="sd">    .. versionadded:: 0.7.7</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Updated method internally to use more :mod:`numpy`, should work</span>
<span class="sd">       faster.  Should also use less memory, previously scaled as</span>
<span class="sd">       :math:`O(n^2)`.  *vdwradii* argument now augments table list</span>
<span class="sd">       rather than replacing entirely.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># why not just use atom.positions?</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;&#39;atoms&#39; and &#39;coord&#39; must be the same length&quot;</span><span class="p">)</span>

    <span class="n">fudge_factor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;fudge_factor&#39;</span><span class="p">,</span> <span class="mf">0.72</span><span class="p">)</span>

    <span class="n">vdwradii</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">vdwradii</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c"># so I don&#39;t permanently change it</span>
    <span class="n">user_vdwradii</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;vdwradii&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user_vdwradii</span><span class="p">:</span>  <span class="c"># this should make algo use their values over defaults</span>
        <span class="n">vdwradii</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">user_vdwradii</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">atomtypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">types</span><span class="p">())</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c"># sometimes atoms is just list of atoms not AG</span>
        <span class="n">atomtypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">])</span>
    <span class="c"># check that all types have a defined vdw</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">val</span> <span class="ow">in</span> <span class="n">vdwradii</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">atomtypes</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&quot;vdw radii for types: &quot;</span> <span class="o">+</span>
                          <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">atomtypes</span> <span class="k">if</span>
                                     <span class="ow">not</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">vdwradii</span><span class="p">])</span> <span class="o">+</span>
                          <span class="s">&quot;. These can be defined manually using the&quot;</span> <span class="o">+</span>
                          <span class="s">&quot; keyword &#39;vdwradii&#39;&quot;</span><span class="p">))</span>

    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;lower_bound&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>

    <span class="n">box</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;box&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="c"># to speed up checking, calculate what the largest possible bond</span>
    <span class="c"># atom that would warrant attention.</span>
    <span class="c"># then use this to quickly mask distance results later</span>
    <span class="n">max_vdw</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">vdwradii</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">atomtypes</span><span class="p">])</span>

    <span class="n">bonds</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">vdw_i</span> <span class="o">=</span> <span class="n">vdwradii</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
        <span class="n">max_d</span> <span class="o">=</span> <span class="p">(</span><span class="n">vdw_i</span> <span class="o">+</span> <span class="n">max_vdw</span><span class="p">)</span> <span class="o">*</span> <span class="n">fudge_factor</span>

        <span class="c"># using self_distance_array scales O(n^2)</span>
        <span class="c"># 20,000 atoms = 1.6 Gb memory</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">distance_array</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span>
                                        <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">lower_bound</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">max_d</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
            <span class="n">atom_j</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">vdw_i</span> <span class="o">+</span> <span class="n">vdwradii</span><span class="p">[</span><span class="n">atom_j</span><span class="o">.</span><span class="n">type</span><span class="p">])</span> <span class="o">*</span> <span class="n">fudge_factor</span><span class="p">:</span>
                <span class="c"># because of method used, same bond won&#39;t be seen twice,</span>
                <span class="c"># so don&#39;t need to worry about duplicates</span>
                <span class="n">bonds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">atom</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">atom_j</span><span class="o">.</span><span class="n">number</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="guess_angles"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_angles">[docs]</a><span class="k">def</span> <span class="nf">guess_angles</span><span class="p">(</span><span class="n">bonds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a list of Bonds, find all angles that exist between atoms.</span>

<span class="sd">    Works by assuming that if atoms 1 &amp; 2 are bonded, and 2 &amp; 3 are bonded,</span>
<span class="sd">    then (1,2,3) must be an angle.</span>

<span class="sd">    :Returns:</span>
<span class="sd">      List of tuples defining the angles.</span>
<span class="sd">      Suitable for use in u._topology</span>

<span class="sd">    .. seeAlso:: :meth:`guess_bonds`</span>

<span class="sd">    .. versionadded 0.9.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angles_found</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">other_a</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>  <span class="c"># who&#39;s my friend currently in Bond</span>
            <span class="k">for</span> <span class="n">other_b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other_b</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>  <span class="c"># if not the same bond I start as</span>
                    <span class="n">third_a</span> <span class="o">=</span> <span class="n">other_b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                    <span class="n">desc</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">other_a</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">third_a</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">desc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c"># first index always less than last</span>
                        <span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">angles_found</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">angles_found</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="guess_torsions"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_torsions">[docs]</a><span class="k">def</span> <span class="nf">guess_torsions</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a list of Angles, find all torsions that exist between atoms.</span>

<span class="sd">    Works by assuming that if (1,2,3) is an angle, and 3 &amp; 4 are bonded,</span>
<span class="sd">    then (1,2,3,4) must be a torsion.</span>

<span class="sd">    :Returns:</span>
<span class="sd">      List of tuples defining the torsions.</span>
<span class="sd">      Suitable for use in u._topology</span>

<span class="sd">    .. versionadded 0.9.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">torsions_found</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
        <span class="n">a_tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">number</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>  <span class="c"># angle as tuple of numbers</span>
        <span class="c"># if searching with b[0], want tuple of (b[2], b[1], b[0], +new)</span>
        <span class="c"># search the first and last atom of each angle</span>
        <span class="k">for</span> <span class="n">atom</span><span class="p">,</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                                <span class="p">[</span><span class="n">a_tup</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">a_tup</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">other_b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">other_b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">third_a</span> <span class="o">=</span> <span class="n">other_b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                    <span class="n">desc</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="p">(</span><span class="n">third_a</span><span class="o">.</span><span class="n">number</span><span class="p">,)</span>
                    <span class="k">if</span> <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">desc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">torsions_found</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">torsions_found</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="guess_improper_torsions"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_improper_torsions">[docs]</a><span class="k">def</span> <span class="nf">guess_improper_torsions</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a list of Angles, find all improper torsions that exist between</span>
<span class="sd">    atoms.</span>

<span class="sd">    Works by assuming that if (1,2,3) is an angle, and 2 &amp; 4 are bonded,</span>
<span class="sd">    then (2, 1, 3, 4) must be an improper torsion.</span>
<span class="sd">    ie the improper torsion is the angle between the planes formed by</span>
<span class="sd">    (1, 2, 3) and (1, 3, 4)</span>

<span class="sd">    :Returns:</span>
<span class="sd">      List of tuples defining the improper torsions.</span>
<span class="sd">      Suitable for use in u._topology</span>

<span class="sd">    .. versionadded 0.9.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">torsions_found</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># select middle atom in angle</span>
        <span class="n">a_tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">number</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>  <span class="c"># start of improper tuple</span>
        <span class="c"># if searching with b[1], want tuple of (b[1], b[2], b[0], +new)</span>
        <span class="c"># search the first and last atom of each angle</span>
        <span class="k">for</span> <span class="n">other_b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">other_atom</span> <span class="o">=</span> <span class="n">other_b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">other_atom</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>  <span class="c"># if this atom isn&#39;t in the angle I started with</span>
                <span class="n">desc</span> <span class="o">=</span> <span class="n">a_tup</span> <span class="o">+</span> <span class="p">(</span><span class="n">other_atom</span><span class="o">.</span><span class="n">number</span><span class="p">,)</span>
                <span class="k">if</span> <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">desc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">torsions_found</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">torsions_found</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="get_atom_mass"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.get_atom_mass">[docs]</a><span class="k">def</span> <span class="nf">get_atom_mass</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the atomic mass in u for *element*.</span>

<span class="sd">    Masses are looked up in :data:`MDAnalysis.topology.tables.masses`.</span>

<span class="sd">    .. Warning:: Unknown masses are set to 0.00</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">element</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.000</span>

</div>
<div class="viewcode-block" id="guess_atom_mass"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_atom_mass">[docs]</a><span class="k">def</span> <span class="nf">guess_atom_mass</span><span class="p">(</span><span class="n">atomname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess a mass based on the atom name.</span>

<span class="sd">    :func:`guess_atom_element` is used to determine the kind of atom.</span>

<span class="sd">    .. warning:: Anything not recognized is simply set to 0; if you rely on the</span>
<span class="sd">                 masses you might want to double check.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">get_atom_mass</span><span class="p">(</span><span class="n">guess_atom_element</span><span class="p">(</span><span class="n">atomname</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="guess_atom_charge"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.guess_atom_charge">[docs]</a><span class="k">def</span> <span class="nf">guess_atom_charge</span><span class="p">(</span><span class="n">atomname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Guess atom charge from the name.</span>

<span class="sd">    .. Warning:: Not implemented; simply returns 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO: do something slightly smarter, at least use name/element</span>
    <span class="k">return</span> <span class="mf">0.0</span>

</div>
<div class="viewcode-block" id="TopologyDict"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.TopologyDict">[docs]</a><span class="k">class</span> <span class="nc">TopologyDict</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A customised dictionary designed for sorting the bonds, angles and</span>
<span class="sd">    torsions present in a group of atoms.</span>

<span class="sd">    Usage::</span>

<span class="sd">      topologydict = TopologyDict(members)</span>

<span class="sd">    :Arguments:</span>
<span class="sd">        *members*</span>
<span class="sd">            A list of :class:`TopologyObject` instances</span>

<span class="sd">    :Returns:</span>
<span class="sd">        *topologydict*</span>
<span class="sd">            A specialised dictionary of the topology instances passed to it</span>

<span class="sd">    TopologyDicts are also built lazily from a :class:`TopologyGroup.topDict`</span>
<span class="sd">    attribute.</span>

<span class="sd">    The :class:`TopologyDict` collects all the selected topology type from the</span>
<span class="sd">    atoms and categorises them according to the types of the atoms within.</span>
<span class="sd">    A :class:`TopologyGroup` containing all of a given bond type can</span>
<span class="sd">    be made by querying with the appropriate key.  The keys to the</span>
<span class="sd">    :class:`TopologyDict` are a tuple of the atom types that the bond represents</span>
<span class="sd">    and can be viewed using the :meth:`keys` method.</span>

<span class="sd">    For example, from a system containing pure ethanol ::</span>

<span class="sd">      &gt;&gt;&gt; td = u.bonds.topDict</span>
<span class="sd">      &gt;&gt;&gt; td.keys()</span>
<span class="sd">      [(&#39;C&#39;, &#39;C&#39;),</span>
<span class="sd">       (&#39;C&#39;, &#39;H&#39;),</span>
<span class="sd">       (&#39;O&#39;, &#39;H&#39;),</span>
<span class="sd">       (&#39;C&#39;, &#39;O&#39;)]</span>
<span class="sd">      &gt;&gt;&gt; td[&#39;C&#39;, &#39;O&#39;]</span>
<span class="sd">      &lt; TopologyGroup containing 912 bonds &gt;</span>

<span class="sd">    .. Note::</span>

<span class="sd">       The key for a bond is taken from the type attribute of the atoms.</span>

<span class="sd">       Getting and setting types of bonds is done smartly, so a C-C-H</span>
<span class="sd">       angle is considered identical to a H-C-C angle.</span>

<span class="sd">    Duplicate entries are automatically removed upon creation and</span>
<span class="sd">    combination of different Dicts.  This means a bond between atoms</span>
<span class="sd">    1 and 2 will only ever appear once in a dict despite both atoms 1</span>
<span class="sd">    and 2 having the bond in their :attr:`bond` attribute.</span>

<span class="sd">    Two :class:`TopologyDict` instances can be combined using</span>
<span class="sd">    addition and it will not create any duplicate bonds in the process.</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Changed initialisation to use a list of :class:`TopologyObject`</span>
<span class="sd">       instances instead of list of atoms; now used from within</span>
<span class="sd">       :class:`TopologyGroup` instead of accessed from :class:`AtomGroup`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c"># Detect what I&#39;ve been given</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">members</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TopologyObject</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">=</span> <span class="n">members</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># Throw error if not given right thing</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Unrecognised input&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">type</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">btype</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">btype</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_removeDupes</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_removeDupes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sorts through contents and makes sure that there are no duplicate keys</span>
<span class="sd">        (through type reversal)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c"># Go through all keys, if the reverse of the key exists add this to</span>
        <span class="c"># that entry else make a new entry</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">newdict</span><span class="p">:</span>
                <span class="n">newdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newdict</span><span class="p">[</span><span class="n">k</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="o">=</span> <span class="n">newdict</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of types of bond in the topology dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<div class="viewcode-block" id="TopologyDict.keys"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.TopologyDict.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of the different types of available bonds&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator over keys in this dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;TopologyDict with {num} unique {type}s&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">toptype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a TopologyGroup matching the criteria if possible,</span>
<span class="sd">        otherwise returns ``None``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns boolean on whether a given type exists within this dictionary</span>

<span class="sd">        For topology groups the key (1,2,3) is considered the same as (3,2,1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="ow">or</span> <span class="n">other</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span>

</div>
<div class="viewcode-block" id="TopologyGroup"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.TopologyGroup">[docs]</a><span class="k">class</span> <span class="nc">TopologyGroup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A container for a groups of bonds.</span>

<span class="sd">    All bonds of a certain types can be retrieved from within the</span>
<span class="sd">    :class:`TopologyGroup` by querying with a tuple of types::</span>

<span class="sd">      tg2 = tg.selectBonds([key])</span>

<span class="sd">    Where *key* describes the desired bond as a tuple of the involved</span>
<span class="sd">    :class:`~MDAnalysis.AtomGroup.Atom` types, as defined by the .type Atom</span>
<span class="sd">    attribute). A list of available keys can be displayed using the</span>
<span class="sd">    :meth:`types` method.</span>

<span class="sd">    Alternatively, all the bonds which are in a given</span>
<span class="sd">    :class:`~MDAnalysis.AtomGroup.AtomGroup` can be extracted using</span>
<span class="sd">    :meth:`atomgroup_intersection`::</span>

<span class="sd">      tg2 = tg.atomgroup_intersection(ag)</span>

<span class="sd">    This allows the keyword *strict* to be given, which forces all members of</span>
<span class="sd">    all bonds to be inside the AtomGroup passed to it.</span>

<span class="sd">    Finally, a TopologyGroup can be sliced similarly to AtomGroups::</span>

<span class="sd">      tg2 = tg[5:10]</span>

<span class="sd">    The :meth:`bonds`, :meth:`angles` and :meth:`torsions` methods offer</span>
<span class="sd">    a &quot;shortcut&quot; to the Cython distance calculation functions in</span>
<span class="sd">    :class:`MDAnalysis.core.distances`.</span>

<span class="sd">    TopologyGroups can be combined with TopologyGroups of the same bond</span>
<span class="sd">    type (ie can combine two angle containing TopologyGroups).</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Overhauled completely: (1) Added internal :class:`TopologyDict`</span>
<span class="sd">       accessible by the :attr:`topDict` attribute. (2)</span>
<span class="sd">       :meth:`selectBonds` allows the :attr:`topDict` to be queried</span>
<span class="sd">       with tuple of types. (3) Added :meth:`atomgroup_intersection`</span>
<span class="sd">       to allow bonds which are in a given :class:`AtomGroup` to be retrieved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bondlist</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bondlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Can&#39;t make empty TopologyGroup&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bondlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TopologyObject</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">=</span> <span class="n">bondlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Input not recognised&quot;</span><span class="p">)</span>
        <span class="c"># Would be nice to make everything work internally using sets, BUT</span>
        <span class="c"># sets can&#39;t be indexed, so couldn&#39;t work backward from .angles()</span>
        <span class="c"># results to find which angle is a certain value.</span>
        <span class="c"># Sorted so that slicing returns sensible results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bondlist</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c"># used for topdict saving</span>

<div class="viewcode-block" id="TopologyGroup.selectBonds"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.TopologyGroup.selectBonds">[docs]</a>    <span class="k">def</span> <span class="nf">selectBonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieves a selection from this topology group based on types.</span>

<span class="sd">        .. seeAlso :meth:`types`</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">topDict</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="TopologyGroup.types"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.TopologyGroup.types">[docs]</a>    <span class="k">def</span> <span class="nf">types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the bond types in this TopologyGroup</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">topDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;dict&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">topDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the TopologyDict for this topology group.</span>

<span class="sd">        This is used for the selectBonds method when fetching a certain type</span>
<span class="sd">        of bond.</span>

<span class="sd">        This is a cached property so will be generated the first time it is</span>
<span class="sd">        accessed.</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TopologyDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyGroup.atomgroup_intersection"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.TopologyGroup.atomgroup_intersection">[docs]</a>    <span class="k">def</span> <span class="nf">atomgroup_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve all bonds from within this TopologyGroup that are within</span>
<span class="sd">        the AtomGroup which is passed.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *strict*</span>
<span class="sd">            Only retrieve bonds which are completely contained within the</span>
<span class="sd">            AtomGroup. [``False``]</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;strict&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strict_intersection</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loose_intersection</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_loose_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies bonds if it appears even once in an AtomGroup</span>

<span class="sd">        This means that some bonds might extend out of the defined AtomGroup</span>

<span class="sd">        .. SeeAlso:: :meth:`_strict_intersection` for including bonds</span>
<span class="sd">                     more strictly</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Bond&#39;</span><span class="p">:</span>
            <span class="n">other_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Angle&#39;</span><span class="p">:</span>
            <span class="n">other_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Torsion&#39;</span><span class="p">:</span>
            <span class="n">other_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">torsions</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Improper_Torsion&#39;</span><span class="p">:</span>
            <span class="n">other_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">impropers</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unsupported intersection&quot;</span><span class="p">)</span>

        <span class="n">newlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other_set</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">newlist</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_strict_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies bonds only if all members of the bond appear in the AtomGroup</span>

<span class="sd">        This means that all bonds will be contained within the AtomGroup</span>

<span class="sd">        .. SeeAlso:: :meth:`_loose_intersection` for including bonds</span>
<span class="sd">                     less strictly</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Create a dictionary of all bonds within this TG, initialised to 0</span>
        <span class="c"># for each</span>
        <span class="c">#</span>
        <span class="c"># Then go through all TopObjs in AtomGroup and count their appearances</span>
        <span class="c"># keeping track using the dict</span>
        <span class="c">#</span>
        <span class="c"># Then see how many times each TopObj was spotted in the AtomGroup&#39;s bonds</span>
        <span class="c">#</span>
        <span class="c"># If this count is equal to crit, (bond=2, angle=3, torsion=4) then</span>
        <span class="c"># the TopObj was seen enough for it to have to be completely be</span>
        <span class="c"># present in the AtomGroup</span>

        <span class="c"># each bond starts with 0 appearances</span>
        <span class="c"># I&#39;m only interested in intersection, so if its not in tg then</span>
        <span class="c"># i&#39;ll get keyerrors which i&#39;ll pass</span>
        <span class="n">count_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">}</span>

        <span class="c"># then go through ag and count appearances of bonds</span>
<span class="c"># This seems to benchmark slow, because __getattribute__ is slower than a.bonds</span>
<span class="c">#        for atom in other:</span>
<span class="c">#            for b in atom.__getattribute__(req_attr):</span>
<span class="c">#                try:</span>
<span class="c">#                    count_dict[b] += 1</span>
<span class="c">#                except KeyError:  # if he&#39;s not in dict then meh</span>
<span class="c">#                    pass</span>
<span class="c"># So I&#39;ll bruteforce here, despite it being fugly</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Bond&#39;</span><span class="p">:</span>
            <span class="n">crit</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">count_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Angle&#39;</span><span class="p">:</span>
            <span class="n">crit</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">angles</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">count_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Torsion&#39;</span><span class="p">:</span>
            <span class="n">crit</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">torsions</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">count_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Improper_Torsion&#39;</span><span class="p">:</span>
            <span class="n">crit</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">impropers</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">count_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>

        <span class="c"># now make new list, which only includes bonds with enough appearances</span>
        <span class="n">newlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span> <span class="k">if</span> <span class="n">count_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="n">crit</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">newlist</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

<div class="viewcode-block" id="TopologyGroup.dump_contents"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.TopologyGroup.dump_contents">[docs]</a>    <span class="k">def</span> <span class="nf">dump_contents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple of tuples which define the contents of this</span>
<span class="sd">        TopologyGroup in terms of the atom numbers,</span>
<span class="sd">        (0 based index within u.atoms)</span>

<span class="sd">        This format should be identical to the original contents of the</span>
<span class="sd">        entries in universe._topology.</span>
<span class="sd">        Note that because bonds are sorted as they are initialised, the order</span>
<span class="sd">        that atoms are defined in each entry might be reversed.</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># should allow topology information to be pickled even if it is</span>
        <span class="c"># substantially changed from original input,</span>
        <span class="c"># eg through merging universes or defining new bonds manually.</span>
        <span class="n">bondlist</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">number</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>
                          <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">bondlist</span>
</div>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;atom1&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">atom1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AtomGroup</span><span class="o">.</span><span class="n">AtomGroup</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;atom2&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">atom2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AtomGroup</span><span class="o">.</span><span class="n">AtomGroup</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;atom3&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">atom3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AtomGroup</span><span class="o">.</span><span class="n">AtomGroup</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s">&#39;atom4&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">atom4</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AtomGroup</span><span class="o">.</span><span class="n">AtomGroup</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of bonds in the topology group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine two TopologyGroups together.</span>

<span class="sd">        Can combined two TopologyGroup of the same type, or add a single</span>
<span class="sd">        TopologyObject to a TopologyGroup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TopologyObject</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Cannot add different types of &quot;</span>
                                <span class="s">&quot;TopologyObjects together&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span> <span class="o">+</span> <span class="p">(</span><span class="n">other</span><span class="p">,))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TopologyGroup</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Can only combine two TopologyGroups&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">toptype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Can only combine TopologyGroups of the same type&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a particular bond as single object or a subset of</span>
<span class="sd">        this TopologyGroup as another TopologyGroup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>  <span class="c"># single TopObj</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>  <span class="c"># new TG</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">item</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator over all bonds&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if this TopologyGroup contains a bond&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;TopologyGroup containing {num} {type}s&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">toptype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if contents of TopologyGroups are equal&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c"># Distance calculation methods below</span>
    <span class="c"># &quot;Slow&quot; versions exist as a way of testing the Cython implementations</span>
    <span class="k">def</span> <span class="nf">_bondsSlow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>  <span class="c"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Slow version of bond (numpy implementation)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Bond&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;TopologyGroup is not of type &#39;Bond&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bond_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
                <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">dimensions</span>
                <span class="c"># orthogonal and divide by zero check</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="mf">90.</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">bond_dist</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">bond_dist</span> <span class="o">/</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Only orthogonal boxes supported&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">bond_dist</span><span class="p">])</span>

<div class="viewcode-block" id="TopologyGroup.bonds"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.TopologyGroup.bonds">[docs]</a>    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the distance between all bonds in this TopologyGroup</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *pbc*</span>
<span class="sd">              apply periodic boundary conditions when calculating distance</span>
<span class="sd">              [False]</span>
<span class="sd">           *result*</span>
<span class="sd">              allows a predefined results array to be used,</span>
<span class="sd">              note that this will be overwritten</span>

<span class="sd">        Uses cython implementation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Bond&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;TopologyGroup is not of type &#39;Bond&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_bonds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                        <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
                                        <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_bonds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                        <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_anglesSlow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Slow version of angle (numpy implementation)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Angle&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;TopologyGroup is not of type &#39;Angle&#39;&quot;</span><span class="p">)</span>

        <span class="n">vec1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="n">vec2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">slowang</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">angles</span>

<div class="viewcode-block" id="TopologyGroup.angles"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.TopologyGroup.angles">[docs]</a>    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the angle in radians formed between a bond</span>
<span class="sd">        between atoms 1 and 2 and a bond between atoms 2 &amp; 3</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *result*</span>
<span class="sd">              allows a predefined results array to be used, note that this</span>
<span class="sd">              will be overwritten</span>
<span class="sd">           *pbc*</span>
<span class="sd">              apply periodic boundary conditions when calculating angles</span>
<span class="sd">              [``False``] this is important when connecting vectors between atoms</span>
<span class="sd">              might require minimum image convention</span>

<span class="sd">        Uses cython implementation</span>

<span class="sd">        .. versionchanged :: 0.9.0</span>
<span class="sd">           Added *pbc* option (default ``False``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">==</span> <span class="s">&#39;Angle&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;TopologyGroup is not of type &#39;Angle&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                         <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
                                         <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                         <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_torsionsSlow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Slow version of torsion (numpy implementation)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;Torsion&#39;</span><span class="p">,</span> <span class="s">&#39;Improper_Torsion&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;TopologyGroup is not of type &#39;Torsion&#39; or &quot;</span>
                            <span class="s">&quot;&#39;Improper_Torsion&#39;&quot;</span><span class="p">)</span>

        <span class="n">vec1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="n">vec2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="n">vec3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom4</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dihedral</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">vec3</span><span class="p">)])</span>

<div class="viewcode-block" id="TopologyGroup.torsions"><a class="viewcode-back" href="../../../documentation_pages/topology/core.html#MDAnalysis.topology.core.TopologyGroup.torsions">[docs]</a>    <span class="k">def</span> <span class="nf">torsions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the torsional angle in radians for this topology</span>
<span class="sd">        group.</span>

<span class="sd">        Defined as the angle between a plane formed by atoms 1, 2 and</span>
<span class="sd">        3 and a plane formed by atoms 2, 3 and 4.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *result*</span>
<span class="sd">              allows a predefined results array to be used, note that this</span>
<span class="sd">              will be overwritten</span>
<span class="sd">           *pbc*</span>
<span class="sd">              apply periodic boundary conditions when calculating angles</span>
<span class="sd">              [``False``] this is important when connecting vectors between</span>
<span class="sd">              atoms might require minimum image convention</span>

<span class="sd">        Uses cython implementation.</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Added *pbc* option (default ``False``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;Torsion&#39;</span><span class="p">,</span> <span class="s">&#39;Improper_Torsion&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;TopologyGroup is not of type &#39;Torsion&#39; or &quot;</span>
                            <span class="s">&quot;&#39;Improper_Torsion&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_torsions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">atom4</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                           <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
                                           <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_torsions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">atom3</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">atom4</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                           <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.9.2 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../../MDAnalysis.html" >MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sbastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domaski, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Danny Parton, Joshua L. Phillips, Tyler Reddy, Paul Rigor, Andy Somogyi,
    Lukas Stelzl, Zhuyi Xue, and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>