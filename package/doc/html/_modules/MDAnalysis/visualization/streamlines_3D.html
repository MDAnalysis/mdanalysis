<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.visualization.streamlines_3D &mdash; MDAnalysis 0.11.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.11.0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.11.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.visualization.streamlines_3D</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Multicore 3D streamplot Python library for MDAnalysis --- :mod:`MDAnalysis.visualization.streamlines_3D`</span>
<span class="sd">=========================================================================================================</span>

<span class="sd">:Authors: Tyler Reddy and Matthieu Chavent</span>
<span class="sd">:Year: 2014</span>
<span class="sd">:Copyright: GNU Public License v3</span>
<span class="sd">:Citation: [Chavent2014]_</span>

<span class="sd">.. autofunction:: generate_streamlines_3d</span>

<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">numpy.testing</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.spatial.distance</span>


<span class="k">def</span> <span class="nf">determine_container_limits</span><span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span> <span class="n">trajectory_file_path</span><span class="p">,</span> <span class="n">buffer_value</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;A function for the parent process which should take the input trajectory and calculate the limits of the</span>
<span class="sd">    container for the system and return these limits.&#39;&#39;&#39;</span>
    <span class="n">universe_object</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span> <span class="n">trajectory_file_path</span><span class="p">)</span>
    <span class="n">all_atom_selection</span> <span class="o">=</span> <span class="n">universe_object</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s">&#39;all&#39;</span><span class="p">)</span>  <span class="c"># select all particles</span>
    <span class="n">all_atom_coordinate_array</span> <span class="o">=</span> <span class="n">all_atom_selection</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">all_atom_coordinate_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
        <span class="n">all_atom_coordinate_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">all_atom_coordinate_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
        <span class="n">all_atom_coordinate_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">all_atom_coordinate_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
        <span class="n">all_atom_coordinate_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
    <span class="n">tuple_of_limits</span> <span class="o">=</span> \
        <span class="p">(</span>
            <span class="n">x_min</span> <span class="o">-</span> <span class="n">buffer_value</span><span class="p">,</span>
            <span class="n">x_max</span> <span class="o">+</span> <span class="n">buffer_value</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">-</span> <span class="n">buffer_value</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">+</span> <span class="n">buffer_value</span><span class="p">,</span> <span class="n">z_min</span> <span class="o">-</span> <span class="n">buffer_value</span><span class="p">,</span>
            <span class="n">z_max</span> <span class="o">+</span> <span class="n">buffer_value</span><span class="p">)</span>  <span class="c"># using buffer_value to catch particles near edges</span>
    <span class="k">return</span> <span class="n">tuple_of_limits</span>


<span class="k">def</span> <span class="nf">produce_grid</span><span class="p">(</span><span class="n">tuple_of_limits</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Produce a grid for the simulation system based on the tuple of Cartesian Coordinate limits calculated in an</span>
<span class="sd">    earlier step.&#39;&#39;&#39;</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span> <span class="o">=</span> <span class="n">tuple_of_limits</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">:</span><span class="n">grid_spacing</span><span class="p">,</span> <span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">:</span><span class="n">grid_spacing</span><span class="p">,</span> <span class="n">z_min</span><span class="p">:</span><span class="n">z_max</span><span class="p">:</span><span class="n">grid_spacing</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">grid</span>


<span class="k">def</span> <span class="nf">split_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">num_cores</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Take the overall grid for the system and split it into lists of cube vertices that can be distributed to each</span>
<span class="sd">    core.&#39;&#39;&#39;</span>
    <span class="c"># unpack the x,y,z mgrid arrays</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">grid</span>
    <span class="n">num_z_values</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">num_sheets</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">delta_array_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">])</span>  <span class="c"># the final target shape for return delta arrays is n-1 in each dimension</span>

    <span class="n">ordered_list_per_sheet_x_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x_sheet</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>  <span class="c"># each x_sheet should have shape (25,23) and the same x value in each element</span>
        <span class="n">array_all_x_values_current_sheet</span> <span class="o">=</span> <span class="n">x_sheet</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">ordered_list_per_sheet_x_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array_all_x_values_current_sheet</span><span class="p">)</span>
    <span class="n">ordered_list_per_sheet_y_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">y_columns</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
        <span class="n">array_all_y_values_current_sheet</span> <span class="o">=</span> <span class="n">y_columns</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">ordered_list_per_sheet_y_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array_all_y_values_current_sheet</span><span class="p">)</span>
    <span class="n">ordered_list_per_sheet_z_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">z_slices</span> <span class="ow">in</span> <span class="n">z</span><span class="p">:</span>
        <span class="n">array_all_z_values_current_sheet</span> <span class="o">=</span> <span class="n">z_slices</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">ordered_list_per_sheet_z_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array_all_z_values_current_sheet</span><span class="p">)</span>

    <span class="n">ordered_list_cartesian_coordinates_per_sheet</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x_sheet_coords</span><span class="p">,</span> <span class="n">y_sheet_coords</span><span class="p">,</span> <span class="n">z_sheet_coords</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ordered_list_per_sheet_x_values</span><span class="p">,</span>
                                                              <span class="n">ordered_list_per_sheet_y_values</span><span class="p">,</span>
                                                              <span class="n">ordered_list_per_sheet_z_values</span><span class="p">):</span>
        <span class="n">ordered_list_cartesian_coordinates_per_sheet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x_sheet_coords</span><span class="p">,</span> <span class="n">y_sheet_coords</span><span class="p">,</span> <span class="n">z_sheet_coords</span><span class="p">))</span>
    <span class="n">array_ordered_cartesian_coords_per_sheet</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ordered_list_cartesian_coordinates_per_sheet</span><span class="p">)</span>
    <span class="c">#now I&#39;m going to want to build cubes in an ordered fashion, and in such a way that I can track the index /</span>
    <span class="c"># centroid of each cube for domain decomposition / reconstruction and mayavi mlab.flow() input</span>
    <span class="c">#cubes will be formed from N - 1 base sheets combined with subsequent sheets</span>
    <span class="n">current_base_sheet</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dictionary_cubes_centroids_indices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">cube_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">current_base_sheet</span> <span class="o">&lt;</span> <span class="n">num_sheets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">current_base_sheet_array</span> <span class="o">=</span> <span class="n">array_ordered_cartesian_coords_per_sheet</span><span class="p">[</span><span class="n">current_base_sheet</span><span class="p">]</span>
        <span class="n">current_top_sheet_array</span> <span class="o">=</span> <span class="n">array_ordered_cartesian_coords_per_sheet</span><span class="p">[</span>
            <span class="n">current_base_sheet</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c"># the points of the sheet &#39;to the right&#39; in the grid</span>
        <span class="n">current_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">current_index</span> <span class="o">&lt;</span> <span class="n">current_base_sheet_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">num_z_values</span><span class="p">:</span>
            <span class="c"># iterate through all the indices in each of the sheet arrays (careful to avoid extra</span>
            <span class="c"># points not needed for cubes)</span>
            <span class="n">column_z_level</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># start at the bottom of a given 4-point column and work up</span>
            <span class="k">while</span> <span class="n">column_z_level</span> <span class="o">&lt;</span> <span class="n">num_z_values</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">current_list_cube_vertices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">first_two_vertices_base_sheet</span> <span class="o">=</span> <span class="n">current_base_sheet_array</span><span class="p">[</span><span class="n">current_index</span><span class="p">:</span><span class="n">current_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">first_two_vertices_top_sheet</span> <span class="o">=</span> <span class="n">current_top_sheet_array</span><span class="p">[</span><span class="n">current_index</span><span class="p">:</span><span class="n">current_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">next_two_vertices_base_sheet</span> <span class="o">=</span> <span class="n">current_base_sheet_array</span><span class="p">[</span><span class="n">current_index</span> <span class="o">+</span>
                                                                        <span class="n">num_z_values</span><span class="p">:</span> <span class="mi">2</span> <span class="o">+</span>
                                                                        <span class="n">num_z_values</span> <span class="o">+</span> <span class="n">current_index</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">next_two_vertices_top_sheet</span> <span class="o">=</span> <span class="n">current_top_sheet_array</span><span class="p">[</span><span class="n">current_index</span> <span class="o">+</span>
                                                                      <span class="n">num_z_values</span><span class="p">:</span> <span class="mi">2</span> <span class="o">+</span>
                                                                      <span class="n">num_z_values</span> <span class="o">+</span> <span class="n">current_index</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">vertex_set</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="n">first_two_vertices_base_sheet</span><span class="p">,</span> <span class="n">first_two_vertices_top_sheet</span><span class="p">,</span>
                    <span class="n">next_two_vertices_base_sheet</span><span class="p">,</span> <span class="n">next_two_vertices_top_sheet</span>
                <span class="p">]:</span>
                    <span class="n">current_list_cube_vertices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vertex_set</span><span class="p">)</span>
                <span class="n">vertex_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">current_list_cube_vertices</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">vertex_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s">&quot;vertex_array has incorrect shape&quot;</span>
                <span class="n">cube_centroid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">current_list_cube_vertices</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">dictionary_cubes_centroids_indices</span><span class="p">[</span><span class="n">cube_counter</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s">&#39;centroid&#39;</span><span class="p">:</span> <span class="n">cube_centroid</span><span class="p">,</span>
                    <span class="s">&#39;vertex_list&#39;</span><span class="p">:</span> <span class="n">current_list_cube_vertices</span><span class="p">}</span>
                <span class="n">cube_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">current_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">column_z_level</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">column_z_level</span> <span class="o">==</span> <span class="n">num_z_values</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># the loop will break but I should also increment the</span>
                <span class="c"># current_index</span>
                    <span class="n">current_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">current_base_sheet</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">total_cubes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dictionary_cubes_centroids_indices</span><span class="p">)</span>

    <span class="c">#produce an array of pseudo cube indices (actually the dictionary keys which are cube numbers in string format):</span>
    <span class="n">pseudo_cube_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_cubes</span><span class="p">)</span>
    <span class="n">sublist_of_cube_indices_per_core</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">pseudo_cube_indices</span><span class="p">,</span> <span class="n">num_cores</span><span class="p">)</span>
    <span class="c">#now, the split of pseudoindices seems to work well, and the above sublist_of_cube_indices_per_core is a list of</span>
    <span class="c"># arrays of cube numbers / keys in the original dictionary</span>
    <span class="c">#now I think I&#39;ll try to produce a list of dictionaries that each contain their assigned cubes based on the above</span>
    <span class="c">#  per core split</span>
    <span class="n">list_dictionaries_for_cores</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">subdictionary_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">array_cube_indices</span> <span class="ow">in</span> <span class="n">sublist_of_cube_indices_per_core</span><span class="p">:</span>
        <span class="n">current_core_dictionary</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">items_to_pop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_cube_indices</span><span class="p">)</span>
        <span class="n">items_popped</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">items_popped</span> <span class="o">&lt;</span> <span class="n">items_to_pop</span><span class="p">:</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dictionary_cubes_centroids_indices</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
            <span class="n">current_core_dictionary</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>
            <span class="n">items_popped</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">list_dictionaries_for_cores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_core_dictionary</span><span class="p">)</span>
        <span class="n">subdictionary_counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">list_dictionaries_for_cores</span><span class="p">,</span> <span class="n">total_cubes</span><span class="p">,</span> <span class="n">num_sheets</span><span class="p">,</span> <span class="n">delta_array_shape</span>


<span class="k">def</span> <span class="nf">per_core_work</span><span class="p">(</span><span class="n">start_frame_coord_array</span><span class="p">,</span> <span class="n">end_frame_coord_array</span><span class="p">,</span> <span class="n">dictionary_cube_data_this_core</span><span class="p">,</span> <span class="n">MDA_selection</span><span class="p">,</span>
                  <span class="n">start_frame</span><span class="p">,</span> <span class="n">end_frame</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;The code to perform on a given core given the dictionary of cube data.&#39;&#39;&#39;</span>
    <span class="n">list_previous_frame_centroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">list_previous_frame_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># define some utility functions for trajectory iteration:</span>

    <span class="k">def</span> <span class="nf">point_in_cube</span><span class="p">(</span><span class="n">array_point_coordinates</span><span class="p">,</span> <span class="n">list_cube_vertices</span><span class="p">,</span> <span class="n">cube_centroid</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Determine if an array of coordinates are within a cube.&#39;&#39;&#39;</span>
        <span class="c">#the simulation particle point can&#39;t be more than half the cube side length away from the cube centroid in</span>
        <span class="c"># any given dimension:</span>
        <span class="n">array_cube_vertices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_cube_vertices</span><span class="p">)</span>
        <span class="n">cube_half_side_length</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">array_cube_vertices</span><span class="p">,</span> <span class="s">&#39;euclidean&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">array_cube_vertex_distances_from_centroid</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">array_cube_vertices</span><span class="p">,</span>
                                                                                 <span class="n">cube_centroid</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">array_cube_vertex_distances_from_centroid</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                                          <span class="n">array_cube_vertex_distances_from_centroid</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                          <span class="n">err_msg</span><span class="o">=</span><span class="s">&quot;not all cube vertex to centroid distances are the same, &quot;</span>
                                                  <span class="s">&quot;so not a true cube&quot;</span><span class="p">)</span>
        <span class="n">absolute_delta_coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">array_point_coordinates</span><span class="p">,</span> <span class="n">cube_centroid</span><span class="p">))</span>
        <span class="n">absolute_delta_x_coords</span> <span class="o">=</span> <span class="n">absolute_delta_coords</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">indices_delta_x_acceptable</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">absolute_delta_x_coords</span> <span class="o">&lt;=</span> <span class="n">cube_half_side_length</span><span class="p">)</span>
        <span class="n">absolute_delta_y_coords</span> <span class="o">=</span> <span class="n">absolute_delta_coords</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">indices_delta_y_acceptable</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">absolute_delta_y_coords</span> <span class="o">&lt;=</span> <span class="n">cube_half_side_length</span><span class="p">)</span>
        <span class="n">absolute_delta_z_coords</span> <span class="o">=</span> <span class="n">absolute_delta_coords</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">indices_delta_z_acceptable</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">absolute_delta_z_coords</span> <span class="o">&lt;=</span> <span class="n">cube_half_side_length</span><span class="p">)</span>
        <span class="n">intersection_xy_acceptable_arrays</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">indices_delta_x_acceptable</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                              <span class="n">indices_delta_y_acceptable</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">overall_indices_points_in_current_cube</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">intersection_xy_acceptable_arrays</span><span class="p">,</span>
                                                                   <span class="n">indices_delta_z_acceptable</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">overall_indices_points_in_current_cube</span>

    <span class="k">def</span> <span class="nf">update_dictionary_point_in_cube_start_frame</span><span class="p">(</span><span class="n">array_simulation_particle_coordinates</span><span class="p">,</span>
                                                    <span class="n">dictionary_cube_data_this_core</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Basically update the cube dictionary objects assigned to this core to contain a new key/value pair</span>
<span class="sd">        corresponding to the indices of the relevant particles that fall within a given cube. Also, for a given cube,</span>
<span class="sd">        store a key/value pair for the centroid of the particles that fall within the cube.&#39;&#39;&#39;</span>
        <span class="n">cube_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">dictionary_cube_data_this_core</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">index_list_in_cube</span> <span class="o">=</span> <span class="n">point_in_cube</span><span class="p">(</span><span class="n">array_simulation_particle_coordinates</span><span class="p">,</span> <span class="n">cube</span><span class="p">[</span><span class="s">&#39;vertex_list&#39;</span><span class="p">],</span>
                                               <span class="n">cube</span><span class="p">[</span><span class="s">&#39;centroid&#39;</span><span class="p">])</span>
            <span class="n">cube</span><span class="p">[</span><span class="s">&#39;start_frame_index_list_in_cube&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_list_in_cube</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_list_in_cube</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># if there&#39;s at least one particle in this cube</span>
                <span class="n">centroid_particles_in_cube</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">array_simulation_particle_coordinates</span><span class="p">[</span><span class="n">index_list_in_cube</span><span class="p">],</span>
                                                           <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">cube</span><span class="p">[</span><span class="s">&#39;centroid_of_particles_first_frame&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centroid_particles_in_cube</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c"># empty cube</span>
                <span class="n">cube</span><span class="p">[</span><span class="s">&#39;centroid_of_particles_first_frame&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;empty&#39;</span>
            <span class="n">cube_counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">update_dictionary_end_frame</span><span class="p">(</span><span class="n">array_simulation_particle_coordinates</span><span class="p">,</span> <span class="n">dictionary_cube_data_this_core</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Update the cube dictionary objects again as appropriate for the second and final frame.&#39;&#39;&#39;</span>
        <span class="n">cube_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">dictionary_cube_data_this_core</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="c"># if there were no particles in the cube in the first frame, then set dx,dy,dz each to 0</span>
            <span class="k">if</span> <span class="n">cube</span><span class="p">[</span><span class="s">&#39;centroid_of_particles_first_frame&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;empty&#39;</span><span class="p">:</span>
                <span class="n">cube</span><span class="p">[</span><span class="s">&#39;dx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">cube</span><span class="p">[</span><span class="s">&#39;dy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">cube</span><span class="p">[</span><span class="s">&#39;dz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c"># there was at least one particle in the starting cube so we can get dx,dy,dz centroid values</span>
                <span class="n">new_coordinate_array_for_particles_starting_in_this_cube</span> <span class="o">=</span> <span class="n">array_simulation_particle_coordinates</span><span class="p">[</span>
                    <span class="n">cube</span><span class="p">[</span><span class="s">&#39;start_frame_index_list_in_cube&#39;</span><span class="p">]]</span>
                <span class="n">new_centroid_for_particles_starting_in_this_cube</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span>
                    <span class="n">new_coordinate_array_for_particles_starting_in_this_cube</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">cube</span><span class="p">[</span><span class="s">&#39;centroid_of_paticles_final_frame&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_centroid_for_particles_starting_in_this_cube</span>
                <span class="n">delta_centroid_array_this_cube</span> <span class="o">=</span> <span class="n">new_centroid_for_particles_starting_in_this_cube</span> <span class="o">-</span> <span class="n">cube</span><span class="p">[</span>
                    <span class="s">&#39;centroid_of_particles_first_frame&#39;</span><span class="p">]</span>
                <span class="n">cube</span><span class="p">[</span><span class="s">&#39;dx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_centroid_array_this_cube</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cube</span><span class="p">[</span><span class="s">&#39;dy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_centroid_array_this_cube</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cube</span><span class="p">[</span><span class="s">&#39;dz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_centroid_array_this_cube</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">cube_counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c">#now that the parent process is dealing with the universe object &amp; grabbing required coordinates, each child</span>
    <span class="c"># process only needs to take the coordinate arrays &amp; perform the operations with its assigned cubes (no more file</span>
    <span class="c">#  opening and trajectory iteration on each core--which I&#39;m hoping will substantially reduce the physical memory</span>
    <span class="c"># footprint of my 3D streamplot code)</span>
    <span class="n">update_dictionary_point_in_cube_start_frame</span><span class="p">(</span><span class="n">start_frame_coord_array</span><span class="p">,</span> <span class="n">dictionary_cube_data_this_core</span><span class="p">)</span>
    <span class="n">update_dictionary_end_frame</span><span class="p">(</span><span class="n">end_frame_coord_array</span><span class="p">,</span> <span class="n">dictionary_cube_data_this_core</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dictionary_cube_data_this_core</span>


<span class="k">def</span> <span class="nf">produce_coordinate_arrays_single_process</span><span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span> <span class="n">trajectory_file_path</span><span class="p">,</span> <span class="n">MDA_selection</span><span class="p">,</span> <span class="n">start_frame</span><span class="p">,</span>
                                             <span class="n">end_frame</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;To reduce memory footprint produce only a single MDA selection and get desired coordinate arrays; can later</span>
<span class="sd">    send these coordinate arrays to all child processes rather than having each child process open a trajectoryand</span>
<span class="sd">    waste memory.&#39;&#39;&#39;</span>
    <span class="n">universe_object</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span> <span class="n">trajectory_file_path</span><span class="p">)</span>
    <span class="n">relevant_particles</span> <span class="o">=</span> <span class="n">universe_object</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">MDA_selection</span><span class="p">)</span>
    <span class="c"># pull out coordinate arrays from desired frames:</span>
    <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">universe_object</span><span class="o">.</span><span class="n">trajectory</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span> <span class="o">&gt;</span> <span class="n">end_frame</span><span class="p">:</span>
            <span class="k">break</span>  <span class="c"># stop here</span>
        <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span> <span class="o">==</span> <span class="n">start_frame</span><span class="p">:</span>
            <span class="n">start_frame_relevant_particle_coordinate_array_xyz</span> <span class="o">=</span> <span class="n">relevant_particles</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span> <span class="o">==</span> <span class="n">end_frame</span><span class="p">:</span>
            <span class="n">end_frame_relevant_particle_coordinate_array_xyz</span> <span class="o">=</span> <span class="n">relevant_particles</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">start_frame_relevant_particle_coordinate_array_xyz</span><span class="p">,</span> <span class="n">end_frame_relevant_particle_coordinate_array_xyz</span><span class="p">)</span>


<div class="viewcode-block" id="generate_streamlines_3d"><a class="viewcode-back" href="../../../documentation_pages/visualization/streamlines_3D.html#MDAnalysis.visualization.streamlines_3D.generate_streamlines_3d">[docs]</a><span class="k">def</span> <span class="nf">generate_streamlines_3d</span><span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span> <span class="n">trajectory_file_path</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="p">,</span> <span class="n">MDA_selection</span><span class="p">,</span> <span class="n">start_frame</span><span class="p">,</span>
                            <span class="n">end_frame</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">maximum_delta_magnitude</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                            <span class="n">num_cores</span><span class="o">=</span><span class="s">&#39;maximum&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Produce the x, y and z components of a 3D streamplot data set.</span>
<span class="sd">    </span>
<span class="sd">    :Parameters:</span>
<span class="sd">        **coordinate_file_path** : str</span>
<span class="sd">            Absolute path to the coordinate file</span>
<span class="sd">        **trajectory_file_path** : str</span>
<span class="sd">            Absolute path to the trajectory file. It will normally be desirable to filter the trajectory with a tool</span>
<span class="sd">            such as GROMACS g_filter (see [Chavent2014]_)</span>
<span class="sd">        **grid_spacing** : float</span>
<span class="sd">            The spacing between grid lines (angstroms)</span>
<span class="sd">        **MDA_selection** : str</span>
<span class="sd">            MDAnalysis selection string</span>
<span class="sd">        **start_frame** : int</span>
<span class="sd">            First frame number to parse</span>
<span class="sd">        **end_frame** : int</span>
<span class="sd">            Last frame number to parse</span>
<span class="sd">        **xmin** : float</span>
<span class="sd">            Minimum coordinate boundary for x-axis (angstroms)</span>
<span class="sd">        **xmax** : float</span>
<span class="sd">            Maximum coordinate boundary for x-axis (angstroms)</span>
<span class="sd">        **ymin** : float</span>
<span class="sd">            Minimum coordinate boundary for y-axis (angstroms)</span>
<span class="sd">        **ymax** : float</span>
<span class="sd">            Maximum coordinate boundary for y-axis (angstroms)</span>
<span class="sd">        **zmin** : float</span>
<span class="sd">            Minimum coordinate boundary for z-axis (angstroms)</span>
<span class="sd">        **zmax** : float</span>
<span class="sd">            Maximum coordinate boundary for z-axis (angstroms)</span>
<span class="sd">        **maximum_delta_magnitude** : float</span>
<span class="sd">            Absolute value of the largest displacement (in dx,dy, or dz) tolerated for the centroid of a group of</span>
<span class="sd">            particles (angstroms; default: 2.0). Values above this displacement will not count in the streamplot (</span>
<span class="sd">            treated as excessively large displacements crossing the periodic boundary)</span>
<span class="sd">        **num_cores** : int, optional</span>
<span class="sd">            The number of cores to use. (Default &#39;maximum&#39; uses all available cores)</span>
<span class="sd">        </span>
<span class="sd">    :Returns:</span>
<span class="sd">        **dx_array** : array of floats</span>
<span class="sd">            An array object containing the displacements in the x direction</span>
<span class="sd">        **dy_array** : array of floats</span>
<span class="sd">            An array object containing the displacements in the y direction</span>
<span class="sd">        **dz_array** : array of floats</span>
<span class="sd">            An array object containing the displacements in the z direction</span>
<span class="sd">    </span>
<span class="sd">    :Examples:</span>

<span class="sd">    ::</span>

<span class="sd">        import numpy</span>
<span class="sd">        import MDAnalysis</span>
<span class="sd">        import MDAnalysis.visualization.streamlines_3D</span>
<span class="sd">        import mayavi, mayavi.mlab</span>

<span class="sd">        #assign coordinate system limits and grid spacing:</span>
<span class="sd">        x_lower,x_upper = -8.73, 1225.96</span>
<span class="sd">        y_lower,y_upper = -12.58, 1224.34</span>
<span class="sd">        z_lower,z_upper = -300, 300</span>
<span class="sd">        grid_spacing_value = 20</span>

<span class="sd">        x1, y1, z1 = MDAnalysis.visualization.streamlines_3D.generate_streamlines_3d(&#39;testing.gro&#39;,</span>
<span class="sd">        &#39;testing_filtered.xtc&#39;,xmin=x_lower,xmax=x_upper,ymin=y_lower,ymax=y_upper,zmin=z_lower,zmax=z_upper,</span>
<span class="sd">        grid_spacing = grid_spacing_value, MDA_selection = &#39;name PO4&#39;,start_frame=2,end_frame=3,num_cores=&#39;maximum&#39;)</span>
<span class="sd">        x,y,z = numpy.mgrid[x_lower:x_upper:x1.shape[0]*1j,y_lower:y_upper:y1.shape[1]*1j,z_lower:z_upper:z1.shape[</span>
<span class="sd">        2]*1j]</span>

<span class="sd">        #plot with mayavi:</span>
<span class="sd">        fig = mayavi.mlab.figure(bgcolor=(1.0,1.0,1.0),size=(800,800),fgcolor=(0, 0, 0))</span>
<span class="sd">        for z_value in numpy.arange(z_lower,z_upper,grid_spacing_value):</span>
<span class="sd">            st = mayavi.mlab.flow(x,y,z,x1,y1,z1,line_width=1,seedtype=&#39;plane&#39;,integration_direction=&#39;both&#39;)</span>
<span class="sd">            st.streamline_type = &#39;tube&#39;</span>
<span class="sd">            st.tube_filter.radius = 2</span>
<span class="sd">            st.seed.widget.origin = numpy.array([ x_lower,  y_upper,   z_value])</span>
<span class="sd">            st.seed.widget.point1 = numpy.array([ x_upper, y_upper,  z_value])</span>
<span class="sd">            st.seed.widget.point2 = numpy.array([ x_lower, y_lower,  z_value])</span>
<span class="sd">            st.seed.widget.resolution = int(x1.shape[0])</span>
<span class="sd">            st.seed.widget.enabled = False</span>
<span class="sd">        mayavi.mlab.axes(extent = [0,1200,0,1200,-300,300])</span>
<span class="sd">        fig.scene.z_plus_view()</span>
<span class="sd">        mayavi.mlab.savefig(&#39;test_streamplot_3D.png&#39;)</span>
<span class="sd">        #more compelling examples can be produced for vesicles and other spherical systems</span>

<span class="sd">    .. image:: test_streamplot_3D.png</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c"># work out the number of cores to use:</span>
    <span class="k">if</span> <span class="n">num_cores</span> <span class="o">==</span> <span class="s">&#39;maximum&#39;</span><span class="p">:</span>
        <span class="n">num_cores</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>  <span class="c"># use all available cores</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_cores</span> <span class="o">=</span> <span class="n">num_cores</span>  <span class="c"># use the value specified by the user</span>
        <span class="c"># assert isinstance(num_cores,(int,long)), &quot;The number of specified cores must (of course) be an integer.&quot;</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s">&#39;warn&#39;</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="s">&#39;raise&#39;</span><span class="p">)</span>
    <span class="n">parent_cube_dictionary</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># collect all data from child processes here</span>

    <span class="k">def</span> <span class="nf">log_result_to_parent</span><span class="p">(</span><span class="n">process_dict</span><span class="p">):</span>
        <span class="n">parent_cube_dictionary</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">process_dict</span><span class="p">)</span>

    <span class="c">#step 1: produce tuple of cartesian coordinate limits for the first frame</span>
    <span class="c">#tuple_of_limits = determine_container_limits(coordinate_file_path = coordinate_file_path,trajectory_file_path =</span>
    <span class="c"># trajectory_file_path,buffer_value=buffer_value)</span>
    <span class="n">tuple_of_limits</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">)</span>
    <span class="c">#step 2: produce a suitable grid (will assume that grid size / container size does not vary during simulation--or</span>
    <span class="c">#  at least not beyond the buffer limit, such that this grid can be used for all subsequent frames)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">produce_grid</span><span class="p">(</span><span class="n">tuple_of_limits</span><span class="o">=</span><span class="n">tuple_of_limits</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="o">=</span><span class="n">grid_spacing</span><span class="p">)</span>
    <span class="c">#step 3: split the grid into a dictionary of cube information that can be sent to each core for processing:</span>
    <span class="n">list_dictionaries_for_cores</span><span class="p">,</span> <span class="n">total_cubes</span><span class="p">,</span> <span class="n">num_sheets</span><span class="p">,</span> <span class="n">delta_array_shape</span> <span class="o">=</span> <span class="n">split_grid</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">num_cores</span><span class="o">=</span><span class="n">num_cores</span><span class="p">)</span>
    <span class="c">#step 3b: produce required coordinate arrays on a single core to avoid making a universe object on each core:</span>
    <span class="n">start_frame_coord_array</span><span class="p">,</span> <span class="n">end_frame_coord_array</span> <span class="o">=</span> <span class="n">produce_coordinate_arrays_single_process</span><span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span>
                                                                                              <span class="n">trajectory_file_path</span><span class="p">,</span>
                                                                                              <span class="n">MDA_selection</span><span class="p">,</span>
                                                                                              <span class="n">start_frame</span><span class="p">,</span> <span class="n">end_frame</span><span class="p">)</span>
    <span class="c">#step 4: per process work using the above grid data split</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">num_cores</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sub_dictionary_of_cube_data</span> <span class="ow">in</span> <span class="n">list_dictionaries_for_cores</span><span class="p">:</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">per_core_work</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span>
            <span class="n">start_frame_coord_array</span><span class="p">,</span> <span class="n">end_frame_coord_array</span><span class="p">,</span> <span class="n">sub_dictionary_of_cube_data</span><span class="p">,</span> <span class="n">MDA_selection</span><span class="p">,</span> <span class="n">start_frame</span><span class="p">,</span>
            <span class="n">end_frame</span><span class="p">),</span> <span class="n">callback</span><span class="o">=</span><span class="n">log_result_to_parent</span><span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="c">#so, at this stage the parent process now has a single dictionary with all the cube objects updated from all</span>
    <span class="c"># available cores</span>
    <span class="c">#the 3D streamplot (i.e, mayavi flow() function) will require separate 3D numpy arrays for dx,dy,dz</span>
    <span class="c">#the shape of each 3D array will unfortunately have to match the mgrid data structure (bit of a pain): (</span>
    <span class="c"># num_sheets - 1, num_sheets - 1, cubes_per_column)</span>
    <span class="n">cubes_per_sheet</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">total_cubes</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">num_sheets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c">#produce dummy zero arrays for dx,dy,dz of the appropriate shape:</span>
    <span class="n">dx_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">delta_array_shape</span><span class="p">)</span>
    <span class="n">dy_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">delta_array_shape</span><span class="p">)</span>
    <span class="n">dz_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">delta_array_shape</span><span class="p">)</span>
    <span class="c">#now use the parent cube dictionary to correctly substitute in dx,dy,dz values</span>
    <span class="n">current_sheet</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># which is also the current row</span>
    <span class="n">y_index_current_sheet</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># sub row</span>
    <span class="n">z_index_current_column</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># column</span>
    <span class="n">total_cubes_current_sheet</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">cube_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_cubes</span><span class="p">):</span>
        <span class="n">dx_array</span><span class="p">[</span><span class="n">current_sheet</span><span class="p">,</span> <span class="n">y_index_current_sheet</span><span class="p">,</span> <span class="n">z_index_current_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent_cube_dictionary</span><span class="p">[</span><span class="n">cube_number</span><span class="p">][</span>
            <span class="s">&#39;dx&#39;</span><span class="p">]</span>
        <span class="n">dy_array</span><span class="p">[</span><span class="n">current_sheet</span><span class="p">,</span> <span class="n">y_index_current_sheet</span><span class="p">,</span> <span class="n">z_index_current_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent_cube_dictionary</span><span class="p">[</span><span class="n">cube_number</span><span class="p">][</span>
            <span class="s">&#39;dy&#39;</span><span class="p">]</span>
        <span class="n">dz_array</span><span class="p">[</span><span class="n">current_sheet</span><span class="p">,</span> <span class="n">y_index_current_sheet</span><span class="p">,</span> <span class="n">z_index_current_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent_cube_dictionary</span><span class="p">[</span><span class="n">cube_number</span><span class="p">][</span>
            <span class="s">&#39;dz&#39;</span><span class="p">]</span>
        <span class="n">z_index_current_column</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">total_cubes_current_sheet</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">z_index_current_column</span> <span class="o">==</span> <span class="n">delta_array_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="c"># done building current y-column so iterate y value and reset z</span>
            <span class="n">z_index_current_column</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">y_index_current_sheet</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">y_index_current_sheet</span> <span class="o">==</span> <span class="n">delta_array_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>  <span class="c"># current sheet is complete</span>
                <span class="n">current_sheet</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">y_index_current_sheet</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># restart for new sheet</span>
                <span class="n">z_index_current_column</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">total_cubes_current_sheet</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c"># now set velocity component values greater than a certain cutoff to 0,</span>
    <span class="c"># because they tend to reflect spurious values (i.e., PBC jumping)</span>
    <span class="n">dx_array</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">dx_array</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">maximum_delta_magnitude</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">dy_array</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">dy_array</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">maximum_delta_magnitude</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">dz_array</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">dz_array</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">maximum_delta_magnitude</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">dx_array</span><span class="p">,</span> <span class="n">dy_array</span><span class="p">,</span> <span class="n">dz_array</span><span class="p">)</span>

<span class="c"># if __name__ == &#39;__main__&#39;: #execute the main control function only if this file is called as a top-level script</span>
<span class="c">#will probably mostly use this for testing on a trajectory</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.11.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sbastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domaski, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac Virshup,
    Zhuyi Xue, Carlos Yez S.,
    and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>