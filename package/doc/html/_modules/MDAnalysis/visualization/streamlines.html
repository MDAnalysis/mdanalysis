

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.visualization.streamlines &mdash; MDAnalysis 0.8.1rc1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.8.1rc1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.8.1rc1 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.8.1rc1 documentation" href="../../../index.html" />
    <link rel="up" title="MDAnalysis" href="../../MDAnalysis.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.8.1rc1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" accesskey="U">MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for MDAnalysis.visualization.streamlines</h1><div class="highlight"><pre>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Multicore 2D streamplot Python library for MDAnalysis --- :mod:`MDAnalysis.visualization.streamlines`</span>
<span class="sd">=====================================================================================================</span>

<span class="sd">:Authors: Tyler Reddy and Matthieu Chavent</span>
<span class="sd">:Year: 2014</span>
<span class="sd">:Copyright: GNU Public License v3</span>

<span class="sd">.. autofunction:: generate_streamlines</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib</span><span class="o">,</span> <span class="nn">matplotlib.nxutils</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;2d streamplot module requires: matplotlib.nxutils for its points_inside_poly method&#39;</span><span class="p">)</span> <span class="c">#deprecated, aim to remove dependency in future</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy</span>

<span class="k">def</span> <span class="nf">produce_grid</span><span class="p">(</span><span class="n">tuple_of_limits</span><span class="p">,</span><span class="n">grid_spacing</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Produce a grid for the simulation system based on the tuple of Cartesian Coordinate limits calculated in an earlier step.&#39;&#39;&#39;</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">tuple_of_limits</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">:</span><span class="n">grid_spacing</span><span class="p">,</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">:</span><span class="n">grid_spacing</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">grid</span>

<span class="k">def</span> <span class="nf">split_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">num_cores</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Take the overall grid for the system and split it into lists of square vertices that can be distributed to each core. Limited to 2D for now&#39;&#39;&#39;</span>
    <span class="c">#produce an array containing the cartesian coordinates of all vertices in the grid:</span>
    <span class="n">x_array</span><span class="p">,</span> <span class="n">y_array</span> <span class="o">=</span> <span class="n">grid</span> 
    <span class="n">grid_vertex_cartesian_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">x_array</span><span class="p">,</span><span class="n">y_array</span><span class="p">))</span>
    <span class="c">#the grid_vertex_cartesian_array has N_rows, with each row corresponding to a column of coordinates in the grid (so a given row has shape N_rows, 2); overall shape (N_columns_in_grid, N_rows_in_a_column, 2)</span>
    <span class="c">#although I&#39;ll eventually want a pure numpy/scipy/vector-based solution, for now I&#39;ll allow loops to simplify the division of the cartesian coordinates into a list of the squares in the grid</span>
    <span class="n">list_all_squares_in_grid</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#should eventually be a nested list of all the square vertices in the grid/system</span>
    <span class="n">list_parent_index_values</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#want an ordered list of assignment indices for reconstructing the grid positions in the parent process</span>
    <span class="n">current_column</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">current_column</span> <span class="o">&lt;</span> <span class="n">grid_vertex_cartesian_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="c">#go through all the columns except the last one and account for the square vertices (the last column has no &#39;right neighbour&#39;)</span>
        <span class="n">current_row</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">current_row</span> <span class="o">&lt;</span> <span class="n">grid_vertex_cartesian_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="c">#all rows except the top row, which doesn&#39;t have a row above it for forming squares</span>
            <span class="n">bottom_left_vertex_current_square</span> <span class="o">=</span> <span class="n">grid_vertex_cartesian_array</span><span class="p">[</span><span class="n">current_column</span><span class="p">,</span><span class="n">current_row</span><span class="p">]</span>
            <span class="n">bottom_right_vertex_current_square</span> <span class="o">=</span> <span class="n">grid_vertex_cartesian_array</span><span class="p">[</span><span class="n">current_column</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">current_row</span><span class="p">]</span>
            <span class="n">top_right_vertex_current_square</span> <span class="o">=</span> <span class="n">grid_vertex_cartesian_array</span><span class="p">[</span><span class="n">current_column</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">top_left_vertex_current_square</span> <span class="o">=</span> <span class="n">grid_vertex_cartesian_array</span><span class="p">[</span><span class="n">current_column</span> <span class="p">,</span><span class="n">current_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c">#append the vertices of this square to the overall list of square vertices:</span>
            <span class="n">list_all_squares_in_grid</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">bottom_left_vertex_current_square</span><span class="p">,</span><span class="n">bottom_right_vertex_current_square</span><span class="p">,</span><span class="n">top_right_vertex_current_square</span><span class="p">,</span><span class="n">top_left_vertex_current_square</span><span class="p">])</span>
            <span class="n">list_parent_index_values</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">current_row</span><span class="p">,</span><span class="n">current_column</span><span class="p">])</span>
            <span class="n">current_row</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">current_column</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c">#split the list of square vertices [[v1,v2,v3,v4],[v1,v2,v3,v4],...,...] into roughly equally-sized sublists to be distributed over the available cores on the system:</span>
    <span class="n">list_square_vertex_arrays_per_core</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">list_all_squares_in_grid</span><span class="p">,</span><span class="n">num_cores</span><span class="p">)</span>
    <span class="n">list_parent_index_values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">list_parent_index_values</span><span class="p">,</span><span class="n">num_cores</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">list_square_vertex_arrays_per_core</span><span class="p">,</span><span class="n">list_parent_index_values</span><span class="p">,</span><span class="n">current_row</span><span class="p">,</span><span class="n">current_column</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">per_core_work</span><span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span><span class="n">trajectory_file_path</span><span class="p">,</span><span class="n">list_square_vertex_arrays_this_core</span><span class="p">,</span><span class="n">MDA_selection</span><span class="p">,</span><span class="n">start_frame</span><span class="p">,</span><span class="n">end_frame</span><span class="p">,</span><span class="n">reconstruction_index_list</span><span class="p">,</span><span class="n">maximum_delta_magnitude</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;The code to perform on a given core given the list of square vertices assigned to it.&#39;&#39;&#39;</span>
    <span class="k">print</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;Starting&#39;</span>
    <span class="c">#obtain the relevant coordinates for particles of interest</span>
    <span class="n">universe_object</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span><span class="n">trajectory_file_path</span><span class="p">)</span>
    <span class="n">list_previous_frame_centroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">list_previous_frame_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c">#define some utility functions for trajectory iteration:</span>
    <span class="k">def</span> <span class="nf">produce_list_indices_point_in_polygon_this_frame</span><span class="p">(</span><span class="n">vertex_coord_list</span><span class="p">):</span>
        <span class="n">list_indices_point_in_polygon</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">square_vertices</span> <span class="ow">in</span> <span class="n">vertex_coord_list</span><span class="p">:</span>
            <span class="n">index_list_in_polygon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">nxutils</span><span class="o">.</span><span class="n">points_inside_poly</span><span class="p">(</span><span class="n">relevant_particle_coordinate_array_xy</span><span class="p">,</span> <span class="n">square_vertices</span><span class="p">))</span>
            <span class="n">list_indices_point_in_polygon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_list_in_polygon</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">list_indices_point_in_polygon</span>

    <span class="k">def</span> <span class="nf">produce_list_centroids_this_frame</span><span class="p">(</span><span class="n">list_indices_in_polygon</span><span class="p">):</span>
        <span class="n">list_centroids_this_frame</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">list_indices_in_polygon</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c">#if there are no particles of interest in this particular square</span>
                <span class="n">list_centroids_this_frame</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;empty&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">current_coordinate_array_in_square</span> <span class="o">=</span> <span class="n">relevant_particle_coordinate_array_xy</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="n">current_square_indices_centroid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">current_coordinate_array_in_square</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">list_centroids_this_frame</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_square_indices_centroid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">list_centroids_this_frame</span> <span class="c">#a list of numpy xy centroid arrays for this frame</span>
    <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">universe_object</span><span class="o">.</span><span class="n">trajectory</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span> <span class="o">&lt;</span> <span class="n">start_frame</span><span class="p">:</span> <span class="c">#don&#39;t start until first specified frame</span>
            <span class="k">print</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;skipping frame&#39;</span><span class="p">,</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
            <span class="k">continue</span>
        <span class="n">relevant_particle_coordinate_array_xy</span> <span class="o">=</span> <span class="n">universe_object</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span><span class="n">MDA_selection</span><span class="p">)</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[</span><span class="o">...</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c">#only 2D / xy coords for now</span>
        <span class="c">#I will need a list of indices for relevant particles falling within each square in THIS frame:</span>
        <span class="n">list_indices_in_squares_this_frame</span> <span class="o">=</span> <span class="n">produce_list_indices_point_in_polygon_this_frame</span><span class="p">(</span><span class="n">list_square_vertex_arrays_this_core</span><span class="p">)</span>
        <span class="c">#likewise, I will need a list of centroids of particles in each square (same order as above list):</span>
        <span class="n">list_centroids_in_squares_this_frame</span> <span class="o">=</span> <span class="n">produce_list_centroids_this_frame</span><span class="p">(</span><span class="n">list_indices_in_squares_this_frame</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">list_previous_frame_indices</span><span class="p">:</span> <span class="c">#if the previous frame had indices in at least one square I will need to use those indices to generate the updates to the corresponding centroids in this frame:</span>
            <span class="n">list_centroids_this_frame_using_indices_from_last_frame</span> <span class="o">=</span> <span class="n">produce_list_centroids_this_frame</span><span class="p">(</span><span class="n">list_previous_frame_indices</span><span class="p">)</span>
            <span class="c">#I need to write a velocity of zero if there are any &#39;empty&#39; squares in either frame:</span>
            <span class="n">xy_deltas_to_write</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">square_1_centroid</span><span class="p">,</span> <span class="n">square_2_centroid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list_centroids_this_frame_using_indices_from_last_frame</span><span class="p">,</span><span class="n">list_previous_frame_centroids</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">square_1_centroid</span> <span class="o">==</span> <span class="s">&#39;empty&#39;</span> <span class="ow">or</span> <span class="n">square_2_centroid</span> <span class="o">==</span> <span class="s">&#39;empty&#39;</span><span class="p">:</span>
                    <span class="n">xy_deltas_to_write</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xy_deltas_to_write</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">square_1_centroid</span><span class="p">,</span><span class="n">square_2_centroid</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>



            <span class="c">#xy_deltas_to_write = numpy.subtract(numpy.array(list_centroids_this_frame_using_indices_from_last_frame),numpy.array(list_previous_frame_centroids))</span>
            <span class="n">xy_deltas_to_write</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xy_deltas_to_write</span><span class="p">)</span>
            <span class="c">#now filter the array to only contain distances in the range [-8,8] as a placeholder for dealing with PBC issues (Matthieu seemed to use a limit of 8 as well);</span>
            <span class="n">xy_deltas_to_write</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">xy_deltas_to_write</span><span class="p">,</span><span class="o">-</span><span class="n">maximum_delta_magnitude</span><span class="p">,</span><span class="n">maximum_delta_magnitude</span><span class="p">)</span>

            <span class="c">#with the xy and dx,dy values calculated I need to set the values from this frame to previous frame values in anticipation of the next frame:</span>
            <span class="n">list_previous_frame_centroids</span> <span class="o">=</span> <span class="n">list_centroids_in_squares_this_frame</span><span class="p">[:]</span>
            <span class="n">list_previous_frame_indices</span> <span class="o">=</span> <span class="n">list_indices_in_squares_this_frame</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c">#either no points in squares or after the first frame I&#39;ll just reset the &#39;previous&#39; values so they can be used when consecutive frames have proper values</span>
            <span class="n">list_previous_frame_centroids</span> <span class="o">=</span> <span class="n">list_centroids_in_squares_this_frame</span><span class="p">[:]</span>
            <span class="n">list_previous_frame_indices</span> <span class="o">=</span> <span class="n">list_indices_in_squares_this_frame</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span> <span class="o">&gt;</span> <span class="n">end_frame</span><span class="p">:</span> <span class="k">break</span> <span class="c">#stop here </span>
        <span class="k">print</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="s">&#39;frame:&#39;</span><span class="p">,</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
    <span class="k">print</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;Finishing&#39;</span>
    <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="n">reconstruction_index_list</span><span class="p">,</span><span class="n">xy_deltas_to_write</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

<div class="viewcode-block" id="generate_streamlines"><a class="viewcode-back" href="../../../documentation_pages/visualization/streamlines.html#MDAnalysis.visualization.streamlines.generate_streamlines">[docs]</a><span class="k">def</span> <span class="nf">generate_streamlines</span><span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span><span class="n">trajectory_file_path</span><span class="p">,</span><span class="n">grid_spacing</span><span class="p">,</span><span class="n">MDA_selection</span><span class="p">,</span><span class="n">start_frame</span><span class="p">,</span><span class="n">end_frame</span><span class="p">,</span><span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span><span class="p">,</span><span class="n">maximum_delta_magnitude</span><span class="p">,</span><span class="n">num_cores</span><span class="o">=</span><span class="s">&#39;maximum&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;The main control function of the code. The various steps in the workflow should be performed in order here.&#39;&#39;&#39;</span>
    <span class="c">#work out the number of cores to use:</span>
    <span class="k">if</span> <span class="n">num_cores</span> <span class="o">==</span> <span class="s">&#39;maximum&#39;</span><span class="p">:</span>
        <span class="n">num_cores</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="c">#use all available cores</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">num_cores</span> <span class="o">=</span> <span class="n">num_cores</span> <span class="c">#use the value specified by the user</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_cores</span><span class="p">,(</span><span class="nb">int</span><span class="p">,</span><span class="nb">long</span><span class="p">)),</span> <span class="s">&quot;The number of specified cores must (of course) be an integer.&quot;</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s">&#39;warn&#39;</span><span class="p">,</span><span class="n">over</span><span class="o">=</span><span class="s">&#39;raise&#39;</span><span class="p">)</span>
    <span class="n">parent_list_deltas</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#collect all data from child processes here</span>
    <span class="k">def</span> <span class="nf">log_result_to_parent</span><span class="p">(</span><span class="n">delta_array</span><span class="p">):</span>
        <span class="n">parent_list_deltas</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">delta_array</span><span class="p">)</span>

    <span class="n">tuple_of_limits</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">produce_grid</span><span class="p">(</span><span class="n">tuple_of_limits</span> <span class="o">=</span> <span class="n">tuple_of_limits</span><span class="p">,</span> <span class="n">grid_spacing</span> <span class="o">=</span> <span class="n">grid_spacing</span><span class="p">)</span>
    <span class="n">list_square_vertex_arrays_per_core</span><span class="p">,</span><span class="n">list_parent_index_values</span><span class="p">,</span><span class="n">total_rows</span><span class="p">,</span><span class="n">total_columns</span> <span class="o">=</span> <span class="n">split_grid</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span><span class="n">num_cores</span><span class="o">=</span><span class="n">num_cores</span><span class="p">)</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">num_cores</span><span class="p">)</span> 
    <span class="k">for</span> <span class="n">vertex_sublist</span><span class="p">,</span><span class="n">index_sublist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list_square_vertex_arrays_per_core</span><span class="p">,</span><span class="n">list_parent_index_values</span><span class="p">):</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">per_core_work</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">coordinate_file_path</span><span class="p">,</span><span class="n">trajectory_file_path</span> <span class="p">,</span><span class="n">vertex_sublist</span><span class="p">,</span><span class="n">MDA_selection</span><span class="p">,</span><span class="n">start_frame</span><span class="p">,</span><span class="n">end_frame</span><span class="p">,</span><span class="n">index_sublist</span><span class="p">,</span><span class="n">maximum_delta_magnitude</span><span class="p">),</span><span class="n">callback</span><span class="o">=</span><span class="n">log_result_to_parent</span><span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">dx_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">total_rows</span><span class="p">,</span><span class="n">total_columns</span><span class="p">))</span>
    <span class="n">dy_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">total_rows</span><span class="p">,</span><span class="n">total_columns</span><span class="p">))</span>
    <span class="c">#the parent_list_deltas is shaped like this: [ ([row_index,column_index],[dx,dy]), ... (...),...,]</span>
    <span class="k">for</span> <span class="n">index_array</span><span class="p">,</span> <span class="n">delta_array</span> <span class="ow">in</span> <span class="n">parent_list_deltas</span><span class="p">:</span> <span class="c">#go through the list in the parent process and assign to the appropriate positions in the dx and dy matrices:</span>
        <span class="c">#build in a filter to replace all values at the cap (currently between -8,8) with 0 to match Matthieu&#39;s code (I think eventually we&#39;ll reduce the cap to a narrower boundary though)</span>
        <span class="n">index_1</span> <span class="o">=</span> <span class="n">index_array</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">index_2</span> <span class="o">=</span> <span class="n">index_array</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">maximum_delta_magnitude</span><span class="p">:</span>
            <span class="n">dx_array</span><span class="p">[</span><span class="n">index_1</span><span class="p">,</span><span class="n">index_2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dx_array</span><span class="p">[</span><span class="n">index_1</span><span class="p">,</span><span class="n">index_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta_array</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">maximum_delta_magnitude</span><span class="p">:</span>
            <span class="n">dy_array</span><span class="p">[</span><span class="n">index_1</span><span class="p">,</span><span class="n">index_2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dy_array</span><span class="p">[</span><span class="n">index_1</span><span class="p">,</span><span class="n">index_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c">#at Matthieu&#39;s request, we now want to calculate the average and standard deviation of the displacement values:</span>
    <span class="n">displacement_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx_array</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dy_array</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">average_displacement</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">displacement_array</span><span class="p">)</span>
    <span class="n">standard_deviation_of_displacement</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">displacement_array</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">dx_array</span><span class="p">,</span><span class="n">dy_array</span><span class="p">,</span><span class="n">average_displacement</span><span class="p">,</span><span class="n">standard_deviation_of_displacement</span><span class="p">)</span>

<span class="c">#if __name__ == &#39;__main__&#39;: #execute the main control function only if this file is called as a top-level script</span>
    <span class="c">#will probably mostly use this for testing on a trajectory:</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.8.1rc1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" >MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2005-2013, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sébastien Buchoux,
    David Caplan, Jan Domański, Xavier Deupi,
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Jinju Lu, Robert McGibbon,
    Manuel Nuno Melo, Danny Parton, Joshua L. Phillips, Tyler Reddy, Paul Rigor, Andy Somogyi,
    Lukas Stelzl, Zhuyi Xue, and Oliver Beckstein.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>