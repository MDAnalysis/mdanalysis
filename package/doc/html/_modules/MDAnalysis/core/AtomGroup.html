<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.core.AtomGroup &mdash; MDAnalysis 0.8.0rc3 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.8.0rc3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.8.0rc3 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.8.0rc3 documentation" href="../../../index.html" />
    <link rel="up" title="MDAnalysis" href="../../MDAnalysis.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.8.0rc3 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" accesskey="U">MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for MDAnalysis.core.AtomGroup</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://mdanalysis.googlecode.com</span>
<span class="c"># Copyright (c) 2006-2011 Naveen Michaud-Agrawal,</span>
<span class="c">#               Elizabeth J. Denning, Oliver Beckstein,</span>
<span class="c">#               and contributors (see website for details)</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c">#     N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and</span>
<span class="c">#     O. Beckstein. MDAnalysis: A Toolkit for the Analysis of</span>
<span class="c">#     Molecular Dynamics Simulations. J. Comput. Chem. 32 (2011), 2319--2327,</span>
<span class="c">#     doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Fundamental building blocks --- :mod:`MDAnalysis.core.AtomGroup`</span>
<span class="sd">================================================================</span>

<span class="sd">The most important data structure in MDAnalysis is the</span>
<span class="sd">:class:`AtomGroup`, which contains :class:`Atom` instances.</span>

<span class="sd">A :class:`Universe` is the user-visible entry point and collects all</span>
<span class="sd">information needed to analyze a structure or a whole trajectory.</span>

<span class="sd">Segments and residues are a way to refer to a collection of atoms. By</span>
<span class="sd">convention, a :class:`Residue` is a single amino acid, or a water</span>
<span class="sd">molecule, ion, or ligand. A :class:`Segment` is a collection of</span>
<span class="sd">residues such as a whole protein or a chain in a protein or all the</span>
<span class="sd">water in the system.</span>

<span class="sd">Class Hierarchy</span>
<span class="sd">---------------</span>

<span class="sd">A :class:`Universe` contains Segments, which contain Residues, which</span>
<span class="sd">contain Atoms; all containers are derived from :class:`AtomGroup`, and</span>
<span class="sd">thus one can always analyze them as a collection of atoms, independent</span>
<span class="sd">of the hierarchical level.</span>

<span class="sd">Each :class:`Atom` can only belong to a single :class:`Residue`, and a</span>
<span class="sd">:class:`Residue` belongs to one specific :class:`Segment`. This</span>
<span class="sd">hierarchy can be described as</span>

<span class="sd">    Segment &gt; Residue &gt; Atom</span>

<span class="sd">Depending on the use case, it can be more convenient to access data</span>
<span class="sd">on, for instance, the basis of residues than atoms, or to write out</span>
<span class="sd">individual chains (segments) of a protein. MDAnalysis simply provides</span>
<span class="sd">access to these groupings and keeps track of where an atom</span>
<span class="sd">belongs. Each object provides three attributes (:attr:`~AtomGroup.atoms`,</span>
<span class="sd">:attr:`~AtomGroup.residues` or :attr:`~Atom.residue`, :attr:`~AtomGroup.segments` or</span>
<span class="sd">:attr:`~Atom.segment`) that give access to the tiers in the hierarchy</span>
<span class="sd">that the object belongs to.</span>


<span class="sd">Manipulating atoms, residues, and segments</span>
<span class="sd">------------------------------------------</span>

<span class="sd">When working with MDAnalysis it is useful to remember that the fundamental</span>
<span class="sd">object is the :class:`Atom`. Each particle in the topology is represented by</span>
<span class="sd">exactly one :class:`Atom` instance. One :class:`Atom`, however, can be a member</span>
<span class="sd">of multiple :class:`AtomGroup` collections, for instance from different</span>
<span class="sd">selections even though they all refer to the *same* :class:`Atom` object. Thus,</span>
<span class="sd">changing a property of a specific and :class:`Atom` in one :class:`AtomGroup`</span>
<span class="sd">changes it &quot;everywhere&quot;.</span>

<span class="sd">The same is mostly true for :class:`Residue` instances although they are</span>
<span class="sd">derived from :class:`Atom` instances: all :class:`Atom` objects with the same</span>
<span class="sd">:attr:`Atom.resid` are bundled into a single :class:`Residue` with</span>
<span class="sd">:class:`Residue.id` = *resid*. This means that just changing, say, the residue</span>
<span class="sd">name with a command such as ::</span>

<span class="sd">  &gt;&gt;&gt; r = u.selectAtoms(&quot;resid 99&quot;).residues[0]</span>
<span class="sd">  &gt;&gt;&gt; print(r)</span>
<span class="sd">  &lt;Residue &#39;ALA&#39;, 99&gt;</span>
<span class="sd">  &gt;&gt;&gt; r.name = &quot;UNK&quot;</span>
<span class="sd">  &gt;&gt;&gt; print(r)</span>
<span class="sd">  &lt;Residue &#39;UNK&#39;, 99&gt;</span>
<span class="sd">  &gt;&gt;&gt; rnew = u.selectAtoms(&quot;resid 99&quot;).residues[0]</span>
<span class="sd">  &gt;&gt;&gt; print(rnew)</span>
<span class="sd">  &lt;Residue &#39;UNK&#39;, 99&gt;</span>

<span class="sd">will typically work as expected. When working with collections such as</span>
<span class="sd">:class:`AtomGroup` or :class:`ResidueGroup` it is generally better to use</span>
<span class="sd">provided setter methods such as :meth:`AtomGroup.set_resname` or</span>
<span class="sd">:meth:`ResidueGroup.set_resname`.</span>

<span class="sd">There are two cases when it is very important to use the setters:</span>

<span class="sd">* changing *resid*: :meth:`AtomGroup.set_resid` and :meth:`ResidueGroup.set_resid`</span>
<span class="sd">* changing *segid*: :meth:`AtomGroup.set_segid` and :meth:`ResidueGroup.set_segid`</span>

<span class="sd">Because residues are determined by the :attr:`Atom.resid` and segments by</span>
<span class="sd">:attr:`Atom.segid`, the above methods take extra care to rebuild the list of</span>
<span class="sd">segments and residues.</span>

<span class="sd">.. Note::</span>

<span class="sd">   :meth:`AtomGroup.set_resid`, :meth:`ResidueGroup.set_resid`,</span>
<span class="sd">   :meth:`AtomGroup.set_segid`, :meth:`ResidueGroup.set_segid` can change the</span>
<span class="sd">   topology: they can split or merge residues or segments.</span>

<span class="sd">Splitting/merging of residues is probably not very useful because no chemical</span>
<span class="sd">rearrangements are carried out. Manipulating segments might be more useful in</span>
<span class="sd">order to add additional structure to a :class:`Universe` and provide instant</span>
<span class="sd">segment selectors for interactive work::</span>

<span class="sd">  u.selectAtoms(&quot;protein&quot;).set_segid(&quot;protein&quot;)</span>
<span class="sd">  u.selectAtoms(&quot;resname POPE or resname POPC&quot;).set_segid(&quot;lipids&quot;)</span>
<span class="sd">  u.selectAtoms(&quot;resname SOL&quot;).set_segid(&quot;water&quot;)</span>
<span class="sd">  u.selectAtoms(&quot;resname NA or resname CL&quot;).set_segid(&quot;ions&quot;)</span>

<span class="sd">  u.protein.numberOfResidues()</span>
<span class="sd">  water_oxygens = u.water.OW</span>

<span class="sd">The setter methods have the additional advantage that they can assign</span>
<span class="sd">lists. For instance, many MD codes number residues consecutively starting from</span>
<span class="sd">1. However, the original structure might be missing a few atoms at the</span>
<span class="sd">N-terminus. Let&#39;s say that the first residue is really residue 10. In order to</span>
<span class="sd">store the canonical residue IDs (&quot;resnum&quot;) one could the use ::</span>

<span class="sd">  import numpy as np</span>
<span class="sd">  protein = u.selectAtoms(&quot;protein&quot;).residues</span>
<span class="sd">  protein.set_resnum(np.array(protein.resnums()) + 9)</span>

<span class="sd">.. TODO: correct this example when resnums has become a property that returns a np array</span>
<span class="sd">..  protein = u.selectAtoms(&quot;protein&quot;).residues</span>
<span class="sd">..  protein.set_resnum(protein.resnums + 9)</span>

<span class="sd">One can then use ``protein.select(&quot;resnum 42&quot;)`` to select the residue that has</span>
<span class="sd">the canonical residue id 42 (instead of ``resid 33``).</span>

<span class="sd">One can also read the resids directly from  an original PDB file:</span>

<span class="sd">  orig = MDAnalysis.Universe(&quot;2jln.pdb&quot;)</span>
<span class="sd">  protein.set_resnum(orig.selectAtoms(&quot;protein&quot;).resids())</span>



<span class="sd">Classes and functions</span>
<span class="sd">---------------------</span>

<span class="sd">.. autoclass:: Universe</span>
<span class="sd">   :members:</span>
<span class="sd">.. autoclass:: AtomGroup</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: _atoms</span>

<span class="sd">      immutable list of references to the atoms :class:`Atom` in the</span>
<span class="sd">      group</span>

<span class="sd">   .. automethod:: _rebuild_caches</span>

<span class="sd">   .. automethod:: _clear_caches</span>

<span class="sd">   .. automethod:: _fill_cache</span>

<span class="sd">.. autoclass:: Atom</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute::     number</span>

<span class="sd">      atom number</span>

<span class="sd">   .. attribute::     segid</span>

<span class="sd">      name of the segment</span>

<span class="sd">   .. attribute::     resid</span>

<span class="sd">      residue number</span>

<span class="sd">   .. attribute::     resnum</span>

<span class="sd">      canonical residue number as, for instance, used in the original</span>
<span class="sd">      PDB file</span>

<span class="sd">      .. versionadded:: 0.7.4</span>

<span class="sd">   .. attribute::        resname</span>

<span class="sd">      residue name</span>

<span class="sd">   .. attribute::        residue</span>

<span class="sd">      :class:`Residue` object containing the atoms</span>

<span class="sd">   .. attribute::     id</span>

<span class="sd">      atom number inside the residue</span>

<span class="sd">   .. attribute::       name</span>

<span class="sd">      string, short name</span>

<span class="sd">   .. attribute::        type</span>

<span class="sd">      string or number (from force field), describing the atom type;</span>
<span class="sd">      stored as a string.</span>

<span class="sd">      .. versionchanged:: 0.7.6</span>
<span class="sd">         The :attr:`Atom.type` attribute is always stored as a string.</span>

<span class="sd">   .. attribute::        mass</span>

<span class="sd">      float, in `atomic mass units`_ (u)</span>

<span class="sd">   .. attribute::        charge</span>

<span class="sd">      float, in `electron charges`_ (*e*)</span>

<span class="sd">   .. attribute::        radius</span>

<span class="sd">      Born-radius for electrostatic calculations. (Only if read from a</span>
<span class="sd">      PQR file with the</span>
<span class="sd">      :class:`~MDAnalysis.coordinates.PQR.PQRReader`.)</span>

<span class="sd">.. autoclass:: Residue</span>
<span class="sd">   :members:</span>
<span class="sd">.. autoclass:: ResidueGroup</span>
<span class="sd">   :members:</span>
<span class="sd">.. autoclass:: Segment</span>
<span class="sd">   :members:</span>
<span class="sd">.. autoclass:: SegmentGroup</span>
<span class="sd">   :members:</span>

<span class="sd">.. autofunction:: asUniverse</span>
<span class="sd">.. autoexception:: SelectionError</span>
<span class="sd">.. autoexception:: SelectionWarning</span>
<span class="sd">.. autoexception:: NoDataError</span>

<span class="sd">.. _atomic mass units: http://physics.nist.gov/cgi-bin/cuu/Value?u</span>
<span class="sd">.. _electron charges: http://physics.nist.gov/cgi-bin/cuu/Value?e</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">SelectionError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">,</span> <span class="n">SelectionWarning</span>
<span class="kn">import</span> <span class="nn">util</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&quot;MDAnalysis.core.AtomGroup&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Atom"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom">[docs]</a><span class="k">class</span> <span class="nc">Atom</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class representing a single atom.</span>

<span class="sd">    :class:`Atom` is the basic building block of all larger data</span>
<span class="sd">    structures in MDAnalysis, in particular of the</span>
<span class="sd">    :class:`AtomGroup`.</span>

<span class="sd">    An :class:`Atom` is typically generated by a :ref:`topology reader</span>
<span class="sd">    &lt;Supported topology formats&gt;` from :mod:`MDAnalysis.topology`.</span>

<span class="sd">    For performance reasons, only a predefined number of attributes</span>
<span class="sd">    are included (and thus it is not possible to add attributes &quot;on</span>
<span class="sd">    the fly&quot;; they have to be included in the class definition).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;type&quot;</span><span class="p">,</span> <span class="s">&quot;resname&quot;</span><span class="p">,</span> <span class="s">&quot;resid&quot;</span><span class="p">,</span> <span class="s">&quot;segid&quot;</span><span class="p">,</span>
                 <span class="s">&quot;mass&quot;</span><span class="p">,</span> <span class="s">&quot;charge&quot;</span><span class="p">,</span> <span class="s">&quot;residue&quot;</span><span class="p">,</span> <span class="s">&quot;segment&quot;</span><span class="p">,</span> <span class="s">&quot;bonds&quot;</span><span class="p">,</span> <span class="s">&quot;angles&quot;</span><span class="p">,</span> <span class="s">&quot;torsions&quot;</span><span class="p">,</span>
                 <span class="s">&quot;__universe&quot;</span><span class="p">,</span>
                 <span class="s">&quot;radius&quot;</span><span class="p">,</span> <span class="s">&quot;bfactor&quot;</span><span class="p">,</span> <span class="s">&quot;resnum&quot;</span><span class="p">,</span> <span class="s">&quot;serial&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">segid</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span>
                 <span class="n">residue</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bfactor</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">resnum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">serial</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>   <span class="c"># always a string (needed for selections)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resname</span> <span class="o">=</span> <span class="n">resname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resid</span> <span class="o">=</span> <span class="n">resid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span> <span class="o">=</span> <span class="n">resnum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residue</span> <span class="o">=</span> <span class="n">residue</span>  <span class="c"># typically patched in later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segid</span> <span class="o">=</span> <span class="n">segid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="n">segment</span>  <span class="c"># typically patched in later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">mass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="n">charge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bfactor</span> <span class="o">=</span> <span class="n">bfactor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serial</span> <span class="o">=</span> <span class="n">serial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">torsions</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt; Atom &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;: name &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span><span class="s">&quot; of type &quot;</span> <span class="o">+</span> \
               <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; of resname &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;, resid &quot;</span> <span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; and segid &quot;</span> <span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segid</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">number</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Can only concatenate Atoms (not &quot;&#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;&quot;) to AtomGroup&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span><span class="o">+</span><span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Atom.pos"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.pos">[docs]</a>    <span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        deprecated, use position,</span>
<span class="sd">        get the Current cartesian coordinates of the atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the current cartesian coordinates of the atom.</span>
<span class="sd">        @return: a numpy 1x3 array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="c"># internal numbering starts at 0</span>

    <span class="nd">@position.setter</span>
<div class="viewcode-block" id="Atom.position"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.position">[docs]</a>    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the current cartesian coordinates of the atom.</span>
<span class="sd">        @param coords: a 1x3 numpy array of {x,y,z} coordinates, or optionally</span>
<span class="sd">            a single scalar if you should want to set all coordinates to the same value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">coords</span> <span class="c"># internal numbering starts at 0</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Atom.velocity"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.velocity">[docs]</a>    <span class="k">def</span> <span class="nf">velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Current velocity of the atom.</span>

<span class="sd">        A :exc:`~MDAnalysis.NoDataError` is raised if the trajectory</span>
<span class="sd">        does not contain velocities.</span>

<span class="sd">        .. versionadded:: 0.7.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">_velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain velocities&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Atom.centroid"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.centroid">[docs]</a>    <span class="k">def</span> <span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The centroid of an atom is its position, :attr:`Atom.pos`.&quot;&quot;&quot;</span>
        <span class="c"># centroid exists for compatibility with AtomGroup</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;a pointer back to the Universe&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__universe</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__universe</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;Atom &quot;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; is not assigned to a Universe&quot;</span><span class="p">)</span>

    <span class="nd">@universe.setter</span>
<div class="viewcode-block" id="Atom.universe"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Atom.universe">[docs]</a>    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__universe</span> <span class="o">=</span> <span class="n">universe</span>

</div></div>
<div class="viewcode-block" id="AtomGroup"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup">[docs]</a><span class="k">class</span> <span class="nc">AtomGroup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A group of atoms.</span>

<span class="sd">      ag = universe.selectAtoms(atom-list)</span>

<span class="sd">    The AtomGroup contains a list of atoms; typically, a AtomGroup is generated</span>
<span class="sd">    from a selection. It is build from any list-like collection of</span>
<span class="sd">    :class:`Atom` instances. It is also possible to create an empty AtomGroup</span>
<span class="sd">    from an empty list.</span>

<span class="sd">    An AtomGroup can be indexed and sliced like a list::</span>

<span class="sd">       ag[0], ag[-1]</span>

<span class="sd">    will return the first and the last :class:`Atom` in the group</span>
<span class="sd">    whereas the slice ::</span>

<span class="sd">       ag[0:6:2]</span>

<span class="sd">    returns every second element, corresponding to indices 0, 2, and 4.</span>

<span class="sd">    It also supports &quot;advanced slicing&quot; when the argument is a</span>
<span class="sd">    :class:`numpy.ndarray` or a :class:`list`::</span>

<span class="sd">       aslice = [0, 3, -1, 10, 3]</span>
<span class="sd">       ag[aslice]</span>

<span class="sd">    will return a new :class:`AtomGroup` containing (ag[0], ag[3], ag[-1],</span>
<span class="sd">    ag[10], ag[3]).</span>

<span class="sd">    .. Note::</span>

<span class="sd">       AtomGroups originating from a selection are sorted and</span>
<span class="sd">       duplicate elements are removed. This is not true for AtomGroups</span>
<span class="sd">       produced by slicing. Thus slicing can be used when the order of</span>
<span class="sd">       atoms is crucial (for instance, in order to define angles or</span>
<span class="sd">       dihedrals).</span>

<span class="sd">    Atoms can also be accessed in a Pythonic fashion by using the atom name as</span>
<span class="sd">    an attribute. For instance, ::</span>

<span class="sd">       ag.CA</span>

<span class="sd">    will provide a :class:`AtomGroup` of all CA atoms in the</span>
<span class="sd">    group. These *instant selector* attributes are auto-generated for</span>
<span class="sd">    each atom name encountered in the group.</span>

<span class="sd">    .. Note::</span>

<span class="sd">       The name-attribute instant selector access to atoms is mainly</span>
<span class="sd">       meant for quick interactive work. Thus it either returns a</span>
<span class="sd">       single :class:`Atom` if there is only one matching atom, *or* a</span>
<span class="sd">       new :class:`AtomGroup` for multiple matches.  This makes it</span>
<span class="sd">       difficult to use the feature consistently in scripts but it is</span>
<span class="sd">       much better for interactive work.</span>

<span class="sd">    .. rubric:: References for analysis methods</span>

<span class="sd">    .. [Dima2004] Dima, R. I., &amp; Thirumalai, D. (2004). Asymmetry in the</span>
<span class="sd">                  shapes of folded and denatured states of proteins. *J</span>
<span class="sd">                  Phys Chem B*, 108(21),</span>
<span class="sd">                  6564-6570. doi:`10.1021/jp037128y`_</span>

<span class="sd">    .. _10.1021/jp037128y: http://dx.doi.org/10.1021/jp037128y</span>


<span class="sd">    .. versionchanged:: 0.7.6</span>
<span class="sd">       An empty AtomGroup can be created and no longer raises a</span>
<span class="sd">       :exc:`NoDataError`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># for generalized __getitem__ (override _containername for ResidueGroup and SegmentGroup)</span>
    <span class="n">_containername</span> <span class="o">=</span> <span class="s">&quot;_atoms&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># __atoms property is effectively readonly</span>
            <span class="c"># check that atoms is indexable:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span> <span class="o">=</span> <span class="n">atoms</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="c"># sanity check</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Atom</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;atoms must be a Atom or a list of Atoms.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># empty AtomGroup</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># managed timestep object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ts</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># caches:</span>
        <span class="c"># - built on the fly when they are needed</span>
        <span class="c"># - delete entry to invalidate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c"># for generalized __getitem__ (override _containername for ResidueGroup and SegmentGroup)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_container</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_containername</span><span class="p">)</span>

<div class="viewcode-block" id="AtomGroup._rebuild_caches"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup._rebuild_caches">[docs]</a>    <span class="k">def</span> <span class="nf">_rebuild_caches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rebuild all AtomGroup caches.</span>

<span class="sd">        A number of lists and attributes are cached. These caches are lazily</span>
<span class="sd">        built the first time they are needed. When editing the topology it</span>
<span class="sd">        might happen that not all caches were synced properly (even though that</span>
<span class="sd">        this is supposed to happen eventually). In this case the user can</span>
<span class="sd">        manually force a complete cache rebuild.</span>

<span class="sd">        Currently the following caches are used:</span>

<span class="sd">        * atoms (for &quot;in&quot; lookup); cache is only built for large systems with</span>
<span class="sd">          &gt; 10,000 atoms</span>
<span class="sd">        * indices (:meth:`AtomGroup.indices`)</span>
<span class="sd">        * masses (:meth:`AtomGroup.masses`)</span>
<span class="sd">        * residues (:attr:`AtomGroup.residues`)</span>
<span class="sd">        * segments (:attr:`AtomGroup.segments`)</span>

<span class="sd">        .. SeeAlso:: :meth:`_clear_caches`</span>

<span class="sd">        .. versionadded:: 0.7.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If the number of atoms is very large, create a dictionary cache for lookup</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;atoms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(((</span><span class="n">x</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span><span class="p">))</span>
        <span class="c"># indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">number</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
        <span class="c"># residue instances</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_residue</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span> <span class="o">!=</span> <span class="n">current_residue</span><span class="p">:</span>
                <span class="n">residues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="p">)</span>
            <span class="n">current_residue</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;residues&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ResidueGroup</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span>
        <span class="c"># segment instances</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_segment</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">segment</span> <span class="o">!=</span> <span class="n">current_segment</span><span class="p">:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">segment</span><span class="p">)</span>
            <span class="n">current_segment</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">segment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;segments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SegmentGroup</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="c"># masses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;masses&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">mass</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="AtomGroup._clear_caches"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup._clear_caches">[docs]</a>    <span class="k">def</span> <span class="nf">_clear_caches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear cache for all *args*.</span>

<span class="sd">        If no args are provided, all caches are cleared.</span>

<span class="sd">        .. SeeAlso:: :meth:`_rebuild_caches`</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
</div>
<div class="viewcode-block" id="AtomGroup._fill_cache"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup._fill_cache">[docs]</a>    <span class="k">def</span> <span class="nf">_fill_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Populate __cache[name] with value.</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c"># AtomGroup.atoms is guaranteed to be a AtomGroup, too; keeps a consistent API</span>
    <span class="c"># between AtomGroup, Residue, ResidueGroup, Segment; access the list as</span>
    <span class="c"># _atoms (although atoms supports all list-like operations, too).</span></div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.atoms"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.atoms">[docs]</a>    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`AtomGroup` of all atoms in this group.</span>

<span class="sd">        If this is a :class:`AtomGroup` then it returns itself. Otherwise, it</span>
<span class="sd">        will return a new :class:`AtomGroup` based on all :class:`Atom`</span>
<span class="sd">        instances contained.</span>

<span class="sd">        Apply `:func:`list` to :attr:`atoms` or use :attr:`_atoms` if you</span>
<span class="sd">        really only need a list of individual :class:`Atom` instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Cannot just return self because fails with inheritance from AtomGroup</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">AtomGroup</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup._atoms"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup._atoms">[docs]</a>    <span class="k">def</span> <span class="nf">_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;a immutable list of references to the atoms in the group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span>

    <span class="c"># Universe pointer is important for Selections to work on groups</span></div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.universe"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.universe">[docs]</a>    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The universe to which the atoms belong (read-only).&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">universe</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of atoms in the group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return element (index) or group (slicing).</span>

<span class="sd">        .. versionchanged:: 0.8 ResidueGroup and SegmentGroup: return groups themselves and allow advanced slicing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">container</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_container</span>     <span class="c"># see __init__ and _containername: used so that __getitem__</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>            <span class="c"># can be used inherited in ResidueGroup and SegmentGroup</span>
        <span class="c"># consistent with the way list indexing/slicing behaves:</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">container</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">container</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="c"># advanced slicing, requires array or list</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">([</span><span class="n">container</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">item</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c"># There can be more than one atom with the same name</span>
        <span class="n">atomlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="s">&quot;No atoms with name &quot;</span><span class="o">+</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">atomlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># XXX: keep this, makes more sense for names</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span>             <span class="c"># XXX: but inconsistent (see residues and Issue 47)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator over all atoms&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c"># If the number of atoms is very large, create a dictionary cache for lookup</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10000</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s">&#39;atoms&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;atoms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(((</span><span class="n">x</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__atoms</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Can only concatenate AtomGroup (not &quot;&#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;&quot;) to AtomGroup&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">+</span> <span class="p">[</span><span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&lt;&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">&#39; with &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">())</span><span class="o">+</span><span class="s">&#39; atoms&gt;&#39;</span>

<div class="viewcode-block" id="AtomGroup.numberOfAtoms"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.numberOfAtoms">[docs]</a>    <span class="k">def</span> <span class="nf">numberOfAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of atoms in the group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.numberOfResidues"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.numberOfResidues">[docs]</a>    <span class="k">def</span> <span class="nf">numberOfResidues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of residues in the group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.numberOfSegments"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.numberOfSegments">[docs]</a>    <span class="k">def</span> <span class="nf">numberOfSegments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of segments in the group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.indices"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.indices">[docs]</a>    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array of all :attr:`Atom.number` in the group.</span>

<span class="sd">        These indices are 0-based and can be used to directly index</span>
<span class="sd">        :attr:`Universe.atoms` or the coordinate array</span>
<span class="sd">        :attr:`MDAnalysis.coordinates.base.Timestep._pos`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;indices&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">number</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="AtomGroup.names"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.names">[docs]</a>    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of atom names.</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Returns a :class:`numpy.ndarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.residues"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.residues">[docs]</a>    <span class="k">def</span> <span class="nf">residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read-only list of :class:`Residue` objects.</span>

<span class="sd">        A :class:`ResidueGroup` of all residues that contain atoms in</span>
<span class="sd">        this group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;residues&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">:</span>
            <span class="n">residues</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">current_residue</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span> <span class="o">!=</span> <span class="n">current_residue</span><span class="p">:</span>
                    <span class="n">residues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="p">)</span>
                <span class="n">current_residue</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;residues&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ResidueGroup</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;residues&#39;</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="AtomGroup.resids"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.resids">[docs]</a>    <span class="k">def</span> <span class="nf">resids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of residue numbers.</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Returns a :class:`numpy.ndarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="AtomGroup.resnames"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.resnames">[docs]</a>    <span class="k">def</span> <span class="nf">resnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of residue names.</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Returns a :class:`numpy.ndarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="AtomGroup.resnums"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.resnums">[docs]</a>    <span class="k">def</span> <span class="nf">resnums</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of canonical residue numbers.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Returns a :class:`numpy.ndarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">resnum</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">])</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.segments"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.segments">[docs]</a>    <span class="k">def</span> <span class="nf">segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read-only list of :class:`Segment` objects.</span>

<span class="sd">        A :class:`SegmentGroup` of all segments that contain atoms in this group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;segments&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">:</span>
            <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">current_segment</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">segment</span> <span class="o">!=</span> <span class="n">current_segment</span><span class="p">:</span>
                    <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">segment</span><span class="p">)</span>
                <span class="n">current_segment</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">segment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;segments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SegmentGroup</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;segments&#39;</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="AtomGroup.segids"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.segids">[docs]</a>    <span class="k">def</span> <span class="nf">segids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of segment ids (=segment names).</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Returns a :class:`numpy.ndarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">])</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.bondDict"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.bondDict">[docs]</a>    <span class="k">def</span> <span class="nf">bondDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A :class:`MDAnalysis.topology.core.TopologyDict` of bonds </span>
<span class="sd">        within this AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;bonds&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">TopologyDict</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;bonds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">TopologyDict</span><span class="p">(</span><span class="s">&#39;bond&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;bonds&#39;</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.angleDict"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.angleDict">[docs]</a>    <span class="k">def</span> <span class="nf">angleDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A :class:`MDAnalysis.topology.core.TopologyDict` of angles </span>
<span class="sd">        within this AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>     
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;angles&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">TopologyDict</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;angles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">TopologyDict</span><span class="p">(</span><span class="s">&#39;angle&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;angles&#39;</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.torsionDict"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.torsionDict">[docs]</a>    <span class="k">def</span> <span class="nf">torsionDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A :class:`MDAnalysis.topology.core.TopologyDict` of angles </span>
<span class="sd">        within this AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>     
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;torsions&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">TopologyDict</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;torsions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">TopologyDict</span><span class="p">(</span><span class="s">&#39;torsion&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;torsions&#39;</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="AtomGroup.numberOfBondTypes"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.numberOfBondTypes">[docs]</a>    <span class="k">def</span> <span class="nf">numberOfBondTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of different bond types in this AtomGroup&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondDict</span><span class="p">)</span></div>
<div class="viewcode-block" id="AtomGroup.numberOfAngleTypes"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.numberOfAngleTypes">[docs]</a>    <span class="k">def</span> <span class="nf">numberOfAngleTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of different angle types in this AtomGroup&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angleDict</span><span class="p">)</span></div>
<div class="viewcode-block" id="AtomGroup.numberOfTorsionTypes"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.numberOfTorsionTypes">[docs]</a>    <span class="k">def</span> <span class="nf">numberOfTorsionTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of different torsions types in this AtomGroup&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">torsionDict</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.selectBonds"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.selectBonds">[docs]</a>    <span class="k">def</span> <span class="nf">selectBonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">criteria</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select all of a given bond, angle or torsion type from the </span>
<span class="sd">        AtomGroup.  This method makes use of the :class:`MDAnalysis.topology.core.TopologyDict`</span>
<span class="sd">        instances for this AtomGroup.</span>

<span class="sd">        Usage:: </span>
<span class="sd">          ag.selectBonds(criteria) </span>

<span class="sd">        *criteria* must match a key from the appropriate TopologyDict, </span>
<span class="sd">        viewable through the :meth:`MDAnalysis.topology.core.TopologyDict.keys` method.</span>
<span class="sd">        These keys are a tuple of the atom types in the bond.</span>

<span class="sd">        :Returns: a :class:`MDAnalysis.topology.core.TopologyGroup`</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">criteria</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondDict</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondDict</span><span class="p">[</span><span class="n">criteria</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">criteria</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">angleDict</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">angleDict</span><span class="p">[</span><span class="n">criteria</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">criteria</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">criteria</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">torsionDict</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">torsionDict</span><span class="p">[</span><span class="n">criteria</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="s">&quot;No bond exists of type &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">criteria</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="AtomGroup.masses"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.masses">[docs]</a>    <span class="k">def</span> <span class="nf">masses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array of atomic masses (as defined in the topology)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;masses&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;masses&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">mass</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cache</span><span class="p">[</span><span class="s">&#39;masses&#39;</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="AtomGroup.totalMass"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.totalMass">[docs]</a>    <span class="k">def</span> <span class="nf">totalMass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total mass of the selection (masses are taken from the topology or guessed).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.charges"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.charges">[docs]</a>    <span class="k">def</span> <span class="nf">charges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array of partial charges of the atoms (as defined in the topology)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="AtomGroup.totalCharge"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.totalCharge">[docs]</a>    <span class="k">def</span> <span class="nf">totalCharge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sum of all partial charges (must be defined in topology).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charges</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.radii"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.radii">[docs]</a>    <span class="k">def</span> <span class="nf">radii</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array of atomic radii (as defined in the PQR file)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">radius</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>

    <span class="c"># TODO release 0.8: make this a method again (in MDAnalysis 0.8)</span></div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.bfactors"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.bfactors">[docs]</a>    <span class="k">def</span> <span class="nf">bfactors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Crystallographic B-factors (from PDB) in A**2.</span>

<span class="sd">        .. deprecated:: 0.8</span>
<span class="sd">           This managed attribute will become a method in 0.8 in order to</span>
<span class="sd">           provide a unified interface to querying properties:</span>
<span class="sd">           :attr:`AtomGroup.bfactors` will become :meth:`AtomGroup.bfactors`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;AtomGroup.bfactors will become AtomGroup.bfactors() in MDAnalysis 0.8&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">bfactor</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span><span class="p">])</span>
</div>
    <span class="k">def</span> <span class="nf">_set_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set attribute *name* to *value* for all elements in *groupname*.</span>

<span class="sd">        *groupname* can be *atoms*, *residues*, *segments. ``getattr(self,</span>
<span class="sd">        groupname)`` should produce one of the groups in the hierarchy.</span>

<span class="sd">        If *value* is a sequence of the same length as the group then each</span>
<span class="sd">        element&#39;s attribute *name* is set to the corresponding value. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        group then a :exc:`ValueError` is raised.</span>

<span class="sd">        A cache entry ``__cache[groupname]`` is deleted if it exists.</span>

<span class="sd">        :Keywords:</span>

<span class="sd">          *conversion*</span>
<span class="sd">               function such as :func:`str` or :func:`int` that converts the</span>
<span class="sd">               argument. ``None`` passes it through unchanged [``None``]</span>

<span class="sd">          *cache*</span>
<span class="sd">               alternative identifier for the cache, instead of *groupname*</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupname</span><span class="p">)</span>
        <span class="n">conversion</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;conversion&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;cache&#39;</span><span class="p">,</span> <span class="n">groupname</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">conversion</span><span class="p">:</span>
            <span class="n">conversion</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conversion</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conversion</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;set_{0}: can only set all atoms to a single value or each atom to a distinct one &quot;</span>
                             <span class="s">&quot;but len(atoms)={1} whereas len(value)={2}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">groupname</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>

        <span class="c"># big hammer... if we find the time, use this in a more surgical fashion.</span>
        <span class="c">#self.atoms._rebuild_caches()</span>
        <span class="c">#if self.atoms is not self.universe.atoms:</span>
        <span class="c">#    self.universe.atoms._rebuild_caches()</span>

    <span class="k">def</span> <span class="nf">_set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set attribute *name* to *value* for all atoms in the :class:`AtomGroup`.</span>

<span class="sd">        If *value* is a sequence of the same length as the :class:`AtomGroup`</span>
<span class="sd">        then each :class:`Atom`&#39;s property *name* is set to the corresponding value. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_attribute</span><span class="p">(</span><span class="s">&quot;atoms&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c"># override for ResidueGroup, SegmentGroup accordingly</span>
    <span class="nb">set</span> <span class="o">=</span> <span class="n">_set_atoms</span>

<div class="viewcode-block" id="AtomGroup.set_name"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_name">[docs]</a>    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the atom name to string for *all atoms* in the AtomGroup.</span>

<span class="sd">        If *value* is a sequence of the same length as the :class:`AtomGroup`</span>
<span class="sd">        then each :attr:`Atom.name` is set to the corresponding value. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_resid"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_resid">[docs]</a>    <span class="k">def</span> <span class="nf">set_resid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the resid to integer *resid* for **all atoms** in the :class:`AtomGroup`.</span>

<span class="sd">        If *resid* is a sequence of the same length as the :class:`AtomGroup`</span>
<span class="sd">        then each :attr:`Atom.resid` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Residue.id` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Changing resids can change the topology.</span>

<span class="sd">           Assigning the same *resid* to multiple residues will</span>
<span class="sd">           **merge** these residues. Assigning different *resid* to</span>
<span class="sd">           atoms in the same residue will **split** a residue (and</span>
<span class="sd">           potentially merge with another one).</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.7.5</span>
<span class="sd">           Also changes the residues.</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a</span>
<span class="sd">           sequence or iterable and can change the topology via</span>
<span class="sd">           :func:`MDAnalysis.topology.core.build_residues`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">build_residues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;resid&quot;</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c"># Note that this also automagically updates THIS AtomGroup;</span>
        <span class="c"># the side effect of build_residues(self.atoms) is to update all Atoms!!!!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">(</span><span class="s">&#39;residues&#39;</span><span class="p">,</span> <span class="n">build_residues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span>
        <span class="c"># make sure to update the whole universe: the Atoms are shared but ResidueGroups are not</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">(</span><span class="s">&#39;residues&#39;</span><span class="p">,</span> <span class="n">build_residues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_resnum"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_resnum">[docs]</a>    <span class="k">def</span> <span class="nf">set_resnum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resnum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the resnum to *resnum* for **all atoms** in the :class:`AtomGroup`.</span>

<span class="sd">        If *resnum* is a sequence of the same length as the :class:`AtomGroup`</span>
<span class="sd">        then each :attr:`Atom.resnum` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Residue.resnum` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Changing *resnum* will not affect the topology: you can have</span>
<span class="sd">           multiple residues with the same *resnum*.</span>

<span class="sd">        .. SeeAlso:: :meth:`set_resid`</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.7.5</span>
<span class="sd">           Also changes the residues.</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">build_residues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;resnum&quot;</span><span class="p">,</span> <span class="n">resnum</span><span class="p">)</span>
        <span class="c"># build_residues() is the easiest (though expensive) way to make sure</span>
        <span class="c"># that all residues get their new resnum. There&#39;s no easy way to parse</span>
        <span class="c"># a per-atom resnum list (with potential duplicates) into a list of</span>
        <span class="c"># corresponding residues.</span>
        <span class="c">#</span>
        <span class="c"># (This comment applies to the analogous methods below as well.)</span>
        <span class="n">build_residues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_resname"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_resname">[docs]</a>    <span class="k">def</span> <span class="nf">set_resname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the resname to string *resname* for **all atoms** in the :class:`AtomGroup`.</span>

<span class="sd">        If *resname* is a sequence of the same length as the :class:`AtomGroup`</span>
<span class="sd">        then each :attr:`Atom.resname` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Residue.name` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.7.5</span>
<span class="sd">           Also changes the residues.</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">build_residues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;resname&quot;</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
        <span class="n">build_residues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_segid"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_segid">[docs]</a>    <span class="k">def</span> <span class="nf">set_segid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segid</span><span class="p">,</span> <span class="n">buildsegments</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the segid to *segid* for all atoms in the :class:`AtomGroup`.</span>

<span class="sd">        If *segid* is a sequence of the same length as the :class:`AtomGroup`</span>
<span class="sd">        then each :attr:`Atom.segid` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Segment.id` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           :meth:`set_segid` can change the topology.</span>

<span class="sd">           With the default *buildsegments* = ``True`` it can be used to join</span>
<span class="sd">           segments or to break groups into multiple disjoint segments. Note</span>
<span class="sd">           that each :class:`Atom` can only belong to a single</span>
<span class="sd">           :class:`Segment`.</span>

<span class="sd">        For performance reasons, *buildsegments* can be set to ``False``. Then</span>
<span class="sd">        one needs to run :meth:`Universe._build_segments` manually later in</span>
<span class="sd">        order to update the list of :class:`Segment` instances and regenerate</span>
<span class="sd">        the segid instant selectors.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;segid&quot;</span><span class="p">,</span> <span class="n">segid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;segments&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">buildsegments</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_build_segments</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># do not even update the local segment</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">_clear_caches</span><span class="p">(</span><span class="s">&#39;segments&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_mass"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_mass">[docs]</a>    <span class="k">def</span> <span class="nf">set_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the atom mass to float *mass* for **all atoms** in the AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;mass&quot;</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="s">&quot;masses&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_type"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_type">[docs]</a>    <span class="k">def</span> <span class="nf">set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the atom type to *atype* for **all atoms** in the AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">,</span> <span class="n">atype</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_charge"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_charge">[docs]</a>    <span class="k">def</span> <span class="nf">set_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">charge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the partial charge to float *charge* for **all atoms** in the AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;charge&quot;</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_radius"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_radius">[docs]</a>    <span class="k">def</span> <span class="nf">set_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the atom radius to float *radius* for **all atoms** in the AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;radius&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_bfactor"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_bfactor">[docs]</a>    <span class="k">def</span> <span class="nf">set_bfactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bfactor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the atom bfactor to float *bfactor* for **all atoms** in the AtomGroup.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;bfactor&quot;</span><span class="p">,</span> <span class="n">bfactor</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.centerOfGeometry"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.centerOfGeometry">[docs]</a>    <span class="k">def</span> <span class="nf">centerOfGeometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Center of geometry (also known as centroid) of the selection.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">()</span></div>
    <span class="n">centroid</span> <span class="o">=</span> <span class="n">centerOfGeometry</span>

<div class="viewcode-block" id="AtomGroup.centerOfMass"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.centerOfMass">[docs]</a>    <span class="k">def</span> <span class="nf">centerOfMass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Center of mass of the selection.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">()[:,</span><span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">totalMass</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="AtomGroup.radiusOfGyration"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.radiusOfGyration">[docs]</a>    <span class="k">def</span> <span class="nf">radiusOfGyration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Radius of gyration.&quot;&quot;&quot;</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">()</span>
        <span class="n">recenteredpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">()</span>
        <span class="n">rog_sq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masses</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">totalMass</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rog_sq</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.shapeParameter"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.shapeParameter">[docs]</a>    <span class="k">def</span> <span class="nf">shapeParameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shape parameter.</span>

<span class="sd">        See [Dima2004]_ for background information.</span>

<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">()</span>
        <span class="n">recenteredpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">()</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">recenteredpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">tensor</span> <span class="o">+=</span> <span class="n">masses</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">,:],</span>
                                              <span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">,:])</span>
        <span class="n">tensor</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">totalMass</span><span class="p">()</span>
        <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="mf">27.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">eig_vals</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">))</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shape</span>
</div>
<div class="viewcode-block" id="AtomGroup.asphericity"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.asphericity">[docs]</a>    <span class="k">def</span> <span class="nf">asphericity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Asphericity.</span>

<span class="sd">        See [Dima2004]_ for background information.</span>

<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">()</span>
        <span class="n">recenteredpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">()</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">recenteredpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">tensor</span> <span class="o">+=</span> <span class="n">masses</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">,:],</span>
                                              <span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">,:])</span>
        <span class="n">tensor</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">totalMass</span><span class="p">()</span>
        <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">eig_vals</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shape</span>
</div>
<div class="viewcode-block" id="AtomGroup.momentOfInertia"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.momentOfInertia">[docs]</a>    <span class="k">def</span> <span class="nf">momentOfInertia</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tensor of inertia as 3x3 NumPy array.&quot;&quot;&quot;</span>
        <span class="c"># Convert to local coordinates</span>
        <span class="n">recenteredpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfMass</span><span class="p">()</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">()</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">masses</span><span class="p">,</span> <span class="n">recenteredpos</span><span class="p">)</span>
        <span class="c"># Create the inertia tensor</span>
        <span class="c"># m_i = mass of atom i</span>
        <span class="c"># (x_i, y_i, z_i) = pos of atom i</span>
        <span class="c"># Ixx = sum(m_i*(y_i^2+z_i^2)); Iyy = sum(m_i*(x_i^2+z_i^2)); Izz = sum(m_i*(x_i^2+y_i^2))</span>
        <span class="c"># Ixy = Iyx = -1*sum(m_i*x_i*y_i)</span>
        <span class="c"># Ixz = Izx = -1*sum(m_i*x_i*z_i)</span>
        <span class="c"># Iyz = Izy = -1*sum(m_i*y_i*z_i)</span>
        <span class="n">Ixx</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span><span class="n">a</span><span class="p">:</span> <span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span> <span class="n">values</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">Iyy</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span><span class="n">a</span><span class="p">:</span> <span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span> <span class="n">values</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">Izz</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span><span class="n">a</span><span class="p">:</span> <span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">values</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">Ixy</span> <span class="o">=</span> <span class="n">Iyx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span><span class="n">a</span><span class="p">:</span> <span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">values</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">Ixz</span> <span class="o">=</span> <span class="n">Izx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span><span class="n">a</span><span class="p">:</span> <span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">values</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">Iyz</span> <span class="o">=</span> <span class="n">Izy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span><span class="n">a</span><span class="p">:</span> <span class="n">t</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">values</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">Ixx</span><span class="p">,</span> <span class="n">Ixy</span><span class="p">,</span> <span class="n">Ixz</span><span class="p">],[</span><span class="n">Iyx</span><span class="p">,</span> <span class="n">Iyy</span><span class="p">,</span> <span class="n">Iyz</span><span class="p">],[</span><span class="n">Izx</span><span class="p">,</span> <span class="n">Izy</span><span class="p">,</span> <span class="n">Izz</span><span class="p">]])</span>
</div>
<div class="viewcode-block" id="AtomGroup.bbox"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.bbox">[docs]</a>    <span class="k">def</span> <span class="nf">bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bounding box of the selection.</span>

<span class="sd">        The lengths A,B,C of the orthorhombic enclosing box are ::</span>

<span class="sd">          L = AtomGroup.bbox()</span>
<span class="sd">          A,B,C = L[1] - L[0]</span>

<span class="sd">        :Returns: [[xmin, ymin, zmin], [xmax, ymax, zmax]]</span>

<span class="sd">        .. versionadded:: 0.7.2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
</div>
<div class="viewcode-block" id="AtomGroup.bsphere"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.bsphere">[docs]</a>    <span class="k">def</span> <span class="nf">bsphere</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bounding sphere of the selection.</span>

<span class="sd">        The sphere is calculated relative to the centre of geometry.</span>

<span class="sd">        :Returns: `(R, [xcen,ycen,zcen])`</span>

<span class="sd">        .. versionadded:: 0.7.3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerOfGeometry</span><span class="p">()</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">centroid</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">centroid</span>
</div>
<div class="viewcode-block" id="AtomGroup.bond"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.bond">[docs]</a>    <span class="k">def</span> <span class="nf">bond</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the distance between atoms in a 2-atom group.</span>

<span class="sd">        Distance between atoms 0 and 1::</span>

<span class="sd">            0---1</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Only makes sense for a :class:`AtomGroup` with exactly 2</span>
<span class="sd">           :class:`Atom`; anything else will raise a</span>
<span class="sd">           :exc:`ValueError`.</span>

<span class="sd">        .. versionadded:: 0.7.3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;distance computation only makes sense for a group with exactly 2 atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.angle"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.angle">[docs]</a>    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the angle in degrees between atoms 0, 1, 2.</span>

<span class="sd">        Angle between atoms 0 and 2 with apex at 1::</span>

<span class="sd">              2</span>
<span class="sd">             /</span>
<span class="sd">            /</span>
<span class="sd">           1------0</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Only makes sense for a :class:`AtomGroup` with exactly 3</span>
<span class="sd">           :class:`Atom`; anything else will raise a :exc:`ValueError`.</span>

<span class="sd">        .. versionadded:: 0.7.3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;angle computation only makes sense for a group with exactly 3 atoms&quot;</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span>
                    <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span>
</div>
<div class="viewcode-block" id="AtomGroup.improper"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.improper">[docs]</a>    <span class="k">def</span> <span class="nf">improper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the improper dihedral between 4 atoms.</span>

<span class="sd">        The improper dihedral is calculated in the same way as the proper</span>
<span class="sd">        :meth:`dihedral`: The angle between the planes formed by atoms (0,1,2)</span>
<span class="sd">        and (1,2,3).</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Only makes sense for a :class:`AtomGroup` with exactly 4</span>
<span class="sd">           :class:`Atom`; anything else will raise a :exc:`ValueError`. The</span>
<span class="sd">           interpretation of the angle as an &quot;improper&quot; solely depends on the</span>
<span class="sd">           selection of atoms and thus the user input!</span>

<span class="sd">        .. versionadded:: 0.7.3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="AtomGroup.dihedral"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.dihedral">[docs]</a>    <span class="k">def</span> <span class="nf">dihedral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the dihedral angle in degrees.</span>

<span class="sd">        Dihedral angle around axis connecting atoms 1 and 2 (i.e. the angle</span>
<span class="sd">        between the planes spanned by atoms (0,1,2) and (1,2,3))::</span>

<span class="sd">                  3</span>
<span class="sd">                  |</span>
<span class="sd">            1-----2</span>
<span class="sd">           /</span>
<span class="sd">          0</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Only makes sense for a :class:`AtomGroup` with exactly 4</span>
<span class="sd">           :class:`Atom`; anything else will raise a :exc:`ValueError`.</span>

<span class="sd">        .. versionadded:: 0.7.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;dihedral computation only makes sense for a group with exactly 4 atoms&quot;</span><span class="p">)</span>

        <span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">B</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">C</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">C</span> <span class="o">-</span> <span class="n">D</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">dihedral</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="AtomGroup.principalAxes"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.principalAxes">[docs]</a>    <span class="k">def</span> <span class="nf">principalAxes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the principal axes from the moment of inertia.</span>

<span class="sd">        e1,e2,e3 = AtomGroup.principalAxes()</span>

<span class="sd">        The eigenvectors are sorted by eigenvalue, i.e. the first one</span>
<span class="sd">        corresponds to the highest eigenvalue and is thus the first principal axes.</span>

<span class="sd">        :Returns: numpy.array ``v`` with ``v[0]`` as first, ``v[1]`` as second,</span>
<span class="sd">                  and ``v[2]`` as third eigenvector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">eig</span>
        <span class="n">eigenval</span><span class="p">,</span> <span class="n">eigenvec</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">momentOfInertia</span><span class="p">())</span>
        <span class="c"># Sort</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">eigenval</span><span class="p">)</span>
        <span class="c"># Return transposed in more logical form. See Issue 33.</span>
        <span class="k">return</span> <span class="n">eigenvec</span><span class="p">[:,</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
</div>
<div class="viewcode-block" id="AtomGroup.get_positions"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.get_positions">[docs]</a>    <span class="k">def</span> <span class="nf">get_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a NumPy array of the coordinates.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *ts*</span>
<span class="sd">               If *ts* is provided then positions are read from that</span>
<span class="sd">               :class:`~MDAnalysis.coordinates.base.Timestep` instead of</span>
<span class="sd">               the one from the current trajectory belonging to this universe.</span>
<span class="sd">               The *ts* is indexed with the indices returned by</span>
<span class="sd">               :meth:`~AtomGroup.indices` and it is the user&#39;s responsibility</span>
<span class="sd">               to provide a time step that has the appropriate dimensions.</span>
<span class="sd">           *copy*</span>
<span class="sd">               ``True``: always make a copy (slow), ``False``: Try to</span>
<span class="sd">               return a array view or reference (faster); note that for</span>
<span class="sd">               passing coordinates to C-code it can be necessary to use</span>
<span class="sd">               a copy [``False``]</span>
<span class="sd">           *dtype*</span>
<span class="sd">               NumPy Data type of the array; the default is usually</span>
<span class="sd">               entirely appropriate. Most C-code actually requires the</span>
<span class="sd">               default  [:class:`numpy.float32`]</span>

<span class="sd">        Coordinates can also be directly obtained from the attribute</span>
<span class="sd">        :attr:`~AtomGroup.positions`.</span>

<span class="sd">        Coordinates can be directly set with :meth:`~AtomGroup.set_positions` or</span>
<span class="sd">        by assigning to :attr:`~AtomGroup.positions`.</span>

<span class="sd">        This method is identical with :meth:`~AtomGroup.coordinates` but named</span>
<span class="sd">        differently for symmetry with with :meth:`~AtomGroup.set_positions`.</span>

<span class="sd">        .. versionadded:: 0.7.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()],</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
</div>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">get_positions</span>
    <span class="sd">&quot;&quot;&quot;NumPy array of the coordinates.</span>

<span class="sd">    .. SeeAlso:: :attr:`~AtomGroup.positions` and :meth:`~AtomGroup.get_positions`</span>

<span class="sd">    .. deprecated:: 0.7.6</span>
<span class="sd">       In new scripts use :meth:`AtomGroup.get_positions` preferrably.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># coordinates() should NOT be removed as it has been used in many scripts,</span>
    <span class="c"># MDAnalysis itself, and in the paper</span>

<div class="viewcode-block" id="AtomGroup.set_positions"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_positions">[docs]</a>    <span class="k">def</span> <span class="nf">set_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the positions for all atoms in the group.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">           *coords*</span>
<span class="sd">               a Nx3 NumPy :class:`numpy.ndarray` where N is the number of</span>
<span class="sd">               atoms in this atom group.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *ts*</span>
<span class="sd">              :class:`~MDAnalysis.coordinates.base.Timestep`, defaults</span>
<span class="sd">              to ``None`` and then the current time step is used.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           If the group contains N atoms and *coord* is a single point (i.e. an</span>
<span class="sd">           array of length 3) then all N atom positions are set to *coord* (due</span>
<span class="sd">           to NumPy&#39;s broadcasting rules), as described for</span>
<span class="sd">           :attr:`~AtomGroup.positions`.</span>

<span class="sd">        See also :meth:`~AtomGroup.get_positions` and attribute access through</span>
<span class="sd">        :attr:`~AtomGroup.positions`.</span>

<span class="sd">        .. versionadded:: 0.7.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">(),:]</span> <span class="o">=</span> <span class="n">coords</span>
</div>
    <span class="n">positions</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_positions</span><span class="p">,</span> <span class="n">set_positions</span><span class="p">,</span>
                         <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">                Coordinates of the atoms in the AtomGroup.</span>

<span class="s">                The positions can be changed by assigning an array of the appropriate</span>
<span class="s">                shape, i.e. either Nx3 to assign individual coordinates or 3, to assign</span>
<span class="s">                the *same* coordinate to all atoms (e.g. ``ag.positions = array([0,0,0])``</span>
<span class="s">                will move all particles to the origin).</span>

<span class="s">                For more control use the :meth:`~AtomGroup.get_positions` and</span>
<span class="s">                :meth:`~AtomGroup.set_positions` methods.</span>

<span class="s">                .. versionadded:: 0.7.6&quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="AtomGroup.get_velocities"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.get_velocities">[docs]</a>    <span class="k">def</span> <span class="nf">get_velocities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NumPy array of the velocities.</span>

<span class="sd">        Raises a :exc:`NoDataError` if the underlying</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.base.Timestep` does not contain</span>
<span class="sd">        :attr:`~MDAnalysis.coordinates.base.Timestep._velocities`.</span>

<span class="sd">        See also :meth:`AtomGroup.set_velocities` and attribute access through</span>
<span class="sd">        :attr:`AtomGroup.velocities`.</span>

<span class="sd">        .. versionadded:: 0.7.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()],</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain velocities&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_velocities"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_velocities">[docs]</a>    <span class="k">def</span> <span class="nf">set_velocities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign the velocities *v* to the timestep.</span>

<span class="sd">        Raises a :exc:`NoDataError` if the underlying</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.base.Timestep` does not contain</span>
<span class="sd">        :attr:`~MDAnalysis.coordinates.base.Timestep._velocities`.</span>

<span class="sd">        See also :meth:`AtomGroup.get_velocities` and :attr:`AtomGroup.velocities` for</span>
<span class="sd">        attribute access.</span>

<span class="sd">        .. versionadded:: 0.7.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">_velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">(),</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain velocities&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.velocities"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.velocities">[docs]</a>    <span class="k">def</span> <span class="nf">velocities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NumPy array of the velocities of the atoms in the group.</span>

<span class="sd">        If the trajectory does not contain velocity information then a</span>
<span class="sd">        :exc:`~MDAnalysis.NoDataError` is raised.</span>

<span class="sd">        .. versionadded:: 0.7.5</span>
<span class="sd">        .. deprecated:: 0.7.6</span>
<span class="sd">           In 0.8 this will become an attribute! You can already use :meth:`get_velocities`</span>
<span class="sd">           and :meth:`set_velocities`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;velocities() will become an attribute &#39;velocities&#39; in 0.8&quot;</span><span class="p">,</span>
                      <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_velocities</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c"># TODO for 0.8</span>
    <span class="c">#velocities = property(get_velocities, set_velocities, doc=&quot;velocities of the atoms\n\n.. versionchanged:: 0.8&quot;)</span>

</div>
<div class="viewcode-block" id="AtomGroup.get_forces"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.get_forces">[docs]</a>    <span class="k">def</span> <span class="nf">get_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a NumPy array of the atomic forces (if available).</span>
<span class="sd">        Currently only supported for Gromacs .trr trajectories.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *ts*</span>
<span class="sd">               If *ts* is provided then positions are read from that</span>
<span class="sd">               :class:`~MDAnalysis.coordinates.base.Timestep` instead of</span>
<span class="sd">               the one from the current trajectory belonging to this universe.</span>
<span class="sd">               The *ts* is indexed with the indices returned by</span>
<span class="sd">               :meth:`~AtomGroup.indices` and it is the user&#39;s responsibility</span>
<span class="sd">               to provide a time step that has the appropriate dimensions.</span>
<span class="sd">           *copy*</span>
<span class="sd">               ``True``: always make a copy (slow), ``False``: Try to</span>
<span class="sd">               return a array view or reference (faster); note that for</span>
<span class="sd">               passing coordinates to C-code it can be necessary to use</span>
<span class="sd">               a copy [``False``]</span>
<span class="sd">           *dtype*</span>
<span class="sd">               NumPy Data type of the array; the default is usually</span>
<span class="sd">               entirely appropriate. Most C-code actually requires the</span>
<span class="sd">               default  [:class:`numpy.float32`]</span>

<span class="sd">        Forces can also be directly obtained from the attribute</span>
<span class="sd">        :attr:`~AtomGroup.forces`.</span>

<span class="sd">        Forces can be directly set with :meth:`~AtomGroup.set_forces` or</span>
<span class="sd">        by assigning to :attr:`~AtomGroup.forces`.</span>

<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()],</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain forces&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.set_forces"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.set_forces">[docs]</a>    <span class="k">def</span> <span class="nf">set_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forces</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the forces for all atoms in the group.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">           *forces*</span>
<span class="sd">               a Nx3 NumPy :class:`numpy.ndarray` where N is the number of</span>
<span class="sd">               atoms in this atom group.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *ts*</span>
<span class="sd">              :class:`~MDAnalysis.coordinates.base.Timestep`, defaults</span>
<span class="sd">              to ``None`` and then the current time step is used.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           If the group contains N atoms and *force* is a single point (i.e. an</span>
<span class="sd">           array of length 3) then all N atom positions are set to *force* (due</span>
<span class="sd">           to NumPy&#39;s broadcasting rules), as described for</span>
<span class="sd">           :attr:`~AtomGroup.forces`.</span>

<span class="sd">        See also :meth:`~AtomGroup.get_forces` and attribute access through</span>
<span class="sd">        :attr:`~AtomGroup.forces`.</span>

<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">_forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">(),</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">forces</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s">&quot;Timestep does not contain forces&quot;</span><span class="p">)</span>
</div>
    <span class="n">forces</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_forces</span><span class="p">,</span> <span class="n">set_forces</span><span class="p">,</span>
                         <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">                Forces on the atoms in the AtomGroup.</span>

<span class="s">                The forces can be changed by assigning an array of the appropriate</span>
<span class="s">                shape, i.e. either Nx3 to assign individual force or 3, to assign</span>
<span class="s">                the *same* force to all atoms (e.g. ``ag.forces = array([0,0,0])``</span>
<span class="s">                will set all forces to (0.,0.,0.)).</span>

<span class="s">                For more control use the :meth:`~AtomGroup.get_forces` and</span>
<span class="s">                :meth:`~AtomGroup.set_forces` methods.</span>

<span class="s">                .. versionadded:: 0.7.7&quot;&quot;&quot;</span><span class="p">)</span>



<div class="viewcode-block" id="AtomGroup.transform"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply homogenous transformation matrix *M* to the coordinates.</span>

<span class="sd">        The matrix *M* must be a 4x4 matrix, with the rotation in</span>
<span class="sd">        ``M[:3,:3]`` and the translation in ``M[:3,3]``.</span>

<span class="sd">        The rotation is applied before the translation::</span>

<span class="sd">           x&#39; = R.x + t</span>

<span class="sd">        .. SeeAlso: :mod:`MDAnalysis.core.transformations`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="c"># changes the coordinates (in place)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">_pos</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>
        <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>  <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">t</span>
        <span class="k">return</span> <span class="n">R</span>
</div>
<div class="viewcode-block" id="AtomGroup.translate"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply translation vector *t* to the selection&#39;s coordinates.</span>

<span class="sd">          &gt;&gt;&gt; AtomGroup.translate(t)</span>
<span class="sd">          &gt;&gt;&gt; AtomGroup.translate((A, B))</span>

<span class="sd">        The method applies a translation to the AtomGroup from current</span>
<span class="sd">        coordinates x to new coordinates x&#39;::</span>

<span class="sd">            x&#39; = x + t</span>

<span class="sd">        The translation can also be given as a tuple of two MDAnalysis objects</span>
<span class="sd">        such as two selections `(selA, selB)`, i.e. two :class:`AtomGroup`, or</span>
<span class="sd">        two :class:`Atom`. The translation vector is computed as the</span>
<span class="sd">        difference between the centers of geometry (centroid) of B and A::</span>

<span class="sd">            t = B.centroid() - A.centroid()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sel1</span><span class="p">,</span><span class="n">sel2</span> <span class="o">=</span> <span class="n">t</span>
            <span class="n">x1</span><span class="p">,</span><span class="n">x2</span> <span class="o">=</span> <span class="n">sel1</span><span class="o">.</span><span class="n">centroid</span><span class="p">(),</span> <span class="n">sel2</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="c"># changes the coordinates (in place)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()]</span> <span class="o">+=</span> <span class="n">vector</span>
        <span class="k">return</span> <span class="n">vector</span>
</div>
<div class="viewcode-block" id="AtomGroup.rotate"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a rotation matrix *R* to the selection&#39;s coordinates.</span>

<span class="sd">        AtomGroup.rotate(R)</span>

<span class="sd">        *R* is a 3x3 orthogonal matrix that transforms x --&gt; x&#39;:</span>

<span class="sd">            x&#39; = R.x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c"># changes the coordinates (in place)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">_pos</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>
        <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span>     <span class="c"># R.T acts to the left &amp; is broadcasted N times.</span>
        <span class="k">return</span> <span class="n">R</span>
</div>
<div class="viewcode-block" id="AtomGroup.rotateby"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.rotateby">[docs]</a>    <span class="k">def</span> <span class="nf">rotateby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a rotation to the selection&#39;s coordinates.</span>

<span class="sd">        AtomGroup.rotateby(angle,axis[,point])</span>

<span class="sd">        The transformation from current coordinates x to new coordinates x&#39; is</span>

<span class="sd">          x&#39; = R.(x-p) + p</span>

<span class="sd">        where R is the rotation by *angle* around the *axis* going through</span>
<span class="sd">        *point* p.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *angle*</span>
<span class="sd">             rotation angle in degrees</span>
<span class="sd">          *axis*</span>
<span class="sd">             rotation axis vector, a 3-tuple, list, or array, or a 2-tuple of</span>
<span class="sd">             two MDAnalysis objects from which the axis is calculated as the</span>
<span class="sd">             vector from the first to the second center of geometry.</span>
<span class="sd">          *point*</span>
<span class="sd">             point on the rotation axis; by default (``None``) the center of</span>
<span class="sd">             geometry of the selection is chosen, or, if *axis* is a tuple of</span>
<span class="sd">             selections, it defaults to the first point of the axis. *point*</span>
<span class="sd">             can be a 3-tuple, list, or array or a MDAnalysis object (in which</span>
<span class="sd">             case its :meth:`centroid` is used).</span>

<span class="sd">        :Returns: The 4x4 matrix which consists of the rotation matrix M[:3,:3]</span>
<span class="sd">                  and the translation vectort M[:3,3].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">transformations</span> <span class="kn">import</span> <span class="n">rotation_matrix</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sel1</span><span class="p">,</span><span class="n">sel2</span> <span class="o">=</span> <span class="n">axis</span>
            <span class="n">x1</span><span class="p">,</span><span class="n">x2</span> <span class="o">=</span> <span class="n">sel1</span><span class="o">.</span><span class="n">centroid</span><span class="p">(),</span> <span class="n">sel2</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">x1</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M</span>
</div>
<div class="viewcode-block" id="AtomGroup.align_principalAxis"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.align_principalAxis">[docs]</a>    <span class="k">def</span> <span class="nf">align_principalAxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Align principal axis with index *axis* with *vector*.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *axis*</span>
<span class="sd">            Index of the principal axis (0, 1, or 2), as produced by</span>
<span class="sd">            :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.principalAxes`.</span>
<span class="sd">          *vector*</span>
<span class="sd">            A 3D vector such as the z-axis (``[0,0,1]``); can be</span>
<span class="sd">            anything that looks like a list with three entries.</span>

<span class="sd">        To align the long axis of a channel (the first principal axis,</span>
<span class="sd">        i.e. *axis* = 0) with the z-axis::</span>

<span class="sd">          u.atoms.align_principalAxis(0, [0,0,1])</span>
<span class="sd">          u.atoms.write(&quot;aligned.pdb&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">transformations</span> <span class="kn">import</span> <span class="n">vecangle</span><span class="p">,</span> <span class="n">rotaxis</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principalAxes</span><span class="p">()[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">vecangle</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">vector</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">rotaxis</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
        <span class="c">#print &quot;principal[%d] = %r&quot; % (axis, p)</span>
        <span class="c">#print &quot;axis = %r, angle = %f deg&quot; % (ax, angle)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotateby</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AtomGroup.packintobox"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.packintobox">[docs]</a>    <span class="k">def</span> <span class="nf">packintobox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shift all atoms in this group to be within the primary unit cell.</span>

<span class="sd">        AtomGroup.packintobox([box])</span>

<span class="sd">        All atoms will be moved so that they lie between 0 and</span>
<span class="sd">        boxlength :math:`L_i` in all dimensions, i.e. the lower left</span>
<span class="sd">        corner of the simulation box is taken to be at (0,0,0):</span>

<span class="sd">        .. math::</span>
<span class="sd">           x_i&#39; = x_i - \left\lfloor \frac{x_i}{L_i} \right\rfloor</span>

<span class="sd">        The default is to take unit cell information from the</span>
<span class="sd">        underlying :class:`~MDAnalysis.coordinates.base.Timestep`</span>
<span class="sd">        instance. The optional argument *box* can be used to provide</span>
<span class="sd">        alternative unit cell information (in the MDAnalysis standard</span>
<span class="sd">        format ``[Lx, Ly, Lz, alpha, beta, gamma]``).</span>

<span class="sd">        .. Warning:: Currently only works with orthogonal boxes. See `Issue 136`_</span>

<span class="sd">        .. _Issue 136: https://code.google.com/p/mdanalysis/issues/detail?id=136</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">box</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="c">#Try and auto detect box dimensions</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="mf">90.</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span> <span class="c">#Check box is orthogonal</span>
                <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;This atomgroup does not belong to a Universe with an orthogonal box&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">box</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span> <span class="c">#Check that a box dimension isn&#39;t zero</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;One or more box dimensions is zero.  You can specify a boxsize with &#39;box=&#39;&quot;</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()]</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">coords</span><span class="o">/</span><span class="n">box</span><span class="p">)</span><span class="o">*</span><span class="n">box</span>
        <span class="c">#np.floor rounds down all numbers, ie floor(-0.1) = -1, floor(0.9) = 0</span>
</div>
<div class="viewcode-block" id="AtomGroup.selectAtoms"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.selectAtoms">[docs]</a>    <span class="k">def</span> <span class="nf">selectAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="o">*</span><span class="n">othersel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Selection of atoms using the MDAnalysis selection syntax.</span>

<span class="sd">        AtomGroup.selectAtoms(selection[,selection[,...]])</span>

<span class="sd">        .. SeeAlso:: :meth:`Universe.selectAtoms`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">Selection</span>     <span class="c"># can ONLY import in method, otherwise cyclical import!</span>
        <span class="n">atomgrp</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">Parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">othersel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">atomgrp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Generate a selection for each selection string</span>
            <span class="c">#atomselections = [atomgrp]</span>
            <span class="k">for</span> <span class="n">sel</span> <span class="ow">in</span> <span class="n">othersel</span><span class="p">:</span>
                <span class="n">atomgrp</span> <span class="o">=</span> <span class="n">atomgrp</span> <span class="o">+</span> <span class="n">Selection</span><span class="o">.</span><span class="n">Parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="c">#atomselections.append(Selection.Parser.parse(sel).apply(self))</span>
            <span class="c">#return tuple(atomselections)</span>
            <span class="k">return</span> <span class="n">atomgrp</span>
</div>
<div class="viewcode-block" id="AtomGroup.write"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;PDB&quot;</span><span class="p">,</span><span class="n">filenamefmt</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%(trjname)s</span><span class="s">_</span><span class="si">%(frame)d</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write AtomGroup to a file.</span>

<span class="sd">        AtomGroup.write(filename[,format])</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *filename*</span>
<span class="sd">               ``None``: create TRJNAME_FRAME.FORMAT from filenamefmt [``None``]</span>
<span class="sd">          *format*</span>
<span class="sd">                PDB, CRD, GRO; case-insensitive and can also be supplied as</span>
<span class="sd">                the filename extension [PDB]</span>
<span class="sd">          *filenamefmt*</span>
<span class="sd">                format string for default filename; use substitution tokens</span>
<span class="sd">                &#39;trjname&#39; and &#39;frame&#39; [&quot;%(trjname)s_%(frame)d&quot;]</span>
<span class="sd">          *bonds*</span>
<span class="sd">                how to handle bond information, especially relevant for PDBs</span>
<span class="sd">                [&quot;conect&quot;] - write only the CONECT records defined in the original</span>
<span class="sd">                file</span>
<span class="sd">                &quot;all&quot; - write out all bonds, both the original defined and those</span>
<span class="sd">                      guessed by MDAnalysis</span>
<span class="sd">                None  - do not write out bonds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">util</span>
        <span class="kn">import</span> <span class="nn">os.path</span>
        <span class="kn">import</span> <span class="nn">MDAnalysis.coordinates</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&quot;multiframe&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>  <span class="c"># for PDB, True makes little sense here</span>

        <span class="n">trj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span>    <span class="c"># unified trajectory API</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">trj</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">trjname</span><span class="p">,</span><span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">trj</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filenamefmt</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">()</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">ext</span><span class="o">=</span><span class="n">format</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span><span class="n">keep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">framewriter</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">framewriter</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>         <span class="c"># wants a atomgroup</span>
        <span class="n">framewriter</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>         <span class="c"># always close single frames (eg PDB writer writes END)</span>

    <span class="c"># TODO: This is _almost_ the same code as write() --- should unify!</span></div>
<div class="viewcode-block" id="AtomGroup.write_selection"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.write_selection">[docs]</a>    <span class="k">def</span> <span class="nf">write_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s">&quot;vmd&quot;</span><span class="p">,</span><span class="n">filenamefmt</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%(trjname)s</span><span class="s">_</span><span class="si">%(frame)d</span><span class="s">&quot;</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write AtomGroup selection to a file to be used in another programme.</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *filename*</span>
<span class="sd">                ``None``: create TRJNAME_FRAME.FORMAT from *filenamefmt*</span>
<span class="sd">          *format*</span>
<span class="sd">                output file format: VMD (tcl), PyMol (pml), Gromacs (ndx), CHARMM (str);</span>
<span class="sd">                can also be supplied as the filename extension. Case insensitive. [vmd]</span>
<span class="sd">          *filenamefmt*</span>
<span class="sd">                format string for default filename; use &#39;%(trjname)s&#39; and &#39;%(frame)s&#39;</span>
<span class="sd">                placeholders; the extension is set according to the *format*</span>
<span class="sd">                [&quot;%(trjname)s_%(frame)d&quot;]</span>
<span class="sd">          *kwargs*</span>
<span class="sd">                additional keywords are passed on to the appropriate</span>
<span class="sd">                :class:`~MDAnalysis.selections.base.SelectionWriter`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">util</span>
        <span class="kn">import</span> <span class="nn">os.path</span>
        <span class="kn">import</span> <span class="nn">MDAnalysis.selections</span>

        <span class="n">SelectionWriter</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">selections</span><span class="o">.</span><span class="n">get_writer</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">format</span><span class="p">)</span>

        <span class="n">trj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span>    <span class="c"># unified trajectory API</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">trj</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span>

        <span class="c"># get actual extension from the static class attribute</span>
        <span class="n">extension</span> <span class="o">=</span> <span class="n">SelectionWriter</span><span class="o">.</span><span class="n">ext</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">trjname</span><span class="p">,</span><span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">trj</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filenamefmt</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">()</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">ext</span><span class="o">=</span><span class="n">extension</span><span class="p">,</span><span class="n">keep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">writer</span> <span class="o">=</span> <span class="n">SelectionWriter</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>         <span class="c"># wants a atomgroup</span>

    <span class="c"># properties</span></div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.dimensions"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dimensions of the Universe to which the group belongs, at the current time step.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;This AtomGroup does not belong to a Universe with a dimension.&quot;</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AtomGroup.ts"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.ts">[docs]</a>    <span class="k">def</span> <span class="nf">ts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Temporary Timestep that contains the selection coordinates.</span>

<span class="sd">        A :class:`~MDAnalysis.coordinates.base.Timestep` instance,</span>
<span class="sd">        which can be passed to a trajectory writer.</span>

<span class="sd">        If :attr:`~AtomGroup.ts` is modified then these modifications</span>
<span class="sd">        will be present until the frame number changes (which</span>
<span class="sd">        typically happens when the underlying trajectory frame</span>
<span class="sd">        changes).</span>

<span class="sd">        It is not possible to assign a new</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.base.Timestep` to the</span>
<span class="sd">        :attr:`AtomGroup.ts` attribute; change attributes of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trj_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>  <span class="c"># original time step</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ts</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ts</span><span class="o">.</span><span class="n">frame</span> <span class="o">!=</span> <span class="n">trj_ts</span><span class="o">.</span><span class="n">frame</span><span class="p">:</span>
            <span class="c"># create a timestep of same type as the underlying trajectory</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">trj_ts</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">())</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">_unitcell</span> <span class="o">=</span> <span class="n">trj_ts</span><span class="o">.</span><span class="n">_unitcell</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">trj_ts</span><span class="o">.</span><span class="n">frame</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ts</span> <span class="o">=</span> <span class="n">ts</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ts</span>
</div></div>
<div class="viewcode-block" id="Residue"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Residue">[docs]</a><span class="k">class</span> <span class="nc">Residue</span><span class="p">(</span><span class="n">AtomGroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A group of atoms corresponding to a residue.</span>

<span class="sd">    Pythonic access to atoms:</span>
<span class="sd">      - Using a atom name as attribute returns the matching atom (a</span>
<span class="sd">        :class:`Atom` instance), i.e. ``r.name``. Example::</span>

<span class="sd">          &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF,DCD</span>
<span class="sd">          &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">          &gt;&gt;&gt; print(u.s4AKE.r1.CA)  # C-alpha of M1</span>
<span class="sd">          &lt; Atom 5: name &#39;CA&#39; of type &#39;22&#39; of resname &#39;MET&#39;, resid 1 and segid &#39;4AKE&#39;&gt;</span>

<span class="sd">      - ``r[&#39;name&#39;]`` or ``r[id]`` - returns the atom corresponding to that name</span>

<span class="sd">    :Data:</span>
<span class="sd">      :attr:`Residue.name`</span>
<span class="sd">        Three letter residue name.</span>
<span class="sd">      :attr:`Residue.id`</span>
<span class="sd">        Numeric (integer) resid, taken from the topology.</span>
<span class="sd">      :attr:`Residue.resnum`</span>
<span class="sd">        Numeric canonical residue id (e.g. as used in the PDB structure).</span>

<span class="sd">    .. Note::</span>

<span class="sd">       Creating a :class:`Residue` modifies the underlying :class:`Atom`</span>
<span class="sd">       instances. Each :class:`Atom` can only belong to a single</span>
<span class="sd">       :class:`Residue`.</span>

<span class="sd">    .. versionchanged:: 0.7.4</span>
<span class="sd">       Added :attr:`Residue.resnum` attribute and *resnum* keyword argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">## FIXME (see below, Issue 70)</span>
    <span class="c">##__cache = {}</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">resnum</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Residue</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="k">if</span> <span class="n">resnum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span> <span class="o">=</span> <span class="n">resnum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>   <span class="c"># TODO: get resnum from topologies that support it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
            <span class="n">a</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">a</span><span class="o">.</span><span class="n">resnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnum</span>
            <span class="n">a</span><span class="o">.</span><span class="n">residue</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c"># Should I cache the positions of atoms within a residue?</span>
        <span class="c"># FIXME: breaks when termini are used to populate the cache; termini typically</span>
        <span class="c">#        have the SAME residue name but different atoms!!! Issue 70</span>
        <span class="c">##if not Residue.__cache.has_key(name):</span>
        <span class="c">##    Residue.__cache[name] = dict([(a.name, i) for i, a in enumerate(self._atoms)])</span>

<div class="viewcode-block" id="Residue.phi_selection"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Residue.phi_selection">[docs]</a>    <span class="k">def</span> <span class="nf">phi_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the phi protein backbone dihedral C&#39;-N-CA-C.</span>

<span class="sd">        :Returns: 4-atom selection in the correct order.  If no C&#39;</span>
<span class="sd">                  found in the previous residue (by resid) then this</span>
<span class="sd">                  method returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span>
                <span class="s">&#39;segid </span><span class="si">%s</span><span class="s"> and resid </span><span class="si">%d</span><span class="s"> and name C&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">CA</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">SelectionError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Residue.psi_selection"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Residue.psi_selection">[docs]</a>    <span class="k">def</span> <span class="nf">psi_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the psi protein backbone dihedral N-CA-C-N&#39;.</span>

<span class="sd">        :Returns: 4-atom selection in the correct order.  If no N&#39;</span>
<span class="sd">                  found in the following residue (by resid) then this</span>
<span class="sd">                  method returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">CA</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span>
                <span class="s">&#39;segid </span><span class="si">%s</span><span class="s"> and resid </span><span class="si">%d</span><span class="s"> and name N&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">SelectionError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Residue.omega_selection"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Residue.omega_selection">[docs]</a>    <span class="k">def</span> <span class="nf">omega_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the omega protein backbone dihedral CA-C-N&#39;-CA&#39;.</span>

<span class="sd">        omega describes the -C-N- peptide bond. Typically, it is trans</span>
<span class="sd">        (180 degrees) although cis-bonds (0 degrees) are also</span>
<span class="sd">        occasionally observed (especially near Proline).</span>

<span class="sd">        :Returns: 4-atom selection in the correct order.  If no C&#39;</span>
<span class="sd">                  found in the previous residue (by resid) then this</span>
<span class="sd">                  method returns ``None``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nextres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">segid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">id</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">CA</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">+</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">selectAtoms</span><span class="p">(</span>
                <span class="s">&#39;segid </span><span class="si">%s</span><span class="s"> and resid </span><span class="si">%d</span><span class="s"> and name N&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">segid</span><span class="p">,</span> <span class="n">nextres</span><span class="p">),</span>
                <span class="s">&#39;segid </span><span class="si">%s</span><span class="s"> and resid </span><span class="si">%d</span><span class="s"> and name CA&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">segid</span><span class="p">,</span> <span class="n">nextres</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">SelectionError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Residue.chi1_selection"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Residue.chi1_selection">[docs]</a>    <span class="k">def</span> <span class="nf">chi1_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the chi1 sidechain dihedral N-CA-CB-CG.</span>

<span class="sd">        :Returns: 4-atom selection in the correct order.  If no CB and/or CG is</span>
<span class="sd">                  found then this method returns ``None``.</span>

<span class="sd">        .. versionadded:: 0.7.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">CA</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">CB</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">CG</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">SelectionError</span><span class="p">,</span> <span class="n">NoDataError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return :class:`Atom` (index) or :class:`AtomGroup` (slicing).</span>

<span class="sd">        .. versionchanged:: 0.8 slicing/advanced slicing returns :class:`AtomGroup`, not just :class:`list`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">container</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="n">AtomGroup</span>
        <span class="c"># consistent with the way list indexing/slicing behaves:</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">container</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">container</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="c"># advanced slicing, requires array or list</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">([</span><span class="n">container</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">item</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c"># There can only be one atom with a certain name</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">atom</span>
        <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="s">&quot;No atom in residue &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&quot; with name &quot;</span><span class="o">+</span><span class="n">name</span><span class="p">)</span>
        <span class="c"># Use the cache</span>
        <span class="c">## FIXME (see above, __cache, Issue 70)</span>
        <span class="c">##try:</span>
        <span class="c">##    index = Residue.__cache[self.name][name]</span>
        <span class="c">##    return self._atoms[index]</span>
        <span class="c">##except KeyError:</span>
        <span class="c">##    raise SelectionError(&quot;No atom in residue &quot;+self.name+&quot; with name &quot;+name)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&lt;&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;, &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;&gt;&#39;</span>
</div>
<div class="viewcode-block" id="ResidueGroup"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.ResidueGroup">[docs]</a><span class="k">class</span> <span class="nc">ResidueGroup</span><span class="p">(</span><span class="n">AtomGroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A group of residues.</span>

<span class="sd">    Pythonic access to atoms:</span>
<span class="sd">      - Using a atom name as attribute returns a list of all atoms (a</span>
<span class="sd">        :class:`AtomGroup`) of the same name. Example::</span>

<span class="sd">          &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF,DCD</span>
<span class="sd">          &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">          &gt;&gt;&gt; print(u.s4AKE.MET.CA)  # C-alpha of all Met</span>
<span class="sd">          &lt;AtomGroup with 6 atoms&gt;</span>

<span class="sd">    :Data: :attr:`ResidueGroup._residues`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_containername</span> <span class="o">=</span> <span class="s">&quot;_residues&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">residues</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the ResidueGroup with a list of :class:`Residue` instances.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_residues</span> <span class="o">=</span> <span class="n">residues</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResidueGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set attribute *name* to *value* for all residues in the :class:`ResidueGroup`.</span>

<span class="sd">        If *value* is a sequence of the same length as the</span>
<span class="sd">        :class:`ResidueGroup` (:attr:`AtomGroup.residues`) then each</span>
<span class="sd">        :class:`Residue`&#39;s property *name* is set to the corresponding</span>
<span class="sd">        value. If *value* is neither of length 1 (or a scalar) nor of the</span>
<span class="sd">        length of the :class:`ResidueGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. versionadded:: 0.7.5</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_atoms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">r</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                <span class="n">r</span><span class="o">.</span><span class="n">_set_atoms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;set_residues: can only set all atoms to a single value or each atom to a distinct one &quot;</span>
                             <span class="s">&quot;but len(residues)={0} whereas len(value)={1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span>

        <span class="c"># also fix self --- otherwise users will get confused if the changes are not reflected in the</span>
        <span class="c"># object they are currently using (it works automatically for AtomGroup but not higher order groups)</span>
        <span class="c">#</span>
        <span class="c"># This is a hack to be able to set properties on Atom and Residue</span>
        <span class="c"># instances where they have different names</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;resname&#39;</span><span class="p">:</span> <span class="s">&#39;name&#39;</span><span class="p">,</span>
                <span class="s">&#39;resid&#39;</span><span class="p">:</span> <span class="s">&#39;id&#39;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">values</span><span class="p">)):</span>
            <span class="n">attrname</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">attrname</span><span class="p">):</span>         <span class="c"># should use __slots__ on Residue and try/except here</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nb">set</span> <span class="o">=</span> <span class="n">_set_residues</span>

<div class="viewcode-block" id="ResidueGroup.set_resid"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.ResidueGroup.set_resid">[docs]</a>    <span class="k">def</span> <span class="nf">set_resid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the resid to integer *resid* for **all residues** in the :class:`ResidueGroup`.</span>

<span class="sd">        If *resid* is a sequence of the same length as the :class:`ResidueGroup`</span>
<span class="sd">        then each :attr:`Atom.resid` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Residue.id` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Changing resids can change the topology.</span>

<span class="sd">           Assigning the same *resid* to multiple residues will **merge** these</span>
<span class="sd">           residues. The new residue name will be the name of the first old</span>
<span class="sd">           residue in the merged residue.</span>

<span class="sd">        .. Warning::</span>

<span class="sd">           The values of *this* :class:`ResidueGroup` are not being</span>
<span class="sd">           changed. You **must create a new :class:`ResidueGroup` from the</span>
<span class="sd">           :class:`Universe`** --- only :class:`Atom` instances are changed,</span>
<span class="sd">           everything else is derived from these atoms.</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">build_residues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;resid&#39;</span><span class="p">,</span> <span class="n">resid</span><span class="p">)</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="n">build_residues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="c"># update THIS residue group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">_residues</span> <span class="o">=</span> <span class="n">residues</span>
        <span class="c"># make sure to update the whole universe: the Atoms are shared but ResidueGroups are not</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">(</span><span class="s">&#39;residues&#39;</span><span class="p">,</span> <span class="n">build_residues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="ResidueGroup.set_resnum"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.ResidueGroup.set_resnum">[docs]</a>    <span class="k">def</span> <span class="nf">set_resnum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resnum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the resnum to *resnum* for **all residues** in the :class:`ResidueGroup`.</span>

<span class="sd">        If *resnum* is a sequence of the same length as the :class:`ResidueGroup`</span>
<span class="sd">        then each :attr:`Atom.resnum` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Residue.resnum` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Changing *resnum* will not affect the topology: you can have</span>
<span class="sd">           multiple residues with the same *resnum*.</span>

<span class="sd">        .. SeeAlso:: :meth:`set_resid`</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.7.5</span>
<span class="sd">           Also changes the residues.</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;resnum&quot;</span><span class="p">,</span> <span class="n">resnum</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ResidueGroup.set_resname"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.ResidueGroup.set_resname">[docs]</a>    <span class="k">def</span> <span class="nf">set_resname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the resname to string *resname* for **all residues** in the :class:`ResidueGroup`.</span>

<span class="sd">        If *resname* is a sequence of the same length as the :class:`ResidueGroup`</span>
<span class="sd">        then each :attr:`Atom.resname` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Residue.name` of the residue the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.7.5</span>
<span class="sd">           Also changes the residues.</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;resname&quot;</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

    <span class="c"># All other AtomGroup.set_xxx() methods should just work as</span>
    <span class="c"># ResidueGroup.set_xxx() because we overrode self.set(); the ones above</span>
    <span class="c"># where kept separate because we can save a call to build_residues()</span>
    <span class="c"># because there is no ambiguity as which residues are changed.</span>

</div>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_residues</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_residues</span><span class="p">)</span>

<span class="c">#    def __getitem__(self, item):</span>
<span class="c">#        if numpy.dtype(type(item)) == numpy.dtype(int) or type(item) == slice:</span>
<span class="c">#            return self._residues[item]</span>
<span class="c">#        else:</span>
<span class="c">#            raise TypeError(&quot;Residue group indices must be int or a slice, not %s.&quot; % type(item))</span>


    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="n">atomlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">attr</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&lt;&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_residues</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;&gt;&#39;</span>
</div>
<div class="viewcode-block" id="Segment"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Segment">[docs]</a><span class="k">class</span> <span class="nc">Segment</span><span class="p">(</span><span class="n">ResidueGroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A group of residues corresponding to one segment of the topology.</span>

<span class="sd">    Pythonic access to residues:</span>

<span class="sd">      - The attribute rN returns the N-th residue :class:`Residue` of the</span>
<span class="sd">        segment (numbering starts at N=1). Example::</span>

<span class="sd">          &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF,DCD</span>
<span class="sd">          &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">          &gt;&gt;&gt; print(u.s4AKE.r1)</span>
<span class="sd">          &lt;Residue &#39;MET&#39;, 1&gt;</span>

<span class="sd">      - Using a residue name as attribute returns a list of all residues (a</span>
<span class="sd">        :class:`ResidueGroup`) of the same name. Example::</span>

<span class="sd">          &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF,DCD</span>
<span class="sd">          &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">          &gt;&gt;&gt; print(u.s4AKE.CYS)</span>
<span class="sd">          &lt;ResidueGroup [&lt;Residue &#39;CYS&#39;, 77&gt;]&gt;</span>
<span class="sd">          &gt;&gt;&gt; print(u.s4AKE.MET)</span>
<span class="sd">          &lt;ResidueGroup [&lt;Residue &#39;MET&#39;, 1&gt;, &lt;Residue &#39;MET&#39;, 21&gt;, &lt;Residue &#39;MET&#39;, 34&gt;, &lt;Residue &#39;MET&#39;, 53&gt;, &lt;Residue &#39;MET&#39;, 96&gt;, &lt;Residue &#39;MET&#39;, 174&gt;]&gt;</span>

<span class="sd">    :Data: :attr:`Segment.name` is the segid from the topology or the</span>
<span class="sd">           chain identifier when loaded from a PDB</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">residues</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a Segment with segid *name* from a list of :class:`Residue` instances.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residues</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Segment.id"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Segment.id">[docs]</a>    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Segment id (alias for :attr:`Segment.name`)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</div>
    <span class="nd">@id.setter</span>
<div class="viewcode-block" id="Segment.id_setter"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Segment.id_setter">[docs]</a>    <span class="k">def</span> <span class="nf">id_setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">x</span>
</div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return :class:`Residue` (index) or :class:`ResidueGroup` (slicing).</span>

<span class="sd">        .. versionchanged:: 0.8 slicing/advanced slicing returns :class:`ResidueGroup`, not just :class:`list`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">container</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residues</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="n">ResidueGroup</span>
        <span class="c"># consistent with the way list indexing/slicing behaves:</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">container</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">container</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="c"># advanced slicing, requires array or list</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">([</span><span class="n">container</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">item</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;r&#39;</span><span class="p">:</span>
            <span class="n">resnum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c"># 1-based for the user, 0-based internally</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">resnum</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># There can be multiple residues with the same name</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residues</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">attr</span><span class="p">):</span> <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="c"># elif (len(r) == 1): return r[0]  ## creates unexpected behaviour (Issue 47)</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">ResidueGroup</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&lt;&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;&gt;&#39;</span>
</div>
<div class="viewcode-block" id="SegmentGroup"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.SegmentGroup">[docs]</a><span class="k">class</span> <span class="nc">SegmentGroup</span><span class="p">(</span><span class="n">ResidueGroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A group of segments.</span>

<span class="sd">    Pythonic access to segments:</span>
<span class="sd">      - Using a segid as attribute returns the segment. Because</span>
<span class="sd">        of python language rule, any segid starting with a non-letter</span>
<span class="sd">        character is prefixed with &#39;s&#39;, thus &#39;4AKE&#39; --&gt; &#39;s4AKE&#39;.</span>

<span class="sd">        Example::</span>

<span class="sd">          &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF,DCD</span>
<span class="sd">          &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">          &gt;&gt;&gt; print(u.atoms.segments.s4AKE)  # segment 4AKE</span>
<span class="sd">          &lt;AtomGroup with 3314 atoms&gt;</span>

<span class="sd">      - Indexing the group returns the appropriate segment.</span>

<span class="sd">    :Data: :attr:`SegmentGroup._segments`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_containername</span> <span class="o">=</span> <span class="s">&quot;_segments&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the SegmentGroup with a list of :class:`Segment` instances.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_segments</span> <span class="o">=</span> <span class="n">segments</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
            <span class="n">residues</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SegmentGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set attribute *name* to *value* for all :class:`Segment` in this :class:`AtomGroup`.</span>

<span class="sd">        If *value* is a sequence of the same length as the</span>
<span class="sd">        :class:`SegmentGroup` (:attr:`AtomGroup.residues`) then each</span>
<span class="sd">        :class:`Segment`&#39;s property *name* is set to the corresponding</span>
<span class="sd">        value. If *value* is neither of length 1 (or a scalar) nor of the</span>
<span class="sd">        length of the :class:`SegmentGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_atoms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                <span class="n">s</span><span class="o">.</span><span class="n">_set_atoms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;set_segments: can only set all atoms to a single value or each atom to a distinct one &quot;</span>
                             <span class="s">&quot;but len(segments)={0} whereas len(value)={1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span>

    <span class="nb">set</span> <span class="o">=</span> <span class="n">_set_segments</span>

<div class="viewcode-block" id="SegmentGroup.set_segid"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.SegmentGroup.set_segid">[docs]</a>    <span class="k">def</span> <span class="nf">set_segid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segid</span><span class="p">,</span> <span class="n">buildsegments</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the segid to *segid* for all atoms in the :class:`SegmentGroup`.</span>

<span class="sd">        If *segid* is a sequence of the same length as the :class:`SegmentGroup`</span>
<span class="sd">        then each :attr:`Atom.segid` is set to the corresponding value together</span>
<span class="sd">        with the :attr:`Segment.id` of the segment the atom belongs to. If</span>
<span class="sd">        *value* is neither of length 1 (or a scalar) nor of the length of the</span>
<span class="sd">        :class:`AtomGroup` then a :exc:`ValueError` is raised.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           :meth:`set_segid` can change the topology.</span>

<span class="sd">           With the default *buildsegments* = ``True`` it can be used to join</span>
<span class="sd">           segments or to break groups into multiple disjoint segments. Note</span>
<span class="sd">           that each :class:`Atom` can only belong to a single</span>
<span class="sd">           :class:`Segment`.</span>

<span class="sd">        For performance reasons, *buildsegments* can be set to ``False``. Then</span>
<span class="sd">        one needs to run :meth:`Universe._build_segments` manually later in</span>
<span class="sd">        order to update the list of :class:`Segment` instances and regenerate</span>
<span class="sd">        the segid instant selectors.</span>

<span class="sd">        .. versionadded:: 0.7.4</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Can set atoms and residues to distinct values by providing a sequence or iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SegmentGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_segid</span><span class="p">(</span><span class="n">segid</span><span class="p">,</span> <span class="n">buildsegments</span><span class="o">=</span><span class="n">buildsegments</span><span class="p">)</span>

        <span class="c"># Is the following needed? -- orbeckst</span>
        <span class="c"># also fix self --- otherwise users will get confused if the changes are not reflected in the</span>
        <span class="c"># object they are currently using (it works automatically for AtomGroup but not higher order groups)</span>
        <span class="c">#</span>
        <span class="c"># This is a hack to be able to set properties on Segment/Atom</span>
        <span class="c"># instances where they have different names</span>
        <span class="c">#attr = {&#39;segid&#39;: &#39;id&#39;}</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">segid</span><span class="p">))):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_segments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_segments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;s&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c"># sNxxx only used for python, the name is stored without s-prefix</span>
        <span class="n">seglist</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segments</span> <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">attr</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seglist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SegmentGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seglist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;SegmentGroup: Multiple segments with the same name {}; a combined, NON-CONSECUTIVE &quot;</span>
                          <span class="s">&quot;Segment is returned.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr</span><span class="p">),</span> <span class="n">category</span><span class="o">=</span><span class="n">SelectionWarning</span><span class="p">)</span>
            <span class="c">#return Segment(sum([s.residues for s in seglist])) ### FIXME: not working yet, need __add__</span>
            <span class="k">return</span> <span class="n">seglist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">seglist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&lt;&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_segments</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;&gt;&#39;</span>

</div>
<div class="viewcode-block" id="Universe"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe">[docs]</a><span class="k">class</span> <span class="nc">Universe</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The MDAnalysis Universe contains all the information describing the system.</span>

<span class="sd">    The system always requires a *topology* file --- in the simplest case just</span>
<span class="sd">    a list of atoms. This can be a CHARMM/NAMD PSF file or a simple coordinate</span>
<span class="sd">    file with atom informations such as PDB, Gromacs GRO, or CHARMM CRD. See</span>
<span class="sd">    :ref:`Supported topology formats` for what kind of topologies can be read.</span>

<span class="sd">    A trajectory provides coordinates; the coordinates have to be ordered in</span>
<span class="sd">    the same way as the list of atoms in the topology. A trajectory can be a</span>
<span class="sd">    single frame such as a PDB, CRD, or GRO file, or it can be a MD trajectory</span>
<span class="sd">    (in CHARMM/NAMD/LAMMPS DCD, Gromacs XTC/TRR, or generic XYZ format).  See</span>
<span class="sd">    :ref:`Supported coordinate formats` for what can be read as a</span>
<span class="sd">    &quot;trajectory&quot;.</span>

<span class="sd">    As a special case, when the topology is a PDB, GRO or CRD file</span>
<span class="sd">    then the coordinates are immediately loaded from the &quot;topology&quot;</span>
<span class="sd">    file unless a trajectory is supplied.</span>

<span class="sd">    Examples for setting up a universe::</span>

<span class="sd">       u = Universe(topology, trajectory)          # read system from file(s)</span>
<span class="sd">       u = Universe(pdbfile)                       # read atoms and coordinates from PDB or GRO</span>
<span class="sd">       u = Universe(topology, [traj1, traj2, ...]) # read from a list of trajectories</span>
<span class="sd">       u = Universe(topology, traj1, traj2, ...)   # read from multiple trajectories</span>

<span class="sd">    Load new data into a universe (replaces old trajectory and does *not* append)::</span>

<span class="sd">       u.load_new(trajectory)                      # read from a new trajectory file</span>

<span class="sd">    Select atoms, with syntax similar to CHARMM (see</span>
<span class="sd">    :class:`~Universe.selectAtoms` for details)::</span>

<span class="sd">       u.selectAtoms(...)</span>

<span class="sd">    *Attributes:*</span>

<span class="sd">    - :attr:`Universe.trajectory`: currently loaded trajectory reader;</span>
<span class="sd">      :attr:`Universe.trajectory.ts` is the current time step</span>
<span class="sd">    - :attr:`Universe.dimensions`: current system dimensions (simulation unit cell, if</span>
<span class="sd">      set in the trajectory)</span>
<span class="sd">    - bonds, angles, dihedrals, impropers (low level access through :attr:`Universe._psf`)</span>

<span class="sd">    .. Note::</span>

<span class="sd">       If atom attributes such as element, mass, or charge are not explicitly</span>
<span class="sd">       provided in the topology file then MDAnalysis tries to guess them (see</span>
<span class="sd">       :mod:`MDAnalysis.topology.tables`). This does not always work and if you</span>
<span class="sd">       require correct values (e.g. because you want to calculate the center of</span>
<span class="sd">       mass) then you need to make sure that MDAnalysis gets all the</span>
<span class="sd">       information needed. Furthermore, the list of bonds is only constructed</span>
<span class="sd">       when provided in the topology and never guessed (see `Issue 23`).</span>

<span class="sd">    .. _`Issue 23`: http://code.google.com/p/mdanalysis/issues/detail?id=23</span>

<span class="sd">    .. versionchanged:: 0.7.5</span>
<span class="sd">       Can also read multi-frame PDB files with the</span>
<span class="sd">       :class:`~MDAnalysis.coordinates.PDB.PrimitivePDBReader`.</span>

<span class="sd">    .. versionchanged:: 0.8</span>
<span class="sd">       Parse arbitrary number of arguments as a single topology file and a a sequence</span>
<span class="sd">       of trajectories.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the central MDAnalysis Universe object.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *topologyfile*</span>
<span class="sd">             A CHARMM/XPLOR PSF topology file, PDB file or Gromacs GRO file; used to define the</span>
<span class="sd">             list of atoms. If the file includes bond information, partial</span>
<span class="sd">             charges, atom masses, ... then these data will be available to</span>
<span class="sd">             MDAnalysis. A &quot;structure&quot; file (PSF, PDB or GRO, in the sense of a</span>
<span class="sd">             topology) is always required.</span>
<span class="sd">          *coordinatefile*</span>
<span class="sd">             A trajectory (such as CHARMM DCD, Gromacs XTC/TRR/GRO, XYZ, XYZ.bz2) or a PDB that</span>
<span class="sd">             will provide coordinates, possibly multiple frames.</span>
<span class="sd">             If a **list of filenames** is provided then they are sequentially read and appear</span>
<span class="sd">             as one single trajectory to the Universe. The list can contain different file</span>
<span class="sd">             formats.</span>

<span class="sd">             .. deprecated:: 0.8</span>
<span class="sd">                Do not use the *coordinatefile* keyword argument, just provide trajectories as</span>
<span class="sd">                positional arguments.</span>

<span class="sd">          *permissive*</span>
<span class="sd">             currently only relevant for PDB files: Set to ``True`` in order to ignore most errors</span>
<span class="sd">             and read typical MD simulation PDB files; set to ``False`` to read with the Bio.PDB reader,</span>
<span class="sd">             which can be useful for real Protein Databank PDB files. ``None``  selects the</span>
<span class="sd">             MDAnalysis default (which is set in :class:`MDAnalysis.core.flags`) [``None``]</span>
<span class="sd">          *topology_format*</span>
<span class="sd">             provide the file format of the topology file; ``None`` guesses it from the file</span>
<span class="sd">             extension [``None``]</span>
<span class="sd">          *format*</span>
<span class="sd">             provide the file format of the coordinate or trajectory file;</span>
<span class="sd">             ``None`` guesses it from the file extension. Note that this</span>
<span class="sd">             keyword has no effect if a list of file names is supplied because</span>
<span class="sd">             the &quot;chained&quot; reader has to guess the file format for each</span>
<span class="sd">             individual list member. [``None``]</span>
<span class="sd">          *bonds*</span>
<span class="sd">             bond handling for PDB files. The default is to read and store the</span>
<span class="sd">             CONECT records only. When set to ``True`` it will attempt to guess</span>
<span class="sd">             connectivity between all atoms in the Universe.</span>
<span class="sd">             Each bond knows if it was guessed or was a CONECT record, so when</span>
<span class="sd">             saving out one can specify which ones to write out by ::</span>

<span class="sd">               u = Universe(&quot;example.pdb&quot;)</span>
<span class="sd">               u.atoms.write(&quot;output.pdb&quot;, bonds=&quot;conect&quot;) # default, only CONECT</span>
<span class="sd">               u.atoms.write(&quot;output.pdb&quot;, bonds=&quot;all&quot;)</span>
<span class="sd">               u.atoms.write(&quot;output.pdb&quot;, bonds=None)</span>


<span class="sd">        This routine tries to do the right thing:</span>

<span class="sd">        1. If a pdb/gro file is provided instead of a psf and no *coordinatefile*</span>
<span class="sd">           then the coordinates are taken from the first file. Thus you can load</span>
<span class="sd">           a functional universe with ::</span>

<span class="sd">              u = Universe(&#39;1ake.pdb&#39;)</span>

<span class="sd">           If you want to specify the coordinate file format yourself you can</span>
<span class="sd">           do so using the *format* keyword::</span>

<span class="sd">              u = Universe(&#39;1ake.ent1&#39;, format=&#39;pdb&#39;)</span>

<span class="sd">        2. If only a topology file without coordinate information is provided</span>
<span class="sd">           one will have to load coordinates manually using</span>
<span class="sd">           :meth:`Universe.load_new`. The file format of the topology file</span>
<span class="sd">           can be explicitly set with the *topology_format* keyword.</span>

<span class="sd">        .. versionchanged:: 0.7.4</span>
<span class="sd">           New *topology_format* and *format* parameters to override the file</span>
<span class="sd">           format detection.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">get_parser_for</span><span class="p">,</span> <span class="n">guess_format</span>
        <span class="kn">import</span> <span class="nn">MDAnalysis.core</span>

        <span class="c"># managed attribute holding TRJReader (the Universe.trajectory</span>
        <span class="c"># attribute is also aliased as Universe.&lt;EXT&gt; where &lt;EXT&gt; is the</span>
        <span class="c"># trajectory format type (i.e. the extension))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__trajectory</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&#39;coordinatefile&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>  <span class="c"># deprecated</span>
        <span class="n">topology_format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;topology_format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;permissive&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;permissive&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;permissive_pdb_reader&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># create an empty universe</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">AtomGroup</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="bp">None</span> 
            <span class="k">return</span> 

        <span class="k">try</span><span class="p">:</span>
            <span class="n">topologyfile</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Universe requires at least a single topology or structure file.&quot;</span><span class="p">)</span>
        <span class="c"># old behaviour (explicit coordfile) overrides new behaviour</span>
        <span class="n">coordinatefile</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;coordinatefile&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;coordinatefile&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">coordinatefile</span><span class="p">:</span>
            <span class="c"># special hacks to treat a coordinate file as a coordinate AND topology file</span>
            <span class="c"># coordinatefile can be None or () (from an empty slice args[1:])</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;format&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">topology_format</span>
            <span class="k">elif</span> <span class="n">topology_format</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">topology_format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">guess_format</span><span class="p">(</span><span class="n">topologyfile</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span> <span class="ow">in</span> \
                    <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">_topology_coordinates_readers</span><span class="p">:</span>
                <span class="n">coordinatefile</span> <span class="o">=</span> <span class="n">topologyfile</span>         <span class="c"># hack for pdb/gro/crd - only</span>
            <span class="c"># Fix by SB: make sure coordinatefile is never an empty tuple</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinatefile</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">coordinatefile</span> <span class="o">=</span> <span class="bp">None</span>


        <span class="c"># build the topology (or at least a list of atoms)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">topologyfile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">parser</span> <span class="o">=</span> <span class="n">get_parser_for</span><span class="p">(</span><span class="n">topologyfile</span><span class="p">,</span> <span class="n">permissive</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;permissive&#39;</span><span class="p">],</span> <span class="n">bonds</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;bonds&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
                                    <span class="n">format</span><span class="o">=</span><span class="n">topology_format</span><span class="p">)</span>
            <span class="n">struc</span> <span class="o">=</span> <span class="n">parser</span><span class="p">(</span><span class="n">topologyfile</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Failed to build a topology from the topology file {0}. Error: {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>

        <span class="c"># populate atoms etc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_topology</span><span class="p">(</span><span class="n">struc</span><span class="p">)</span>

        <span class="c"># Load coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_new</span><span class="p">(</span><span class="n">coordinatefile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Bonds (Can we move this after _init_topology() or do we need coordinates eg for bond guessing?)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_bonds</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_init_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">struc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Populate Universe attributes from the structure dictionary *struc*.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span> <span class="o">=</span> <span class="n">struc</span>
        <span class="c">#for data in struc.keys():</span>
        <span class="c">#    setattr(self, data, struc[data])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="n">struc</span><span class="p">[</span><span class="s">&quot;_atoms&quot;</span><span class="p">])</span>

        <span class="c"># TODO wrap-around in a BondGroup class, translating bonds to lists of Atom objects; otherwise indexing becomes a pain</span>
        <span class="c"># TODO move to universe._psf.bonds</span>
        <span class="k">if</span> <span class="n">struc</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&quot;_bonds&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="n">struc</span><span class="p">[</span><span class="s">&quot;_bonds&quot;</span><span class="p">]</span>

        <span class="c"># XXX: add H-bond information here if available from psf (or other sources)</span>
        <span class="c"># segment instant selectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_segments</span><span class="p">()</span>

        <span class="c"># Not sure what the best way to load angles and torsions into universe is, so it&#39;s here for now - RG</span>
        <span class="k">if</span> <span class="s">&quot;_angles&quot;</span> <span class="ow">in</span> <span class="n">struc</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">struc</span><span class="p">[</span><span class="s">&quot;_angles&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="s">&quot;_dihe&quot;</span> <span class="ow">in</span> <span class="n">struc</span><span class="p">:</span>
            <span class="n">torsions</span> <span class="o">=</span> <span class="n">struc</span><span class="p">[</span><span class="s">&quot;_dihe&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">torsions</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">build_bondlists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="n">angles</span><span class="p">,</span> <span class="n">torsions</span><span class="o">=</span><span class="n">torsions</span><span class="p">)</span>
        <span class="c"># Let atoms access the universe</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_build_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse list of atoms into segments.</span>

<span class="sd">        * updates :attr:`Universe.atoms` as a side effect</span>
<span class="sd">        * updates :attr:`Universe.segments` and :attr:`Universe.residues`</span>
<span class="sd">        * creates the segid instant selectors</span>

<span class="sd">        Because of Python&#39;s syntax rules, attribute names cannot start with a</span>
<span class="sd">        digit and so we prefix any segments starting with a digit with the</span>
<span class="sd">        letter &#39;s&#39;. For instance, &#39;4AKE&#39; becomes the segid instant selector</span>
<span class="sd">        &#39;s4AKE&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">build_segments</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="n">build_segments</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segments</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="n">newsegname</span> <span class="o">=</span> <span class="s">&#39;s&#39;</span><span class="o">+</span><span class="n">seg</span>
                <span class="n">segments</span><span class="p">[</span><span class="n">newsegname</span><span class="p">]</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">segments</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="c"># convenience access to residues and segments (these are managed attributes</span>
        <span class="c"># (properties) and are built on the fly or read from a cache) -- does this</span>
        <span class="c"># create memory problems?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">residues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="bp">self</span>    <span class="c"># for Writer.write(universe), see Issue 49</span>
        
    <span class="k">def</span> <span class="nf">_init_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set bond information.</span>

<span class="sd">        * FIXME JD: bonds generated from connect records are different than those</span>
<span class="sd">          guessed from atom distances it&#39;d be good to keep a record of weather a bond</span>
<span class="sd">          is guessed or created</span>
<span class="sd">        * FIXME by OB: the CONECT bonds should take priority over the guessed bonds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO wrap-around in a BondGroup class, translating bonds to lists of Atom objects; otherwise indexing becomes a pain</span>
        <span class="c"># TODO move to universe._psf.bonds</span>
        <span class="c">#MDAnalysis.topology.core.build_bondlists(self.atoms, self._bonds)</span>
        <span class="c"># FIXME JD: bonds generated from connect records are different than those</span>
        <span class="c"># guessed from atom distances it&#39;d be good to keep a record of weather a bond</span>
        <span class="c"># is guessed or created</span>
        <span class="c"># FIXME by OB: the CONECT bonds should take priority over the guessed bonds</span>
        <span class="c">#bonds.extend(guessed_bonds)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.topology.core</span> <span class="kn">import</span> <span class="n">Bond</span>

        <span class="n">struc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psf</span>
        <span class="n">putative_bonds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">struc</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&quot;_bonds&quot;</span><span class="p">):</span>
            <span class="n">putative_bonds</span> <span class="o">=</span> <span class="n">putative_bonds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">struc</span><span class="p">[</span><span class="s">&quot;_bonds&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">struc</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&quot;_guessed_bonds&quot;</span><span class="p">):</span>
            <span class="n">putative_bonds</span> <span class="o">=</span> <span class="n">putative_bonds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">struc</span><span class="p">[</span><span class="s">&quot;_guessed_bonds&quot;</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">putative_bonds</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">Bond</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">bond</span>
            <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">bond</span> <span class="o">=</span> <span class="n">Bond</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">struc</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&quot;_guessed_bonds&quot;</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="nb">set</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="ow">in</span> <span class="n">struc</span><span class="p">[</span><span class="s">&quot;_guessed_bonds&quot;</span><span class="p">]</span> <span class="ow">and</span> \
                    <span class="nb">set</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">struc</span><span class="p">[</span><span class="s">&quot;_bonds&quot;</span><span class="p">]:</span>
                <span class="n">bond</span><span class="o">.</span><span class="n">set_is_guessed</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span>


<div class="viewcode-block" id="Universe.load_new"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.load_new">[docs]</a>    <span class="k">def</span> <span class="nf">load_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load coordinates from *filename*, using the suffix to detect file format.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">             *filename*</span>
<span class="sd">                 the coordinate file (single frame or trajectory) *or* a list of</span>
<span class="sd">                 filenames, which are read one after another.</span>
<span class="sd">             *permissive*</span>
<span class="sd">                 currently only relevant for PDB files: Set to ``True`` in order to ignore most errors</span>
<span class="sd">                 and read typical MD simulation PDB files; set to ``False`` to read with the Bio.PDB reader,</span>
<span class="sd">                 which can be useful for real Protein Databank PDB files. ``None``  selects the</span>
<span class="sd">                 MDAnalysis default (which is set in :class:`MDAnalysis.core.flags`) [``None``]</span>
<span class="sd">             *format*</span>
<span class="sd">                 provide the file format of the coordinate or trajectory file;</span>
<span class="sd">                 ``None`` guesses it from the file extension. Note that this</span>
<span class="sd">                 keyword has no effect if a list of file names is supplied because</span>
<span class="sd">                 the &quot;chained&quot; reader has to guess the file format for each</span>
<span class="sd">                 individual list member [``None``]</span>
<span class="sd">             *kwargs*</span>
<span class="sd">                 other kwargs are passed to the trajectory reader (only for advanced use)</span>

<span class="sd">        :Returns: (filename, trajectory_format) or ``None`` if *filename* == ``None``</span>
<span class="sd">        :Raises: :exc:`TypeError` if trajectory format can not be</span>
<span class="sd">                  determined or no appropriate trajectory reader found</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           If a list or sequence that is provided for *filename*  only contains a single entry</span>
<span class="sd">           then it is treated as single coordinate file. This has the consequence that it is</span>
<span class="sd">           not read by the :class:`~MDAnalysis.coordinates.base.ChainReader` but directly by</span>
<span class="sd">           its specialized file format reader, which typically has more features than the</span>
<span class="sd">           :class:`~MDAnalysis.coordinates.base.ChainReader`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="kn">import</span> <span class="nn">MDAnalysis.core</span>
        <span class="kn">from</span> <span class="nn">MDAnalysis.coordinates.core</span> <span class="kn">import</span> <span class="n">get_reader_for</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;permissive&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;permissive&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s">&#39;permissive_pdb_reader&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># make sure a single filename is not handed to the ChainReader</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Universe.load_new(): loading {0}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">TRJReader</span> <span class="o">=</span> <span class="n">get_reader_for</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">permissive</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;permissive&#39;</span><span class="p">),</span>
                                       <span class="n">format</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Universe.load_new() cannot find an appropriate coordinate reader &quot;</span>
                            <span class="s">&quot;for file </span><span class="si">%r</span><span class="s">.</span><span class="se">\n</span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
        <span class="c"># supply number of atoms for readers that cannot do it for themselves</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;numatoms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">TRJReader</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>    <span class="c"># unified trajectory API</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">numatoms</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">numberOfAtoms</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The topology and </span><span class="si">%s</span><span class="s"> trajectory files don&#39;t have the same number of atoms!&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">format</span>
</div>
<div class="viewcode-block" id="Universe.selectAtoms"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.selectAtoms">[docs]</a>    <span class="k">def</span> <span class="nf">selectAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="o">*</span><span class="n">othersel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select atoms using a CHARMM selection string.</span>

<span class="sd">        Returns an :class:`AtomGroup` with atoms sorted according to their</span>
<span class="sd">        index in the psf (this is to ensure that there aren&#39;t any duplicates,</span>
<span class="sd">        which can happen with complicated selections).</span>

<span class="sd">        Subselections can be grouped with parentheses.</span>

<span class="sd">        Example::</span>
<span class="sd">           &gt;&gt;&gt; universe.selectAtoms(&quot;segid DMPC and not ( name H* or name O* )&quot;)</span>
<span class="sd">           &lt;AtomGroup with 3420 atoms&gt;</span>

<span class="sd">        .. Note::</span>

<span class="sd">           If exact ordering of atoms is required (for instance, for</span>
<span class="sd">           :meth:`~AtomGroup.angle` or :meth:`~AtomGroup.dihedral`</span>
<span class="sd">           calculations) then one supplies selections *separately* in the</span>
<span class="sd">           required order. Also, when multiple :class:`AtomGroup` instances are</span>
<span class="sd">           concatenated with the ``+`` operator then the order of :class:`Atom`</span>
<span class="sd">           instances is preserved and duplicates are not removed.</span>

<span class="sd">        .. SeeAlso:: :ref:`selection-commands-label` for further details and examples.</span>

<span class="sd">        The selection parser understands the following CASE SENSITIVE *keywords*:</span>

<span class="sd">        **Simple selections**</span>

<span class="sd">            protein, backbone, nucleic, nucleicbackbone</span>
<span class="sd">                selects all atoms that belong to a standard set of residues; a protein</span>
<span class="sd">                is identfied by a hard-coded set of residue names so it  may not</span>
<span class="sd">                work for esoteric residues.</span>
<span class="sd">            segid *seg-name*</span>
<span class="sd">                select by segid (as given in the topology), e.g. ``segid 4AKE`` or ``segid DMPC``</span>
<span class="sd">            resid *residue-number-range*</span>
<span class="sd">                resid can take a single residue number or a range of numbers. A range</span>
<span class="sd">                consists of two numbers separated by a colon (inclusive) such</span>
<span class="sd">                as ``resid 1:5``. A residue number (&quot;resid&quot;) is taken directly from the</span>
<span class="sd">                topology.</span>
<span class="sd">            resnum *resnum-number-range*</span>
<span class="sd">                resnum is the canonical residue number; typically it is set to the residue id</span>
<span class="sd">                in the original PDB structure.</span>
<span class="sd">            resname *residue-name*</span>
<span class="sd">                select by residue name, e.g. ``resname LYS``</span>
<span class="sd">            name *atom-name*</span>
<span class="sd">                select by atom name (as given in the topology). Often, this is force</span>
<span class="sd">                field dependent. Example: ``name CA`` (for C&amp;alpha; atoms) or ``name OW`` (for SPC water oxygen)</span>
<span class="sd">            type *atom-type*</span>
<span class="sd">                select by atom type; this is either a string or a number and depends on</span>
<span class="sd">                the force field; it is read from the topology file (e.g. the CHARMM PSF</span>
<span class="sd">                file contains numeric atom types). It has non-sensical values when a</span>
<span class="sd">                PDB or GRO file is used as a topology.</span>
<span class="sd">            atom *seg-name*  *residue-number*  *atom-name*</span>
<span class="sd">                a selector for a single atom consisting of segid resid atomname,</span>
<span class="sd">                e.g. ``DMPC 1 C2`` selects the C2 carbon of the first residue of the DMPC</span>
<span class="sd">                segment</span>

<span class="sd">        **Boolean**</span>

<span class="sd">            not</span>
<span class="sd">                all atoms not in the selection, e.g. ``not protein`` selects</span>
<span class="sd">                all atoms that aren&#39;t part of a protein</span>

<span class="sd">            and, or</span>
<span class="sd">                combine two selections according to the rules of boolean algebra,</span>
<span class="sd">                e.g. ``protein and not (resname ALA or resname LYS)`` selects all atoms</span>
<span class="sd">                that belong to a protein, but are not in a lysine or alanine residue</span>

<span class="sd">        **Geometric**</span>

<span class="sd">            around *distance*  *selection*</span>
<span class="sd">                selects all atoms a certain cutoff away from another selection,</span>
<span class="sd">                e.g. ``around 3.5 protein`` selects all atoms not belonging to protein</span>
<span class="sd">                that are within 3.5 Angstroms from the protein</span>
<span class="sd">            point *x* *y* *z*  *distance*</span>
<span class="sd">                selects all atoms within a cutoff of a point in space, make sure</span>
<span class="sd">                coordinate is separated by spaces, e.g. ``point 5.0 5.0 5.0  3.5`` selects</span>
<span class="sd">                all atoms within 3.5 Angstroms of the coordinate (5.0, 5.0, 5.0)</span>
<span class="sd">            prop [abs] *property*  *operator*  *value*</span>
<span class="sd">                selects atoms based on position, using *property*  **x**, **y**, or</span>
<span class="sd">                **z** coordinate. Supports the **abs** keyword (for absolute value) and</span>
<span class="sd">                the following *operators*: **&lt;, &gt;, &lt;=, &gt;=, ==, !=**. For example, ``prop z &gt;= 5.0``</span>
<span class="sd">                selects all atoms with z coordinate greater than 5.0; ``prop abs z &lt;= 5.0``</span>
<span class="sd">                selects all atoms within -5.0 &lt;= z &lt;= 5.0.</span>

<span class="sd">        **Connectivity**</span>

<span class="sd">            byres *selection*</span>
<span class="sd">                selects all atoms that are in the same segment and residue as</span>
<span class="sd">                selection, e.g. specify the subselection after the byres keyword</span>

<span class="sd">        **Index**</span>

<span class="sd">            bynum *index-range*</span>
<span class="sd">                selects all atoms within a range of (1-based) inclusive indices,</span>
<span class="sd">                e.g. ``bynum 1`` selects the first atom in the universe; ``bynum 5:10``</span>
<span class="sd">                selects atoms 5 through 10 inclusive. All atoms in the</span>
<span class="sd">                :class:`MDAnalysis.Universe` are consecutively numbered, and the index</span>
<span class="sd">                runs from 1 up to the total number of atoms.</span>

<span class="sd">        .. versionchanged:: 0.7.4</span>
<span class="sd">           Added *resnum* selection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">Selection</span>     <span class="c"># can ONLY import in method, otherwise cyclical import!</span>
        <span class="n">atomgrp</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">Parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">othersel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">atomgrp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Generate a selection for each selection string</span>
            <span class="c">#atomselections = [atomgrp]</span>
            <span class="k">for</span> <span class="n">sel</span> <span class="ow">in</span> <span class="n">othersel</span><span class="p">:</span>
                <span class="n">atomgrp</span> <span class="o">=</span> <span class="n">atomgrp</span> <span class="o">+</span> <span class="n">Selection</span><span class="o">.</span><span class="n">Parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="c">#atomselections.append(Selection.Parser.parse(sel).apply(self))</span>
            <span class="c">#return tuple(atomselections)</span>
            <span class="k">return</span> <span class="n">atomgrp</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&lt;&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">&#39; with &#39;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span><span class="o">+</span><span class="s">&#39; atoms&#39;</span> \
                <span class="o">+</span><span class="p">(</span><span class="s">&quot; and </span><span class="si">%d</span><span class="s"> bonds&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span> \
                  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;bonds&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span> <span class="k">else</span> <span class="s">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;&gt;&#39;</span>

    <span class="c"># Properties</span>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Universe.dimensions"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Current dimensions of the unitcell&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">dimensions</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Universe.coord"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.coord">[docs]</a>    <span class="k">def</span> <span class="nf">coord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reference to current timestep and coordinates of universe.</span>

<span class="sd">        The raw trajectory coordinates are :attr:`Universe.coord._pos`,</span>
<span class="sd">        represented as a :class:`numpy.float32` array.</span>

<span class="sd">        Because :attr:`coord` is a reference to a</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.base.Timestep`, it changes its contents</span>
<span class="sd">        while one is stepping through the trajectory.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           In order to access the coordinates it is probably better to use the</span>
<span class="sd">           :meth:`AtomGroup.coordinates` method; for instance, all coordinates</span>
<span class="sd">           of the Universe as a numpy array:</span>
<span class="sd">           :meth:`Universe.atoms.coordinates`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reference to trajectory reader object containing trajectory data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__trajectory</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__trajectory</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;No trajectory loaded into Universe&quot;</span><span class="p">)</span>

    <span class="nd">@trajectory.setter</span>
<div class="viewcode-block" id="Universe.trajectory"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.Universe.trajectory">[docs]</a>    <span class="k">def</span> <span class="nf">trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__trajectory</span>  <span class="c"># guarantees that files are closed (?)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__trajectory</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c"># NOTE: DO NOT ADD A __del__() method: it somehow keeps the Universe</span>
    <span class="c">#       alive during unit tests and the unit tests run out of memory!</span>
    <span class="c">#### def __del__(self): &lt;------ do not add this! [orbeckst]</span>



</div></div>
<div class="viewcode-block" id="asUniverse"><a class="viewcode-back" href="../../../documentation_pages/core/AtomGroup.html#MDAnalysis.core.AtomGroup.asUniverse">[docs]</a><span class="k">def</span> <span class="nf">asUniverse</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a universe from the input arguments.</span>

<span class="sd">    1. If the first argument is a universe, just return it::</span>

<span class="sd">         as_universe(universe) --&gt; universe</span>

<span class="sd">    2. Otherwise try to build a universe from the first or the first</span>
<span class="sd">       and second argument::</span>

<span class="sd">         asUniverse(PDB, **kwargs) --&gt; Universe(PDB, **kwargs)</span>
<span class="sd">         asUniverse(PSF, DCD, **kwargs) --&gt; Universe(PSF, DCD, **kwargs)</span>
<span class="sd">         asUniverse(*args, **kwargs) --&gt; Universe(*args, **kwargs)</span>

<span class="sd">    :Returns: an instance of :class:`~MDAnalaysis.AtomGroup.Universe`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;asUniverse() takes at least one argument (</span><span class="si">%d</span><span class="s"> given)&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Universe</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Universe</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">Merge</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a universe from 2 or more AtomGroups. </span>
<span class="sd">    AtomGroups can come from different Universes, or come from selectAtom </span>
<span class="sd">    command. </span>

<span class="sd">         u1 = Universe(&quot;protein.pdb&quot;)</span>
<span class="sd">         u2 = Universe(&quot;ligand.pdb&quot;)</span>
<span class="sd">         u3 = Universe(&quot;solvent.pdb&quot;)</span>
<span class="sd">         u = Merge(u1.atoms, u2.atoms, u3.atoms)</span>
<span class="sd">         u.atoms.write(&quot;system.pdb&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Can also be used with a single AtomGroup if the user wants to, </span>
<span class="sd">    for example, re-order the atoms in the Universe.</span>
<span class="sd">     </span>
<span class="sd">    :Returns: an instance of :class:`~MDAnalaysis.AtomGroup.Universe`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="c"># one or more AtomGroups can be merged</span>
    
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span> <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span> <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="c"># cannot merge empty AtomGroup</span>
    
    <span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
    <span class="n">trajectory</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Reader</span><span class="p">()</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Timestep</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">trajectory</span><span class="p">,</span> <span class="s">&quot;ts&quot;</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span>
    <span class="n">trajectory</span><span class="o">.</span><span class="n">numframes</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="c"># create an empty Universe object</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">()</span>
    <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">trajectory</span>
    
    <span class="c"># create a list of Atoms, then convert it to an AtomGroup</span>
    <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">gr</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">u</span>
    <span class="c"># adjust the atom numbering</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span> 
        <span class="n">a</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">a</span><span class="o">.</span><span class="n">serial</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">u</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span>    
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.8.0rc3 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" >MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2005-2013, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Sbastien Buchoux, David Caplan, Jan Domaski, Xavier Deupi,
    Philip Fowler, Joseph Goose, Lukas Grossar, Benjamin Hall, Jinju Lu, Robert McGibbon,
    Manuel Nuno Melo, Danny Parton, Joshua L. Phillips, Tyler Reddy, Paul Rigor, Andy Somogyi,
    Lukas Stelzl, Zhuyi Xue, and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>