

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.coordinates.__init__ &mdash; MDAnalysis 0.11.0-dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.11.0-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.11.0-dev documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.11.0-dev documentation" href="../../../index.html" />
    <link rel="up" title="MDAnalysis" href="../../MDAnalysis.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.11.0-dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" accesskey="U">MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for MDAnalysis.coordinates.__init__</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Trajectory Readers and Writers  --- :mod:`MDAnalysis.coordinates`</span>
<span class="sd">============================================================================</span>

<span class="sd">The coordinates submodule contains code to read, write and store coordinate</span>
<span class="sd">information,</span>
<span class="sd">either single frames (e.g. the GRO module) or trajectories (such as the DCD</span>
<span class="sd">reader).</span>


<span class="sd">Readers</span>
<span class="sd">-------</span>

<span class="sd">All Readers are supposed to expose a :class:`ProtoReader` object</span>
<span class="sd">that presents a common `Trajectory API`_ to other code.</span>

<span class="sd">The :class:`~MDAnalysis.core.AtomGroup.Universe` contains the API</span>
<span class="sd">entry point attribute</span>

<span class="sd">  :attr:`Universe.trajectory`</span>

<span class="sd">that points to the actual :class:`~MDAnalysis.coordinates.base.Reader`</span>
<span class="sd">object; all Readers are supposed to be accessible through this entry</span>
<span class="sd">point in the same manner (&quot;`duck typing`_&quot;).</span>

<span class="sd">There are three types of base Reader which act as starting points</span>
<span class="sd">for each specific format. These are:</span>

<span class="sd">:class:`~MDAnalysis.coordinates.base.Reader`</span>
<span class="sd">   A standard multi frame Reader which allows iteration over a single</span>
<span class="sd">   file to provide multiple frames of data.  This is used by formats</span>
<span class="sd">   such as TRR and DCD.</span>

<span class="sd">:class:`~MDAnalysis.coordinates.base.SingleFrameReader`</span>
<span class="sd">   A simplified Reader which reads a file containing only a single</span>
<span class="sd">   frame of information.  This is used with formats such as GRO</span>
<span class="sd">   and CRD</span>

<span class="sd">:class:`~MDAnalysis.coordinates.baseChainReader`</span>
<span class="sd">   An advanced Reader designed to read a sequence of files, to</span>
<span class="sd">   provide iteration over all the frames in each file seamlessly.</span>
<span class="sd">   This Reader can also provide this functionality over a</span>
<span class="sd">   sequence of files in different formats.</span>

<span class="sd">Normally, one does not explicitly need to select a reader. This is handled</span>
<span class="sd">automatically when creating a :class:`~MDAnalysis.core.AtomGroup.Universe` and</span>
<span class="sd">the appropriate reader for the file type is selected (typically by the file</span>
<span class="sd">extension but this choice can be overriden with the ``format`` argument to</span>
<span class="sd">:class:`~MDAnalysis.core.AtomGroup.Universe`).</span>


<span class="sd">Writers</span>
<span class="sd">-------</span>

<span class="sd">In order to **write coordinates**, a factory function is provided</span>
<span class="sd">(:func:`MDAnalysis.coordinates.core.writer`) which is made available</span>
<span class="sd">as :func:`MDAnalysis.Writer`) that returns a *Writer* appropriate for</span>
<span class="sd">the desired file format (as indicated by the filename</span>
<span class="sd">suffix). Furthermore, a trajectory</span>
<span class="sd">:class:`~MDAnalysis.coordinates.base.Reader` can also have a method</span>
<span class="sd">:meth:`~MDAnalysis.coordinates.base.Reader.Writer` that returns an</span>
<span class="sd">appropriate :class:`~MDAnalysis.coordinates.base.Writer` for the file</span>
<span class="sd">format of the trajectory.</span>

<span class="sd">In analogy to :func:`MDAnalysis.coordinates.core.writer`, there is</span>
<span class="sd">also a :func:`MDAnalysis.coordinates.core.reader` function available</span>
<span class="sd">to return a trajectory :class:`~MDAnalysis.coordinates.base.Reader`</span>
<span class="sd">instance although this is often not needed because the</span>
<span class="sd">:class:`~MDAnalysis.core.AtomGroup.Universe` class can choose an</span>
<span class="sd">appropriate reader automatically.</span>

<span class="sd">.. _duck typing: http://c2.com/cgi/wiki?DuckTyping</span>


<span class="sd">A typical approach is to generate a new trajectory from an old one, e.g. to</span>
<span class="sd">only keep the protein::</span>

<span class="sd">  u = MDAnalysis.Universe(PDB, XTC)</span>
<span class="sd">  protein = u.select_atoms(&quot;protein&quot;)</span>
<span class="sd">  with MDAnalysis.Writer(&quot;protein.xtc&quot;, protein.n_atoms) as W:</span>
<span class="sd">      for ts in u.trajectory:</span>
<span class="sd">          W.write(protein)</span>

<span class="sd">Using the :func:`with` statement will automatically close the trajectory when</span>
<span class="sd">the last frame has been written.</span>


<span class="sd">Timesteps</span>
<span class="sd">---------------</span>

<span class="sd">Both Readers and Writers use Timesteps as their working object.  A Timestep</span>
<span class="sd">represents all data for a given frame in a trajectory.  The data inside a</span>
<span class="sd">Timestep is often accessed indirectly through a :class:`~MDAnalysis.core.AtomGroup.AtomGroup`</span>
<span class="sd">but it is also possible to manipulate Timesteps directly.</span>

<span class="sd">The current Timestep can be accessed through the trajectory read attached</span>
<span class="sd">to the active :class:`~MDAnalysis.core.AtomGroup.Universe`</span>

<span class="sd">   ts = u.trajectory.ts</span>
<span class="sd">   ts.positions  # returns a numpy array of positions</span>

<span class="sd">Most individual formats have slightly different data available</span>
<span class="sd">in each Timestep due to differences in individual simulation</span>
<span class="sd">packages, but all share in common a broad set of basic data,</span>
<span class="sd">detailed in `Timestep API`_</span>


<span class="sd">Supported coordinate formats</span>
<span class="sd">----------------------------</span>

<span class="sd">The table below lists the coordinate file formats understood by MDAnalysis. The</span>
<span class="sd">emphasis is on formats that are used in popular molecular dynamics codes. By</span>
<span class="sd">default, MDAnalysis figures out formats by looking at the extension. Thus, a</span>
<span class="sd">DCD file always has to end with &quot;.dcd&quot; to be recognized as such unless the</span>
<span class="sd">format is explicitly specified with the *format* keyword to</span>
<span class="sd">:class:`~MDAnalysis.core.AtomGroup.Universe` or</span>
<span class="sd">:meth:`~MDAnalysis.core.AtomGroup.Universe.load_new`.  A number of files are</span>
<span class="sd">also recognized when they are compressed with :program:`gzip` or</span>
<span class="sd">:program:`bzip2` such as &quot;.xyz.bz2&quot;.</span>

<span class="sd">.. _Supported coordinate formats:</span>

<span class="sd">.. table:: Table of supported coordinate formats</span>

<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   |Name           | extension |  IO   | remarks                                              |</span>
<span class="sd">   +===============+===========+=======+======================================================+</span>
<span class="sd">   | CHARMM,       | dcd       |  r/w  | standard CHARMM binary trajectory; endianness is     |</span>
<span class="sd">   | NAMD          |           |       | autodetected. Fixed atoms may not be handled         |</span>
<span class="sd">   |               |           |       | correctly (requires testing). Module                 |</span>
<span class="sd">   |               |           |       | :mod:`MDAnalysis.coordinates.DCD`                    |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | LAMMPS        | dcd       |  r/w  | CHARMM-style binary trajectory; endianness is        |</span>
<span class="sd">   |               |           |       | autodetected. Units are appropriate for LAMMPS.      |</span>
<span class="sd">   |               |           |       | Module :mod:`MDAnalysis.coordinates.LAMMPS`          |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | LAMMPS [#a]_  | data      |  r    | Single frame of coordinates read from .data files    |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | Gromacs       | xtc       |  r/w  | Compressed (lossy) xtc trajectory format. Module     |</span>
<span class="sd">   |               |           |       | :mod:`MDAnalysis.coordinates.XTC`                    |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | Gromacs       | trr       |  r/w  | Full precision trr trajectory. Coordinates and       |</span>
<span class="sd">   |               |           |       | velocities are processed. Module                     |</span>
<span class="sd">   |               |           |       | :mod:`MDAnalysis.coordinates.TRR`                    |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | XYZ [#a]_     |  xyz      |  r/w  | Generic white-space separate XYZ format; can be      |</span>
<span class="sd">   |               |           |       | compressed (gzip or bzip2). Module                   |</span>
<span class="sd">   |               |           |       | :mod:`MDAnalysis.coordinates.XYZ`                    |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | GAMESS        |  gms,     |  r    | Generic semi-formatted GAMESS output log; can be     |</span>
<span class="sd">   |               |  log,     |       | compressed (gzip or bzip2). Module                   |</span>
<span class="sd">   |               |  out      |       | :mod:`MDAnalysis.coordinates.GMS`                    |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | AMBER         | trj,      |  r    | formatted (ASCII) trajectories; the presence of a    |</span>
<span class="sd">   |               | mdcrd     |       | periodic box is autodetected (*experimental*).       |</span>
<span class="sd">   |               |           |       | Module :mod:`MDAnalysis.coordinates.TRJ`             |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | AMBER         | inpcrd    | r     | formatted (ASCII) coordinate/restart file            |</span>
<span class="sd">   |               | restrt    |       | Module :mod:`MDAnalysis.coordinates.INPCRD`          |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | AMBER         | ncdf      |  r/w  | binary (NetCDF) trajectories are fully supported with|</span>
<span class="sd">   |               |           |       | optional `netcdf4-python`_ module (coordinates and   |</span>
<span class="sd">   |               |           |       | velocities). Module :mod:`MDAnalysis.coordinates.TRJ`|</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | Brookhaven    | pdb       |  r/w  | a simplified PDB format (as used in MD simulations)  |</span>
<span class="sd">   | [#a]_         |           |       | is read by default; the full format can be read by   |</span>
<span class="sd">   |               |           |       | supplying the `permissive=False` flag to             |</span>
<span class="sd">   |               |           |       | :class:`MDAnalysis.Universe`. Multiple frames (MODEL)|</span>
<span class="sd">   |               |           |       | are supported but require the *multiframe* keyword.  |</span>
<span class="sd">   |               |           |       | Module :mod:`MDAnalysis.coordinates.PDB`             |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | XPDB          | pdb       |   r   | Extended PDB format (can use 5-digit residue         |</span>
<span class="sd">   |               |           |       | numbers). To use, specify the format &quot;XPBD&quot;          |</span>
<span class="sd">   |               |           |       | explicitly: ``Universe(..., format=&quot;XPDB&quot;)``.        |</span>
<span class="sd">   |               |           |       | Module :mod:`MDAnalysis.coordinates.PDB`             |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | PDBQT [#a]_   | pdbqt     | r/w   | file format used by AutoDock with atom types *t*     |</span>
<span class="sd">   |               |           |       | and partial charges *q*. Module:                     |</span>
<span class="sd">   |               |           |       | :mod:`MDAnalysis.coordinates.PDBQT`                  |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | PQR [#a]_     | pqr       | r/w   | PDB-like but whitespace-separated files with charge  |</span>
<span class="sd">   |               |           |       | and radius information. Module                       |</span>
<span class="sd">   |               |           |       | :mod:`MDAnalysis.coordinates.PQR`                    |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | GROMOS96      | gro       |  r/w  | basic GROMOS96 format (velocities as well). Module   |</span>
<span class="sd">   | [#a]_         |           |       | :mod:`MDAnalysis.coordinates.GRO`                    |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | CHARMM        | crd       |  r/w  | &quot;CARD&quot; coordinate output from CHARMM; deals with     |</span>
<span class="sd">   | CARD [#a]_    |           |       | either standard or EXTended format. Module           |</span>
<span class="sd">   |               |           |       | :mod:`MDAnalysis.coordinates.CRD`                    |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | DESRES [#a]_  | dms       |  r    | DESRES Molecular Structure file format reader.       |</span>
<span class="sd">   |               |           |       | Module :mod:`MDAnalysis.coordinates.DMS`             |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | IBIsCO/YASP   | trz       |  r/w  | Binary IBIsCO or YASP trajectories Module            |</span>
<span class="sd">   |               |           |       | :mod:`MDAnalysis.coordinates.TRZ`                    |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | MOL2          | mol2      |  r/w  | Text-based Tripos molecular structure format         |</span>
<span class="sd">   |               |           |       | :mod:`MDAnalysis.coordinates.MOL2`                   |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | DL_Poly [#a]_ | config    |  r    | DL_Poly ascii config file                            |</span>
<span class="sd">   |               |           |       | :mod:`MDAnalysis.coordinates.DLPOLY`                 |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>
<span class="sd">   | DL_Poly [#a]_ | history   |  r    | DL_Poly ascii history file                           |</span>
<span class="sd">   |               |           |       | :mod:`MDAnalysis.coordinates.DLPOLY`                 |</span>
<span class="sd">   +---------------+-----------+-------+------------------------------------------------------+</span>

<span class="sd">.. [#a] This format can also be used to provide basic *topology*</span>
<span class="sd">   information (i.e. the list of atoms); it is possible to create a</span>
<span class="sd">   full :mod:`~MDAnalysis.core.AtomGroup.Universe` by simply</span>
<span class="sd">   providing a file of this format: ``u = Universe(filename)``</span>

<span class="sd">.. _`netcdf4-python`: https://github.com/Unidata/netcdf4-python</span>

<span class="sd">.. _Trajectory API:</span>

<span class="sd">Trajectory API</span>
<span class="sd">--------------</span>

<span class="sd">The **Trajectory API** defines how classes have to be structured that allow</span>
<span class="sd">reading and writing of coordinate files. By following the API it is possible to</span>
<span class="sd">seamlessly enhance the I/O capabilities of MDAnalysis. The actual underlying</span>
<span class="sd">I/O code can be written in C or python or a mixture thereof.</span>

<span class="sd">Typically, each format resides in its own module, named by the format specifier</span>
<span class="sd">(and using upper case by convention).</span>

<span class="sd">Reader and Writer classes are derived from base classes in</span>
<span class="sd">:mod:`MDAnalysis.coordinates.base`.</span>


<span class="sd">History</span>
<span class="sd">~~~~~~~</span>

<span class="sd">- 2010-04-30 Draft [orbeckst]</span>
<span class="sd">- 2010-08-20 added single frame writers to API [orbeckst]</span>
<span class="sd">- 2010-10-09 added write() method to Writers [orbeckst]</span>
<span class="sd">- 2010-10-19 use close() instead of close_trajectory() [orbeckst]</span>
<span class="sd">- 2010-10-30 clarified Writer write() methods (see also `Issue 49`_)</span>
<span class="sd">- 2011-02-01 extended call signature of Reader class</span>
<span class="sd">- 2011-03-30 optional Writer() method for Readers</span>
<span class="sd">- 2011-04-18 added time and frame managed attributes to Reader</span>
<span class="sd">- 2011-04-20 added volume to Timestep</span>
<span class="sd">- 2012-02-11 added _velocities to Timestep</span>
<span class="sd">- 2012-05-24 multiframe keyword to distinguish trajectory from single frame writers</span>
<span class="sd">- 2012-06-04 missing implementations of Reader.__getitem__ should raise :exc:`TypeError`</span>
<span class="sd">- 2013-08-02 Readers/Writers must conform to the Python `Context Manager`_ API</span>
<span class="sd">- 2015-01-15 Timestep._init_unitcell() method added</span>
<span class="sd">- 2015-06-11 Reworked Timestep init.  Base Timestep now does Vels &amp; Forces</span>
<span class="sd">- 2015-07-21 Major changes to Timestep and Reader API (release 0.11.0)</span>

<span class="sd">.. _Issue 49: https://github.com/MDAnalysis/mdanalysis/issues/49</span>
<span class="sd">.. _Context Manager: http://docs.python.org/2/reference/datamodel.html#context-managers</span>

<span class="sd">Registry</span>
<span class="sd">~~~~~~~~</span>

<span class="sd">In various places, MDAnalysis tries to automatically select appropriate formats</span>
<span class="sd">(e.g. by looking at file extensions). In order to allow it to choose the</span>
<span class="sd">correct format, all I/O classes must be registered in one of three dictionaries</span>
<span class="sd">with the format (typically the file extension in upper case):</span>

<span class="sd">- Trajectory reader classes must be added to</span>
<span class="sd">  :data:`MDAnalysis.coordinates._trajectory_readers`.</span>

<span class="sd">- Trajectory writer classes must be added to</span>
<span class="sd">  :data:`MDAnalysis.coordinates._trajectory_writers`.</span>

<span class="sd">- Single-frame writer classes must be added to to</span>
<span class="sd">  :data:`MDAnalysis.coordinates._frame_writers`.</span>


<span class="sd">.. _Timestep API:</span>

<span class="sd">Timestep class</span>
<span class="sd">~~~~~~~~~~~~~~</span>

<span class="sd">A Timestep instance holds data for the current frame. It is updated whenever a</span>
<span class="sd">new frame of the trajectory is read.</span>

<span class="sd">Timestep classes are derived from</span>
<span class="sd">:class:`MDAnalysis.coordinates.base.Timestep`, which is the primary</span>
<span class="sd">implementation example (and used directly for the DCDReader).</span>

<span class="sd">The discussion on this format is detailed in `Issue 250`_</span>

<span class="sd">.. _Issue 250: https://github.com/MDAnalysis/mdanalysis/issues/250</span>


<span class="sd">Methods</span>
<span class="sd">.......</span>

<span class="sd">  ``__init__(n_atoms, positions=True, velocities=False, forces=False)``</span>
<span class="sd">      Define the number of atoms this Timestep will hold and whether or not</span>
<span class="sd">      it will have velocity and force information</span>
<span class="sd">  ``__eq__``</span>
<span class="sd">      Compares a Timestep with another</span>
<span class="sd">  ``__getitem__(atoms)``</span>
<span class="sd">      position(s) of atoms; can be a slice or numpy array and then returns</span>
<span class="sd">      coordinate array</span>
<span class="sd">  ``__len__()``</span>
<span class="sd">      number of coordinates (atoms) in the frame</span>
<span class="sd">  ``__iter__()``</span>
<span class="sd">      iterator over all coordinates</span>
<span class="sd">  ``copy()``</span>
<span class="sd">      deep copy of the instance</span>
<span class="sd">  ``_init_unitcell``</span>
<span class="sd">      hook that returns empty data structure for the unitcell representation</span>
<span class="sd">      of this particular file format; called from within ``__init__()`` to</span>
<span class="sd">      initialize :attr:`Timestep._unitcell`.</span>

<span class="sd">Attributes</span>
<span class="sd">..........</span>

<span class="sd">  ``n_atoms``</span>
<span class="sd">      number of atoms in the frame</span>
<span class="sd">  ``frame``</span>
<span class="sd">      current frame number (0-based)</span>
<span class="sd">  ``_frame``</span>
<span class="sd">      The native frame number of the trajectory.  This can differ from ``frame``</span>
<span class="sd">      as that will always count sequentially from 0 on iteration, whilst</span>
<span class="sd">      ``_frame`` is taken directly from the trajectory.</span>
<span class="sd">  ``time``</span>
<span class="sd">      The current system time in ps.  This value is calculated either from a time</span>
<span class="sd">      set as the Timestep attribute, or from `frame` * `dt`.  Either method allows</span>
<span class="sd">      allows an offset to be applied to the time.</span>
<span class="sd">  ``dt``</span>
<span class="sd">      The change in system time between different frames.  This can be set as an</span>
<span class="sd">      attribute, but defaults to 1.0 ps.</span>
<span class="sd">  ``data``</span>
<span class="sd">      A dictionary containing all miscellaneous information for the</span>
<span class="sd">      current Timestep.</span>
<span class="sd">  ``positions``</span>
<span class="sd">      A numpy array of all positions in this Timestep, otherwise raises a</span>
<span class="sd">      :class:`~MDAnalysis.exceptions.NoDataError`</span>
<span class="sd">  ``velocities``</span>
<span class="sd">      If present, returns a numpy array of velocities, otherwise raises a</span>
<span class="sd">      :class:`~MDAnalysis.exceptions.NoDataError`</span>
<span class="sd">  ``forces``</span>
<span class="sd">      If present, returns a numpy array of forces, otherwise raises a</span>
<span class="sd">      :class:`~MDAnalysis.exceptions.NoDataError`</span>
<span class="sd">  ``has_positions``</span>
<span class="sd">      Boolean of whether position data is available</span>
<span class="sd">  ``has_velocities``</span>
<span class="sd">      Boolean of whether velocity data is available</span>
<span class="sd">  ``has_forces``</span>
<span class="sd">      Boolean of whether force data is available</span>
<span class="sd">  ``dimensions``</span>
<span class="sd">      system box dimensions (`x, y, z, alpha, beta, gamma`)</span>
<span class="sd">      (typically implemented as a property because it needs to translate whatever is in the</span>
<span class="sd">      underlying :class:`~MDAnalysis.coordinates.base.Timestep._unitcell` attribute. Also</span>
<span class="sd">      comes with a setter that takes a MDAnalysis box so that one can do ::</span>

<span class="sd">          Timestep.dimensions = [A, B, C, alpha, beta, gamma]</span>

<span class="sd">      which then converts automatically to the underlying representation and stores it</span>
<span class="sd">      in :attr:`Timestep._unitcell`.</span>
<span class="sd">  ``volume``</span>
<span class="sd">      system box volume (derived as the determinant of the box vectors of ``dimensions``)</span>


<span class="sd">Private attributes</span>
<span class="sd">..................</span>

<span class="sd">These attributes are set directly by the underlying trajectory</span>
<span class="sd">readers. Normally the user should not have to directly access those,</span>
<span class="sd">but instead should use the attribute above.</span>

<span class="sd">  ``_pos``</span>
<span class="sd">      raw coordinates, a :class:`numpy.float32` array; ``X = _pos[:,0], Y =</span>
<span class="sd">      _pos[:,1], Z = _pos[:,2]``</span>

<span class="sd">  ``_velocities``</span>
<span class="sd">      raw velocities, a :class:`numpy.float32` array containing velocities</span>
<span class="sd">      (similar to ``_pos``)</span>

<span class="sd">  ``_forces``</span>
<span class="sd">      forces, similar to velocities above.</span>

<span class="sd">  ``_unitcell``</span>
<span class="sd">      native unit cell description; the format depends on the</span>
<span class="sd">      underlying trajectory format. A user should use the</span>
<span class="sd">      :class:`~MDAnalysis.coordinates.base.Timestep.dimensions`</span>
<span class="sd">      attribute to access the data in a canonical format instead of</span>
<span class="sd">      accessing :class:`Timestep._unitcell` directly.</span>

<span class="sd">      The method :meth:`Timestep._init_unitcell` is a hook to initialize</span>
<span class="sd">      this attribute.</span>



<span class="sd">Trajectory Reader class</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">Trajectory readers are derived from :class:`MDAnalysis.coordinates.base.Reader`.</span>
<span class="sd">Typically, many methods and attributes are overriden.</span>

<span class="sd">Methods</span>
<span class="sd">.......</span>

<span class="sd">The :class:`MDAnalysis.coordinates.DCD.DCDReader` class is the primary</span>
<span class="sd">implementation example.</span>

<span class="sd">**Mandatory methods**</span>

<span class="sd">The following methods must be implemented in a Reader class.</span>

<span class="sd"> ``__init__(filename, **kwargs)``</span>
<span class="sd">     open *filename*; other *kwargs* are processed as needed and the</span>
<span class="sd">     Reader is free to ignore them. Typically, MDAnalysis supplies as</span>
<span class="sd">     much information as possible to the Reader in `kwargs`; at the moment the</span>
<span class="sd">     following data are supplied in keywords when a trajectory is loaded from</span>
<span class="sd">     within :class:`MDAnalysis.Universe`:</span>

<span class="sd">      - *n_atoms*: the number of atoms (known from the topology)</span>

<span class="sd"> ``__iter__()``</span>
<span class="sd">     allow iteration from beginning to end::</span>

<span class="sd">        for ts in trajectory:</span>
<span class="sd">            print ts.frame</span>

<span class="sd"> ``close()``</span>
<span class="sd">     close the file and cease I/O</span>
<span class="sd"> ``next()``</span>
<span class="sd">     advance to next time step or raise :exc:`IOError` when moving</span>
<span class="sd">     past the last frame</span>
<span class="sd"> ``rewind()``</span>
<span class="sd">     reposition to first frame</span>
<span class="sd"> ``__entry__()``</span>
<span class="sd">     entry method of a `Context Manager`_ (returns self)</span>
<span class="sd"> ``__exit__()``</span>
<span class="sd">     exit method of a `Context Manager`_, should call ``close()``.</span>

<span class="sd">.. Note::</span>
<span class="sd">   a ``__del__()`` method should also be present to ensure that the</span>
<span class="sd">   trajectory is properly closed. However, certain types of Reader can ignore</span>
<span class="sd">   this requirement. These include the :class:`SingleFrameReader` (file reading</span>
<span class="sd">   is done within a context manager and needs no closing by hand) and the :class:`ChainReader`</span>
<span class="sd">   (it is a collection of Readers, each already with its own ``__del__`` method).</span>

<span class="sd">**Optional methods**</span>

<span class="sd">Not all trajectory formats support the following methods, either because the</span>
<span class="sd">data are not available or the methods have not been implemented. Code should</span>
<span class="sd">deal with missing methods gracefully.</span>

<span class="sd"> ``__len__()``</span>
<span class="sd">     number of frames in trajectory</span>

<span class="sd"> ``__getitem__(arg)``</span>
<span class="sd">     advance to time step `arg` = `frame` and return :class:`Timestep`; or if `arg` is a</span>
<span class="sd">     slice, then return an iterator over that part of the trajectory.</span>

<span class="sd">     The first functionality allows one to randomly access frames in the</span>
<span class="sd">     trajectory::</span>

<span class="sd">       universe.trajectory[314]</span>

<span class="sd">     would load frame 314 into the current :class:`Timestep`.</span>

<span class="sd">     Using slices allows iteration over parts of a trajectory ::</span>

<span class="sd">       for ts in universe.trajectory[1000:2000]:</span>
<span class="sd">           process_frame(ts)   # do some analysis on ts</span>

<span class="sd">     or skipping frames ::</span>

<span class="sd">       for ts in universe.trajectory[1000::100]:</span>
<span class="sd">           process_frame(ts)   # do some analysis on ts</span>

<span class="sd">     The last example starts reading the trajectory at frame 1000 and</span>
<span class="sd">     reads every 100th frame until the end.</span>

<span class="sd">     The performance of the ``__getitem__()`` method depends on the underlying</span>
<span class="sd">     trajectory reader and if it can implement random access to frames. In many</span>
<span class="sd">     cases this is not easily (or reliably) implementable and thus one is</span>
<span class="sd">     restricted to sequential iteration.</span>

<span class="sd">     If the Reader is not able to provide random access to frames then it</span>
<span class="sd">     should raise :exc:`TypeError` on indexing. It is possible to partially</span>
<span class="sd">     implement ``__getitem__`` (as done on</span>
<span class="sd">     :class:`MDAnalysis.coordinates.base.Reader.__getitem__` where slicing the</span>
<span class="sd">     full trajectory is equivalent to</span>
<span class="sd">     :class:`MDAnalysis.coordinates.base.Reader.__iter__` (which is always</span>
<span class="sd">     implemented) and other slices raise :exc:`TypeError`.</span>

<span class="sd"> ``Writer(filename, **kwargs)``</span>
<span class="sd">     returns a :class:`~MDAnalysis.coordinates.base.Writer` which is set up with</span>
<span class="sd">     the same parameters as the trajectory that is being read (e.g. time step,</span>
<span class="sd">     length etc), which facilitates copying and simple on-the-fly manipulation.</span>

<span class="sd">     If no Writer is defined then a :exc:`NotImplementedError` is raised.</span>

<span class="sd">     The *kwargs* can be used to customize the Writer as they are typically</span>
<span class="sd">     passed through to the init method of the Writer, with sensible defaults</span>
<span class="sd">     filled in; the actual keyword arguments depend on the Writer.</span>

<span class="sd"> ``timeseries(atomGroup, [start[,stop[,skip[,format]]]])``</span>
<span class="sd">     returns a subset of coordinate data</span>

<span class="sd"> ``correl(timeseriesCollection[,start[,stop[,skip]]])``</span>
<span class="sd">     populate a :class:`MDAnalysis.core.Timeseries.TimeseriesCollection` object</span>
<span class="sd">     with observable timeseries computed from the trajectory</span>


<span class="sd">Attributes</span>
<span class="sd">..........</span>

<span class="sd"> ``filename``</span>
<span class="sd">     filename of the trajectory</span>
<span class="sd"> ``n_atoms``</span>
<span class="sd">     number of atoms (coordinate sets) in a frame (constant)</span>
<span class="sd"> ``n_frames``</span>
<span class="sd">     total number of frames (if known) -- ``None`` if not known</span>
<span class="sd"> ``ts``</span>
<span class="sd">     the :class:`~base.Timestep` object; typically customized for each</span>
<span class="sd">     trajectory format and derived from :class:`base.Timestep`.</span>
<span class="sd"> ``units``</span>
<span class="sd">     dictionary with keys *time*, *length*, *speed*, *force* and the</span>
<span class="sd">     appropriate unit (e.g. &#39;AKMA&#39; and &#39;Angstrom&#39; for Charmm dcds, &#39;ps&#39; and</span>
<span class="sd">     &#39;nm&#39; for Gromacs trajectories, ``None`` and &#39;Angstrom&#39; for PDB).</span>
<span class="sd">     Any field not used should be set to ``None``.</span>
<span class="sd"> ``format``</span>
<span class="sd">     string that identifies the file format, e.g. &quot;DCD&quot;, &quot;PDB&quot;, &quot;CRD&quot;, &quot;XTC&quot;,</span>
<span class="sd">     &quot;TRR&quot;; this is typically the file extension in upper case.</span>
<span class="sd"> ``dt``</span>
<span class="sd">     time between frames in ps; a managed attribute (read only) that computes</span>
<span class="sd">     on the fly ``skip_timestep * delta`` and converts to the MDAnalysis base</span>
<span class="sd">     unit for time (pico seconds by default)</span>
<span class="sd"> ``totaltime``</span>
<span class="sd">     total length of the trajectory = ``n_frames * dt``</span>
<span class="sd"> ``time``</span>
<span class="sd">     time of the current time step, in MDAnalysis time units (ps)</span>
<span class="sd"> ``frame``</span>
<span class="sd">     frame number of the current time step (0-based)</span>

<span class="sd">**Optional attributes**</span>

<span class="sd"> ``delta``</span>
<span class="sd">     integrator time step (in native units); hence the &quot;length&quot;</span>
<span class="sd">     of a trajctory frame is  ``skip_timestep*delta`` time units</span>
<span class="sd"> ``compressed``</span>
<span class="sd">     string that identifies the compression (e.g. &quot;gz&quot; or &quot;bz2&quot;) or ``None``.</span>
<span class="sd"> ``fixed``</span>
<span class="sd">     bool, saying if there are fixed atoms (e.g. dcds)</span>
<span class="sd"> ``periodic``</span>
<span class="sd">     boolean saying if contains box information for periodic boundary conditions</span>
<span class="sd">     unit cell information is stored in attribute `dimensions`</span>
<span class="sd"> ``skip_timestep``</span>
<span class="sd">     number of integrator steps between frames + 1 (i.e.</span>
<span class="sd">     the stride at which the MD simulation was sampled)</span>


<span class="sd">Trajectory Writer class</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">Trajectory writers are derived from</span>
<span class="sd">:class:`MDAnalysis.coordinates.base.Writer`. They are used to write</span>
<span class="sd">multiple frames to a trajectory file. Every time the</span>
<span class="sd">:meth:`~MDAnalysis.coordinates.base.Writer.write` method is called,</span>
<span class="sd">another frame is appended to the trajectory.</span>

<span class="sd">Typically, many methods and attributes are overriden.</span>

<span class="sd">Signature::</span>

<span class="sd">   W = TrajectoryWriter(filename,n_atoms,**kwargs)</span>
<span class="sd">   W.write_next_timestep(Timestep)</span>

<span class="sd">or::</span>

<span class="sd">   W.write(AtomGroup)   # write a selection</span>
<span class="sd">   W.write(Universe)    # write a whole universe</span>
<span class="sd">   W.write(Timestep)    # same as write_next_timestep()</span>


<span class="sd">Methods</span>
<span class="sd">.......</span>

<span class="sd"> ``__init__(filename,n_atoms[,start[,step[,delta[,remarks]]]])``</span>
<span class="sd">     opens *filename* and writes header if required by format</span>
<span class="sd"> ``write(obj)``</span>
<span class="sd">     write Timestep data in *obj*</span>
<span class="sd"> ``write_next_timestep([timestep])``</span>
<span class="sd">     write data in *timestep* to trajectory file</span>
<span class="sd"> ``convert_dimensions_to_unitcell(timestep)``</span>
<span class="sd">     take the dimensions from the timestep and convert to the native</span>
<span class="sd">     unitcell representation of the format</span>
<span class="sd"> ``close()``</span>
<span class="sd">     close file and finish I/O</span>
<span class="sd"> ``__del__()``</span>
<span class="sd">     ensures that close() is called</span>

<span class="sd">Attributes</span>
<span class="sd">..........</span>

<span class="sd"> ``filename``</span>
<span class="sd">     name of the trajectory file</span>
<span class="sd"> ``start, stop, step``</span>
<span class="sd">     first and last frame number (0-based) and step</span>
<span class="sd"> ``units``</span>
<span class="sd">     dictionary with keys *time*, *length*, *speed*, *force* and the</span>
<span class="sd">     appropriate unit (e.g. &#39;AKMA&#39; and &#39;Angstrom&#39; for Charmm dcds, &#39;ps&#39; and</span>
<span class="sd">     &#39;nm&#39; for Gromacs trajectories, ``None`` and &#39;Angstrom&#39; for PDB).</span>
<span class="sd">     Any field not used should be set to ``None``.</span>
<span class="sd"> ``format``</span>
<span class="sd">     string that identifies the file format, e.g. &quot;DCD&quot;, &quot;PDB&quot;, &quot;CRD&quot;, &quot;XTC&quot;,</span>
<span class="sd">     &quot;TRR&quot;</span>


<span class="sd">**Optional**</span>

<span class="sd"> ``ts``</span>
<span class="sd">     :class:`Timestep` instance</span>


<span class="sd">Single Frame Writer class</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">A single frame writer is a special case of a trajectory writer in that it</span>
<span class="sd">writes only a single coordinate frame to a file, for instance, a pdb or gro</span>
<span class="sd">file. Unlike trajectory formats, which only contains coordinates, *single</span>
<span class="sd">frame* formats contain much more information (e.g. atom and residue names and</span>
<span class="sd">numbers) and hence it is possible to write selections of atoms in a meaningful</span>
<span class="sd">way.</span>

<span class="sd">Signature::</span>

<span class="sd">   W = FrameWriter(filename, **kwargs)</span>
<span class="sd">   W.write(AtomGroup)</span>
<span class="sd">   W.write(Universe)</span>

<span class="sd">The blanket *kwargs* is required so that one can pass the same kind of</span>
<span class="sd">arguments (filename and n_atoms) as for the Trajectory writers. In</span>
<span class="sd">this way, the simple :func:`~MDAnalysis.coordinates.core.writer`</span>
<span class="sd">factory function can be used for all writers.</span>

<span class="sd">Methods</span>
<span class="sd">.......</span>

<span class="sd"> ``__init__(filename, **kwargs)``</span>
<span class="sd">   opens *filename* for writing; `kwargs` are typically ignored</span>
<span class="sd"> ``write(obj)``</span>
<span class="sd">   writes the object *obj*, containing a</span>
<span class="sd">   :class:`~MDAnalysis.core.AtomGroup.AtomGroup` group of atoms (typically</span>
<span class="sd">   obtained from a selection) or :class:`~MDAnalysis.core.AtomGroup.Universe`</span>
<span class="sd">   to the file and closes the file</span>

<span class="sd">.. Note::</span>

<span class="sd">   Trajectory and Frame writers can be used in almost exactly the same</span>
<span class="sd">   manner with the one difference that Frame writers cannot deal with</span>
<span class="sd">   raw :class:`~MDAnalysis.coordinates.base.Timestep` objects.</span>


<span class="sd">Reader/Writer registry</span>
<span class="sd">----------------------</span>

<span class="sd">The following data structures connect reader/writer classes to their</span>
<span class="sd">format identifiers. They are documented for programmers who want to</span>
<span class="sd">enhance MDAnalysis; the casual user is unlikely to access them</span>
<span class="sd">directly.</span>

<span class="sd">Some formats can either write single frames or trajectories (such as</span>
<span class="sd">PDB). In theses cases, the kind of writer is selected with the</span>
<span class="sd">*multiframe* keyword to :func:`MDAnalysis.coordinates.core.get_writer`</span>
<span class="sd">(or the writer itself).</span>

<span class="sd">.. autodata:: _trajectory_readers</span>
<span class="sd">.. autodata:: _topology_coordinates_readers</span>
<span class="sd">.. autodata:: _compressed_formats</span>
<span class="sd">.. autodata:: _frame_writers</span>
<span class="sd">.. autodata:: _trajectory_writers</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;reader&#39;</span><span class="p">,</span> <span class="s">&#39;writer&#39;</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">base</span>
<span class="kn">from</span> <span class="nn">.core</span> <span class="kn">import</span> <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">CRD</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">DCD</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">DLPoly</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">DMS</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">GMS</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">GRO</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">INPCRD</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">LAMMPS</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">MOL2</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">PDB</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">PDBQT</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">PQR</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">TRJ</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">TRR</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">TRZ</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">XTC</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">XYZ</span>

<span class="c">#: standard trajectory readers (dict with identifier as key and reader class as value)</span>
<span class="n">_trajectory_readers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;DCD&#39;</span><span class="p">:</span> <span class="n">DCD</span><span class="o">.</span><span class="n">DCDReader</span><span class="p">,</span>
    <span class="c"># &#39;TRJ&#39;: DCD.DCDReader, #commented out because overridden by TRJ.TRJReader</span>
    <span class="s">&#39;CONFIG&#39;</span><span class="p">:</span> <span class="n">DLPoly</span><span class="o">.</span><span class="n">ConfigReader</span><span class="p">,</span>
    <span class="s">&#39;HISTORY&#39;</span><span class="p">:</span> <span class="n">DLPoly</span><span class="o">.</span><span class="n">HistoryReader</span><span class="p">,</span>
    <span class="s">&#39;XTC&#39;</span><span class="p">:</span> <span class="n">XTC</span><span class="o">.</span><span class="n">XTCReader</span><span class="p">,</span>
    <span class="s">&#39;XYZ&#39;</span><span class="p">:</span> <span class="n">XYZ</span><span class="o">.</span><span class="n">XYZReader</span><span class="p">,</span>
    <span class="s">&#39;TRR&#39;</span><span class="p">:</span> <span class="n">TRR</span><span class="o">.</span><span class="n">TRRReader</span><span class="p">,</span>
    <span class="s">&#39;Permissive_PDB&#39;</span><span class="p">:</span> <span class="n">PDB</span><span class="o">.</span><span class="n">PrimitivePDBReader</span><span class="p">,</span>
    <span class="s">&#39;PDB&#39;</span><span class="p">:</span> <span class="n">PDB</span><span class="o">.</span><span class="n">PDBReader</span><span class="p">,</span>
    <span class="s">&#39;XPDB&#39;</span><span class="p">:</span> <span class="n">PDB</span><span class="o">.</span><span class="n">ExtendedPDBReader</span><span class="p">,</span>
    <span class="s">&#39;PDBQT&#39;</span><span class="p">:</span> <span class="n">PDBQT</span><span class="o">.</span><span class="n">PDBQTReader</span><span class="p">,</span>
    <span class="s">&#39;CRD&#39;</span><span class="p">:</span> <span class="n">CRD</span><span class="o">.</span><span class="n">CRDReader</span><span class="p">,</span>
    <span class="s">&#39;GRO&#39;</span><span class="p">:</span> <span class="n">GRO</span><span class="o">.</span><span class="n">GROReader</span><span class="p">,</span>
    <span class="s">&#39;MOL2&#39;</span><span class="p">:</span> <span class="n">MOL2</span><span class="o">.</span><span class="n">MOL2Reader</span><span class="p">,</span>
    <span class="s">&#39;TRJ&#39;</span><span class="p">:</span> <span class="n">TRJ</span><span class="o">.</span><span class="n">TRJReader</span><span class="p">,</span>  <span class="c"># AMBER text</span>
    <span class="s">&#39;MDCRD&#39;</span><span class="p">:</span> <span class="n">TRJ</span><span class="o">.</span><span class="n">TRJReader</span><span class="p">,</span>  <span class="c"># AMBER text</span>
    <span class="s">&#39;NCDF&#39;</span><span class="p">:</span> <span class="n">TRJ</span><span class="o">.</span><span class="n">NCDFReader</span><span class="p">,</span>  <span class="c"># AMBER netcdf</span>
    <span class="s">&#39;NC&#39;</span><span class="p">:</span> <span class="n">TRJ</span><span class="o">.</span><span class="n">NCDFReader</span><span class="p">,</span>
    <span class="s">&#39;INPCRD&#39;</span><span class="p">:</span> <span class="n">INPCRD</span><span class="o">.</span><span class="n">INPReader</span><span class="p">,</span>
    <span class="s">&#39;RESTRT&#39;</span><span class="p">:</span> <span class="n">INPCRD</span><span class="o">.</span><span class="n">INPReader</span><span class="p">,</span>
    <span class="s">&#39;PQR&#39;</span><span class="p">:</span> <span class="n">PQR</span><span class="o">.</span><span class="n">PQRReader</span><span class="p">,</span>
    <span class="s">&#39;LAMMPS&#39;</span><span class="p">:</span> <span class="n">LAMMPS</span><span class="o">.</span><span class="n">DCDReader</span><span class="p">,</span>
    <span class="s">&#39;CHAIN&#39;</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">ChainReader</span><span class="p">,</span>
    <span class="s">&#39;DMS&#39;</span><span class="p">:</span> <span class="n">DMS</span><span class="o">.</span><span class="n">DMSReader</span><span class="p">,</span>
    <span class="s">&#39;TRZ&#39;</span><span class="p">:</span> <span class="n">TRZ</span><span class="o">.</span><span class="n">TRZReader</span><span class="p">,</span>
    <span class="s">&#39;DATA&#39;</span><span class="p">:</span> <span class="n">LAMMPS</span><span class="o">.</span><span class="n">DATAReader</span><span class="p">,</span>
    <span class="s">&#39;GMS&#39;</span><span class="p">:</span> <span class="n">GMS</span><span class="o">.</span><span class="n">GMSReader</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">#: formats of readers that can also handle gzip or bzip2 compressed files</span>
<span class="n">_compressed_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;XYZ&#39;</span><span class="p">,</span> <span class="s">&#39;TRJ&#39;</span><span class="p">,</span> <span class="s">&#39;MDCRD&#39;</span><span class="p">,</span> <span class="s">&#39;PQR&#39;</span><span class="p">,</span> <span class="s">&#39;PDBQT&#39;</span><span class="p">]</span>

<span class="c">#: readers of files that contain both topology/atom data and coordinates</span>
<span class="c">#: (currently only the keys are used)</span>
<span class="n">_topology_coordinates_readers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;PDB&#39;</span><span class="p">:</span> <span class="n">PDB</span><span class="o">.</span><span class="n">PrimitivePDBReader</span><span class="p">,</span>  <span class="c"># FIXME: should be able to use BioPython PDBReader for topolgy if permissive=False!</span>
    <span class="s">&#39;XPDB&#39;</span><span class="p">:</span> <span class="n">PDB</span><span class="o">.</span><span class="n">ExtendedPDBReader</span><span class="p">,</span>
    <span class="s">&#39;PDBQT&#39;</span><span class="p">:</span> <span class="n">PDBQT</span><span class="o">.</span><span class="n">PDBQTReader</span><span class="p">,</span>
    <span class="s">&#39;GRO&#39;</span><span class="p">:</span> <span class="n">GRO</span><span class="o">.</span><span class="n">GROReader</span><span class="p">,</span>
    <span class="s">&#39;CRD&#39;</span><span class="p">:</span> <span class="n">CRD</span><span class="o">.</span><span class="n">CRDReader</span><span class="p">,</span>
    <span class="s">&#39;CONFIG&#39;</span><span class="p">:</span> <span class="n">DLPoly</span><span class="o">.</span><span class="n">ConfigReader</span><span class="p">,</span>
    <span class="s">&#39;HISTORY&#39;</span><span class="p">:</span> <span class="n">DLPoly</span><span class="o">.</span><span class="n">HistoryReader</span><span class="p">,</span>
    <span class="s">&#39;PQR&#39;</span><span class="p">:</span> <span class="n">PQR</span><span class="o">.</span><span class="n">PQRReader</span><span class="p">,</span>
    <span class="s">&#39;DMS&#39;</span><span class="p">:</span> <span class="n">DMS</span><span class="o">.</span><span class="n">DMSReader</span><span class="p">,</span>
    <span class="s">&#39;MOL2&#39;</span><span class="p">:</span> <span class="n">MOL2</span><span class="o">.</span><span class="n">MOL2Reader</span><span class="p">,</span>
    <span class="s">&#39;DATA&#39;</span><span class="p">:</span> <span class="n">LAMMPS</span><span class="o">.</span><span class="n">DATAReader</span><span class="p">,</span>
    <span class="s">&#39;GMS&#39;</span><span class="p">:</span> <span class="n">GMS</span><span class="o">.</span><span class="n">GMSReader</span><span class="p">,</span>
    <span class="s">&#39;XYZ&#39;</span><span class="p">:</span> <span class="n">XYZ</span><span class="o">.</span><span class="n">XYZReader</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">#: frame writers: export to single frame formats such as PDB, gro, crd</span>
<span class="c">#: Signature::</span>
<span class="c">#:</span>
<span class="c">#:   W = FrameWriter(filename)</span>
<span class="c">#:   W.write(AtomGroup)</span>
<span class="n">_frame_writers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;PDBQT&#39;</span><span class="p">:</span> <span class="n">PDBQT</span><span class="o">.</span><span class="n">PDBQTWriter</span><span class="p">,</span>
    <span class="s">&#39;CRD&#39;</span><span class="p">:</span> <span class="n">CRD</span><span class="o">.</span><span class="n">CRDWriter</span><span class="p">,</span>
    <span class="s">&#39;GRO&#39;</span><span class="p">:</span> <span class="n">GRO</span><span class="o">.</span><span class="n">GROWriter</span><span class="p">,</span>
    <span class="s">&#39;PDB&#39;</span><span class="p">:</span> <span class="n">PDB</span><span class="o">.</span><span class="n">PrimitivePDBWriter</span><span class="p">,</span>
    <span class="s">&#39;PQR&#39;</span><span class="p">:</span> <span class="n">PQR</span><span class="o">.</span><span class="n">PQRWriter</span><span class="p">,</span>
    <span class="s">&#39;XYZ&#39;</span><span class="p">:</span> <span class="n">XYZ</span><span class="o">.</span><span class="n">XYZWriter</span><span class="p">,</span>
    <span class="s">&#39;MOL2&#39;</span><span class="p">:</span> <span class="n">MOL2</span><span class="o">.</span><span class="n">MOL2Writer</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">#: trajectory writers: export frames, typically only saving coordinates</span>
<span class="c">#: Signature::</span>
<span class="c">#:</span>
<span class="c">#:   W = TrajectoryWriter(filename,n_atoms,**kwargs)</span>
<span class="c">#:   W.write_next_timestep(TimeStep)</span>
<span class="c">#:   W.write(Timestep)</span>
<span class="c">#:   W.write(AtomGroup)</span>
<span class="c">#:   W.write(Universe)</span>
<span class="n">_trajectory_writers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;DCD&#39;</span><span class="p">:</span> <span class="n">DCD</span><span class="o">.</span><span class="n">DCDWriter</span><span class="p">,</span>
    <span class="s">&#39;XTC&#39;</span><span class="p">:</span> <span class="n">XTC</span><span class="o">.</span><span class="n">XTCWriter</span><span class="p">,</span>
    <span class="s">&#39;TRR&#39;</span><span class="p">:</span> <span class="n">TRR</span><span class="o">.</span><span class="n">TRRWriter</span><span class="p">,</span>
    <span class="s">&#39;LAMMPS&#39;</span><span class="p">:</span> <span class="n">LAMMPS</span><span class="o">.</span><span class="n">DCDWriter</span><span class="p">,</span>
    <span class="s">&#39;PDB&#39;</span><span class="p">:</span> <span class="n">PDB</span><span class="o">.</span><span class="n">MultiPDBWriter</span><span class="p">,</span>
    <span class="s">&#39;NCDF&#39;</span><span class="p">:</span> <span class="n">TRJ</span><span class="o">.</span><span class="n">NCDFWriter</span><span class="p">,</span>
    <span class="s">&#39;TRZ&#39;</span><span class="p">:</span> <span class="n">TRZ</span><span class="o">.</span><span class="n">TRZWriter</span><span class="p">,</span>
    <span class="s">&#39;XYZ&#39;</span><span class="p">:</span> <span class="n">XYZ</span><span class="o">.</span><span class="n">XYZWriter</span><span class="p">,</span>
    <span class="s">&#39;MOL2&#39;</span><span class="p">:</span> <span class="n">MOL2</span><span class="o">.</span><span class="n">MOL2Writer</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.11.0-dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" >MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sbastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domaski, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac Virshup,
    Zhuyi Xue, Carlos Yez S.,
    and Oliver Beckstein.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>