


  
    
  




<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="shortcut icon" href="../../_static/logo/mda_favicon.ico">
</head>

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4.2.4. Parallel analysis &mdash; MDAnalysis 2.8.0-dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/site.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=a9b57af3"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/js/versions.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 2.8.0-dev0 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="4.3.1. Coordinate fitting and alignment — MDAnalysis.analysis.align" href="align.html" />
    <link rel="prev" title="4.2.3. Analysis results and their aggregation — MDAnalysis.analysis.results" href="results.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >




  




<a href="../../index.html">
  
    <img src="../../_static/logo/mda_logo.png" class="logo" alt="Logo"/>
</a>


  
  
  
    <div class="version">
      2.8.0-dev0
    </div>
  



<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>
<div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
    <!-- <p class="caption" role="heading"></p> -->
    <ul>
        
        <li class="toctree-l1"><a class="reference internal" href="http://mdanalysis.org">MDAnalysis</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="http://userguide.mdanalysis.org">User guide</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="https://mdakits.mdanalysis.org/">MDAKits</a></li>
        
    </ul>
    
        <p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../selections.html">3. Selection commands</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../analysis_modules.html">4. Analysis modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../analysis_modules.html#getting-started-with-analysis">4.1. Getting started with analysis</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../analysis_modules.html#building-blocks-for-analysis">4.2. Building blocks for Analysis</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="base.html">4.2.1. Analysis building blocks — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.analysis.base</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="backends.html">4.2.2. Analysis backends — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.analysis.backends</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="results.html">4.2.3. Analysis results and their aggregation — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.analysis.results</span></code></a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">4.2.4. Parallel analysis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#how-to-use-parallelization">4.2.4.1. How to use parallelization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-does-parallelization-work">4.2.4.2. How does parallelization work</a></li>
<li class="toctree-l4"><a class="reference internal" href="#helper-classes-for-parallelization">4.2.4.3. Helper classes for parallelization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#when-to-use-parallelization-known-limitations">4.2.4.4. When to use parallelization? (Known limitations)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#adding-parallelization-to-your-own-analysis-class">4.2.4.5. Adding parallelization to your own analysis class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writing-custom-backends">4.2.4.6. Writing custom backends</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../analysis_modules.html#distances-and-contacts">4.3. Distances and contacts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis_modules.html#hydrogen-bonding">4.4. Hydrogen bonding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis_modules.html#membranes-and-membrane-proteins">4.5. Membranes and membrane proteins</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis_modules.html#nucleic-acids">4.6. Nucleic acids</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis_modules.html#polymers">4.7. Polymers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis_modules.html#structure">4.8. Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis_modules.html#volumetric-analysis">4.9. Volumetric analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis_modules.html#dimensionality-reduction">4.10. Dimensionality Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis_modules.html#legacy-analysis-modules">4.11. Legacy analysis modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis_modules.html#data">4.12. Data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../converters.html">7. Converter modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trajectory_transformations.html">8. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../selections_modules.html">9. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auxiliary_modules.html">10. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core_modules.html">11. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../visualization_modules.html">12. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lib_modules.html">13. Library functions — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../version.html">14. Version information for MDAnalysis - <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../units.html">15. Constants and unit conversion — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../exceptions.html">16. Custom exceptions and warnings — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">17. References</a></li>
</ul>

</div>

      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">MDAnalysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../analysis_modules.html"><span class="section-number">4. </span>Analysis modules</a></li>
      <li class="breadcrumb-item active"><span class="section-number">4.2.4. </span>Parallel analysis</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/documentation_pages/analysis/parallelization.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="parallel-analysis">
<span id="id1"></span><h1><span class="section-number">4.2.4. </span>Parallel analysis<a class="headerlink" href="#parallel-analysis" title="Link to this heading"></a></h1>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.8.0: </span>Parallelization of analysis classes was added during Google Summer of Code
2023 by <a class="reference external" href="https://github.com/marinegor">&#64;marinegor</a> and MDAnalysis GSoC mentors.</p>
</div>
<p>This section explains the implementation and background for
parallelization with the <a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase" title="MDAnalysis.analysis.base.AnalysisBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.base.AnalysisBase</span></code></a>, what
users and developers need to know, when you should use parallelization (almost
always!), and when you should abstain from doing so (rarely).</p>
<section id="how-to-use-parallelization">
<h2><span class="section-number">4.2.4.1. </span>How to use parallelization<a class="headerlink" href="#how-to-use-parallelization" title="Link to this heading"></a></h2>
<p>In order to use parallelization in a built-in analysis class <code class="docutils literal notranslate"><span class="pre">SomeAnalysisClass</span></code>,
simply check which backends are available (see <a class="reference internal" href="backends.html#backends"><span class="std std-ref">Backends</span></a> for backends
that are generally available), and then just enable them by providing
<code class="docutils literal notranslate"><span class="pre">backend='multiprocessing'</span></code> and <code class="docutils literal notranslate"><span class="pre">n_workers=...</span></code> to <code class="docutils literal notranslate"><span class="pre">SomeClass.run(...)</span></code>
method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">mda</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">my_run</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">SomeClass</span><span class="o">.</span><span class="n">get_supported_backends</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;serial&#39;</span><span class="p">,</span> <span class="s1">&#39;multiprocessing&#39;</span><span class="p">,</span> <span class="s1">&#39;dask&#39;</span><span class="p">)</span>

<span class="n">my_run</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s1">&#39;multiprocessing&#39;</span><span class="p">,</span> <span class="n">n_workers</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
</pre></div>
</div>
<p>For some classes, such as <a class="reference internal" href="rms.html#MDAnalysis.analysis.rms.RMSF" title="MDAnalysis.analysis.rms.RMSF"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.rms.RMSF</span></code></a> (in its current implementation),
split-apply-combine parallelization isn’t possible, and running them will be
impossible with any but the <code class="docutils literal notranslate"><span class="pre">serial</span></code> backend.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parallelization is getting added to existing analysis classes.  Initially,
only <a class="reference internal" href="rms.html#MDAnalysis.analysis.rms.RMSD" title="MDAnalysis.analysis.rms.RMSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.rms.RMSD</span></code></a> supports parallel analysis, but
we aim to increase support in future releases.</p>
</div>
</section>
<section id="how-does-parallelization-work">
<h2><span class="section-number">4.2.4.2. </span>How does parallelization work<a class="headerlink" href="#how-does-parallelization-work" title="Link to this heading"></a></h2>
<p>The main idea behind its current implementation is that a trajectory analysis is
often trivially parallelizable, meaning you can analyze all frames
independently, and then merge them in a single object. This approach is also
known as “split-apply-combine”, and isn’t new to MDAnalysis users, since it was
first introduced in <a class="reference external" href="https://github.com/mdanalysis/pmda">PMDA</a> <a class="footnote-reference brackets" href="#footcite-fan2019" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.
Version 2.8.0 of MDAnalysis brings this approach to the main library.</p>
<section id="split-apply-combine">
<h3><span class="section-number">4.2.4.2.1. </span>split-apply-combine<a class="headerlink" href="#split-apply-combine" title="Link to this heading"></a></h3>
<p>The following scheme explains the current <a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase.run" title="MDAnalysis.analysis.base.AnalysisBase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AnalysisBase.run</span></code></a> protocol (user-implemented methods
are highlighted in orange):</p>
<figure class="align-default">
<img alt="../../_images/AnalysisBase_parallel.png" src="../../_images/AnalysisBase_parallel.png" />
</figure>
<p>In short, after checking input parameters and configuring the backend,
<code class="xref py py-class docutils literal notranslate"><span class="pre">AnalysisBase</span></code> splits all the
frames into <em>computation groups</em> (equally sized sequential groups of frames to
be processed by each worker). All groups then get <strong>split</strong> between workers of
a backend configured early, the main instance gets serialized and distributed
between workers, and then
<a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._compute" title="MDAnalysis.analysis.base.AnalysisBase._compute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_compute()</span></code></a> method gets called
for all frames of a computation group. Within this method, a user-implemented
<a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._single_frame" title="MDAnalysis.analysis.base.AnalysisBase._single_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_single_frame()</span></code></a> method gets
<strong>applied</strong> to each frame in a computation group.  After that, the main
instance gets an object that will <strong>combine</strong> all the objects from other
workers, and all instances get <em>merged</em> with an instance of
<a class="reference internal" href="results.html#MDAnalysis.analysis.results.ResultsGroup" title="MDAnalysis.analysis.results.ResultsGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.results.ResultsGroup</span></code></a>. Then, a normal
user-implemented <a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._compute" title="MDAnalysis.analysis.base.AnalysisBase._compute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_compute()</span></code></a> method
is called.</p>
<p>Parallelization is fully compatible with existing code and does <em>not</em> break
any existing code pre-2.8.0. The parallelization protocol mimics the
single-process workflow where possible. Thus, user-implemented methods such as
<a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._prepare" title="MDAnalysis.analysis.base.AnalysisBase._prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_prepare()</span></code></a>,
<a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._single_frame" title="MDAnalysis.analysis.base.AnalysisBase._single_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_single_frame()</span></code></a> and
<a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._conclude" title="MDAnalysis.analysis.base.AnalysisBase._conclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_conclude()</span></code></a> won’t need to know
they are operating on an instance within the main python process, or on a
remote instance, since the executed code is the same in both cases.</p>
</section>
<section id="methods-in-analysisbase-for-parallelization">
<h3><span class="section-number">4.2.4.2.2. </span>Methods in <code class="docutils literal notranslate"><span class="pre">AnalysisBase</span></code> for parallelization<a class="headerlink" href="#methods-in-analysisbase-for-parallelization" title="Link to this heading"></a></h3>
<section id="for-developers-of-new-analysis-tools">
<h4><span class="section-number">4.2.4.2.2.1. </span>For developers of new analysis tools<a class="headerlink" href="#for-developers-of-new-analysis-tools" title="Link to this heading"></a></h4>
<p>If you want to write your own <em>parallel</em> analysis class, you have to implement
<a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._prepare" title="MDAnalysis.analysis.base.AnalysisBase._prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_prepare()</span></code></a>,
<a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._single_frame" title="MDAnalysis.analysis.base.AnalysisBase._single_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_single_frame()</span></code></a> and
<a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._conclude" title="MDAnalysis.analysis.base.AnalysisBase._conclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_conclude()</span></code></a>. You also have to
denote if your analysis can run in parallel by following the steps under
<a class="reference internal" href="#adding-parallelization"><span class="std std-ref">Adding parallelization to your own analysis class</span></a>.</p>
</section>
<section id="for-mdanalysis-developers">
<h4><span class="section-number">4.2.4.2.2.2. </span>For MDAnalysis developers<a class="headerlink" href="#for-mdanalysis-developers" title="Link to this heading"></a></h4>
<p>From a developer point of view, there are a few methods that are important in
order to understand how parallelization is implemented:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._define_run_frames" title="MDAnalysis.analysis.base.AnalysisBase._define_run_frames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MDAnalysis.analysis.base.AnalysisBase._define_run_frames()</span></code></a></p></li>
<li><p><a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._prepare_sliced_trajectory" title="MDAnalysis.analysis.base.AnalysisBase._prepare_sliced_trajectory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MDAnalysis.analysis.base.AnalysisBase._prepare_sliced_trajectory()</span></code></a></p></li>
<li><p><a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._configure_backend" title="MDAnalysis.analysis.base.AnalysisBase._configure_backend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MDAnalysis.analysis.base.AnalysisBase._configure_backend()</span></code></a></p></li>
<li><p><a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._setup_computation_groups" title="MDAnalysis.analysis.base.AnalysisBase._setup_computation_groups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MDAnalysis.analysis.base.AnalysisBase._setup_computation_groups()</span></code></a></p></li>
<li><p><a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._compute" title="MDAnalysis.analysis.base.AnalysisBase._compute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MDAnalysis.analysis.base.AnalysisBase._compute()</span></code></a></p></li>
<li><p><a class="reference internal" href="base.html#MDAnalysis.analysis.base.AnalysisBase._get_aggregator" title="MDAnalysis.analysis.base.AnalysisBase._get_aggregator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MDAnalysis.analysis.base.AnalysisBase._get_aggregator()</span></code></a></p></li>
</ol>
<p>The first two methods share the functionality of <code class="xref py py-meth docutils literal notranslate"><span class="pre">_setup_frames()</span></code>.
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_define_run_frames()</span></code> is run once during analysis, as it checks that input
parameters <cite>start</cite>, <cite>stop</cite>, <cite>step</cite> or <cite>frames</cite> are consistent with the given
trajectory and prepares the <code class="docutils literal notranslate"><span class="pre">slicer</span></code> object that defines the iteration
pattern through the trajectory. <code class="xref py py-meth docutils literal notranslate"><span class="pre">_prepare_sliced_trajectory()</span></code> assigns to
the <code class="xref py py-attr docutils literal notranslate"><span class="pre">self._sliced_trajectory</span></code> attribute, computes the number of frames in
it, and fills the <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.frames</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.times</span></code> arrays. In case
the computation will be later split between other processes, this method will
be called again on each of the computation groups.</p>
<p>The method <code class="xref py py-meth docutils literal notranslate"><span class="pre">_configure_backend()</span></code> performs basic health checks for a given
analysis class – namely, it compares a given backend (if it’s a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>
instance, such as <code class="docutils literal notranslate"><span class="pre">'multiprocessing'</span></code>) with the list of builtin backends (and
also the backends implemented for a given analysis subclass), and configures a
<a class="reference internal" href="backends.html#MDAnalysis.analysis.backends.BackendBase" title="MDAnalysis.analysis.backends.BackendBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.backends.BackendBase</span></code></a> instance accordingly. If the
user decides to provide a custom backend (any subclass of
<a class="reference internal" href="backends.html#MDAnalysis.analysis.backends.BackendBase" title="MDAnalysis.analysis.backends.BackendBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.backends.BackendBase</span></code></a>, or anything with an
<code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> method), it ensures that the number of workers wasn’t specified
twice (during backend initialization and in <code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code> arguments).</p>
<p>After a backend is configured, <code class="xref py py-meth docutils literal notranslate"><span class="pre">_setup_computation_groups()</span></code> splits the
frames prepared earlier in <code class="xref py py-attr docutils literal notranslate"><span class="pre">self._prepare_sliced_trajectory</span></code> into a
number of groups, by default equal to the number of workers.</p>
<p>In the <code class="xref py py-meth docutils literal notranslate"><span class="pre">_compute()</span></code> method, frames get initialized again with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_prepare_sliced_trajectory()</span></code>, and attributes necessary for a specific
analysis get initialized with the <code class="xref py py-meth docutils literal notranslate"><span class="pre">_prepare()</span></code> method. Then the function
iterates over <code class="xref py py-attr docutils literal notranslate"><span class="pre">self._sliced_trajectory</span></code>, assigning
<code class="xref py py-attr docutils literal notranslate"><span class="pre">self._frame_index</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">self._ts</span></code> as frame index (within a
computation group) and timestamp, and also setting respective
<code class="xref py py-attr docutils literal notranslate"><span class="pre">self.frames</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.times</span></code> array values.</p>
<p>After <code class="xref py py-meth docutils literal notranslate"><span class="pre">_compute()</span></code> has finished, the main analysis instance calls the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_get_aggregator()</span></code> method, which merges the <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.results</span></code>
attributes from other processes into a single
<a class="reference internal" href="results.html#MDAnalysis.analysis.results.Results" title="MDAnalysis.analysis.results.Results"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.results.Results</span></code></a> instance, making it look for the
subsequent <code class="xref py py-meth docutils literal notranslate"><span class="pre">_conclude()</span></code> method as if the run was performed in a serial
fashion, without parallelization.</p>
</section>
</section>
</section>
<section id="helper-classes-for-parallelization">
<h2><span class="section-number">4.2.4.3. </span>Helper classes for parallelization<a class="headerlink" href="#helper-classes-for-parallelization" title="Link to this heading"></a></h2>
<section id="resultsgroup">
<h3><span class="section-number">4.2.4.3.1. </span><code class="docutils literal notranslate"><span class="pre">ResultsGroup</span></code><a class="headerlink" href="#resultsgroup" title="Link to this heading"></a></h3>
<p><a class="reference internal" href="results.html#MDAnalysis.analysis.results.ResultsGroup" title="MDAnalysis.analysis.results.ResultsGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.results.ResultsGroup</span></code></a> extends the functionality of
the <a class="reference internal" href="results.html#MDAnalysis.analysis.results.Results" title="MDAnalysis.analysis.results.Results"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.results.Results</span></code></a> class. Since the <code class="docutils literal notranslate"><span class="pre">Results</span></code>
class is basically a dictionary that also keeps track of assigned attributes, it
is possible to iterate over all these attributes later. <code class="docutils literal notranslate"><span class="pre">ResultsGroup</span></code> does
exactly that: given a list of the <code class="docutils literal notranslate"><span class="pre">Results</span></code> objects with the same attributes,
it applies a specific aggregation function to every attribute, and stores it as
a same attribute of the returned object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">MDAnalysis.analysis.results</span> <span class="kn">import</span> <span class="n">ResultsGroup</span><span class="p">,</span> <span class="n">Results</span>
<span class="n">group</span> <span class="o">=</span> <span class="n">ResultsGroup</span><span class="p">(</span><span class="n">lookup</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;mass&#39;</span><span class="p">:</span> <span class="n">ResultsGroup</span><span class="o">.</span><span class="n">float_mean</span><span class="p">})</span>
<span class="n">obj1</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">mass</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">obj2</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">mass</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">group</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span><span class="p">])</span> <span class="o">==</span> <span class="n">Results</span><span class="p">(</span><span class="n">mass</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="backendbase">
<h3><span class="section-number">4.2.4.3.2. </span><code class="docutils literal notranslate"><span class="pre">BackendBase</span></code><a class="headerlink" href="#backendbase" title="Link to this heading"></a></h3>
<p><a class="reference internal" href="backends.html#MDAnalysis.analysis.backends.BackendBase" title="MDAnalysis.analysis.backends.BackendBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.backends.BackendBase</span></code></a> holds all backend attributes,
and also implements an <a class="reference internal" href="backends.html#MDAnalysis.analysis.backends.BackendBase.apply" title="MDAnalysis.analysis.backends.BackendBase.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MDAnalysis.analysis.backends.BackendBase.apply()</span></code></a>
method, applying a given function to a list of its parameters, but in a parallel
fashion. Although in <code class="docutils literal notranslate"><span class="pre">AnalysisBase</span></code> it is used to apply a <code class="docutils literal notranslate"><span class="pre">_compute</span></code>
function, in principle it can be used to any arbitrary function and arguments,
given they’re serializable.</p>
</section>
</section>
<section id="when-to-use-parallelization-known-limitations">
<h2><span class="section-number">4.2.4.4. </span>When to use parallelization? (Known limitations)<a class="headerlink" href="#when-to-use-parallelization-known-limitations" title="Link to this heading"></a></h2>
<p>For now, the syntax for running parallel analysis is explicit, meaning by
default the <code class="docutils literal notranslate"><span class="pre">serial</span></code> version will be run, and the parallelization won’t be
enabled by default. Although we expect the parallelization to be useful in most
cases, there are some known caveats from the inital benchmarks.</p>
<section id="fast-single-frame-compared-to-reading-from-disk">
<h3><span class="section-number">4.2.4.4.1. </span>Fast <code class="docutils literal notranslate"><span class="pre">_single_frame</span></code> compared to reading from disk<a class="headerlink" href="#fast-single-frame-compared-to-reading-from-disk" title="Link to this heading"></a></h3>
<p>In all cases, parallelization will not be useful only when frames are being
processed faster than being read from the disk, otherwise reading is the
bottleneck here. Hence, you’ll benefit from parallelization only if you have
relatively much compute per frame, or a fast drive, as illustrated below:</p>
<figure class="align-default">
<img alt="../../_images/parallelization_time.png" src="../../_images/parallelization_time.png" />
</figure>
<p>In other words, if you have <em>fast</em> analysis (say,
<a class="reference internal" href="rms.html#MDAnalysis.analysis.rms.RMSD" title="MDAnalysis.analysis.rms.RMSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.rms.RMSD</span></code></a>) <strong>and</strong> a slow HDD drive, you are likely
to not get any benefits from parallelization. Otherwise, you should be fine.</p>
</section>
<section id="serialization-issues">
<h3><span class="section-number">4.2.4.4.2. </span>Serialization issues<a class="headerlink" href="#serialization-issues" title="Link to this heading"></a></h3>
<p>For built-in analysis classes, the default serialization with both
<a class="reference external" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" title="(in Python v3.12)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> and <code class="xref py py-mod docutils literal notranslate"><span class="pre">dask</span></code> is known to work. If you’re using some custom
analysis class that e.g. stores a non-serializable object in one of its
attributes, you might get a serialization error (<code class="xref py py-exc docutils literal notranslate"><span class="pre">PicklingError</span></code> if you’re
using a <code class="docutils literal notranslate"><span class="pre">multiprocessing</span></code> backend). If you want to get around that, we suggest
trying <code class="docutils literal notranslate"><span class="pre">backend='dask'</span></code> (it uses <code class="docutils literal notranslate"><span class="pre">dask</span></code> serialization engine instead of
<a class="reference external" href="https://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.12)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a>).</p>
</section>
<section id="out-of-memory-issues">
<h3><span class="section-number">4.2.4.4.3. </span>Out of memory issues<a class="headerlink" href="#out-of-memory-issues" title="Link to this heading"></a></h3>
<p>If you have large memory footprint of each worker, you can run into
out-of-memory errors (i.e. your server freezes when executing a run). In this
case we suggest decreasing the number of workers from all available CPUs (that
you can get with <a class="reference external" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.cpu_count" title="(in Python v3.12)"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiprocessing.cpu_count()</span></code></a>) to a smaller number.</p>
</section>
<section id="progress-bar-is-missing">
<h3><span class="section-number">4.2.4.4.4. </span>Progress bar is missing<a class="headerlink" href="#progress-bar-is-missing" title="Link to this heading"></a></h3>
<p>It is yet not possible to get a progress bar running with any parallel backend.
If you want an ETA of your analysis, we suggest running it in <code class="docutils literal notranslate"><span class="pre">serial</span></code> mode
for the first 10-100 frames with <code class="docutils literal notranslate"><span class="pre">verbose=True</span></code>, and then running it with
multiple workers. Processing time scales almost linearly, so you can get your
ETA by dividing <code class="docutils literal notranslate"><span class="pre">serial</span></code> ETA by the number of workers.</p>
</section>
</section>
<section id="adding-parallelization-to-your-own-analysis-class">
<span id="adding-parallelization"></span><h2><span class="section-number">4.2.4.5. </span>Adding parallelization to your own analysis class<a class="headerlink" href="#adding-parallelization-to-your-own-analysis-class" title="Link to this heading"></a></h2>
<p>If you want to add parallelization to your own analysis class, first make sure
your algorithm allows you to do that, i.e. you can process each frame independently.
Then it’s rather simple – let’s look at the actual code that added
parallelization to the <a class="reference internal" href="rms.html#MDAnalysis.analysis.rms.RMSD" title="MDAnalysis.analysis.rms.RMSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.rms.RMSD</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">MDAnalysis.analysis.base</span> <span class="kn">import</span> <span class="n">AnalysisBase</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.analysis.results</span> <span class="kn">import</span> <span class="n">ResultsGroup</span>

<span class="k">class</span> <span class="nc">RMSD</span><span class="p">(</span><span class="n">BackendBase</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_supported_backends</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;serial&#39;</span><span class="p">,</span> <span class="s1">&#39;multiprocessing&#39;</span><span class="p">,</span> <span class="s1">&#39;dask&#39;</span><span class="p">,)</span>

    <span class="n">_analysis_algorithm_is_parallelizable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_get_aggregator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ResultsGroup</span><span class="p">(</span><span class="n">lookup</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;rmsd&#39;</span><span class="p">:</span> <span class="n">ResultsGroup</span><span class="o">.</span><span class="n">ndarray_vstack</span><span class="p">})</span>
</pre></div>
</div>
<p>That’s it! The first two methods are boilerplate –
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_supported_backends()</span></code> returns a tuple with built-in backends that will
work for your class (if there are no serialization issues, it should be all
three), and <code class="docutils literal notranslate"><span class="pre">_is_parallelizable</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (which is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> in
<code class="docutils literal notranslate"><span class="pre">AnalysisBase</span></code>, hence we have to re-define it), and <code class="xref py py-meth docutils literal notranslate"><span class="pre">_get_aggregator()</span></code>
will be used as described earlier. Note that <a class="reference internal" href="results.html#module-MDAnalysis.analysis.results" title="MDAnalysis.analysis.results"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.analysis.results</span></code></a>
also provides a few convenient functions (defined as class methods of
<a class="reference internal" href="results.html#MDAnalysis.analysis.results.ResultsGroup" title="MDAnalysis.analysis.results.ResultsGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResultsGroup</span></code></a>) for results aggregation:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="results.html#MDAnalysis.analysis.results.ResultsGroup.flatten_sequence" title="MDAnalysis.analysis.results.ResultsGroup.flatten_sequence"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flatten_sequence()</span></code></a></p></li>
<li><p><a class="reference internal" href="results.html#MDAnalysis.analysis.results.ResultsGroup.ndarray_sum" title="MDAnalysis.analysis.results.ResultsGroup.ndarray_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndarray_sum()</span></code></a></p></li>
<li><p><a class="reference internal" href="results.html#MDAnalysis.analysis.results.ResultsGroup.ndarray_mean" title="MDAnalysis.analysis.results.ResultsGroup.ndarray_mean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndarray_mean()</span></code></a></p></li>
<li><p><a class="reference internal" href="results.html#MDAnalysis.analysis.results.ResultsGroup.float_mean" title="MDAnalysis.analysis.results.ResultsGroup.float_mean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float_mean()</span></code></a></p></li>
<li><p><a class="reference internal" href="results.html#MDAnalysis.analysis.results.ResultsGroup.ndarray_hstack" title="MDAnalysis.analysis.results.ResultsGroup.ndarray_hstack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndarray_hstack()</span></code></a></p></li>
<li><p><a class="reference internal" href="results.html#MDAnalysis.analysis.results.ResultsGroup.ndarray_vstack" title="MDAnalysis.analysis.results.ResultsGroup.ndarray_vstack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndarray_vstack()</span></code></a></p></li>
</ol>
<p>So you’ll likely find appropriate functions for basic aggregation there.</p>
</section>
<section id="writing-custom-backends">
<h2><span class="section-number">4.2.4.6. </span>Writing custom backends<a class="headerlink" href="#writing-custom-backends" title="Link to this heading"></a></h2>
<p>In order to write your custom backend (e.g. using <code class="xref py py-mod docutils literal notranslate"><span class="pre">dask.distributed</span></code>), inherit
from the <a class="reference internal" href="backends.html#MDAnalysis.analysis.backends.BackendBase" title="MDAnalysis.analysis.backends.BackendBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.backends.BackendBase</span></code></a> and (re)-implement
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> methods. Optionally, you can implement methods for
validation of correct backend initialization – <code class="xref py py-meth docutils literal notranslate"><span class="pre">_get_checks()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_get_warnings()</span></code>, that would raise an exception or give a warning, respectively,
when a new class instance is created:</p>
<ol class="arabic simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">MDAnalysis.analysis.backends._get_checks()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">MDAnalysis.analysis.backends._get_warnings()</span></code></p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">MDAnalysis.analysis.backends</span> <span class="kn">import</span> <span class="n">BackendBase</span>
<span class="k">class</span> <span class="nc">ThreadsBackend</span><span class="p">(</span><span class="n">BackendBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_workers</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">starting_message</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Useless backend&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_workers</span> <span class="o">=</span> <span class="n">n_workers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">starting_message</span> <span class="o">=</span> <span class="n">starting_message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_warnings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="kc">True</span><span class="p">:</span> <span class="s1">&#39;warning: this backend is useless&#39;</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_get_checks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_workers</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;error: self.n_workers is not an integer&#39;</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">computations</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">multiprocessing.dummy</span> <span class="kn">import</span> <span class="n">Pool</span>

        <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_workers</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starting_message</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">computations</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
<p>In order to use a custom backend with another analysis class that does not
explicitly support it, you must <em>explicitly state</em> that you’re about to use an
unsupported_backend by passing the keyword argument
<code class="docutils literal notranslate"><span class="pre">unsupported_backend=True</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">MDAnalysis.analysis.rms</span> <span class="kn">import</span> <span class="n">RMSD</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">RMSD</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1"># setup the run</span>
<span class="n">n_workers</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">backend</span> <span class="o">=</span> <span class="n">ThreadsBackend</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="n">n_workers</span><span class="p">)</span>
<span class="n">R</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">unsupported_backend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In this way, you will override the check for supported backends.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When you use <code class="docutils literal notranslate"><span class="pre">unsupported_backend=True</span></code> you should make sure that you get
the same results as when using a supported backend for which the analysis
class was tested.</p>
<p>Before reporting a problem with an analysis class, make sure you tested it
with a supported backend. When reporting <em>always mention if you used</em>
<code class="docutils literal notranslate"><span class="pre">unsupported_backend=True</span></code>.</p>
</div>
<p class="rubric">References</p>
<div class="docutils container" id="id3">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-fan2019" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>Shujie Fan, Max Linke, Ioannis Paraskevakos, Richard J. Gowers, Michael Gecht, and Oliver Beckstein. PMDA - Parallel Molecular Dynamics Analysis. In Chris Calloway, David Lippa, Dillon Niederhut, and David Shupe, editors, <em>Proceedings of the 18th Python in Science Conference</em>, 134 – 142. Austin, TX, 2019. SciPy. <a class="reference external" href="https://doi.org/10.25080/Majora-7ddc1dd1-013">doi:10.25080/Majora-7ddc1dd1-013</a>.</p>
</aside>
</aside>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="results.html" class="btn btn-neutral float-left" title="4.2.3. Analysis results and their aggregation — MDAnalysis.analysis.results" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="align.html" class="btn btn-neutral float-right" title="4.3.1. Coordinate fitting and alignment — MDAnalysis.analysis.align" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2024, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Henok Ademtew, Shobhit Agarwal, Aya M. Alaa, Irfan Alibay, Kazi Shudipto Amin, Anshul Angaria, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Patricio Barletta, Leonardo Barneschi, Jonathan Barnoud, Estefania Barreto-Ojeda, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Kavya Bisht, Wouter Boomsma, Jose Borreguero, Cédric Bouysset, Kevin Boyd, Meet Brijwani, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, Yantong Cai, David Caplan, Yuanyu Chang, Pratham Chauhan, Matthieu Chavent, Haochuan Chen, Xu Hong Chen, Kathleen Clark, Jennifer A Clark, Orion Cohen, Charlie Cook, Ruggero Cortini, Nicholas Craven, Ramon Crehuet, Davide Cruz, Matthew Davies, Robert Delgado, John Detlefs, Xavier Deupi, Bradley Dice, Jan Domanski, David L. Dotson, Mark D. Driver, Ali Ehlen, Daniel J. Evans, Shujie Fan, Bjarne Feddersen, Lennard van der Feltz, Jake Fennick, Philip Fowler, Guillaume Fraux, Anirvinya G, Michael Gecht, Ahmed Salah Ghoneim, Mikhail Glagolev, William Glass, Jenna M. Swarthout Goddard, Joseph Goose, Alexander Gorfer, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Pratik Gupta, Sumit Gupta, Benjamin Hall, Ameya Harmalkar, Ivan Hristov, Eugen Hruska, Kyle J. Huston, Siddharth Jain, Edis Jakupovic, Joe Jordan, Henrik Jäger, Uma D Kadam, Aditya Kamath, Jon Kapla, Ian M. Kenney, Aditya Keshari, Haleema Khan, Navya Khare, Utsav Khatu, Andrew William King, Henry Kobin, Abhishek A. Kognole, Kosuke Kudo, Atharva Kulkarni, Manish Kumar, Mohit Kumar, Shubham Kumar, Alia Lescoulie, Zhenbo Li, Max Linke, Philip Loche, Jinju Lu, Hugo MacDermott-Opeskin, Shaivi Malik, Egor Marin, Domenico Marson, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Kurt McKee, Rocco Meli, Manuel Nuno Melo, Marcelo C. R. Melo, Dominik &#39;Rathann&#39; Mierzejewski, David Minh, Geongi Moon, Sampurna Mukherjee, Henry Mull, Morgan L. Nance, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Meghan Osato, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Dimitrios Papageorgiou, Rafael R. Pappalardo, Vishal Parmar, Danny Parton, Shakul Pathak, Christian Pfaendner, Joshua L. Phillips, Marcelo D. Poleto, Hannah Pollak, Kashish Punjani, Michael Quevillon, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Andrea Rizzi, Xiaoxu Ruan, Carlos Yanez S., Utkarsh Saxena, Moritz Schaeffler, Alexander Schlaich, Marcello Sega, Ricky Sexton, Sean L. Seyler, Faraaz Shah, Sulay Shah, Abhishek Shandilya, Shubham Sharma, Laksh Krishna Sharma, Rishabh Shukla, Karthikeyan Singaravelan, Tamandeep Singh, Brigitta Sipőcz, Paul Smith, Andy Somogyi, Caio S. Souza, Kai Niklas Spauszus, David van der Spoel, Shantanu Srivastava, Lukas Stelzl, Jan Stevens, Gorman Stock, Philipp Stärk, Johannes Stöckelmaier, Fenil Suchak, Ayush Suhane, Filip T. Szczypiński, Sukeerti T, Matthijs Tadema, Valerij Talagayev, Joao Miguel Correia Teixeira, Paarth Thadani, Matthew W. Thompson, Hao Tian, Matteo Tiberti, Zaheer Timol, Wiep van der Toorn, Mieczyslaw Torchala, Aditi Tripathi, Heet Vekariya, Mark Verma, Josh Vermaas, Isaac Virshup, Lily Wang, Leon Wehrhan, Nestor Wendt, Lawson Woods, Zhiyi Wu, Tengyu Xie, Zhuyi Xue, Mingyi Xue, Alexander Yang, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, Raymond Zhao, Yuxuan Zhuang, Fabian Zills, and Oliver Beckstein.</p>
  </div>

  

<div class="footer"><p>Please see
    our <a href="https://www.mdanalysis.org/pages/privacy/">Privacy Policy</a>
    to learn how <a href="https://www.mdanalysis.org">MDAnalysis</a> collects data.</p>
    <script data-goatcounter="https://mdanalysis.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</div>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
    var versions_json_url = 'https://docs.mdanalysis.org/versions.json'
</script>

<div class="rst-versions" data-toggle="rst-versions" role="note"
     aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
        2.8.0-dev0
      <span class="fa fa-caret-down"></span>
    </span>

    <div class="rst-other-versions">
        <dl id="versionselector">
            <dt>Other Versions</dt>
        </dl>

    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>