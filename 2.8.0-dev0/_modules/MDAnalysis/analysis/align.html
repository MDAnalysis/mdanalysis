


  
    
  




<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="shortcut icon" href="../../../_static/logo/mda_favicon.ico">
</head>

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MDAnalysis.analysis.align &mdash; MDAnalysis 2.8.0-dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/site.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=a9b57af3"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/js/versions.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 2.8.0-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >




  




<a href="../../../index.html">
  
    <img src="../../../_static/logo/mda_logo.png" class="logo" alt="Logo"/>
</a>


  
  
  
    <div class="version">
      2.8.0-dev0
    </div>
  



<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>
<div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
    <!-- <p class="caption" role="heading"></p> -->
    <ul>
        
        <li class="toctree-l1"><a class="reference internal" href="http://mdanalysis.org">MDAnalysis</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="http://userguide.mdanalysis.org">User guide</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="https://mdakits.mdanalysis.org/">MDAKits</a></li>
        
    </ul>
    
        <p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/converters.html">7. Converter modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/trajectory_transformations.html">8. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections_modules.html">9. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/auxiliary_modules.html">10. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/core_modules.html">11. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/visualization_modules.html">12. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/lib_modules.html">13. Library functions — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/version.html">14. Version information for MDAnalysis - <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/units.html">15. Constants and unit conversion — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/exceptions.html">16. Custom exceptions and warnings — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/references.html">17. References</a></li>
</ul>

</div>

      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MDAnalysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">MDAnalysis.analysis.align</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MDAnalysis.analysis.align</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1"># doi: 10.25080/majora-629e541a-00e</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;Coordinate fitting and alignment --- :mod:`MDAnalysis.analysis.align`</span>
<span class="sd">=====================================================================</span>

<span class="sd">:Author: Oliver Beckstein, Joshua Adelman</span>
<span class="sd">:Year: 2010--2013</span>
<span class="sd">:Copyright: GNU Public License v3</span>

<span class="sd">The module contains functions to fit a target structure to a reference</span>
<span class="sd">structure. They use the fast QCP algorithm to calculate the root mean</span>
<span class="sd">square distance (RMSD) between two coordinate sets [Theobald2005]_ and</span>
<span class="sd">the rotation matrix *R* that minimizes the RMSD [Liu2010]_. (Please</span>
<span class="sd">cite these references when using this module.).</span>

<span class="sd">Typically, one selects a group of atoms (such as the C-alphas),</span>
<span class="sd">calculates the RMSD and transformation matrix, and applys the</span>
<span class="sd">transformation to the current frame of a trajectory to obtain the</span>
<span class="sd">rotated structure. The :func:`alignto` and :class:`AlignTraj`</span>
<span class="sd">functions can be used to do this for individual frames and</span>
<span class="sd">trajectories respectively.</span>

<span class="sd">The :ref:`RMS-fitting-tutorial` shows how to do the individual steps</span>
<span class="sd">manually and explains the intermediate steps.</span>

<span class="sd">See Also</span>
<span class="sd">--------</span>
<span class="sd">:mod:`MDAnalysis.analysis.rms`</span>
<span class="sd">     contains functions to compute RMSD (when structural alignment is not</span>
<span class="sd">     required)</span>
<span class="sd">:mod:`MDAnalysis.lib.qcprot`</span>
<span class="sd">     implements the fast RMSD algorithm.</span>


<span class="sd">.. _RMS-fitting-tutorial:</span>

<span class="sd">RMS-fitting tutorial</span>
<span class="sd">--------------------</span>

<span class="sd">The example uses files provided as part of the MDAnalysis test suite</span>
<span class="sd">(in the variables :data:`~MDAnalysis.tests.datafiles.PSF`,</span>
<span class="sd">:data:`~MDAnalysis.tests.datafiles.DCD`, and</span>
<span class="sd">:data:`~MDAnalysis.tests.datafiles.PDB_small`). For all further</span>
<span class="sd">examples execute first ::</span>

<span class="sd">   &gt;&gt;&gt; import MDAnalysis as mda</span>
<span class="sd">   &gt;&gt;&gt; from MDAnalysis.analysis import align</span>
<span class="sd">   &gt;&gt;&gt; from MDAnalysis.analysis.rms import rmsd</span>
<span class="sd">   &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF, DCD, PDB_small</span>


<span class="sd">In the simplest case, we can simply calculate the C-alpha RMSD between</span>
<span class="sd">two structures, using :func:`rmsd`::</span>

<span class="sd">   &gt;&gt;&gt; ref = mda.Universe(PDB_small)</span>
<span class="sd">   &gt;&gt;&gt; mobile = mda.Universe(PSF, DCD)</span>
<span class="sd">   &gt;&gt;&gt; rmsd(mobile.select_atoms(&#39;name CA&#39;).positions, ref.select_atoms(&#39;name CA&#39;).positions)</span>
<span class="sd">   28.20178579474479</span>

<span class="sd">Note that in this example translations have not been removed. In order</span>
<span class="sd">to look at the pure rotation one needs to superimpose the centres of</span>
<span class="sd">mass (or geometry) first::</span>

<span class="sd">   &gt;&gt;&gt; rmsd(mobile.select_atoms(&#39;name CA&#39;).positions, ref.select_atoms(&#39;name CA&#39;).positions, center=True)</span>
<span class="sd">   21.892591663632704</span>

<span class="sd">This has only done a translational superposition. If you want to also do a</span>
<span class="sd">rotational superposition use the superposition keyword. This will calculate a</span>
<span class="sd">minimized RMSD between the reference and mobile structure::</span>

<span class="sd">   &gt;&gt;&gt; rmsd(mobile.select_atoms(&#39;name CA&#39;).positions, ref.select_atoms(&#39;name CA&#39;).positions, </span>
<span class="sd">   ...      superposition=True)</span>
<span class="sd">   6.809396586471815</span>

<span class="sd">The rotation matrix that superimposes *mobile* on *ref* while</span>
<span class="sd">minimizing the CA-RMSD is obtained with the :func:`rotation_matrix`</span>
<span class="sd">function ::</span>

<span class="sd">   &gt;&gt;&gt; mobile0 = mobile.select_atoms(&#39;name CA&#39;).positions - mobile.select_atoms(&#39;name CA&#39;).center_of_mass()</span>
<span class="sd">   &gt;&gt;&gt; ref0 = ref.select_atoms(&#39;name CA&#39;).positions - ref.select_atoms(&#39;name CA&#39;).center_of_mass()</span>
<span class="sd">   &gt;&gt;&gt; R, rmsd = align.rotation_matrix(mobile0, ref0)</span>
<span class="sd">   &gt;&gt;&gt; rmsd</span>
<span class="sd">   6.809396586471805</span>
<span class="sd">   &gt;&gt;&gt; R</span>
<span class="sd">   array([[ 0.14514539, -0.27259113,  0.95111876],</span>
<span class="sd">   ...    [ 0.88652593,  0.46267112, -0.00268642],</span>
<span class="sd">   ...    [-0.43932289,  0.84358136,  0.30881368]])</span>

<span class="sd">Putting all this together one can superimpose all of *mobile* onto *ref*::</span>

<span class="sd">   &gt;&gt;&gt; mobile.atoms.translate(-mobile.select_atoms(&#39;name CA&#39;).center_of_mass())</span>
<span class="sd">   &lt;AtomGroup with 3341 atoms&gt;</span>
<span class="sd">   &gt;&gt;&gt; mobile.atoms.rotate(R)</span>
<span class="sd">   &lt;AtomGroup with 3341 atoms&gt;</span>
<span class="sd">   &gt;&gt;&gt; mobile.atoms.translate(ref.select_atoms(&#39;name CA&#39;).center_of_mass())</span>
<span class="sd">   &lt;AtomGroup with 3341 atoms&gt;</span>
<span class="sd">   &gt;&gt;&gt; mobile.atoms.write(&quot;mobile_on_ref.pdb&quot;)</span>


<span class="sd">Common usage</span>
<span class="sd">------------</span>

<span class="sd">To **fit a single structure** with :func:`alignto`::</span>

<span class="sd">   &gt;&gt;&gt; ref = mda.Universe(PSF, PDB_small)</span>
<span class="sd">   &gt;&gt;&gt; mobile = mda.Universe(PSF, DCD)     # we use the first frame</span>
<span class="sd">   &gt;&gt;&gt; align.alignto(mobile, ref, select=&quot;protein and name CA&quot;, weights=&quot;mass&quot;)</span>
<span class="sd">   (21.892591663632704, 6.809396586471809)</span>

<span class="sd">This will change *all* coordinates in *mobile* so that the protein</span>
<span class="sd">C-alpha atoms are optimally superimposed (translation and rotation).</span>

<span class="sd">To **fit a whole trajectory** to a reference structure with the</span>
<span class="sd">:class:`AlignTraj` class::</span>

<span class="sd">   &gt;&gt;&gt; ref = mda.Universe(PSF, PDB_small)   # reference structure 1AKE</span>
<span class="sd">   &gt;&gt;&gt; trj = mda.Universe(PSF, DCD)         # trajectory of change 1AKE-&gt;4AKE</span>
<span class="sd">   &gt;&gt;&gt; alignment = align.AlignTraj(trj, ref, filename=&#39;rmsfit.dcd&#39;)</span>
<span class="sd">   &gt;&gt;&gt; alignment.run()</span>
<span class="sd">   &lt;MDAnalysis.analysis.align.AlignTraj object at ...&gt; </span>

<span class="sd">It is also possible to align two arbitrary structures by providing a</span>
<span class="sd">mapping between atoms based on a sequence alignment. This allows</span>
<span class="sd">fitting of structural homologs or wild type and mutant.</span>

<span class="sd">If a alignment was provided as &quot;sequences.aln&quot; one would first produce</span>
<span class="sd">the appropriate MDAnalysis selections with the :func:`fasta2select`</span>
<span class="sd">function and then feed the resulting dictionary to :class:`AlignTraj`::</span>

<span class="sd">   &gt;&gt;&gt; seldict = align.fasta2select(&#39;sequences.aln&#39;) # doctest: +SKIP</span>
<span class="sd">   &gt;&gt;&gt; alignment = align.AlignTraj(trj, ref, filename=&#39;rmsfit.dcd&#39;, select=seldict) # doctest: +SKIP</span>
<span class="sd">   &gt;&gt;&gt; alignment.run() # doctest: +SKIP</span>

<span class="sd">(See the documentation of the functions for this advanced usage.)</span>


<span class="sd">Functions and Classes</span>
<span class="sd">---------------------</span>

<span class="sd">.. versionchanged:: 0.10.0</span>
<span class="sd">   Function :func:`~MDAnalysis.analysis.rms.rmsd` was removed from</span>
<span class="sd">   this module and is now exclusively accessible as</span>
<span class="sd">   :func:`~MDAnalysis.analysis.rms.rmsd`.</span>

<span class="sd">.. versionchanged:: 0.16.0</span>
<span class="sd">   Function :func:`~MDAnalysis.analysis.align.rms_fit_trj` deprecated</span>
<span class="sd">   in favor of :class:`AlignTraj` class.</span>

<span class="sd">.. versionchanged:: 0.17.0</span>
<span class="sd">   removed deprecated :func:`~MDAnalysis.analysis.align.rms_fit_trj`</span>

<span class="sd">.. autofunction:: alignto</span>
<span class="sd">.. autoclass:: AlignTraj</span>
<span class="sd">.. autoclass:: AverageStructure</span>
<span class="sd">.. autofunction:: rotation_matrix</span>
<span class="sd">.. autofunction:: iterative_average</span>


<span class="sd">Helper functions</span>
<span class="sd">----------------</span>

<span class="sd">The following functions are used by the other functions in this</span>
<span class="sd">module. They are probably of more interest to developers than to</span>
<span class="sd">normal users.</span>

<span class="sd">.. autofunction:: _fit_to</span>
<span class="sd">.. autofunction:: fasta2select</span>
<span class="sd">.. autofunction:: sequence_alignment</span>
<span class="sd">.. autofunction:: get_matching_atoms</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">collections</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">Bio.AlignIO</span>
    <span class="kn">import</span> <span class="nn">Bio.Align</span>
    <span class="kn">import</span> <span class="nn">Bio.Align.Applications</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">HAS_BIOPYTHON</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">HAS_BIOPYTHON</span> <span class="o">=</span> <span class="kc">True</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span> <span class="k">as</span> <span class="nn">mda</span>
<span class="kn">import</span> <span class="nn">MDAnalysis.lib.qcprot</span> <span class="k">as</span> <span class="nn">qcp</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.exceptions</span> <span class="kn">import</span> <span class="n">SelectionError</span><span class="p">,</span> <span class="n">SelectionWarning</span>
<span class="kn">import</span> <span class="nn">MDAnalysis.analysis.rms</span> <span class="k">as</span> <span class="nn">rms</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.coordinates.memory</span> <span class="kn">import</span> <span class="n">MemoryReader</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.util</span> <span class="kn">import</span> <span class="n">get_weights</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.util</span> <span class="kn">import</span> <span class="n">deprecate</span>   <span class="c1"># remove 3.0</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.log</span> <span class="kn">import</span> <span class="n">ProgressBar</span>
<span class="kn">from</span> <span class="nn">..due</span> <span class="kn">import</span> <span class="n">due</span><span class="p">,</span> <span class="n">Doi</span>

<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">AnalysisBase</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;MDAnalysis.analysis.align&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="rotation_matrix">
<a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align.rotation_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">rotation_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the 3x3 rotation matrix `R` for RMSD fitting coordinate</span>
<span class="sd">    sets `a` and `b`.</span>

<span class="sd">    The rotation matrix `R` transforms vector `a` to overlap with</span>
<span class="sd">    vector `b` (i.e., `b` is the reference structure):</span>

<span class="sd">    .. math::</span>
<span class="sd">       \mathbf{b} = \mathsf{R} \cdot \mathbf{a}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        coordinates that are to be rotated (&quot;mobile set&quot;); array of N atoms</span>
<span class="sd">        of shape N*3 as generated by, e.g.,</span>
<span class="sd">        :attr:`MDAnalysis.core.groups.AtomGroup.positions`.</span>
<span class="sd">    b : array_like</span>
<span class="sd">        reference coordinates; array of N atoms of shape N*3 as generated by,</span>
<span class="sd">        e.g., :attr:`MDAnalysis.core.groups.AtomGroup.positions`.</span>
<span class="sd">    weights : array_like (optional)</span>
<span class="sd">        array of floats of size N for doing weighted RMSD fitting (e.g. the</span>
<span class="sd">        masses of the atoms)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : ndarray</span>
<span class="sd">        rotation matrix</span>
<span class="sd">    rmsd : float</span>
<span class="sd">        RMSD between `a` and `b` before rotation</span>
<span class="sd">    ``(R, rmsd)`` rmsd and rotation matrix *R*</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    `R` can be used as an argument for</span>
<span class="sd">    :meth:`MDAnalysis.core.groups.AtomGroup.rotate` to generate a rotated</span>
<span class="sd">    selection, e.g. ::</span>

<span class="sd">        &gt;&gt;&gt; from MDAnalysisTests.datafiles import TPR, TRR</span>
<span class="sd">        &gt;&gt;&gt; from MDAnalysis.analysis import align</span>
<span class="sd">        &gt;&gt;&gt; A = mda.Universe(TPR,TRR)</span>
<span class="sd">        &gt;&gt;&gt; B = A.copy()</span>
<span class="sd">        &gt;&gt;&gt; R = rotation_matrix(A.select_atoms(&#39;backbone&#39;).positions,</span>
<span class="sd">        ...                     B.select_atoms(&#39;backbone&#39;).positions)[0]</span>
<span class="sd">        &gt;&gt;&gt; A.atoms.rotate(R)</span>
<span class="sd">        &lt;AtomGroup with 47681 atoms&gt;</span>
<span class="sd">        &gt;&gt;&gt; A.atoms.write(&quot;rotated.pdb&quot;)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function does *not* shift the centers of mass or geometry;</span>
<span class="sd">    this needs to be done by the user.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MDAnalysis.analysis.rms.rmsd: Calculates the RMSD between *a* and *b*.</span>
<span class="sd">    alignto: A complete fit of two structures.</span>
<span class="sd">    AlignTraj: Fit a whole trajectory.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;a&#39; and &#39;b&#39; must have same shape&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="mf">0.0</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># qcp does NOT divide weights relative to the mean</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># Need to transpose coordinates such that the coordinate array is</span>
    <span class="c1"># 3xN instead of Nx3. Also qcp requires that the dtype be float64</span>
    <span class="c1"># (I think we swapped the position of ref and traj in CalcRMSDRotationalMatrix</span>
    <span class="c1"># so that R acts **to the left** and can be broadcasted; we&#39;re saving</span>
    <span class="c1"># one transpose. [orbeckst])</span>
    <span class="n">rmsd</span> <span class="o">=</span> <span class="n">qcp</span><span class="o">.</span><span class="n">CalcRMSDRotationalMatrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">rmsd</span></div>



<div class="viewcode-block" id="_fit_to">
<a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align._fit_to">[docs]</a>
<span class="k">def</span> <span class="nf">_fit_to</span><span class="p">(</span><span class="n">mobile_coordinates</span><span class="p">,</span> <span class="n">ref_coordinates</span><span class="p">,</span> <span class="n">mobile_atoms</span><span class="p">,</span>
            <span class="n">mobile_com</span><span class="p">,</span> <span class="n">ref_com</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Perform an rmsd-fitting to determine rotation matrix and align atoms</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mobile_coordinates : ndarray</span>
<span class="sd">        Coordinates of atoms to be aligned</span>
<span class="sd">    ref_coordinates : ndarray</span>
<span class="sd">        Coordinates of atoms to be fit against</span>
<span class="sd">    mobile_atoms : AtomGroup</span>
<span class="sd">        Atoms to be translated</span>
<span class="sd">    mobile_com: ndarray</span>
<span class="sd">        array of xyz coordinate of mobile center of mass</span>
<span class="sd">    ref_com : ndarray</span>
<span class="sd">        array of xyz coordinate of reference center of mass</span>
<span class="sd">    weights : array_like (optional)</span>
<span class="sd">       choose weights. With ``None`` weigh each atom equally. If a float array</span>
<span class="sd">       of the same length as `mobile_coordinates` is provided, use each element</span>
<span class="sd">       of the `array_like` as a weight for the corresponding atom in</span>
<span class="sd">       `mobile_coordinates`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mobile_atoms : AtomGroup</span>
<span class="sd">        AtomGroup of translated and rotated atoms</span>
<span class="sd">    min_rmsd : float</span>
<span class="sd">        Minimum rmsd of coordinates</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function assumes that `mobile_coordinates` and `ref_coordinates` have</span>
<span class="sd">    already been shifted so that their centers of geometry (or centers of mass,</span>
<span class="sd">    depending on `weights`) coincide at the origin. `mobile_com` and `ref_com`</span>
<span class="sd">    are the centers *before* this shift.</span>

<span class="sd">    1. The rotation matrix :math:`\mathsf{R}` is determined with</span>
<span class="sd">       :func:`rotation_matrix` directly from `mobile_coordinates` and</span>
<span class="sd">       `ref_coordinates`.</span>
<span class="sd">    2. `mobile_atoms` :math:`X` is rotated according to the</span>
<span class="sd">       rotation matrix and the centers according to</span>

<span class="sd">       .. math::</span>

<span class="sd">           X&#39; = \mathsf{R}(X - \bar{X}) + \bar{X}_{\text{ref}}</span>

<span class="sd">       where :math:`\bar{X}` is the center.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span><span class="p">,</span> <span class="n">min_rmsd</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">mobile_coordinates</span><span class="p">,</span> <span class="n">ref_coordinates</span><span class="p">,</span>
                                  <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

    <span class="n">mobile_atoms</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">mobile_com</span><span class="p">)</span>
    <span class="n">mobile_atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="n">mobile_atoms</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">ref_com</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mobile_atoms</span><span class="p">,</span> <span class="n">min_rmsd</span></div>



<div class="viewcode-block" id="alignto">
<a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align.alignto">[docs]</a>
<span class="k">def</span> <span class="nf">alignto</span><span class="p">(</span><span class="n">mobile</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">subselection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">match_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform a spatial superposition by minimizing the RMSD.</span>

<span class="sd">    Spatially align the group of atoms `mobile` to `reference` by</span>
<span class="sd">    doing a RMSD fit on `select` atoms.</span>

<span class="sd">    The superposition is done in the following way:</span>

<span class="sd">    1. A rotation matrix is computed that minimizes the RMSD between</span>
<span class="sd">       the coordinates of `mobile.select_atoms(sel1)` and</span>
<span class="sd">       `reference.select_atoms(sel2)`; before the rotation, `mobile` is</span>
<span class="sd">       translated so that its center of geometry (or center of mass)</span>
<span class="sd">       coincides with the one of `reference`. (See below for explanation of</span>
<span class="sd">       how *sel1* and *sel2* are derived from `select`.)</span>

<span class="sd">    2. All atoms in :class:`~MDAnalysis.core.universe.Universe` that</span>
<span class="sd">       contain `mobile` are shifted and rotated. (See below for how</span>
<span class="sd">       to change this behavior through the `subselection` keyword.)</span>

<span class="sd">    The `mobile` and `reference` atom groups can be constructed so that they</span>
<span class="sd">    already match atom by atom. In this case, `select` should be set to &quot;all&quot;</span>
<span class="sd">    (or ``None``) so that no further selections are applied to `mobile` and</span>
<span class="sd">    `reference`, therefore preserving the exact atom ordering (see</span>
<span class="sd">    :ref:`ordered-selections-label`).</span>

<span class="sd">    .. Warning:: The atom order for `mobile` and `reference` is *only*</span>
<span class="sd">       preserved when `select` is either &quot;all&quot; or ``None``. In any other case,</span>
<span class="sd">       a new selection will be made that will sort the resulting AtomGroup by</span>
<span class="sd">       index and therefore destroy the correspondence between the two groups.</span>
<span class="sd">       **It is safest not to mix ordered AtomGroups with selection strings.**</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mobile : Universe or AtomGroup</span>
<span class="sd">       structure to be aligned, a</span>
<span class="sd">       :class:`~MDAnalysis.core.groups.AtomGroup` or a whole</span>
<span class="sd">       :class:`~MDAnalysis.core.universe.Universe`</span>
<span class="sd">    reference : Universe or AtomGroup</span>
<span class="sd">       reference structure, a :class:`~MDAnalysis.core.groups.AtomGroup`</span>
<span class="sd">       or a whole :class:`~MDAnalysis.core.universe.Universe`</span>
<span class="sd">    select : str or dict or tuple (optional)</span>
<span class="sd">       The selection to operate on; can be one of:</span>

<span class="sd">       1. any valid selection string for</span>
<span class="sd">          :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` that</span>
<span class="sd">          produces identical selections in `mobile` and `reference`; or</span>

<span class="sd">       2. a dictionary ``{&#39;mobile&#39;: sel1, &#39;reference&#39;: sel2}`` where *sel1*</span>
<span class="sd">          and *sel2* are valid selection strings that are applied to</span>
<span class="sd">          `mobile` and `reference` respectively (the</span>
<span class="sd">          :func:`MDAnalysis.analysis.align.fasta2select` function returns such</span>
<span class="sd">          a dictionary based on a ClustalW_ or STAMP_ sequence alignment); or</span>

<span class="sd">       3. a tuple ``(sel1, sel2)``</span>

<span class="sd">       When using 2. or 3. with *sel1* and *sel2* then these selection strings</span>
<span class="sd">       are applied to `atomgroup` and `reference` respectively and should</span>
<span class="sd">       generate *groups of equivalent atoms*.  *sel1* and *sel2* can each also</span>
<span class="sd">       be a *list of selection strings* to generate a</span>
<span class="sd">       :class:`~MDAnalysis.core.groups.AtomGroup` with defined atom order as</span>
<span class="sd">       described under :ref:`ordered-selections-label`).</span>
<span class="sd">    match_atoms : bool (optional)</span>
<span class="sd">        Whether to match the mobile and reference atom-by-atom. Default ``True``.</span>
<span class="sd">    weights : {&quot;mass&quot;, ``None``} or array_like (optional)</span>
<span class="sd">       choose weights. With ``&quot;mass&quot;`` uses masses as weights; with ``None``</span>
<span class="sd">       weigh each atom equally. If a float array of the same length as</span>
<span class="sd">       `mobile` is provided, use each element of the `array_like` as a</span>
<span class="sd">       weight for the corresponding atom in `mobile`.</span>
<span class="sd">    tol_mass: float (optional)</span>
<span class="sd">       Reject match if the atomic masses for matched atoms differ by more than</span>
<span class="sd">       `tol_mass`, default [0.1]</span>
<span class="sd">    strict: bool (optional)</span>
<span class="sd">       ``True``</span>
<span class="sd">           Will raise :exc:`SelectionError` if a single atom does not</span>
<span class="sd">           match between the two selections.</span>
<span class="sd">       ``False`` [default]</span>
<span class="sd">           Will try to prepare a matching selection by dropping</span>
<span class="sd">           residues with non-matching atoms. See :func:`get_matching_atoms`</span>
<span class="sd">           for details.</span>
<span class="sd">    subselection : str or AtomGroup or None (optional)</span>
<span class="sd">       Apply the transformation only to this selection.</span>

<span class="sd">       ``None`` [default]</span>
<span class="sd">           Apply to ``mobile.universe.atoms`` (i.e., all atoms in the</span>
<span class="sd">           context of the selection from `mobile` such as the rest of a</span>
<span class="sd">           protein, ligands and the surrounding water)</span>
<span class="sd">       *selection-string*</span>
<span class="sd">           Apply to ``mobile.select_atoms(selection-string)``</span>
<span class="sd">       :class:`~MDAnalysis.core.groups.AtomGroup`</span>
<span class="sd">           Apply to the arbitrary group of atoms</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    old_rmsd : float</span>
<span class="sd">        RMSD before spatial alignment</span>
<span class="sd">    new_rmsd : float</span>
<span class="sd">        RMSD after spatial alignment</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    AlignTraj: More efficient method for RMSD-fitting trajectories.</span>


<span class="sd">    .. _ClustalW: http://www.clustal.org/</span>
<span class="sd">    .. _STAMP: http://www.compbio.dundee.ac.uk/manuals/stamp.4.2/</span>

<span class="sd">    .. versionchanged:: 1.0.0</span>
<span class="sd">       Added *match_atoms* keyword to toggle atom matching.</span>

<span class="sd">    .. versionchanged:: 0.8</span>
<span class="sd">       Added check that the two groups describe the same atoms including</span>
<span class="sd">       the new *tol_mass* keyword.</span>

<span class="sd">    .. versionchanged:: 0.10.0</span>
<span class="sd">       Uses :func:`get_matching_atoms` to work with incomplete selections</span>
<span class="sd">       and new `strict` keyword. The new default is to be lenient whereas</span>
<span class="sd">       the old behavior was the equivalent of ``strict = True``.</span>

<span class="sd">    .. versionchanged:: 0.16.0</span>
<span class="sd">       new general &#39;weights&#39; kwarg replace `mass_weighted`, deprecated `mass_weighted`</span>
<span class="sd">    .. deprecated:: 0.16.0</span>
<span class="sd">       Instead of ``mass_weighted=True`` use new ``weights=&#39;mass&#39;``</span>

<span class="sd">    .. versionchanged:: 0.17.0</span>
<span class="sd">       Deprecated keyword `mass_weighted` was removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">select</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># keep the EXACT order in the input AtomGroups; select_atoms(&#39;all&#39;)</span>
        <span class="c1"># orders them by index, which can lead to wrong results if the user</span>
        <span class="c1"># has crafted mobile and reference to match atom by atom</span>
        <span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">mobile</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">ref_atoms</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">atoms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">rms</span><span class="o">.</span><span class="n">process_selection</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">mobile</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">select</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">])</span>
        <span class="n">ref_atoms</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">select</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">])</span>


    <span class="n">ref_atoms</span><span class="p">,</span> <span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">get_matching_atoms</span><span class="p">(</span><span class="n">ref_atoms</span><span class="p">,</span> <span class="n">mobile_atoms</span><span class="p">,</span>
                                                <span class="n">tol_mass</span><span class="o">=</span><span class="n">tol_mass</span><span class="p">,</span>
                                                <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
                                                <span class="n">match_atoms</span><span class="o">=</span><span class="n">match_atoms</span><span class="p">)</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="n">get_weights</span><span class="p">(</span><span class="n">ref_atoms</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

    <span class="n">mobile_com</span> <span class="o">=</span> <span class="n">mobile_atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">ref_com</span> <span class="o">=</span> <span class="n">ref_atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="n">ref_coordinates</span> <span class="o">=</span> <span class="n">ref_atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">ref_com</span>
    <span class="n">mobile_coordinates</span> <span class="o">=</span> <span class="n">mobile_atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">mobile_com</span>

    <span class="n">old_rmsd</span> <span class="o">=</span> <span class="n">rms</span><span class="o">.</span><span class="n">rmsd</span><span class="p">(</span><span class="n">mobile_coordinates</span><span class="p">,</span> <span class="n">ref_coordinates</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">subselection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># mobile_atoms is Universe</span>
        <span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">mobile</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subselection</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># select mobile_atoms from string</span>
        <span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">mobile</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">subselection</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># treat subselection as AtomGroup</span>
            <span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">subselection</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;subselection must be a selection string, an&quot;</span>
                   <span class="s2">&quot; AtomGroup or Universe or None&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>


    <span class="c1"># _fit_to DOES subtract center of mass, will provide proper min_rmsd</span>
    <span class="n">mobile_atoms</span><span class="p">,</span> <span class="n">new_rmsd</span> <span class="o">=</span> <span class="n">_fit_to</span><span class="p">(</span><span class="n">mobile_coordinates</span><span class="p">,</span> <span class="n">ref_coordinates</span><span class="p">,</span>
                                     <span class="n">mobile_atoms</span><span class="p">,</span> <span class="n">mobile_com</span><span class="p">,</span> <span class="n">ref_com</span><span class="p">,</span>
                                     <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">old_rmsd</span><span class="p">,</span> <span class="n">new_rmsd</span></div>



<div class="viewcode-block" id="iterative_average">
<a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align.iterative_average">[docs]</a>
<span class="nd">@due</span><span class="o">.</span><span class="n">dcite</span><span class="p">(</span>
        <span class="n">Doi</span><span class="p">(</span><span class="s2">&quot;10.1021/acs.jpcb.7b11988&quot;</span><span class="p">),</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Iterative Calculation of Opimal Reference&quot;</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="s2">&quot;MDAnalysis.analysis.align.iterative_average&quot;</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">iterative_average</span><span class="p">(</span>
    <span class="n">mobile</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">eps</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iteratively calculate an optimal reference that is also the average</span>
<span class="sd">    structure after an RMSD alignment.</span>

<span class="sd">    The optimal reference is defined as average</span>
<span class="sd">    structure of a trajectory, with the optimal reference used as input.</span>
<span class="sd">    This function computes the optimal reference by using a starting</span>
<span class="sd">    reference for the average structure, which is used as the reference</span>
<span class="sd">    to calculate the average structure again. This is repeated until the</span>
<span class="sd">    reference structure has converged. :footcite:p:`Linke2018`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mobile : mda.Universe</span>
<span class="sd">        Universe containing trajectory to be fitted to reference.</span>
<span class="sd">    reference : mda.Universe (optional)</span>
<span class="sd">        Universe containing the initial reference structure.</span>
<span class="sd">    select : str or tuple or dict (optional)</span>
<span class="sd">        Atom selection for fitting a substructue. Default is set to all.</span>
<span class="sd">        Can be tuple or dict to define different selection strings for</span>
<span class="sd">        mobile and target.</span>
<span class="sd">    weights : str, array_like (optional)</span>
<span class="sd">        Weights that can be used. If `None` use equal weights, if `&#39;mass&#39;`</span>
<span class="sd">        use masses of ref as weights or give an array of arbitrary weights.</span>
<span class="sd">    niter : int (optional)</span>
<span class="sd">        Maximum number of iterations.</span>
<span class="sd">    eps : float (optional)</span>
<span class="sd">        RMSD distance at which reference and average are assumed to be</span>
<span class="sd">        equal.</span>
<span class="sd">    verbose : bool (optional)</span>
<span class="sd">        Verbosity.</span>
<span class="sd">    **kwargs : dict (optional)</span>
<span class="sd">        AverageStructure kwargs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    avg_struc : AverageStructure</span>
<span class="sd">        AverageStructure result from the last iteration.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    `iterative_average` can be used to obtain a :class:`MDAnalysis.Universe`</span>
<span class="sd">    with the optimal reference structure.</span>

<span class="sd">    ::</span>

<span class="sd">        import MDAnalysis as mda</span>
<span class="sd">        from MDAnalysis.analysis import align</span>
<span class="sd">        from MDAnalysisTests.datafiles import PSF, DCD</span>

<span class="sd">        u = mda.Universe(PSF, DCD)</span>
<span class="sd">        av = align.iterative_average(u, u, verbose=True)</span>

<span class="sd">        averaged_universe = av.results.universe</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. footbibliography::</span>

<span class="sd">    .. versionadded:: 2.8.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reference</span><span class="p">:</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">mobile</span>

    <span class="n">select</span> <span class="o">=</span> <span class="n">rms</span><span class="o">.</span><span class="n">process_selection</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">mda</span><span class="o">.</span><span class="n">Merge</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">select</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">]))</span>
    <span class="n">sel_mobile</span> <span class="o">=</span> <span class="n">select</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="n">get_weights</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

    <span class="n">drmsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ProgressBar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">)):</span>
        <span class="c1"># found a converged structure</span>
        <span class="k">if</span> <span class="n">drmsd</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">avg_struc</span> <span class="o">=</span> <span class="n">AverageStructure</span><span class="p">(</span>
            <span class="n">mobile</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">ref</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;mobile&#39;</span><span class="p">:</span> <span class="n">sel_mobile</span><span class="p">,</span> <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="s1">&#39;all&#39;</span>
                <span class="p">},</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        <span class="n">drmsd</span> <span class="o">=</span> <span class="n">rms</span><span class="o">.</span><span class="n">rmsd</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">avg_struc</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                         <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">avg_struc</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">universe</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;iterative_average(): i = </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;rmsd-change = </span><span class="si">{</span><span class="n">drmsd</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;ave-rmsd = </span><span class="si">{</span><span class="n">avg_struc</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">rmsd</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;iterative_average(): Did not converge in &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">niter</span><span class="si">}</span><span class="s2"> iterations to DRMSD &lt; </span><span class="si">{</span><span class="n">eps</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Final average RMSD = </span><span class="si">{</span><span class="n">avg_struc</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">rmsd</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;iterative_average(): Converged to DRMSD &lt; </span><span class="si">{</span><span class="n">eps</span><span class="si">}</span><span class="s2">. &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;Final average RMSD = </span><span class="si">{</span><span class="n">avg_struc</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">rmsd</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">avg_struc</span></div>



<div class="viewcode-block" id="AlignTraj">
<a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align.AlignTraj">[docs]</a>
<span class="k">class</span> <span class="nc">AlignTraj</span><span class="p">(</span><span class="n">AnalysisBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;RMS-align trajectory to a reference structure using a selection.</span>

<span class="sd">    Both the reference `reference` and the trajectory `mobile` must be</span>
<span class="sd">    :class:`MDAnalysis.Universe` instances. If they contain a trajectory then</span>
<span class="sd">    it is used. The output file format is determined by the file extension of</span>
<span class="sd">    `filename`. One can also use the same universe if one wants to fit to the</span>
<span class="sd">    current frame.</span>

<span class="sd">    .. versionchanged:: 1.0.0</span>
<span class="sd">       ``save()`` has now been removed, as an alternative use ``np.savetxt()``</span>
<span class="sd">       on :attr:`results.rmsd`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;rmsfit_&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">match_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">in_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mobile : Universe</span>
<span class="sd">            Universe containing trajectory to be fitted to reference</span>
<span class="sd">        reference : Universe</span>
<span class="sd">            Universe containing trajectory frame to be used as reference</span>
<span class="sd">        select : str (optional)</span>
<span class="sd">            Set as default to all, is used for Universe.select_atoms to choose</span>
<span class="sd">            subdomain to be fitted against</span>
<span class="sd">        filename : str (optional)</span>
<span class="sd">            Provide a filename for results to be written to</span>
<span class="sd">        prefix : str (optional)</span>
<span class="sd">            Provide a string to prepend to filename for results to be written</span>
<span class="sd">            to</span>
<span class="sd">        weights : {&quot;mass&quot;, ``None``} or array_like (optional)</span>
<span class="sd">            choose weights. With ``&quot;mass&quot;`` uses masses of `reference` as</span>
<span class="sd">            weights; with ``None`` weigh each atom equally. If a float array of</span>
<span class="sd">            the same length as the selection is provided, use each element of</span>
<span class="sd">            the `array_like` as a weight for the corresponding atom in the</span>
<span class="sd">            selection.</span>
<span class="sd">        tol_mass : float (optional)</span>
<span class="sd">            Tolerance given to `get_matching_atoms` to find appropriate atoms</span>
<span class="sd">        match_atoms : bool (optional)</span>
<span class="sd">            Whether to match the mobile and reference atom-by-atom. Default ``True``.</span>
<span class="sd">        strict : bool (optional)</span>
<span class="sd">            Force `get_matching_atoms` to fail if atoms can&#39;t be found using</span>
<span class="sd">            exact methods</span>
<span class="sd">        force : bool (optional)</span>
<span class="sd">            Force overwrite of filename for rmsd-fitting</span>
<span class="sd">        in_memory : bool (optional)</span>
<span class="sd">            *Permanently* switch `mobile` to an in-memory trajectory</span>
<span class="sd">            so that alignment can be done in-place, which can improve</span>
<span class="sd">            performance substantially in some cases. In this case, no file</span>
<span class="sd">            is written out (`filename` and `prefix` are ignored) and only</span>
<span class="sd">            the coordinates of `mobile` are *changed in memory*.</span>
<span class="sd">        verbose : bool (optional)</span>
<span class="sd">             Set logger to show more information and show detailed progress of</span>
<span class="sd">             the calculation if set to ``True``; the default is ``False``.</span>


<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_atoms : AtomGroup</span>
<span class="sd">            Atoms of the reference structure to be aligned against</span>
<span class="sd">        mobile_atoms : AtomGroup</span>
<span class="sd">            Atoms inside each trajectory frame to be rmsd_aligned</span>
<span class="sd">        results.rmsd : :class:`numpy.ndarray`</span>
<span class="sd">            Array of the rmsd values of the least rmsd between the mobile_atoms</span>
<span class="sd">            and reference_atoms after superposition and minimimization of rmsd</span>

<span class="sd">            .. versionadded:: 2.0.0</span>

<span class="sd">        rmsd : :class:`numpy.ndarray`</span>
<span class="sd">            Alias to the :attr:`results.rmsd` attribute.</span>

<span class="sd">            .. deprecated:: 2.0.0</span>
<span class="sd">               Will be removed in MDAnalysis 3.0.0. Please use</span>
<span class="sd">               :attr:`results.rmsd` instead.</span>

<span class="sd">        filename : str</span>
<span class="sd">            String reflecting the filename of the file where the aligned</span>
<span class="sd">            positions will be written to upon running RMSD alignment</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If set to ``verbose=False``, it is recommended to wrap the statement</span>
<span class="sd">          in a ``try ...  finally`` to guarantee restoring of the log level in</span>
<span class="sd">          the case of an exception.</span>
<span class="sd">        - The ``in_memory`` option changes the `mobile` universe to an</span>
<span class="sd">          in-memory representation (see :mod:`MDAnalysis.coordinates.memory`)</span>
<span class="sd">          for the remainder of the Python session. If ``mobile.trajectory`` is</span>
<span class="sd">          already a :class:`MemoryReader` then it is *always* treated as if</span>
<span class="sd">          ``in_memory`` had been set to ``True``.</span>

<span class="sd">        .. versionchanged:: 1.0.0</span>
<span class="sd">           Default ``filename`` has now been changed to the current directory.</span>

<span class="sd">        .. deprecated:: 0.19.1</span>
<span class="sd">           Default ``filename`` directory will change in 1.0 to the current directory.</span>

<span class="sd">        .. versionchanged:: 0.16.0</span>
<span class="sd">           new general ``weights`` kwarg replace ``mass_weights``</span>

<span class="sd">        .. deprecated:: 0.16.0</span>
<span class="sd">           Instead of ``mass_weighted=True`` use new ``weights=&#39;mass&#39;``</span>

<span class="sd">        .. versionchanged:: 0.17.0</span>
<span class="sd">           removed deprecated `mass_weighted` keyword</span>

<span class="sd">        .. versionchanged:: 1.0.0</span>
<span class="sd">           Support for the ``start``, ``stop``, and ``step`` keywords has been</span>
<span class="sd">           removed. These should instead be passed to :meth:`AlignTraj.run`.</span>

<span class="sd">        .. versionchanged:: 2.0.0</span>
<span class="sd">           :attr:`rmsd` results are now stored in a</span>
<span class="sd">           :class:`MDAnalysis.analysis.base.Results` instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">rms</span><span class="o">.</span><span class="n">process_selection</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">select</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">mobile</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">select</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">in_memory</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mobile</span><span class="o">.</span><span class="n">trajectory</span><span class="p">,</span> <span class="n">MemoryReader</span><span class="p">):</span>
            <span class="n">mobile</span><span class="o">.</span><span class="n">transfer_to_memory</span><span class="p">()</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Moved mobile trajectory to in-memory representation&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">mobile</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">fn</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;filename of rms_align with no filename given&#39;</span>
                            <span class="s1">&#39;: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                    <span class="s1">&#39;Filename already exists in path and force is not set&#39;</span>
                    <span class="s1">&#39; to True&#39;</span><span class="p">)</span>

        <span class="c1"># do this after setting the memory reader to have a reference to the</span>
        <span class="c1"># right reader.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AlignTraj</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mobile</span><span class="o">.</span><span class="n">trajectory</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">disable</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">WARN</span><span class="p">)</span>

        <span class="c1"># store reference to mobile atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mobile</span> <span class="o">=</span> <span class="n">mobile</span><span class="o">.</span><span class="n">atoms</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="n">natoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobile</span><span class="o">.</span><span class="n">n_atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">get_matching_atoms</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="n">tol_mass</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span> <span class="n">match_atoms</span><span class="o">=</span><span class="n">match_atoms</span><span class="p">)</span>

        <span class="c1"># with self.filename == None (in_memory), the NullWriter is chosen</span>
        <span class="c1"># (which just ignores input) and so only the in_memory trajectory is</span>
        <span class="c1"># retained</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_writer</span> <span class="o">=</span> <span class="n">mda</span><span class="o">.</span><span class="n">Writer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">natoms</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="n">get_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;RMS-fitting on </span><span class="si">{0:d}</span><span class="s2"> atoms.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># reference centre of mass system</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_com</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_com</span>
        <span class="c1"># allocate the array for selection atom coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">rmsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">_single_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_index</span>
        <span class="n">mobile_com</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">)</span>
        <span class="n">mobile_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">mobile_com</span>
        <span class="n">mobile_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">rmsd</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">_fit_to</span><span class="p">(</span>
                <span class="n">mobile_coordinates</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coordinates</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mobile</span><span class="p">,</span>
                <span class="n">mobile_com</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ref_com</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">)</span>
        <span class="c1"># write whole aligned input trajectory system</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mobile_atoms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_conclude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">disable</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NOTSET</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rmsd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">wmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The `rmsd` attribute was deprecated in MDAnalysis 2.0.0 and &quot;</span>
                <span class="s2">&quot;will be removed in MDAnalysis 3.0.0. Please use &quot;</span>
                <span class="s2">&quot;`results.rmsd` instead.&quot;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">wmsg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">rmsd</span></div>



<div class="viewcode-block" id="AverageStructure">
<a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align.AverageStructure">[docs]</a>
<span class="k">class</span> <span class="nc">AverageStructure</span><span class="p">(</span><span class="n">AnalysisBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;RMS-align trajectory to a reference structure using a selection,</span>
<span class="sd">    and calculate the average coordinates of the trajectory.</span>

<span class="sd">    Both the reference `reference` and the trajectory `mobile` must be</span>
<span class="sd">    :class:`MDAnalysis.Universe` instances. If they contain a trajectory, then</span>
<span class="sd">    it is used. You can also use the same universe if you want to fit to the</span>
<span class="sd">    current frame.</span>

<span class="sd">    The output file format is determined by the file extension of</span>
<span class="sd">    `filename`.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">    ::</span>

<span class="sd">        import MDAnalysis as mda</span>
<span class="sd">        from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">        from MDAnalysis.analysis import align</span>

<span class="sd">        u = mda.Universe(PSF, DCD)</span>

<span class="sd">        # align to the third frame and average structure</span>
<span class="sd">        av = align.AverageStructure(u, ref_frame=3).run()</span>
<span class="sd">        averaged_universe = av.results.universe</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">match_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">in_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">ref_frame</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mobile : Universe</span>
<span class="sd">            Universe containing trajectory to be fitted to reference</span>
<span class="sd">        reference : Universe (optional)</span>
<span class="sd">            Universe containing trajectory frame to be used as reference</span>
<span class="sd">        select : str (optional)</span>
<span class="sd">            Set as default to all, is used for Universe.select_atoms to choose</span>
<span class="sd">            subdomain to be fitted against</span>
<span class="sd">        filename : str (optional)</span>
<span class="sd">            Provide a filename for results to be written to</span>
<span class="sd">        weights : {&quot;mass&quot;, ``None``} or array_like (optional)</span>
<span class="sd">            choose weights. With ``&quot;mass&quot;`` uses masses of `reference` as</span>
<span class="sd">            weights; with ``None`` weigh each atom equally. If a float array of</span>
<span class="sd">            the same length as the selection is provided, use each element of</span>
<span class="sd">            the `array_like` as a weight for the corresponding atom in the</span>
<span class="sd">            selection.</span>
<span class="sd">        tol_mass : float (optional)</span>
<span class="sd">            Tolerance given to `get_matching_atoms` to find appropriate atoms</span>
<span class="sd">        match_atoms : bool (optional)</span>
<span class="sd">            Whether to match the mobile and reference atom-by-atom. Default ``True``.</span>
<span class="sd">        strict : bool (optional)</span>
<span class="sd">            Force `get_matching_atoms` to fail if atoms can&#39;t be found using</span>
<span class="sd">            exact methods</span>
<span class="sd">        force : bool (optional)</span>
<span class="sd">            Force overwrite of filename for rmsd-fitting</span>
<span class="sd">        in_memory : bool (optional)</span>
<span class="sd">            *Permanently* switch `mobile` to an in-memory trajectory</span>
<span class="sd">            so that alignment can be done in-place, which can improve</span>
<span class="sd">            performance substantially in some cases. In this case, no file</span>
<span class="sd">            is written out (`filename` and `prefix` are ignored) and only</span>
<span class="sd">            the coordinates of `mobile` are *changed in memory*.</span>
<span class="sd">        ref_frame : int (optional)</span>
<span class="sd">            frame index to select frame from `reference`</span>
<span class="sd">        verbose : bool (optional)</span>
<span class="sd">            Set logger to show more information and show detailed progress of</span>
<span class="sd">            the calculation if set to ``True``; the default is ``False``.</span>


<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_atoms : AtomGroup</span>
<span class="sd">            Atoms of the reference structure to be aligned against</span>
<span class="sd">        mobile_atoms : AtomGroup</span>
<span class="sd">            Atoms inside each trajectory frame to be rmsd_aligned</span>
<span class="sd">        results.universe : :class:`MDAnalysis.Universe`</span>
<span class="sd">            New Universe with average positions</span>

<span class="sd">            .. versionadded:: 2.0.0</span>

<span class="sd">        universe : :class:`MDAnalysis.Universe`</span>
<span class="sd">            Alias to the :attr:`results.universe` attribute.</span>

<span class="sd">            .. deprecated:: 2.0.0</span>
<span class="sd">               Will be removed in MDAnalysis 3.0.0. Please use</span>
<span class="sd">               :attr:`results.universe` instead.</span>

<span class="sd">        results.positions : np.ndarray(dtype=float)</span>
<span class="sd">            Average positions</span>

<span class="sd">            .. versionadded:: 2.0.0</span>

<span class="sd">        positions : np.ndarray(dtype=float)</span>
<span class="sd">            Alias to the :attr:`results.positions` attribute.</span>

<span class="sd">            .. deprecated:: 2.0.0</span>
<span class="sd">               Will be removed in MDAnalysis 3.0.0. Please use</span>
<span class="sd">               :attr:`results.positions` instead.</span>

<span class="sd">        results.rmsd : float</span>
<span class="sd">            Average RMSD per frame</span>

<span class="sd">            .. versionadded:: 2.0.0</span>

<span class="sd">        rmsd : float</span>
<span class="sd">            Alias to the :attr:`results.rmsd` attribute.</span>

<span class="sd">            .. deprecated:: 2.0.0</span>
<span class="sd">               Will be removed in MDAnalysis 3.0.0. Please use</span>
<span class="sd">               :attr:`results.rmsd` instead.</span>

<span class="sd">        filename : str</span>
<span class="sd">            String reflecting the filename of the file where the average</span>
<span class="sd">            structure is written</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If set to ``verbose=False``, it is recommended to wrap the statement</span>
<span class="sd">          in a ``try ...  finally`` to guarantee restoring of the log level in</span>
<span class="sd">          the case of an exception.</span>
<span class="sd">        - The ``in_memory`` option changes the `mobile` universe to an</span>
<span class="sd">          in-memory representation (see :mod:`MDAnalysis.coordinates.memory`)</span>
<span class="sd">          for the remainder of the Python session. If ``mobile.trajectory`` is</span>
<span class="sd">          already a :class:`MemoryReader` then it is *always* treated as if</span>
<span class="sd">          ``in_memory`` had been set to ``True``.</span>


<span class="sd">        .. versionadded:: 1.0.0</span>
<span class="sd">        .. versionchanged:: 2.0.0</span>
<span class="sd">           :attr:`universe`, :attr:`positions`, and :attr:`rmsd` are now</span>
<span class="sd">           stored in a :class:`MDAnalysis.analysis.base.Results` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">in_memory</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mobile</span><span class="o">.</span><span class="n">trajectory</span><span class="p">,</span> <span class="n">MemoryReader</span><span class="p">):</span>
            <span class="n">mobile</span><span class="o">.</span><span class="n">transfer_to_memory</span><span class="p">()</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Moved mobile trajectory to in-memory representation&quot;</span><span class="p">)</span>

        <span class="c1"># do this after setting the memory reader to have a reference to the</span>
        <span class="c1"># right reader.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AverageStructure</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mobile</span><span class="o">.</span><span class="n">trajectory</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">disable</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">WARN</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span> <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mobile</span>

        <span class="n">select</span> <span class="o">=</span> <span class="n">rms</span><span class="o">.</span><span class="n">process_selection</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">select</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">mobile</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">select</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span><span class="p">):</span>
            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Reference and trajectory atom selections do &quot;</span>
                   <span class="s2">&quot;not contain the same number of atoms: &quot;</span>
                   <span class="s2">&quot;N_ref=</span><span class="si">{0:d}</span><span class="s2">, N_traj=</span><span class="si">{1:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;RMS calculation &quot;</span>
                    <span class="s2">&quot;for </span><span class="si">{0:d}</span><span class="s2"> atoms.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">)))</span>

        <span class="c1"># store reference to mobile atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mobile</span> <span class="o">=</span> <span class="n">mobile</span><span class="o">.</span><span class="n">atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">=</span> <span class="n">ref_frame</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">mda</span><span class="o">.</span><span class="n">Merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span><span class="p">)</span>

        <span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span> <span class="o">=</span> <span class="n">get_matching_atoms</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="n">tol_mass</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span> <span class="n">match_atoms</span><span class="o">=</span><span class="n">match_atoms</span><span class="p">)</span>

        <span class="c1"># with self.filename == None (in_memory), the NullWriter is chosen</span>
        <span class="c1"># (which just ignores input) and so only the in_memory trajectory is</span>
        <span class="c1"># retained</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_writer</span> <span class="o">=</span> <span class="n">mda</span><span class="o">.</span><span class="n">Writer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">natoms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="n">get_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;RMS-fitting on </span><span class="si">{0:d}</span><span class="s2"> atoms.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Move to the ref_frame</span>
            <span class="c1"># (coordinates MUST be stored in case the ref traj is advanced</span>
            <span class="c1"># elsewhere or if ref == mobile universe)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_com</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">)</span>
            <span class="c1"># makes a copy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_com</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Move back to the original frame</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">current_frame</span><span class="p">]</span>

        <span class="c1"># allocate the array for selection atom coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">rmsd</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_single_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mobile_com</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">)</span>
        <span class="n">mobile_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">mobile_com</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">rmsd</span> <span class="o">+=</span> <span class="n">_fit_to</span><span class="p">(</span><span class="n">mobile_coordinates</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coordinates</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">mobile</span><span class="p">,</span>
                                     <span class="n">mobile_com</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_ref_com</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">positions</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobile_atoms</span><span class="o">.</span><span class="n">positions</span>

    <span class="k">def</span> <span class="nf">_conclude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">positions</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">rmsd</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">load_new</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">disable</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NOTSET</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">wmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The `universe` attribute was deprecated in MDAnalysis 2.0.0 &quot;</span>
                <span class="s2">&quot;and will be removed in MDAnalysis 3.0.0. Please use &quot;</span>
                <span class="s2">&quot;`results.universe` instead.&quot;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">wmsg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">universe</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">wmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The `positions` attribute was deprecated in MDAnalysis 2.0.0 &quot;</span>
                <span class="s2">&quot;and will be removed in MDAnalysis 3.0.0. Please use &quot;</span>
                <span class="s2">&quot;`results.positions` instead.&quot;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">wmsg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">positions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rmsd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">wmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The `rmsd` attribute was deprecated in MDAnalysis 2.0.0 &quot;</span>
                <span class="s2">&quot;and will be removed in MDAnalysis 3.0.0. Please use &quot;</span>
                <span class="s2">&quot;`results.rmsd` instead.&quot;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">wmsg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">rmsd</span></div>



<span class="nd">@deprecate</span><span class="p">(</span><span class="n">release</span><span class="o">=</span><span class="s2">&quot;2.4.0&quot;</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span><span class="s2">&quot;3.0&quot;</span><span class="p">,</span>
           <span class="n">message</span><span class="o">=</span><span class="s2">&quot;See the documentation under Notes on how to directly use&quot;</span>
                   <span class="s2">&quot;Bio.Align.PairwiseAligner with ResidueGroups.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sequence_alignment</span><span class="p">(</span><span class="n">mobile</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">match_score</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">mismatch_penalty</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                       <span class="n">gap_penalty</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">gapextension_penalty</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a global sequence alignment between two residue groups.</span>

<span class="sd">    The residues in `reference` and `mobile` will be globally aligned.</span>
<span class="sd">    The global alignment uses the Needleman-Wunsch algorithm as</span>
<span class="sd">    implemented in :mod:`Bio.Align.PairwiseAligner`. The parameters of the dynamic</span>
<span class="sd">    programming algorithm can be tuned with the keywords. The defaults</span>
<span class="sd">    should be suitable for two similar sequences. For sequences with</span>
<span class="sd">    low sequence identity, more specialized tools such as clustalw,</span>
<span class="sd">    muscle, tcoffee, or similar should be used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mobile : AtomGroup</span>
<span class="sd">        Atom group to be aligned</span>
<span class="sd">    reference : AtomGroup</span>
<span class="sd">        Atom group to be aligned against</span>
<span class="sd">    match_score : float (optional), default 2</span>
<span class="sd">         score for matching residues, default 2</span>
<span class="sd">    mismatch_penalty : float (optional), default -1</span>
<span class="sd">         penalty for residues that do not match , default : -1</span>
<span class="sd">    gap_penalty : float (optional), default -2</span>
<span class="sd">         penalty for opening a gap; the high default value creates compact</span>
<span class="sd">         alignments for highly identical sequences but might not be suitable</span>
<span class="sd">         for sequences with low identity, default : -2</span>
<span class="sd">    gapextension_penalty : float (optional), default -0.1</span>
<span class="sd">         penalty for extending a gap, default: -0.1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alignment : tuple</span>
<span class="sd">        Tuple of top sequence matching output `(&#39;Sequence A&#39;, &#39;Sequence B&#39;, score,</span>
<span class="sd">        begin, end)`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ImportError</span>
<span class="sd">      If optional dependency Biopython is not available.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If you prefer to work directly with :mod:`Bio.Align` objects then you can</span>
<span class="sd">    run your alignment with :class:`Bio.Alig.PairwiseAligner` as ::</span>

<span class="sd">      import Bio.Align.PairwiseAligner</span>

<span class="sd">      aligner = Bio.Align.PairwiseAligner(</span>
<span class="sd">         mode=&quot;global&quot;,</span>
<span class="sd">         match_score=match_score,</span>
<span class="sd">         mismatch_score=mismatch_penalty,</span>
<span class="sd">         open_gap_score=gap_penalty,</span>
<span class="sd">         extend_gap_score=gapextension_penalty)</span>
<span class="sd">      aln = aligner.align(reference.residues.sequence(format=&quot;Seq&quot;),</span>
<span class="sd">                          mobile.residues.sequence(format=&quot;Seq&quot;))</span>

<span class="sd">      # choose top alignment with highest score</span>
<span class="sd">      topalignment = aln[0]</span>

<span class="sd">    The ``topalignment`` is a :class:`Bio.Align.PairwiseAlignment` instance</span>
<span class="sd">    that can be used in your bioinformatics workflows.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    BioPython documentation for `PairwiseAligner`_. Alternatively, use</span>
<span class="sd">    :func:`fasta2select` with :program:`clustalw2` and the option</span>
<span class="sd">    ``is_aligned=False``.</span>


<span class="sd">    .. _`PairwiseAligner`:</span>
<span class="sd">       https://biopython.org/docs/latest/api/Bio.Align.html#Bio.Align.PairwiseAligner</span>


<span class="sd">    .. versionadded:: 0.10.0</span>

<span class="sd">    .. versionchanged:: 2.4.0</span>
<span class="sd">       Replace use of deprecated :func:`Bio.pairwise2.align.globalms` with</span>
<span class="sd">       :class:`Bio.Align.PairwiseAligner`.</span>

<span class="sd">    .. versionchanged:: 2.7.0</span>
<span class="sd">       Biopython is now an optional dependency which this method requires.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">HAS_BIOPYTHON</span><span class="p">:</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The `sequence_alignment` method requires an installation &quot;</span>
                  <span class="s2">&quot;of `Biopython`. Please install `Biopython` to use this &quot;</span>
                  <span class="s2">&quot;method: https://biopython.org/wiki/Download&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

    <span class="n">aligner</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">Align</span><span class="o">.</span><span class="n">PairwiseAligner</span><span class="p">(</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span>
        <span class="n">match_score</span><span class="o">=</span><span class="n">match_score</span><span class="p">,</span>
        <span class="n">mismatch_score</span><span class="o">=</span><span class="n">mismatch_penalty</span><span class="p">,</span>
        <span class="n">open_gap_score</span><span class="o">=</span><span class="n">gap_penalty</span><span class="p">,</span>
        <span class="n">extend_gap_score</span><span class="o">=</span><span class="n">gapextension_penalty</span><span class="p">)</span>
    <span class="n">aln</span> <span class="o">=</span> <span class="n">aligner</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">sequence</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;Seq&quot;</span><span class="p">),</span>
                        <span class="n">mobile</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">sequence</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;Seq&quot;</span><span class="p">))</span>
    <span class="c1"># choose top alignment with highest score</span>
    <span class="n">topalignment</span> <span class="o">=</span> <span class="n">aln</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># reconstruct the results tuple that used to be of type Bio.pairwise2.Alignment</span>
    <span class="n">AlignmentTuple</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span>
        <span class="s2">&quot;Alignment&quot;</span><span class="p">,</span>
        <span class="p">[</span><span class="s2">&quot;seqA&quot;</span><span class="p">,</span> <span class="s2">&quot;seqB&quot;</span><span class="p">,</span> <span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">])</span>
    <span class="c1"># start/stop are not particularly meaningful and there&#39;s no obvious way to</span>
    <span class="c1"># get the old pairwise2 start/stop from the new PairwiseAligner output.</span>
    <span class="k">return</span> <span class="n">AlignmentTuple</span><span class="p">(</span><span class="n">topalignment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">topalignment</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                          <span class="n">topalignment</span><span class="o">.</span><span class="n">score</span><span class="p">,</span>
                          <span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">n_residues</span><span class="p">,</span> <span class="n">mobile</span><span class="o">.</span><span class="n">n_residues</span><span class="p">))</span>



<div class="viewcode-block" id="fasta2select">
<a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align.fasta2select">[docs]</a>
<span class="k">def</span> <span class="nf">fasta2select</span><span class="p">(</span><span class="n">fastafilename</span><span class="p">,</span> <span class="n">is_aligned</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">ref_resids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_resids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ref_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">target_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">alnfilename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">treefilename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clustalw</span><span class="o">=</span><span class="s2">&quot;clustalw2&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return selection strings that will select equivalent residues.</span>

<span class="sd">    The function aligns two sequences provided in a FASTA file and</span>
<span class="sd">    constructs MDAnalysis selection strings of the common atoms. When</span>
<span class="sd">    these two strings are applied to the two different proteins they</span>
<span class="sd">    will generate AtomGroups of the aligned residues.</span>

<span class="sd">    `fastafilename` contains the two un-aligned sequences in FASTA</span>
<span class="sd">    format. The reference is assumed to be the first sequence, the</span>
<span class="sd">    target the second. ClustalW_ produces a pairwise</span>
<span class="sd">    alignment (which is written to a file with suffix ``.aln``).  The</span>
<span class="sd">    output contains atom selection strings that select the same atoms</span>
<span class="sd">    in the two structures.</span>

<span class="sd">    Unless `ref_offset` and/or `target_offset` are specified, the resids</span>
<span class="sd">    in the structure are assumed to correspond to the positions in the</span>
<span class="sd">    un-aligned sequence, namely the first residue has resid == 1.</span>

<span class="sd">    In more complicated cases (e.g., when the resid numbering in the</span>
<span class="sd">    input structure has gaps due to missing parts), simply provide the</span>
<span class="sd">    sequence of resids as they appear in the topology in `ref_resids` or</span>
<span class="sd">    `target_resids`, e.g. ::</span>

<span class="sd">       target_resids = [a.resid for a in trj.select_atoms(&#39;name CA&#39;)]</span>

<span class="sd">    (This translation table *is* combined with any value for</span>
<span class="sd">    `ref_offset` or `target_offset`!)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fastafilename : str, path to filename</span>
<span class="sd">        FASTA file with first sequence as reference and</span>
<span class="sd">        second the one to be aligned (ORDER IS IMPORTANT!)</span>
<span class="sd">    is_aligned : bool (optional)</span>
<span class="sd">        ``False`` (default)</span>
<span class="sd">            run clustalw for sequence alignment;</span>
<span class="sd">        ``True``</span>
<span class="sd">            use the alignment in the file (e.g. from STAMP) [``False``]</span>
<span class="sd">    ref_offset : int (optional)</span>
<span class="sd">        add this number to the column number in the FASTA file</span>
<span class="sd">        to get the original residue number, default: 0</span>
<span class="sd">    target_offset : int (optional)</span>
<span class="sd">        add this number to the column number in the FASTA file</span>
<span class="sd">        to get the original residue number, default: 0</span>
<span class="sd">    ref_resids : str (optional)</span>
<span class="sd">        sequence of resids as they appear in the reference structure</span>
<span class="sd">    target_resids : str (optional)</span>
<span class="sd">        sequence of resids as they appear in the target</span>
<span class="sd">    alnfilename : str (optional)</span>
<span class="sd">        filename of ClustalW alignment (clustal format) that is</span>
<span class="sd">        produced by *clustalw* when *is_aligned* = ``False``.</span>
<span class="sd">        default ``None`` uses the name and path of *fastafilename* and</span>
<span class="sd">        substitutes the suffix with &#39;.aln&#39;.</span>
<span class="sd">    treefilename: str (optional)</span>
<span class="sd">        filename of ClustalW guide tree (Newick format);</span>
<span class="sd">        if default ``None``  the the filename is generated from *alnfilename*</span>
<span class="sd">        with the suffix &#39;.dnd&#39; instead of &#39;.aln&#39;</span>
<span class="sd">    clustalw : str (optional)</span>
<span class="sd">        path to the ClustalW (or ClustalW2) binary; only</span>
<span class="sd">        needed for `is_aligned` = ``False``, default: &quot;ClustalW2&quot;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    select_dict : dict</span>
<span class="sd">        dictionary with &#39;reference&#39; and &#39;mobile&#39; selection string</span>
<span class="sd">        that can be used immediately in :class:`AlignTraj` as</span>
<span class="sd">        ``select=select_dict``.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`sequence_alignment`, which does not require external</span>
<span class="sd">    programs.</span>

<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ImportError</span>
<span class="sd">      If optional dependency Biopython is not available.</span>


<span class="sd">    .. _ClustalW: http://www.clustal.org/</span>
<span class="sd">    .. _STAMP: http://www.compbio.dundee.ac.uk/manuals/stamp.4.2/</span>

<span class="sd">    .. versionchanged:: 1.0.0</span>
<span class="sd">       Passing `alnfilename` or `treefilename` as `None` will create a file in</span>
<span class="sd">       the current working directory.</span>
<span class="sd">    .. versionchanged:: 2.7.0</span>
<span class="sd">       Biopython is now an optional dependency which this method requires.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">HAS_BIOPYTHON</span><span class="p">:</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The `fasta2select` method requires an installation &quot;</span>
                  <span class="s2">&quot;of `Biopython`. Please install `Biopython` to use this &quot;</span>
                  <span class="s2">&quot;method: https://biopython.org/wiki/Download&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_aligned</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using provided alignment </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fastafilename</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fastafilename</span><span class="p">)</span> <span class="k">as</span> <span class="n">fasta</span><span class="p">:</span>
            <span class="n">alignment</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
                <span class="n">fasta</span><span class="p">,</span> <span class="s2">&quot;fasta&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">alnfilename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filepath</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fastafilename</span><span class="p">)</span>
            <span class="n">alnfilename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.aln&#39;</span>
        <span class="k">if</span> <span class="n">treefilename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filepath</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">alnfilename</span><span class="p">)</span>
            <span class="n">treefilename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.dnd&#39;</span>
        <span class="n">run_clustalw</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">Align</span><span class="o">.</span><span class="n">Applications</span><span class="o">.</span><span class="n">ClustalwCommandline</span><span class="p">(</span>
            <span class="n">clustalw</span><span class="p">,</span>
            <span class="n">infile</span><span class="o">=</span><span class="n">fastafilename</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;protein&quot;</span><span class="p">,</span>
            <span class="n">align</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">outfile</span><span class="o">=</span><span class="n">alnfilename</span><span class="p">,</span>
            <span class="n">newtree</span><span class="o">=</span><span class="n">treefilename</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Aligning sequences in </span><span class="si">%(fastafilename)r</span><span class="s2"> with </span><span class="si">%(clustalw)r</span><span class="s2">.&quot;</span><span class="p">,</span>
            <span class="nb">vars</span><span class="p">())</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;ClustalW commandline: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">run_clustalw</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="n">run_clustalw</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;ClustalW </span><span class="si">%(clustalw)r</span><span class="s2"> failed&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">())</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;(You can get clustalw2 from http://www.clustal.org/clustal2/)&quot;</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">alnfilename</span><span class="p">)</span> <span class="k">as</span> <span class="n">aln</span><span class="p">:</span>
            <span class="n">alignment</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">AlignIO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
                <span class="n">aln</span><span class="p">,</span> <span class="s2">&quot;clustal&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Using clustalw sequence alignment </span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alnfilename</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;ClustalW Newick guide tree was also produced: </span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">treefilename</span><span class="p">))</span>

    <span class="n">nseq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nseq</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Only two sequences in the alignment can be processed.&quot;</span><span class="p">)</span>

    <span class="c1"># implict assertion that we only have two sequences in the alignment</span>
    <span class="n">orig_resids</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref_resids</span><span class="p">,</span> <span class="n">target_resids</span><span class="p">]</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref_offset</span><span class="p">,</span> <span class="n">target_offset</span><span class="p">]</span>
    <span class="n">GAP</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
    <span class="k">for</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alignment</span><span class="p">):</span>
        <span class="c1"># need iseq index to change orig_resids</span>
        <span class="k">if</span> <span class="n">orig_resids</span><span class="p">[</span><span class="n">iseq</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># build default: assume consecutive numbering of all</span>
            <span class="c1"># residues in the alignment</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">GAP</span><span class="p">)</span>
            <span class="n">orig_resids</span><span class="p">[</span><span class="n">iseq</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">orig_resids</span><span class="p">[</span><span class="n">iseq</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orig_resids</span><span class="p">[</span><span class="n">iseq</span><span class="p">])</span>
    <span class="c1"># add offsets to the sequence &lt;--&gt; resid translation table</span>
    <span class="n">seq2resids</span> <span class="o">=</span> <span class="p">[</span><span class="n">resids</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">resids</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">orig_resids</span><span class="p">,</span> <span class="n">offsets</span><span class="p">)]</span>
    <span class="k">del</span> <span class="n">orig_resids</span>
    <span class="k">del</span> <span class="n">offsets</span>

    <span class="k">def</span> <span class="nf">resid_factory</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">seq2resids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a function that gives the resid for a position ipos in</span>
<span class="sd">        the nseq&#39;th alignment.</span>

<span class="sd">        resid = resid_factory(alignment,seq2resids)</span>
<span class="sd">        r = resid(nseq,ipos)</span>

<span class="sd">        It is based on a look up table that translates position in the</span>
<span class="sd">        alignment to the residue number in the original</span>
<span class="sd">        sequence/structure.</span>

<span class="sd">        The first index of resid() is the alignmment number, the</span>
<span class="sd">        second the position in the alignment.</span>

<span class="sd">        seq2resids translates the residues in the sequence to resid</span>
<span class="sd">        numbers in the psf. In the simplest case this is a linear map</span>
<span class="sd">        but if whole parts such as loops are ommitted from the protein</span>
<span class="sd">        the seq2resids may have big gaps.</span>

<span class="sd">        Format: a tuple of two numpy arrays; the first array is for</span>
<span class="sd">        the reference, the second for the target, The index in each</span>
<span class="sd">        array gives the consecutive number of the amino acid in the</span>
<span class="sd">        sequence, the value the resid in the structure/psf.</span>

<span class="sd">        Note: assumes that alignments have same length and are padded if</span>
<span class="sd">        necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># could maybe use Bio.PDB.StructureAlignment instead?</span>
        <span class="n">nseq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nseq</span><span class="p">,</span> <span class="n">alignment</span><span class="o">.</span><span class="n">get_alignment_length</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alignment</span><span class="p">):</span>
            <span class="n">GAP</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
            <span class="n">t</span><span class="p">[</span><span class="n">iseq</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">seq2resids</span><span class="p">[</span><span class="n">iseq</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">seq</span><span class="p">))</span> <span class="o">==</span> <span class="n">GAP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># -1 because seq2resid is index-1 based (resids start at 1)</span>

        <span class="k">def</span> <span class="nf">resid</span><span class="p">(</span><span class="n">nseq</span><span class="p">,</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">nseq</span><span class="p">,</span> <span class="n">ipos</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">resid</span>

    <span class="n">resid</span> <span class="o">=</span> <span class="n">resid_factory</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">seq2resids</span><span class="p">)</span>

    <span class="n">res_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># collect individual selection string</span>
    <span class="c1"># could collect just resid and type (with/without CB) and</span>
    <span class="c1"># then post-process and use ranges for continuous stretches, eg</span>
    <span class="c1"># ( resid 1:35 and ( backbone or name CB ) ) or ( resid 36 and backbone )</span>
    <span class="k">for</span> <span class="n">ipos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alignment</span><span class="o">.</span><span class="n">get_alignment_length</span><span class="p">()):</span>
        <span class="n">aligned</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">alignment</span><span class="p">[:,</span> <span class="n">ipos</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">GAP</span> <span class="ow">in</span> <span class="n">aligned</span><span class="p">:</span>
            <span class="k">continue</span>  <span class="c1"># skip residue</span>
        <span class="n">template</span> <span class="o">=</span> <span class="s2">&quot;resid </span><span class="si">%i</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;G&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">aligned</span><span class="p">:</span>
            <span class="c1"># can use CB</span>
            <span class="n">template</span> <span class="o">+=</span> <span class="s2">&quot; and ( backbone or name CB )&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">template</span> <span class="o">+=</span> <span class="s2">&quot; and backbone&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="s2">&quot;( &quot;</span> <span class="o">+</span> <span class="n">template</span> <span class="o">+</span> <span class="s2">&quot; )&quot;</span>

        <span class="n">res_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">template</span> <span class="o">%</span> <span class="n">resid</span><span class="p">(</span><span class="n">iseq</span><span class="p">,</span> <span class="n">ipos</span><span class="p">)</span> <span class="k">for</span> <span class="n">iseq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nseq</span><span class="p">)])</span>

    <span class="n">sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res_list</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="n">ref_selection</span> <span class="o">=</span> <span class="s2">&quot; or &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sel</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">target_selection</span> <span class="o">=</span> <span class="s2">&quot; or &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="n">ref_selection</span><span class="p">,</span> <span class="s1">&#39;mobile&#39;</span><span class="p">:</span> <span class="n">target_selection</span><span class="p">}</span></div>



<div class="viewcode-block" id="get_matching_atoms">
<a class="viewcode-back" href="../../../documentation_pages/analysis/align.html#MDAnalysis.analysis.align.get_matching_atoms">[docs]</a>
<span class="k">def</span> <span class="nf">get_matching_atoms</span><span class="p">(</span><span class="n">ag1</span><span class="p">,</span> <span class="n">ag2</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">match_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return two atom groups with one-to-one matched atoms.</span>

<span class="sd">    The function takes two :class:`~MDAnalysis.core.groups.AtomGroup`</span>
<span class="sd">    instances `ag1` and `ag2` and returns two atom groups `g1` and `g2` that</span>
<span class="sd">    consist of atoms so that the mass of atom ``g1[0]`` is the same as the mass</span>
<span class="sd">    of atom ``g2[0]``, ``g1[1]`` and ``g2[1]`` etc.</span>

<span class="sd">    The current implementation is very simplistic and works on a per-residue basis:</span>

<span class="sd">    1. The two groups must contain the same number of residues.</span>
<span class="sd">    2. Any residues in each group that have differing number of atoms are discarded.</span>
<span class="sd">    3. The masses of corresponding atoms are compared. and if any masses differ</span>
<span class="sd">       by more than `tol_mass` the test is considered failed and a</span>
<span class="sd">       :exc:`SelectionError` is raised.</span>

<span class="sd">    The log file (see :func:`MDAnalysis.start_logging`) will contain detailed</span>
<span class="sd">    information about mismatches.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ag1 : AtomGroup</span>
<span class="sd">        First :class:`~MDAnalysis.core.groups.AtomGroup` instance that is</span>
<span class="sd">        compared</span>
<span class="sd">    ag2 : AtomGroup</span>
<span class="sd">        Second :class:`~MDAnalysis.core.groups.AtomGroup` instance that is</span>
<span class="sd">        compared</span>
<span class="sd">    tol_mass : float (optional)</span>
<span class="sd">         Reject if the atomic masses for matched atoms differ by more than</span>
<span class="sd">         `tol_mass` [0.1]</span>
<span class="sd">    strict : bool (optional)</span>
<span class="sd">        ``True``</span>
<span class="sd">            Will raise :exc:`SelectionError` if a single atom does not</span>
<span class="sd">            match between the two selections.</span>
<span class="sd">        ``False`` [default]</span>
<span class="sd">            Will try to prepare a matching selection by dropping</span>
<span class="sd">            residues with non-matching atoms. See :func:`get_matching_atoms`</span>
<span class="sd">            for details.</span>
<span class="sd">    match_atoms : bool (optional)</span>
<span class="sd">        ``True``</span>
<span class="sd">            Will attempt to match atoms based on mass</span>
<span class="sd">        ``False``</span>
<span class="sd">            Will not attempt to match atoms based on mass</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (g1, g2) : tuple</span>
<span class="sd">        Tuple with :class:`~MDAnalysis.core.groups.AtomGroup`</span>
<span class="sd">        instances that match, atom by atom. The groups are either the</span>
<span class="sd">        original groups if all matched or slices of the original</span>
<span class="sd">        groups.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    :exc:`SelectionError`</span>
<span class="sd">        Error raised if the number of residues does not match or if in the final</span>
<span class="sd">        matching masses differ by more than *tol*.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm could be improved by using e.g. the Needleman-Wunsch</span>
<span class="sd">    algorithm in :mod:`Bio.profile2` to align atoms in each residue (doing a</span>
<span class="sd">    global alignment is too expensive).</span>

<span class="sd">    .. versionadded:: 0.8</span>

<span class="sd">    .. versionchanged:: 0.10.0</span>
<span class="sd">       Renamed from :func:`check_same_atoms` to</span>
<span class="sd">       :func:`get_matching_atoms` and now returns matching atomgroups</span>
<span class="sd">       (possibly with residues removed)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">ag1</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">!=</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match_atoms</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Mobile and reference atom selections do not &quot;</span>
                      <span class="s2">&quot;contain the same number of atoms and atom &quot;</span>
                      <span class="s2">&quot;matching is turned off. To match atoms based &quot;</span>
                      <span class="s2">&quot;on residue and mass, try match_atoms=True&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ag1</span><span class="o">.</span><span class="n">n_residues</span> <span class="o">!=</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_residues</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Reference and trajectory atom selections do not contain &quot;</span>
                    <span class="s2">&quot;the same number of atoms: </span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;atoms:    N_ref=</span><span class="si">{0}</span><span class="s2">, N_traj=</span><span class="si">{1}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;and also not the same number of residues:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;residues: N_ref=</span><span class="si">{2}</span><span class="s2">, N_traj=</span><span class="si">{3}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">ag1</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span>
                        <span class="n">ag1</span><span class="o">.</span><span class="n">n_residues</span><span class="p">,</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_residues</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Reference and trajectory atom selections do not contain &quot;</span>
                   <span class="s2">&quot;the same number of atoms: </span><span class="se">\n</span><span class="s2">&quot;</span>
                   <span class="s2">&quot;atoms:    N_ref=</span><span class="si">{0}</span><span class="s2">, N_traj=</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                       <span class="n">ag1</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># continue with trying to create a valid selection</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">but we attempt to create a valid selection &quot;</span> <span class="o">+</span>
                    <span class="s2">&quot;(use strict=True to disable this heuristic).&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">SelectionWarning</span><span class="p">)</span>

        <span class="c1"># continue with trying to salvage the selection:</span>
        <span class="c1"># - number of atoms is different</span>
        <span class="c1"># - number of residues is the same</span>
        <span class="c1"># We will remove residues with mismatching number of atoms (e.g. not resolved</span>
        <span class="c1"># in an X-ray structure)</span>
        <span class="k">assert</span> <span class="n">ag1</span><span class="o">.</span><span class="n">n_residues</span> <span class="o">==</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_residues</span>

        <span class="c1"># Alternatively, we could align all atoms but Needleman-Wunsch</span>
        <span class="c1"># pairwise2 consumes too much memory for thousands of characters in</span>
        <span class="c1"># each sequence. Perhaps a solution would be pairwise alignment per residue.</span>
        <span class="c1">#</span>
        <span class="c1"># aln_elem = Bio.pairwise2.align.globalms(&quot;&quot;.join([MDAnalysis.topology.</span>
        <span class="c1"># core.guess_atom_element(n) for n in gref.atoms.names]),</span>
        <span class="c1"># &quot;&quot;.join([MDAnalysis.topology.core.guess_atom_element(n)</span>
        <span class="c1"># for n in models[0].atoms.names]),</span>
        <span class="c1"># 2, -1, -1, -0.1,</span>
        <span class="c1"># one_alignment_only=True)</span>

        <span class="c1"># For now, just remove the residues that don&#39;t have matching numbers</span>
        <span class="c1"># NOTE: This can create empty selections, e.g., when comparing a structure</span>
        <span class="c1">#       with hydrogens to a PDB structure without hydrogens.</span>
        <span class="n">rsize1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ag1</span><span class="o">.</span><span class="n">residues</span><span class="p">])</span>
        <span class="n">rsize2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ag2</span><span class="o">.</span><span class="n">residues</span><span class="p">])</span>
        <span class="n">rsize_mismatches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">rsize1</span> <span class="o">-</span> <span class="n">rsize2</span><span class="p">)</span>
        <span class="n">mismatch_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">rsize_mismatches</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mismatch_mask</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">get_atoms_byres</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">match_mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">mismatch_mask</span><span class="p">)):</span>
                <span class="c1"># not pretty... but need to do things on a per-atom basis in</span>
                <span class="c1"># order to preserve original selection</span>
                <span class="n">ag</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">atoms</span>
                <span class="n">good</span> <span class="o">=</span> <span class="n">ag</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">resids</span><span class="p">[</span><span class="n">match_mask</span><span class="p">]</span>  <span class="c1"># resid for each residue</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="n">ag</span><span class="o">.</span><span class="n">resids</span>                     <span class="c1"># resid for each atom</span>
                <span class="c1"># boolean array for all matching atoms</span>
                <span class="n">ix_good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">resids</span><span class="p">,</span> <span class="n">good</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ag</span><span class="p">[</span><span class="n">ix_good</span><span class="p">]</span>

            <span class="n">_ag1</span> <span class="o">=</span> <span class="n">get_atoms_byres</span><span class="p">(</span><span class="n">ag1</span><span class="p">)</span>
            <span class="n">_ag2</span> <span class="o">=</span> <span class="n">get_atoms_byres</span><span class="p">(</span><span class="n">ag2</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">_ag1</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">==</span> <span class="n">_ag2</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span>

            <span class="c1"># diagnostics</span>
            <span class="n">mismatch_resindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ag1</span><span class="o">.</span><span class="n">n_residues</span><span class="p">)[</span><span class="n">mismatch_mask</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Removed </span><span class="si">{0}</span><span class="s2"> residues with non-matching numbers of atoms&quot;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mismatch_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Removed residue ids: group 1: </span><span class="si">{0}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ag1</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">resids</span><span class="p">[</span><span class="n">mismatch_resindex</span><span class="p">]))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Removed residue ids: group 2: </span><span class="si">{0}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ag2</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">resids</span><span class="p">[</span><span class="n">mismatch_resindex</span><span class="p">]))</span>
            <span class="c1"># replace after logging (still need old ag1 and ag2 for</span>
            <span class="c1"># diagnostics)</span>
            <span class="n">ag1</span> <span class="o">=</span> <span class="n">_ag1</span>
            <span class="n">ag2</span> <span class="o">=</span> <span class="n">_ag2</span>
            <span class="k">del</span> <span class="n">_ag1</span><span class="p">,</span> <span class="n">_ag2</span>

            <span class="c1"># stop if we created empty selections (by removing ALL residues...)</span>
            <span class="k">if</span> <span class="n">ag1</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Failed to automatically find matching atoms: created empty selections. &quot;</span>
                          <span class="s2">&quot;Try to improve your selections for mobile and reference.&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">match_atoms</span><span class="p">:</span>
        <span class="c1"># check again because the residue matching heuristic is not very</span>
        <span class="c1"># good and can easily be misled (e.g., when one of the selections</span>
        <span class="c1"># had fewer atoms but the residues in mobile and reference have</span>
        <span class="c1"># each the same number)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ag1</span><span class="p">,</span> <span class="s1">&#39;masses&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ag2</span><span class="p">,</span> <span class="s1">&#39;masses&#39;</span><span class="p">)):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Atoms could not be matched since they don&#39;t contain masses.&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">SelectionWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mass_mismatches</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">ag1</span><span class="o">.</span><span class="n">masses</span> <span class="o">-</span> <span class="n">ag2</span><span class="o">.</span><span class="n">masses</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_mass</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Failed to find matching atoms: len(reference) = </span><span class="si">{}</span><span class="s2">, len(mobile) = </span><span class="si">{}</span><span class="s2"> &quot;</span>
                          <span class="s2">&quot;Try to improve your selections for mobile and reference.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">ag1</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">ag2</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mass_mismatches</span><span class="p">):</span>
                <span class="c1"># Test 2 failed.</span>
                <span class="c1"># diagnostic output:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Atoms: reference | trajectory&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ar</span><span class="p">,</span> <span class="n">at</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ag1</span><span class="p">[</span><span class="n">mass_mismatches</span><span class="p">],</span> <span class="n">ag2</span><span class="p">[</span><span class="n">mass_mismatches</span><span class="p">]):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{0!s:&gt;4}</span><span class="s2"> </span><span class="si">{1:3d}</span><span class="s2"> </span><span class="si">{2!s:&gt;3}</span><span class="s2"> </span><span class="si">{3!s:&gt;3}</span><span class="s2"> </span><span class="si">{4:6.3f}</span><span class="s2">  |  </span><span class="si">{5!s:&gt;4}</span><span class="s2"> </span><span class="si">{6:3d}</span><span class="s2"> </span><span class="si">{7!s:&gt;3}</span><span class="s2"> </span><span class="si">{8!s:&gt;3}</span><span class="s2"> </span><span class="si">{9:6.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">ar</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span>
                            <span class="n">ar</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span>
                            <span class="n">ar</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span>
                            <span class="n">ar</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                            <span class="n">ar</span><span class="o">.</span><span class="n">mass</span><span class="p">,</span>
                            <span class="n">at</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span>
                            <span class="n">at</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span>
                            <span class="n">at</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span>
                            <span class="n">at</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                            <span class="n">at</span><span class="o">.</span><span class="n">mass</span><span class="p">))</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Inconsistent selections, masses differ by more than </span><span class="si">{0}</span><span class="s2">; &quot;</span>
                           <span class="s2">&quot;mis-matching atoms are shown above.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tol_mass</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ag1</span><span class="p">,</span> <span class="n">ag2</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2024, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Henok Ademtew, Shobhit Agarwal, Aya M. Alaa, Irfan Alibay, Kazi Shudipto Amin, Anshul Angaria, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Patricio Barletta, Leonardo Barneschi, Jonathan Barnoud, Estefania Barreto-Ojeda, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Kavya Bisht, Wouter Boomsma, Jose Borreguero, Cédric Bouysset, Kevin Boyd, Meet Brijwani, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, Yantong Cai, David Caplan, Yuanyu Chang, Pratham Chauhan, Matthieu Chavent, Haochuan Chen, Xu Hong Chen, Kathleen Clark, Jennifer A Clark, Orion Cohen, Charlie Cook, Ruggero Cortini, Nicholas Craven, Ramon Crehuet, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Bradley Dice, Jan Domanski, David L. Dotson, Mark D. Driver, Ali Ehlen, Daniel J. Evans, Shujie Fan, Bjarne Feddersen, Lennard van der Feltz, Jake Fennick, Philip Fowler, Guillaume Fraux, Anirvinya G, Michael Gecht, Ahmed Salah Ghoneim, Mikhail Glagolev, William Glass, Jenna M. Swarthout Goddard, Joseph Goose, Alexander Gorfer, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Pratik Gupta, Sumit Gupta, Benjamin Hall, Ameya Harmalkar, Ivan Hristov, Eugen Hruska, Kyle J. Huston, Siddharth Jain, Edis Jakupovic, Joe Jordan, Henrik Jäger, Uma D Kadam, Aditya Kamath, Jon Kapla, Ian M. Kenney, Aditya Keshari, Haleema Khan, Navya Khare, Utsav Khatu, Andrew William King, Henry Kobin, Abhishek A. Kognole, Kosuke Kudo, Atharva Kulkarni, Manish Kumar, Mohit Kumar, Shubham Kumar, Alia Lescoulie, Zhenbo Li, Max Linke, Philip Loche, Jinju Lu, Hugo MacDermott-Opeskin, Shaivi Malik, Egor Marin, Domenico Marson, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Rocco Meli, Manuel Nuno Melo, Marcelo C. R. Melo, Dominik &#39;Rathann&#39; Mierzejewski, David Minh, Geongi Moon, Sampurna Mukherjee, Henry Mull, Morgan L. Nance, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Meghan Osato, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Dimitrios Papageorgiou, Rafael R. Pappalardo, Vishal Parmar, Danny Parton, Shakul Pathak, Christian Pfaendner, Joshua L. Phillips, Marcelo D. Poleto, Hannah Pollak, Kashish Punjani, Michael Quevillon, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Andrea Rizzi, Xiaoxu Ruan, Carlos Yanez S., Utkarsh Saxena, Moritz Schaeffler, Alexander Schlaich, Marcello Sega, Ricky Sexton, Sean L. Seyler, Faraaz Shah, Sulay Shah, Abhishek Shandilya, Shubham Sharma, Rishabh Shukla, Karthikeyan Singaravelan, Tamandeep Singh, Brigitta Sipőcz, Paul Smith, Andy Somogyi, Caio S. Souza, Kai Niklas Spauszus, David van der Spoel, Shantanu Srivastava, Lukas Stelzl, Jan Stevens, Gorman Stock, Philipp Stärk, Johannes Stöckelmaier, Fenil Suchak, Ayush Suhane, Filip T. Szczypiński, Sukeerti T, Matthijs Tadema, Valerij Talagayev, Joao Miguel Correia Teixeira, Paarth Thadani, Matthew W. Thompson, Hao Tian, Matteo Tiberti, Zaheer Timol, Wiep van der Toorn, Mieczyslaw Torchala, Aditi Tripathi, Heet Vekariya, Mark Verma, Josh Vermaas, Isaac Virshup, Lily Wang, Leon Wehrhan, Nestor Wendt, Lawson Woods, Zhiyi Wu, Tengyu Xie, Zhuyi Xue, Mingyi Xue, Alexander Yang, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, Raymond Zhao, Yuxuan Zhuang, and Oliver Beckstein.</p>
  </div>

  

<div class="footer"><p>Please see
    our <a href="https://www.mdanalysis.org/pages/privacy/">Privacy Policy</a>
    to learn how <a href="https://www.mdanalysis.org">MDAnalysis</a> collects data.</p>
    <script data-goatcounter="https://mdanalysis.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</div>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
    var versions_json_url = 'https://docs.mdanalysis.org/versions.json'
</script>

<div class="rst-versions" data-toggle="rst-versions" role="note"
     aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
        2.8.0-dev0
      <span class="fa fa-caret-down"></span>
    </span>

    <div class="rst-other-versions">
        <dl id="versionselector">
            <dt>Other Versions</dt>
        </dl>

    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>