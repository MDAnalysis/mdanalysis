


  
    
  




<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="shortcut icon" href="../../../../_static/logo/mda_favicon.ico">
</head>

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MDAnalysis.analysis.hydrogenbonds.wbridge_analysis &mdash; MDAnalysis 2.8.0-dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/site.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=a9b57af3"></script>
        <script src="../../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../../_static/js/versions.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 2.8.0-dev0 documentation"
          href="../../../../_static/opensearch.xml"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >




  




<a href="../../../../index.html">
  
    <img src="../../../../_static/logo/mda_logo.png" class="logo" alt="Logo"/>
</a>


  
  
  
    <div class="version">
      2.8.0-dev0
    </div>
  



<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>
<div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
    <!-- <p class="caption" role="heading"></p> -->
    <ul>
        
        <li class="toctree-l1"><a class="reference internal" href="http://mdanalysis.org">MDAnalysis</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="http://userguide.mdanalysis.org">User guide</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="https://mdakits.mdanalysis.org/">MDAKits</a></li>
        
    </ul>
    
        <p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/converters.html">7. Converter modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/trajectory_transformations.html">8. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/selections_modules.html">9. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/auxiliary_modules.html">10. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/core_modules.html">11. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/visualization_modules.html">12. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/lib_modules.html">13. Library functions — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/version.html">14. Version information for MDAnalysis - <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/units.html">15. Constants and unit conversion — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/exceptions.html">16. Custom exceptions and warnings — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation_pages/references.html">17. References</a></li>
</ul>

</div>

      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MDAnalysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">MDAnalysis.analysis.hydrogenbonds.wbridge_analysis</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MDAnalysis.analysis.hydrogenbonds.wbridge_analysis</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1"># doi: 10.25080/majora-629e541a-00e</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;Water Bridge analysis --- :mod:`MDAnalysis.analysis.hydrogenbonds.WaterBridgeAnalysis`</span>
<span class="sd">==========================================================================================</span>

<span class="sd">:Author: Zhiyi Wu</span>
<span class="sd">:Year: 2017-2018</span>
<span class="sd">:Copyright: GNU Public License v3</span>
<span class="sd">:Maintainer: Zhiyi Wu &lt;zhiyi.wu@gtc.ox.ac.uk&gt;,  `@xiki-tempula`_ on GitHub</span>


<span class="sd">.. _`@xiki-tempula`: https://github.com/xiki-tempula</span>


<span class="sd">Given a :class:`~MDAnalysis.core.universe.Universe` (simulation</span>
<span class="sd">trajectory with 1 or more frames) measure all water bridges for each</span>
<span class="sd">frame between selections 1 and 2.</span>
<span class="sd">Water bridge is defined as a bridging water which simultaneously forms</span>
<span class="sd">two hydrogen bonds with atoms from both selection 1 and selection 2.</span>

<span class="sd">A water bridge can form between two hydrogen bond acceptors.</span>

<span class="sd">e.g. -CO\ :sub:`2`\ :sup:`-`:···H−O−H···:\ :sup:`-`\ O\ :sub:`2`\ C-</span>

<span class="sd">A water bridge can also form between two hydrogen bond donors.</span>

<span class="sd">e.g. -NH···:O:···HN- (where O is the oxygen of a bridging water)</span>

<span class="sd">A hydrogen bond acceptor and another hydrogen bond donor can be bridged by a</span>
<span class="sd">water.</span>

<span class="sd">e.g. -CO\ :sub:`2`\ :sup:`-`:···H−O:···HN- (where H−O is part of **H−O**\ −H)</span>

<span class="sd">A higher order water bridge is defined as more than one water bridging</span>
<span class="sd">hydrogen bond acceptor and donor. An example of a second order water bridge:</span>

<span class="sd">e.g. -CO\ :sub:`2`\ :sup:`-`:···H−O:···H−O:···HN-</span>
<span class="sd">(where H−O is part of **H−O**\ −H)</span>

<span class="sd">The following keyword arguments are important to control the behaviour of the</span>
<span class="sd">water bridge analysis:</span>

<span class="sd">- *water_selection* (``resname SOL``): the selection string for the bridging water</span>
<span class="sd">- *order* the maximum number of water bridging both ends</span>
<span class="sd">- donor-acceptor *distance* (Å): 3.0</span>
<span class="sd">- Angle *cutoff* (degrees): 120.0</span>
<span class="sd">- *forcefield* to switch between default values for different force fields</span>
<span class="sd">- *donors* and *acceptors* atom types (to add additional atom names)</span>

<span class="sd">Theory</span>
<span class="sd">------</span>

<span class="sd">This module attempts to find multi-order water bridge by an approach similar</span>
<span class="sd">to breadth-first search, where the first solvation shell of selection 1 is</span>
<span class="sd">selected, followed by the selection of the second solvation shell as well as</span>
<span class="sd">any hydrogen bonding partner from selection 1. After that, the third solvation</span>
<span class="sd">shell, as well as any binding partners from selection 2, are detected. This</span>
<span class="sd">process is repeated until the maximum order of water bridges is reached.</span>

<span class="sd">.. _wb_Analysis_Network:</span>

<span class="sd">Output as Network</span>
<span class="sd">-----------------</span>

<span class="sd">Since the waters connecting the two ends of the selections are by nature a</span>
<span class="sd">network. We provide a network representation of the water network. Water bridge</span>
<span class="sd">data are returned per frame, which is stored in</span>
<span class="sd">:attr:`WaterBridgeAnalysis.results.network`. Each frame is represented as a</span>
<span class="sd">dictionary, where the keys are the hydrogen bonds originating from selection</span>
<span class="sd">1 and the values are new dictionaries representing the hydrogen bonds coming</span>
<span class="sd">out of the corresponding molecules making hydrogen bonds with selection 1.</span>

<span class="sd">As for the hydrogen bonds which reach the selection 2, the values of the</span>
<span class="sd">corresponding keys are None. One example where selection 1 and selection 2 are</span>
<span class="sd">joined by one water molecule (A) which also hydrogen bond to another water (B)</span>
<span class="sd">which also hydrogen bond to selection 2 would be represented as ::</span>

<span class="sd">    # (selection 1)-O:···H-O(water 1):···H-(selection 2)</span>
<span class="sd">    #                      |             :</span>
<span class="sd">    #                      H·············O-H(water2)</span>
<span class="sd">    #                                    H</span>
<span class="sd">    {(sele1_acceptor, None, water1_donor, water1_donor_heavy, distance, angle):</span>
<span class="sd">         {(water1_acceptor, None, sele2_donor, sele2_donor_heavy,</span>
<span class="sd">         distance, angle): None},</span>
<span class="sd">         {(water1_donor, water1_donor_heavy, water2_acceptor, None,</span>
<span class="sd">         distance, angle):</span>
<span class="sd">              {(water2_acceptor, None, sele2_donor, sele2_donor_heavy,</span>
<span class="sd">              distance, angle): None}</span>
<span class="sd">          },</span>
<span class="sd">    }</span>

<span class="sd">The atoms are represented by atom index and if the atom is hydrogen bond donor,</span>
<span class="sd">it is followed by the index of the corresponding heavy atom</span>
<span class="sd">``(donor_proton, donor_heavy_atom)``.</span>
<span class="sd">If the atom is a hydrogen bond acceptor, it is followed by none.</span>

<span class="sd">.. _wb_Analysis_Timeseries:</span>

<span class="sd">Output as Timeseries</span>
<span class="sd">--------------------</span>

<span class="sd">For lower order water bridges, it might be desirable to represent the</span>
<span class="sd">connections as :attr:`WaterBridgeAnalysis.results.timeseries`. The results</span>
<span class="sd">are returned per frame and are a list of hydrogen bonds between the selection</span>
<span class="sd">1 or selection 2 and the bridging waters. Due to the complexity of the higher</span>
<span class="sd">order water bridge and the fact that one hydrogen bond between two waters can</span>
<span class="sd">appear in both third and fourth order water bridge, the hydrogen bonds in the</span>
<span class="sd">:attr:`WaterBridgeAnalysis.results.timeseries` attribute are generated in a</span>
<span class="sd">depth-first search manner to avoid duplication. Example code of how</span>
<span class="sd">:attr:`WaterBridgeAnalysis.results.timeseries` is generated::</span>

<span class="sd">    def network2timeseries(network, timeseries):</span>
<span class="sd">        &#39;&#39;&#39;Traverse the network in a depth-first fashion.</span>
<span class="sd">        expand_timeseries will expand the compact representation to the</span>
<span class="sd">        familiar timeseries representation.&#39;&#39;&#39;</span>

<span class="sd">        if network is None:</span>
<span class="sd">            return</span>
<span class="sd">        else:</span>
<span class="sd">            for node in network:</span>
<span class="sd">                timeseries.append(expand_timeseries(node))</span>
<span class="sd">                network2timeseries(network[node], timeseries)</span>

<span class="sd">    timeseries = []</span>
<span class="sd">    network2timeseries(network, timeseries)</span>

<span class="sd">An example would be. ::</span>

<span class="sd">    results = [</span>
<span class="sd">        [ # frame 1</span>
<span class="sd">           [ &lt;donor index&gt;, &lt;acceptor index&gt;,</span>
<span class="sd">            (&lt;donor residue name&gt;, &lt;donor residue number&gt;, &lt;donor atom name&gt;),</span>
<span class="sd">            (&lt;acceptor residue name&gt;, &lt;acceptor residue number&gt;,</span>
<span class="sd">            &lt;acceptor atom name&gt;),</span>
<span class="sd">             &lt;distance&gt;, &lt;angle&gt;],</span>
<span class="sd">           ....</span>
<span class="sd">        ],</span>
<span class="sd">        [ # frame 2</span>
<span class="sd">          [ ... ], [ ... ], ...</span>
<span class="sd">        ],</span>
<span class="sd">        ...</span>
<span class="sd">    ]</span>

<span class="sd">Using the :meth:`WaterBridgeAnalysis.generate_table` method one can reformat</span>
<span class="sd">the results as a flat &quot;normalised&quot; table that is easier to import into a</span>
<span class="sd">database or dataframe for further processing.</span>

<span class="sd">Detection of water bridges</span>
<span class="sd">--------------------------</span>
<span class="sd">Water bridges are recorded if a bridging water simultaneously forms</span>
<span class="sd">hydrogen bonds with selection 1 and selection 2.</span>

<span class="sd">Hydrogen bonds are detected based on a geometric criterion:</span>

<span class="sd">1. The distance between acceptor and hydrogen is less than or equal to</span>
<span class="sd">   `distance` (default is 3 Å).</span>

<span class="sd">2. The angle between donor-hydrogen-acceptor is greater than or equal to</span>
<span class="sd">   `angle` (default is 120º).</span>

<span class="sd">The cut-off values `angle` and `distance` can be set as keywords to</span>
<span class="sd">:class:`WaterBridgeAnalysis`.</span>

<span class="sd">Donor and acceptor heavy atoms are detected from atom names. The current</span>
<span class="sd">defaults are appropriate for the CHARMM27 and GLYCAM06 force fields as defined</span>
<span class="sd">in Table `Default atom names for water bridge analysis`_.</span>

<span class="sd">Hydrogen atoms bonded to a donor are searched based on its distance to the</span>
<span class="sd">donor. The algorithm searches for all hydrogens</span>
<span class="sd">(name &quot;H*&quot; or name &quot;[123]H&quot; or type &quot;H&quot;) in the same residue as the donor atom</span>
<span class="sd">within a cut-off distance of 1.2 Å.</span>

<span class="sd">.. _Default atom names for water bridge analysis:</span>

<span class="sd">.. table:: Default heavy atom names for CHARMM27 force field.</span>

<span class="sd">   =========== ==============  =========== ====================================</span>
<span class="sd">   group       donor           acceptor    comments</span>
<span class="sd">   =========== ==============  =========== ====================================</span>
<span class="sd">   main chain  N               O, OC1, OC2 OC1, OC2 from amber99sb-ildn</span>
<span class="sd">                                           (Gromacs)</span>
<span class="sd">   water       OH2, OW         OH2, OW     SPC, TIP3P, TIP4P (CHARMM27,Gromacs)</span>

<span class="sd">   ARG         NE, NH1, NH2</span>
<span class="sd">   ASN         ND2             OD1</span>
<span class="sd">   ASP                         OD1, OD2</span>
<span class="sd">   CYS         SG</span>
<span class="sd">   CYH                         SG          possible false positives for CYS</span>
<span class="sd">   GLN         NE2             OE1</span>
<span class="sd">   GLU                         OE1, OE2</span>
<span class="sd">   HIS         ND1, NE2        ND1, NE2    presence of H determines if donor</span>
<span class="sd">   HSD         ND1             NE2</span>
<span class="sd">   HSE         NE2             ND1</span>
<span class="sd">   HSP         ND1, NE2</span>
<span class="sd">   LYS         NZ</span>
<span class="sd">   MET                         SD          see e.g. :footcite:p:`Gregoret1991`</span>
<span class="sd">   SER         OG              OG</span>
<span class="sd">   THR         OG1             OG1</span>
<span class="sd">   TRP         NE1</span>
<span class="sd">   TYR         OH              OH</span>
<span class="sd">   =========== ==============  =========== ====================================</span>

<span class="sd">.. table:: Heavy atom types for GLYCAM06 force field.</span>

<span class="sd">   =========== =========== ==================</span>
<span class="sd">   element     donor       acceptor</span>
<span class="sd">   =========== =========== ==================</span>
<span class="sd">   N           N,NT,N3     N,NT</span>
<span class="sd">   O           OH,OW       O,O2,OH,OS,OW,OY</span>
<span class="sd">   S                       SM</span>
<span class="sd">   =========== =========== ==================</span>

<span class="sd">Donor and acceptor names for the CHARMM27 force field will also work for e.g.</span>
<span class="sd">OPLS/AA or amber (tested in Gromacs). Residue names in the table are for</span>
<span class="sd">information only and are not taken into account when determining acceptors and</span>
<span class="sd">donors. This can potentially lead to some ambiguity in the assignment of</span>
<span class="sd">donors/acceptors for residues such as histidine or cytosine.</span>

<span class="sd">For more information about the naming convention in GLYCAM06 have a look at the</span>
<span class="sd">`Carbohydrate Naming Convention in Glycam`_.</span>

<span class="sd">.. _`Carbohydrate Naming Convention in Glycam`:</span>
<span class="sd">   http://glycam.ccrc.uga.edu/documents/FutureNomenclature.htm</span>

<span class="sd">The lists of donor and acceptor names can be extended by providing lists of</span>
<span class="sd">atom names in the `donors` and `acceptors` keywords to</span>
<span class="sd">:class:`WaterBridgeAnalysis`. If the lists are entirely inappropriate</span>
<span class="sd">(e.g. when analysing simulations done with a force field that uses very</span>
<span class="sd">different atom names) then one should either use the value &quot;other&quot; for</span>
<span class="sd">`forcefield` to set no default values or derive a new class and set the</span>
<span class="sd">default list oneself::</span>

<span class="sd"> class WaterBridgeAnalysis_OtherFF(WaterBridgeAnalysis):</span>
<span class="sd">       DEFAULT_DONORS = {&quot;OtherFF&quot;: tuple(set([...]))}</span>
<span class="sd">       DEFAULT_ACCEPTORS = {&quot;OtherFF&quot;: tuple(set([...]))}</span>

<span class="sd">Then simply use the new class instead of the parent class and call it with</span>
<span class="sd">```forcefield` = &quot;OtherFF&quot;``. Please also consider contributing the list of</span>
<span class="sd">heavy atom names to MDAnalysis.</span>


<span class="sd">.. rubric:: References</span>

<span class="sd">.. footbibliography::</span>


<span class="sd">How to perform ``WaterBridgeAnalysis``</span>
<span class="sd">--------------------------------------</span>

<span class="sd">All water bridges between arginine and aspartic acid can be analysed with ::</span>

<span class="sd">  import MDAnalysis</span>
<span class="sd">  from MDAnalysis.analysis.hydrogenbonds import WaterBridgeAnalysis</span>

<span class="sd">  u = MDAnalysis.Universe(&#39;topology&#39;, &#39;trajectory&#39;)</span>
<span class="sd">  w = WaterBridgeAnalysis(u, &#39;resname ARG&#39;, &#39;resname ASP&#39;)</span>
<span class="sd">  w.run()</span>

<span class="sd">The maximum number of bridging waters detected can be changed using the order</span>
<span class="sd">keyword. ::</span>

<span class="sd">  w = WaterBridgeAnalysis(u, &#39;resname ARG&#39;, &#39;resname ASP&#39;, order=3)</span>

<span class="sd">Thus, a maximum of three bridging waters will be detected.</span>

<span class="sd">An example of using the :attr:`~WaterBridgeAnalysis` would be</span>
<span class="sd">detecting the percentage of time a certain water bridge exits.</span>

<span class="sd">Trajectory :code:`u` has two frames, where the first frame contains a water</span>
<span class="sd">bridge from the oxygen of the first arginine to one of the oxygens in the</span>
<span class="sd">carboxylic group of aspartate (ASP3:OD1). In the second frame, the same water</span>
<span class="sd">bridge forms but is between the oxygen of the arginine and the other oxygen in</span>
<span class="sd">the carboxylic group (ASP3:OD2). ::</span>

<span class="sd">  # index residue id residue name atom name</span>
<span class="sd">  #     0          1          ARG         O</span>
<span class="sd">  #     1          2          SOL        OW</span>
<span class="sd">  #     2          2          SOL       HW1</span>
<span class="sd">  #     3          2          SOL       HW2</span>
<span class="sd">  #     4          3          ASP       OD1</span>
<span class="sd">  #     5          3          ASP       OD2</span>
<span class="sd">  print(w.results.timeseries)</span>

<span class="sd">prints out ::</span>

<span class="sd">  [ # frame 1</span>
<span class="sd">    # A water bridge SOL2 links O from ARG1 to the carboxylic group OD1 of ASP3</span>
<span class="sd">   [[0,2,(&#39;ARG&#39;,1,  &#39;O&#39;),(&#39;SOL&#39;,2,&#39;HW1&#39;),  3.0,180],</span>
<span class="sd">    [3,4,(&#39;SOL&#39;,2,&#39;HW2&#39;),(&#39;ASP&#39;,3,&#39;OD1&#39;),  3.0,180],</span>
<span class="sd">   ],</span>
<span class="sd">    # frame 2</span>
<span class="sd">    # Another water bridge SOL2 links O from ARG1 to the other oxygen of the</span>
<span class="sd">    # carboxylic group OD2 of ASP3</span>
<span class="sd">   [[0,2,(&#39;ARG&#39;,1,  &#39;O&#39;),(&#39;SOL&#39;,2,&#39;HW1&#39;),  3.0,180],</span>
<span class="sd">    [3,5,(&#39;SOL&#39;,2,&#39;HW2&#39;),(&#39;ASP&#39;,3,&#39;OD2&#39;),  3.0,180],</span>
<span class="sd">   ],</span>
<span class="sd">  ]</span>


<span class="sd">.. _wb_count_by_type:</span>

<span class="sd">Use ``count_by_type``</span>
<span class="sd">---------------------</span>

<span class="sd">We can use the :meth:`~WaterBridgeAnalysis.count_by_type` to</span>
<span class="sd">generate the frequency of all water bridges in the simulation. ::</span>

<span class="sd">  w.count_by_type()</span>

<span class="sd">Returns ::</span>

<span class="sd">  [(0, 3, &#39;ARG&#39;, 1, &#39;O&#39;, &#39;ASP&#39;, 3, &#39;OD1&#39;, 0.5),</span>
<span class="sd">   (0, 4, &#39;ARG&#39;, 1, &#39;O&#39;, &#39;ASP&#39;, 3, &#39;OD2&#39;, 0.5),]</span>

<span class="sd">You might think that the OD1 and OD2 are the same oxygen and the aspartate has</span>
<span class="sd">just flipped and thus, they should be counted as the same type of water bridge.</span>
<span class="sd">The type of the water bridge can be customised by supplying an analysis</span>
<span class="sd">function to :meth:`~WaterBridgeAnalysis.count_by_type`.</span>

<span class="sd">The analysis function has two parameters. The current and the output. The</span>
<span class="sd">current is a list of hydrogen bonds from selection 1 to selection 2, formatted</span>
<span class="sd">in the same fashion as :attr:`WaterBridgeAnalysis.network`, and an example will</span>
<span class="sd">be ::</span>

<span class="sd">  [</span>
<span class="sd">  # sele1 acceptor idx,   , water donor index, donor heavy atom idx, dist, ang.</span>
<span class="sd">   [                 0, None,                 2,                   1, 3.0,180],</span>
<span class="sd">  # water donor idx, donor heavy atom idx, sele2 acceptor idx, distance, angle.</span>
<span class="sd">   [              3,                    1,                  4, None, 3.0,180],]</span>

<span class="sd">Where ``current[0]`` is the first hydrogen bond originating from selection 1</span>
<span class="sd">and ``current[-1]`` is the final hydrogen bond ending in selection 2. The</span>
<span class="sd">output sums up all the information in the current frame and is a dictionary</span>
<span class="sd">with a user-defined key and the value is the weight of the corresponding key.</span>
<span class="sd">During the analysis phase, the function analysis iterates through all the water</span>
<span class="sd">bridges and modify the output in-place. At the end of the analysis, the keys</span>
<span class="sd">from all the frames are collected and the corresponding values will be summed</span>
<span class="sd">up and returned. ::</span>

<span class="sd">  def analysis(current, output, u):</span>
<span class="sd">      r&#39;&#39;&#39;This function defines how the type of water bridge should be</span>
<span class="sd">      specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current : list</span>
<span class="sd">            The current water bridge being analysed is a list of hydrogen bonds</span>
<span class="sd">            from selection 1 to selection 2.</span>
<span class="sd">        output : dict</span>
<span class="sd">            A dictionary which is modified in-place where the key is the type</span>
<span class="sd">            of the water bridge and the value is the weight of this type of</span>
<span class="sd">            water bridge.</span>
<span class="sd">        u : MDAnalysis.universe</span>
<span class="sd">            The current Universe for looking up atoms.&#39;&#39;&#39;</span>

<span class="sd">      # decompose the first hydrogen bond.</span>
<span class="sd">      sele1_index, sele1_heavy_index, atom2, heavy_atom2, dist, angle =</span>
<span class="sd">      current[0]</span>
<span class="sd">      # decompose the last hydrogen bond.</span>
<span class="sd">      atom1, heavy_atom1, sele2_index, sele2_heavy_index, dist, angle =</span>
<span class="sd">      current[-1]</span>
<span class="sd">      # expand the atom index to the resname, resid, atom names</span>
<span class="sd">      sele1 = u.atoms[sele1_index]</span>
<span class="sd">      sele2 = u.atoms[sele2_index]</span>
<span class="sd">      (s1_resname, s1_resid, s1_name) = (sele1.resname, sele1.resid,</span>
<span class="sd">      sele1.name)</span>
<span class="sd">      (s2_resname, s2_resid, s2_name) = (sele2.resname, sele2.resid,</span>
<span class="sd">      sele2.name)</span>
<span class="sd">      # if the residue name is ASP and the atom name is OD2 or OD1,</span>
<span class="sd">      # the atom name is changed to OD</span>
<span class="sd">      if s2_resname == &#39;ASP&#39; and (s2_name == &#39;OD1&#39; or s2_name == &#39;OD2&#39;):</span>
<span class="sd">          s2_name = &#39;OD&#39;</span>
<span class="sd">      # setting up the key which defines this type of water bridge.</span>
<span class="sd">      key = (s1_resname, s1_resid, s1_name, s2_resname, s2_resid, s2_name)</span>
<span class="sd">      # The number of this type of water bridge is incremented by 1.</span>
<span class="sd">      output[key] += 1</span>

<span class="sd">  w.count_by_type(analysis_func=analysis)</span>

<span class="sd">Returns ::</span>

<span class="sd">  [((&#39;ARG&#39;, 1, &#39;O&#39;, &#39;ASP&#39;, 3, &#39;OD&#39;), 1.0),]</span>

<span class="sd">Note that the result is arranged in the format of</span>
<span class="sd">``(key, the proportion of time)``. When no custom analysis function is supplied</span>
<span class="sd">, the key is expanded and is formatted as ::</span>

<span class="sd">  [(&#39;ARG&#39;, 1, &#39;O&#39;, &#39;ASP&#39;, 3, &#39;OD&#39;, 1.0),]</span>

<span class="sd">Some people might only interested in contacts between residues and pay no</span>
<span class="sd">attention to the details regarding the atom name. However, since multiple water</span>
<span class="sd">bridges can exist between two residues, which sometimes can give a result such</span>
<span class="sd">that the water bridge between two residues exists 300% of the time. Though this</span>
<span class="sd">might be a desirable result for some people, others might want the water bridge</span>
<span class="sd">between two residues to be only counted once per frame. This can also be</span>
<span class="sd">achieved by supplying an analysis function to</span>
<span class="sd">:meth:`~WaterBridgeAnalysis.count_by_type`. ::</span>

<span class="sd">  def analysis(current, output, u):</span>
<span class="sd">      &#39;&#39;&#39;This function defines how the type of water bridge should be specified</span>
<span class="sd">      .</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current : list</span>
<span class="sd">            The current water bridge being analysed is a list of hydrogen bonds</span>
<span class="sd">            from selection 1 to selection 2.</span>
<span class="sd">        output : dict</span>
<span class="sd">            A dictionary which is modified in-place where the key is the type</span>
<span class="sd">            of the water bridge and the value is the weight of this type of</span>
<span class="sd">            water bridge.</span>
<span class="sd">        u : MDAnalysis.universe</span>
<span class="sd">            The current Universe for looking up atoms.</span>
<span class="sd">      &#39;&#39;&#39;</span>

<span class="sd">      # decompose the first hydrogen bond.</span>
<span class="sd">      sele1_index, sele1_heavy_index, atom2, heavy_atom2, dist, angle =</span>
<span class="sd">      current[0]</span>
<span class="sd">      # decompose the last hydrogen bond.</span>
<span class="sd">      atom1, heavy_atom1, sele2_index, sele2_heavy_index, dist, angle =</span>
<span class="sd">      current[-1]</span>
<span class="sd">      # expand the atom index to the resname, resid, atom names</span>
<span class="sd">      sele1 = u.atoms[sele1_index]</span>
<span class="sd">      sele2 = u.atoms[sele2_index]</span>
<span class="sd">      (s1_resname, s1_resid, s1_name) = (sele1.resname, sele1.resid,</span>
<span class="sd">      sele1.name)</span>
<span class="sd">      (s2_resname, s2_resid, s2_name) = (sele2.resname, sele2.resid,</span>
<span class="sd">      sele2.name)</span>
<span class="sd">      # s1_name and s2_name are not included in the key</span>
<span class="sd">      key = (s1_resname, s1_resid, s2_resname, s2_resid)</span>

<span class="sd">      # Each residue is only counted once per frame</span>
<span class="sd">      output[key] = 1</span>

<span class="sd">  w.count_by_type(analysis_func=analysis)</span>

<span class="sd">Returns ::</span>

<span class="sd">  [((&#39;ARG&#39;, 1, &#39;ASP&#39;, 3), 1.0),]</span>

<span class="sd">On the other hand, other people may insist that the first order and</span>
<span class="sd">second-order water bridges shouldn&#39;t be mixed together, which can also be</span>
<span class="sd">achieved by supplying an analysis function to</span>
<span class="sd">:meth:`~WaterBridgeAnalysis.count_by_type`.  ::</span>

<span class="sd">  def analysis(current, output, u):</span>
<span class="sd">      &#39;&#39;&#39;This function defines how the type of water bridge should be specified</span>
<span class="sd">      .</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current : list</span>
<span class="sd">            The current water bridge being analysed is a list of hydrogen bonds</span>
<span class="sd">            from selection 1 to selection 2.</span>
<span class="sd">        output : dict</span>
<span class="sd">            A dictionary which is modified in-place where the key is the type</span>
<span class="sd">            of the water bridge and the value is the weight of this type of</span>
<span class="sd">            water bridge.</span>
<span class="sd">        u : MDAnalysis.universe</span>
<span class="sd">            The current Universe for looking up atoms.</span>
<span class="sd">      &#39;&#39;&#39;</span>

<span class="sd">      # decompose the first hydrogen bond.</span>
<span class="sd">      sele1_index, sele1_heavy_index, atom2, heavy_atom2, dist, angle =</span>
<span class="sd">      current[0]</span>
<span class="sd">      # decompose the last hydrogen bond.</span>
<span class="sd">      atom1, heavy_atom1, sele2_index, sele2_heavy_index, dist, angle =</span>
<span class="sd">      current[-1]</span>
<span class="sd">      # expand the atom index to the resname, resid, atom names</span>
<span class="sd">      sele1 = u.atoms[sele1_index]</span>
<span class="sd">      sele2 = u.atoms[sele2_index]</span>
<span class="sd">      (s1_resname, s1_resid, s1_name) = (sele1.resname, sele1.resid,</span>
<span class="sd">      sele1.name)</span>
<span class="sd">      (s2_resname, s2_resid, s2_name) = (sele2.resname, sele2.resid,</span>
<span class="sd">      sele2.name)</span>
<span class="sd">      # order of the current water bridge is computed</span>
<span class="sd">      order_of_water_bridge = len(current) - 1</span>
<span class="sd">      # and is included in the key</span>
<span class="sd">      key = (s1_resname, s1_resid, s2_resname, s2_resid, order_of_water_bridge)</span>
<span class="sd">      # The number of this type of water bridge is incremented by 1.</span>
<span class="sd">      output[key] += 1</span>

<span class="sd">  w.count_by_type(analysis_func=analysis)</span>

<span class="sd">The extra number 1 precede the 1.0 indicate that this is a first order water</span>
<span class="sd">bridge ::</span>

<span class="sd">  [((&#39;ARG&#39;, 1, &#39;ASP&#39;, 3, 1), 1.0),]</span>

<span class="sd">Some people might not be interested in the interactions related to arginine.</span>
<span class="sd">The undesirable interactions can be discarded by supplying an analysis function</span>
<span class="sd">to :meth:`~WaterBridgeAnalysis.count_by_type`.  ::</span>

<span class="sd">  def analysis(current, output, u):</span>
<span class="sd">      &#39;&#39;&#39;This function defines how the type of water bridge should be</span>
<span class="sd">      specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current : list</span>
<span class="sd">            The current water bridge being analysed is a list of hydrogen bonds</span>
<span class="sd">            from selection 1 to selection 2.</span>
<span class="sd">        output : dict</span>
<span class="sd">            A dictionary which is modified in-place where the key is the type</span>
<span class="sd">            of the water bridge and the value is the number of this type of</span>
<span class="sd">            water bridge.</span>
<span class="sd">        u : MDAnalysis.universe</span>
<span class="sd">            The current Universe for looking up atoms.</span>
<span class="sd">      &#39;&#39;&#39;</span>

<span class="sd">      # decompose the first hydrogen bond.</span>
<span class="sd">      sele1_index, sele1_heavy_index, atom2, heavy_atom2, dist, angle =</span>
<span class="sd">      current[0]</span>
<span class="sd">      # decompose the last hydrogen bond.</span>
<span class="sd">      atom1, heavy_atom1, sele2_index, sele2_heavy_index, dist, angle =</span>
<span class="sd">      current[-1]</span>
<span class="sd">      # expand the atom index to the resname, resid, atom names</span>
<span class="sd">      sele1 = u.atoms[sele1_index]</span>
<span class="sd">      sele2 = u.atoms[sele2_index]</span>
<span class="sd">      (s1_resname, s1_resid, s1_name) = (sele1.resname, sele1.resid,</span>
<span class="sd">      sele1.name)</span>
<span class="sd">      (s2_resname, s2_resid, s2_name) = (sele2.resname, sele2.resid,</span>
<span class="sd">      sele2.name)</span>
<span class="sd">      if not s1_resname == &#39;ARG&#39;:</span>
<span class="sd">          key = (s1_resname, s1_resid, s2_resname, s2_resid)</span>
<span class="sd">          output[key] += 1</span>

<span class="sd">  w.count_by_type(analysis_func=analysis)</span>

<span class="sd">Returns nothing in this case ::</span>

<span class="sd">  [,]</span>

<span class="sd">Additional keywords can be supplied to the analysis function by passing through</span>
<span class="sd">:meth:`~WaterBridgeAnalysis.count_by_type`.  ::</span>

<span class="sd">  def analysis(current, output, **kwargs):</span>
<span class="sd">      ...</span>
<span class="sd">  w.count_by_type(analysis_func=analysis, **kwargs)</span>


<span class="sd">.. _wb_count_by_time:</span>

<span class="sd">Use ``count_by_time``</span>
<span class="sd">---------------------</span>

<span class="sd">:meth:`~WaterBridgeAnalysis.count_by_type` aggregates data across frames, which</span>
<span class="sd">might be desirable in some cases but not the others.</span>
<span class="sd">:meth:`~WaterBridgeAnalysis.count_by_time` provides additional functionality</span>
<span class="sd">for aggregating results for each frame.</span>

<span class="sd">The default behaviour of :meth:`~WaterBridgeAnalysis.count_by_time` is counting</span>
<span class="sd">the number of water bridges from selection 1 to selection 2 for each frame.</span>
<span class="sd">Take the previous ASP, ARG salt bridge for example:  ::</span>

<span class="sd">  w.count_by_time()</span>

<span class="sd">As one water bridge is found in both frames, the method returns ::</span>

<span class="sd">  [(1.0, 1), (2.0, 1), ]</span>

<span class="sd">Similar to :meth:`~WaterBridgeAnalysis.count_by_type`</span>
<span class="sd">The behaviour of :meth:`~WaterBridgeAnalysis.count_by_time` can also be</span>
<span class="sd">modified by supplying an analysis function.</span>

<span class="sd">Suppose we want to count</span>

<span class="sd">  - the **number** of water molecules involved in bridging selection 1 to</span>
<span class="sd">    selection 2.</span>
<span class="sd">  - only if water bridge terminates in atom name **OD1 of ASP**.</span>
<span class="sd">  - only when water bridge is joined by less than **two** water.</span>

<span class="sd">The analysis function can be written as::</span>

<span class="sd">  def analysis(current, output, u, **kwargs):</span>
<span class="sd">      &#39;&#39;&#39;This function defines how the counting of water bridge should be</span>
<span class="sd">      specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current : list</span>
<span class="sd">            The current water bridge being analysed is a list of hydrogen bonds</span>
<span class="sd">            from selection 1 to selection 2.</span>
<span class="sd">        output : dict</span>
<span class="sd">            A dictionary which is modified in-place where the key is the type</span>
<span class="sd">            of the water bridge and the value is the number of this type of</span>
<span class="sd">            water  bridge.</span>
<span class="sd">        u : MDAnalysis.universe</span>
<span class="sd">            The current Universe for looking up atoms.</span>
<span class="sd">      &#39;&#39;&#39;</span>

<span class="sd">      # decompose the first hydrogen bond.</span>
<span class="sd">      sele1_index, sele1_heavy_index, atom2, heavy_atom2, dist, angle =</span>
<span class="sd">      current[0]</span>
<span class="sd">      # decompose the last hydrogen bond.</span>
<span class="sd">      atom1, heavy_atom1, sele2_index, sele2_heavy_index, dist, angle =</span>
<span class="sd">      current[-1]</span>
<span class="sd">      # expand the atom index to the resname, resid, atom names</span>
<span class="sd">      sele1 = u.atoms[sele1_index]</span>
<span class="sd">      sele2 = u.atoms[sele2_index]</span>
<span class="sd">      (s1_resname, s1_resid, s1_name) =</span>
<span class="sd">      (sele1.resname, sele1.resid, sele1.name)</span>
<span class="sd">      (s2_resname, s2_resid, s2_name) =</span>
<span class="sd">      (sele2.resname, sele2.resid, sele2.name)</span>

<span class="sd">      # only the residue name is ASP and the atom name is OD1,</span>
<span class="sd">      if s2_resname == &#39;ASP&#39; and s2_name == &#39;OD1&#39;:</span>
<span class="sd">          # only if the order of water bridge is less than 2</span>
<span class="sd">          if len(current) -1 &lt; 2:</span>
<span class="sd">              # extract all water molecules involved in the water bridge</span>
<span class="sd">              # extract the first water from selection 1</span>
<span class="sd">              s1_index, to_index, (s1_resname, s1_resid, s1_name),</span>
<span class="sd">              (to_resname, to_resid, to_name), dist, angle = current[0]</span>
<span class="sd">              key = (to_resname, to_resid)</span>
<span class="sd">              output[key] = 1</span>

<span class="sd">              # extract all the waters between selection 1 and selection 2</span>
<span class="sd">              for hbond in current[1:-1]:</span>
<span class="sd">                  # decompose the hydrogen bond.</span>
<span class="sd">                  from_index, to_index, (from_resname, from_resid, from_name),</span>
<span class="sd">                  (to_resname, to_resid, to_name), dist, angle = hbond</span>
<span class="sd">                  # add first water</span>
<span class="sd">                  key1 = (from_resname, from_resid)</span>
<span class="sd">                  output[key1] = 1</span>
<span class="sd">                  # add second water</span>
<span class="sd">                  key2 = (to_resname, to_resid)</span>
<span class="sd">                  output[key2] = 1</span>

<span class="sd">              # extract the last water to selection 2</span>
<span class="sd">              from_index, s2_index, (from_resname, from_resid, from_name),</span>
<span class="sd">              (s2_resname, s2_resid, s2_name), dist, angle = current[-1]</span>
<span class="sd">              key = (from_resname, from_resid)</span>
<span class="sd">              output[key] = 1</span>

<span class="sd">  w.count_by_time(analysis_func=analysis)</span>

<span class="sd">Returns ::</span>

<span class="sd">  [(1.0, 1), (2.0, 0),]</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>

<span class="sd">.. autoclass:: WaterBridgeAnalysis</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: timesteps</span>

<span class="sd">      List of the times of each timestep. This can be used together with</span>
<span class="sd">      :attr:`~WaterBridgeAnalysis.results.timeseries` to find the specific</span>
<span class="sd">      time point of a water bridge existence.</span>

<span class="sd">   .. attribute:: results.network</span>

<span class="sd">      Network representation of the water network.</span>

<span class="sd">      .. versionadded:: 2.0.0</span>

<span class="sd">   .. attribute:: network</span>

<span class="sd">      Alias to the :attr:`results.network` attribute.</span>

<span class="sd">      .. deprecated:: 2.0.0</span>
<span class="sd">         Will be removed in MDAnalysis 3.0.0. Please use</span>
<span class="sd">         :attr:`results.network` instead.</span>

<span class="sd">   .. attribute:: table</span>

<span class="sd">      .. deprecated:: 2.0.0</span>
<span class="sd">         Will be removed in MDAnalysis 3.0.0. Please generate</span>
<span class="sd">         the table with :meth:`generate_table` instead.</span>

<span class="sd">   .. attribute:: results.timeseries</span>

<span class="sd">      List of hydrogen bonds between the selection 1 or selection 2</span>
<span class="sd">      and the bridging waters, for each frame.</span>

<span class="sd">      .. versionadded:: 2.0.0</span>

<span class="sd">   .. attribute:: timeseries</span>

<span class="sd">      Alias to the :attr:`results.timeseries` attribute.</span>

<span class="sd">      .. deprecated:: 2.0.0</span>
<span class="sd">         Will be removed in MDAnalysis 3.0.0. Please use</span>
<span class="sd">         :attr:`results.timeseries` instead.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">..base</span> <span class="kn">import</span> <span class="n">AnalysisBase</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.NeighborSearch</span> <span class="kn">import</span> <span class="n">AtomNeighborSearch</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.distances</span> <span class="kn">import</span> <span class="n">capped_distance</span><span class="p">,</span> <span class="n">calc_angles</span>
<span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">NoDataError</span><span class="p">,</span> <span class="n">MissingDataWarning</span><span class="p">,</span> <span class="n">SelectionError</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;MDAnalysis.analysis.WaterBridgeAnalysis&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="WaterBridgeAnalysis">
<a class="viewcode-back" href="../../../../documentation_pages/analysis/wbridge_analysis.html#MDAnalysis.analysis.hydrogenbonds.wbridge_analysis.WaterBridgeAnalysis">[docs]</a>
<span class="k">class</span> <span class="nc">WaterBridgeAnalysis</span><span class="p">(</span><span class="n">AnalysisBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform a water bridge analysis</span>

<span class="sd">    The analysis of the trajectory is performed with the</span>
<span class="sd">    :meth:`WaterBridgeAnalysis.run` method. The result is stored in</span>
<span class="sd">    :attr:`WaterBridgeAnalysis.results.timeseries`. See</span>
<span class="sd">    :meth:`~WaterBridgeAnalysis.run` for the format.</span>

<span class="sd">    .. versionadded:: 0.17.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># use tuple(set()) here so that one can just copy&amp;paste names from the</span>
    <span class="c1"># table; set() takes care for removing duplicates. At the end the</span>
    <span class="c1"># DEFAULT_DONORS and DEFAULT_ACCEPTORS should simply be tuples.</span>

    <span class="c1">#: default heavy atom names whose hydrogens are treated as *donors*</span>
    <span class="c1">#: (see :ref:`Default atom names for water bridge analysis`);</span>
    <span class="c1">#: use the keyword `donors` to add a list of additional donor names.</span>
    <span class="n">DEFAULT_DONORS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;CHARMM27&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">{</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;OH2&#39;</span><span class="p">,</span> <span class="s1">&#39;OW&#39;</span><span class="p">,</span> <span class="s1">&#39;NE&#39;</span><span class="p">,</span> <span class="s1">&#39;NH1&#39;</span><span class="p">,</span> <span class="s1">&#39;NH2&#39;</span><span class="p">,</span> <span class="s1">&#39;ND2&#39;</span><span class="p">,</span> <span class="s1">&#39;SG&#39;</span><span class="p">,</span> <span class="s1">&#39;NE2&#39;</span><span class="p">,</span> <span class="s1">&#39;ND1&#39;</span><span class="p">,</span>
             <span class="s1">&#39;NZ&#39;</span><span class="p">,</span> <span class="s1">&#39;OG&#39;</span><span class="p">,</span> <span class="s1">&#39;OG1&#39;</span><span class="p">,</span> <span class="s1">&#39;NE1&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">}),</span>
        <span class="s1">&#39;GLYCAM06&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">({</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;NT&#39;</span><span class="p">,</span> <span class="s1">&#39;N3&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">,</span> <span class="s1">&#39;OW&#39;</span><span class="p">}),</span>
        <span class="s1">&#39;other&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([]))}</span>

    <span class="c1">#: default atom names that are treated as hydrogen *acceptors*</span>
    <span class="c1">#: (see :ref:`Default atom names for water bridge analysis`);</span>
    <span class="c1">#: use the keyword `acceptors` to add a list of additional acceptor names.</span>
    <span class="n">DEFAULT_ACCEPTORS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;CHARMM27&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">{</span><span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;OC1&#39;</span><span class="p">,</span> <span class="s1">&#39;OC2&#39;</span><span class="p">,</span> <span class="s1">&#39;OH2&#39;</span><span class="p">,</span> <span class="s1">&#39;OW&#39;</span><span class="p">,</span> <span class="s1">&#39;OD1&#39;</span><span class="p">,</span> <span class="s1">&#39;OD2&#39;</span><span class="p">,</span> <span class="s1">&#39;SG&#39;</span><span class="p">,</span> <span class="s1">&#39;OE1&#39;</span><span class="p">,</span> <span class="s1">&#39;OE1&#39;</span><span class="p">,</span>
             <span class="s1">&#39;OE2&#39;</span><span class="p">,</span> <span class="s1">&#39;ND1&#39;</span><span class="p">,</span> <span class="s1">&#39;NE2&#39;</span><span class="p">,</span> <span class="s1">&#39;SD&#39;</span><span class="p">,</span> <span class="s1">&#39;OG&#39;</span><span class="p">,</span> <span class="s1">&#39;OG1&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">}),</span>
        <span class="s1">&#39;GLYCAM06&#39;</span><span class="p">:</span>
            <span class="nb">tuple</span><span class="p">({</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;NT&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;O2&#39;</span><span class="p">,</span> <span class="s1">&#39;OH&#39;</span><span class="p">,</span> <span class="s1">&#39;OS&#39;</span><span class="p">,</span> <span class="s1">&#39;OW&#39;</span><span class="p">,</span> <span class="s1">&#39;OY&#39;</span><span class="p">,</span> <span class="s1">&#39;SM&#39;</span><span class="p">}),</span>
        <span class="s1">&#39;other&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">([]))}</span>

    <span class="c1">#: A :class:`collections.defaultdict` of covalent radii of common donors</span>
    <span class="c1">#: (used in :meth`_get_bonded_hydrogens_list` to check if a hydrogen is</span>
    <span class="c1">#: sufficiently close to its donor heavy atom). Values are stored for</span>
    <span class="c1">#: N, O, P, and S. Any other heavy atoms are assumed to have hydrogens</span>
    <span class="c1">#: covalently bound at a maximum distance of 1.5 Å.</span>
    <span class="n">r_cov</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">,</span>  <span class="c1"># default value</span>
                        <span class="n">N</span><span class="o">=</span><span class="mf">1.31</span><span class="p">,</span> <span class="n">O</span><span class="o">=</span><span class="mf">1.31</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="mf">1.58</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="mf">1.55</span><span class="p">)</span>  <span class="c1"># noqa: E741</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="n">selection1</span><span class="o">=</span><span class="s1">&#39;protein&#39;</span><span class="p">,</span>
                 <span class="n">selection2</span><span class="o">=</span><span class="s1">&#39;not resname SOL&#39;</span><span class="p">,</span> <span class="n">water_selection</span><span class="o">=</span><span class="s1">&#39;resname SOL&#39;</span><span class="p">,</span>
                 <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">selection1_type</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">update_selection</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">update_water_selection</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filter_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">distance_type</span><span class="o">=</span><span class="s1">&#39;hydrogen&#39;</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mf">120.0</span><span class="p">,</span>
                 <span class="n">forcefield</span><span class="o">=</span><span class="s1">&#39;CHARMM27&#39;</span><span class="p">,</span> <span class="n">donors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">acceptors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">output_format</span><span class="o">=</span><span class="s2">&quot;sele1_sele2&quot;</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up the calculation of water bridges between two selections in a</span>
<span class="sd">        universe.</span>

<span class="sd">        The timeseries is accessible as the attribute</span>
<span class="sd">        :attr:`WaterBridgeAnalysis.results.timeseries`.</span>

<span class="sd">        If no hydrogen bonds are detected or if the initial check fails, look</span>
<span class="sd">        at the log output (enable with :func:`MDAnalysis.start_logging` and set</span>
<span class="sd">        `verbose` ``=True``). It is likely that the default names for donors</span>
<span class="sd">        and acceptors are not suitable (especially for non-standard</span>
<span class="sd">        ligands). In this case, either change the `forcefield` or use</span>
<span class="sd">        customized `donors` and/or `acceptors`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        universe : Universe</span>
<span class="sd">            Universe object</span>
<span class="sd">        selection1 : str (optional)</span>
<span class="sd">            Selection string for first selection [&#39;protein&#39;]</span>
<span class="sd">        selection2 : str (optional)</span>
<span class="sd">            Selection string for second selection [&#39;not resname SOL&#39;]</span>
<span class="sd">            This string selects everything except water where water is assumed</span>
<span class="sd">            to have a residue name as SOL.</span>
<span class="sd">        water_selection : str (optional)</span>
<span class="sd">            Selection string for bridging water selection [&#39;resname SOL&#39;]</span>
<span class="sd">            The default selection assumes that the water molecules have residue</span>
<span class="sd">            name &quot;SOL&quot;. Change it to the appropriate selection for your</span>
<span class="sd">            specific force field.</span>

<span class="sd">            However, in theory, this selection can be anything which forms</span>
<span class="sd">            a hydrogen bond with selection 1 and selection 2.</span>
<span class="sd">        order : int (optional)</span>
<span class="sd">            The maximum number of water bridges linking both selections.</span>
<span class="sd">            if the order is set to 3, then all the residues linked with less</span>
<span class="sd">            than three water molecules will be detected. [1]</span>

<span class="sd">            Computation of high order water bridges can be very time-consuming.</span>
<span class="sd">            Think carefully before running the calculation, do you really want</span>
<span class="sd">            to compute the 20th order water bridge between domain A and domain</span>
<span class="sd">            B or you just want to know the third order water bridge between two</span>
<span class="sd">            residues.</span>
<span class="sd">        selection1_type : {&quot;donor&quot;, &quot;acceptor&quot;, &quot;both&quot;} (optional)</span>
<span class="sd">            Selection 1 can be &#39;donor&#39;, &#39;acceptor&#39; or &#39;both&#39;. Note that the</span>
<span class="sd">            value for `selection1_type` automatically determines how</span>
<span class="sd">            `selection2` handles donors and acceptors: If `selection1` contains</span>
<span class="sd">            &#39;both&#39; then `selection2` will also contain &#39;both&#39;. If `selection1`</span>
<span class="sd">            is set to &#39;donor&#39; then `selection2` is &#39;acceptor&#39; (and vice versa).</span>
<span class="sd">            [&#39;both&#39;].</span>
<span class="sd">        update_selection : bool (optional)</span>
<span class="sd">            Update selection 1 and 2 at each frame. Setting to ``True`` if the</span>
<span class="sd">            selection is not static. Selections are filtered first to speed up</span>
<span class="sd">            performance. Thus, setting to ``True`` is recommended if contact</span>
<span class="sd">            surface between selection 1 and selection 2 is constantly</span>
<span class="sd">            changing. [``False``]</span>
<span class="sd">        update_water_selection : bool (optional)</span>
<span class="sd">            Update selection of water at each frame. Setting to ``False`` is</span>
<span class="sd">            **only** recommended when the total amount of water molecules in</span>
<span class="sd">            the simulation are small and when water molecules remain static</span>
<span class="sd">            across the simulation.</span>

<span class="sd">            However, in normal simulations, only a tiny proportion of water is</span>
<span class="sd">            engaged in the formation of water bridge. It is recommended to</span>
<span class="sd">            update the water selection and set keyword `filter_first` to</span>
<span class="sd">            ``True`` so as to filter out water not residing between the two</span>
<span class="sd">            selections. [``True``]</span>
<span class="sd">        filter_first : bool (optional)</span>
<span class="sd">            Filter the water selection to only include water within 4 Å +</span>
<span class="sd">            `order` * (2 Å + `distance`) away from `both` selection 1 and</span>
<span class="sd">            selection 2.</span>
<span class="sd">            Selection 1 and selection 2 are both filtered to only include atoms</span>
<span class="sd">            with the same distance away from the other selection. [``True``]</span>
<span class="sd">        distance : float (optional)</span>
<span class="sd">            Distance cutoff for hydrogen bonds; only interactions with a H-A</span>
<span class="sd">            distance &lt;= `distance` (and the appropriate D-H-A angle, see</span>
<span class="sd">            `angle`) are recorded. (Note: `distance_type` can change this to</span>
<span class="sd">            the D-A distance.) [3.0]</span>
<span class="sd">        angle : float (optional)</span>
<span class="sd">            Angle cutoff for hydrogen bonds; an ideal H-bond has an angle of</span>
<span class="sd">            180º.  A hydrogen bond is only recorded if the D-H-A angle is</span>
<span class="sd">            &gt;=  `angle`. The default of 120º also finds fairly non-specific</span>
<span class="sd">            hydrogen interactions and possibly better value is 150º. [120.0]</span>
<span class="sd">        forcefield : {&quot;CHARMM27&quot;, &quot;GLYCAM06&quot;, &quot;other&quot;} (optional)</span>
<span class="sd">            Name of the forcefield used. Switches between different</span>
<span class="sd">            :attr:`~DEFAULT_DONORS` and</span>
<span class="sd">            :attr:`~DEFAULT_ACCEPTORS` values.</span>
<span class="sd">            [&quot;CHARMM27&quot;]</span>
<span class="sd">        donors : sequence (optional)</span>
<span class="sd">            Extra H donor atom types (in addition to those in :attr:`~DEFAULT_DONORS`).</span>
<span class="sd">            This shall be the name of the heavy atom that is bonded to the hydrogen.</span>
<span class="sd">            For example, the oxygen (&#39;O&#39;) in the hydroxyl group. Must be a sequence.</span>
<span class="sd">        acceptors : sequence (optional)</span>
<span class="sd">            Extra H acceptor atom types (in addition to those in</span>
<span class="sd">            :attr:`~DEFAULT_ACCEPTORS`), must be a</span>
<span class="sd">            sequence.</span>
<span class="sd">        distance_type : {&quot;hydrogen&quot;, &quot;heavy&quot;} (optional)</span>
<span class="sd">            Measure hydrogen bond lengths between donor and acceptor heavy</span>
<span class="sd">            atoms (&quot;heavy&quot;) or between donor hydrogen and acceptor heavy</span>
<span class="sd">            atom (&quot;hydrogen&quot;). If using &quot;heavy&quot; then one should set the</span>
<span class="sd">            *distance* cutoff to a higher value such as 3.5 Å. [&quot;hydrogen&quot;]</span>
<span class="sd">        output_format: {&quot;sele1_sele2&quot;, &quot;donor_acceptor&quot;} (optional)</span>
<span class="sd">            Setting the output format for timeseries and table. If set to</span>
<span class="sd">            &quot;sele1_sele2&quot;, for each hydrogen bond, the one close to selection 1</span>
<span class="sd">            will be placed before selection 2. If set to &quot;donor_acceptor&quot;, the</span>
<span class="sd">            donor will be placed before acceptor. &quot;sele1_sele2&quot;]</span>
<span class="sd">        debug : bool (optional)</span>
<span class="sd">            If set to ``True`` enables per-frame debug logging. This is</span>
<span class="sd">            disabled by default because it generates a very large amount of</span>
<span class="sd">            output in the log file. (Note that a logger must have been started</span>
<span class="sd">            to see the output, e.g. using :func:`MDAnalysis.start_logging`.)</span>
<span class="sd">        verbose : bool (optional)</span>
<span class="sd">            Toggle progress output. (Can also be given as keyword argument to</span>
<span class="sd">            :meth:`run`.)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In order to speed up processing, atoms are filtered by a coarse</span>
<span class="sd">        distance criterion before a detailed hydrogen bonding analysis is</span>
<span class="sd">        performed (`filter_first` = ``True``).</span>

<span class="sd">        If selection 1 and selection 2 are very mobile during the simulation</span>
<span class="sd">        and the contact surface is constantly changing (i.e. residues are</span>
<span class="sd">        moving farther than 4 Å + `order` * (2 Å + `distance`)), you might</span>
<span class="sd">        consider setting the `update_selection` keywords to ``True``</span>
<span class="sd">        to ensure correctness.</span>

<span class="sd">        .. versionchanged 0.20.0</span>
<span class="sd">           The :attr:`WaterBridgeAnalysis.timeseries` has been updated</span>
<span class="sd">           see :attr:`WaterBridgeAnalysis.timeseries` for detail.</span>
<span class="sd">           This class is now based on</span>
<span class="sd">           :class:`~MDAnalysis.analysis.base.AnalysisBase`.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WaterBridgeAnalysis</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">water_selection</span> <span class="o">=</span> <span class="n">water_selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_water_selection</span> <span class="o">=</span> <span class="n">update_water_selection</span>
        <span class="c1"># per-frame debugging output?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>

        <span class="c1"># set the output format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_format</span> <span class="o">=</span> <span class="n">output_format</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection1</span> <span class="o">=</span> <span class="n">selection1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span> <span class="o">=</span> <span class="n">selection2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="o">=</span> <span class="n">selection1_type</span>
        <span class="k">if</span> <span class="s2">&quot;selection2_type&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`selection2_type` is not a keyword argument.&quot;</span><span class="p">)</span>

        <span class="c1"># if the selection 1 and selection 2 are the same</span>
        <span class="k">if</span> <span class="n">selection1</span> <span class="o">==</span> <span class="n">selection2</span><span class="p">:</span>
            <span class="c1"># eliminate the duplication</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="o">=</span> <span class="s2">&quot;donor&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span> <span class="o">=</span> <span class="n">update_selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_first</span> <span class="o">=</span> <span class="n">filter_first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="k">if</span> <span class="n">distance_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;hydrogen&quot;</span><span class="p">,</span> <span class="s2">&quot;heavy&quot;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only &#39;hydrogen&#39; and &#39;heavy&#39; are allowed for option `distance_type&#39; (</span><span class="si">{</span><span class="n">distance_type</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span> <span class="o">=</span> <span class="n">distance_type</span>
        <span class="c1"># will give the default behavior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>

        <span class="c1"># set up the donors/acceptors lists</span>
        <span class="k">if</span> <span class="n">donors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">donors</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">if</span> <span class="n">acceptors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">acceptors</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcefield</span> <span class="o">=</span> <span class="n">forcefield</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">donors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_DONORS</span><span class="p">[</span><span class="n">forcefield</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">donors</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_ACCEPTORS</span><span class="p">[</span><span class="n">forcefield</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="n">acceptors</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;WaterBridgeAnalysis: &#39;</span>
                             <span class="s1">&#39;Invalid selection type </span><span class="si">{0!s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span><span class="p">))</span>

        <span class="c1"># final result accessed as self.results.network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># time for each frame</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log_parameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_log_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log important parameters to the logfile.&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: selection = </span><span class="si">%r</span><span class="s2"> (update: </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: water selection = </span><span class="si">%r</span><span class="s2"> (update: </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">water_selection</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_water_selection</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: criterion: donor </span><span class="si">%s</span><span class="s2"> atom and &quot;</span>
                    <span class="s2">&quot;acceptor atom distance &lt;= </span><span class="si">%.3f</span><span class="s2"> A&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: criterion: &quot;</span>
                    <span class="s2">&quot;angle D-H-A &gt;= </span><span class="si">%.3f</span><span class="s2"> degrees&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: force field </span><span class="si">%s</span><span class="s2"> to guess donor and </span><span class="se">\</span>
<span class="s2">        acceptor names&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcefield</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_residue_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
        <span class="c1"># Build the residue_dict where the key is the residue name</span>
        <span class="c1"># The content is a dictionary where hydrogen bond donor heavy atom</span>
        <span class="c1"># names is the key</span>
        <span class="c1"># The content is the hydrogen bond donor hydrogen atom names</span>
        <span class="n">atom_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">atom_group</span><span class="o">.</span><span class="n">residues</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">resname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residue_dict</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_residue_dict</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">resname</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_residue_dict</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">resname</span><span class="p">][</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_hydrogens</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_donor_h</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_ix</span><span class="p">,</span> <span class="n">h_donors</span><span class="p">,</span> <span class="n">donors_h</span><span class="p">):</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_ix</span><span class="p">]</span>
        <span class="n">residue</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span>
        <span class="n">hydrogen_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residue_dict</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">resname</span><span class="p">][</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">hydrogen_names</span><span class="p">:</span>
            <span class="n">hydrogens</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">hydrogen_names</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">:</span>
                <span class="n">h_donors</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom_ix</span>
                <span class="n">donors_h</span><span class="p">[</span><span class="n">atom_ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_h_donors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_h_donors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">)</span><span class="o">.</span><span class="n">ix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">)</span><span class="o">.</span><span class="n">ix</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_first</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s1">&#39;Size of selection 1 before filtering:&#39;</span>
                              <span class="s1">&#39; </span><span class="si">{}</span><span class="s1"> atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">)))</span>
            <span class="n">ns_selection_1</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">],</span>
                                                <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s1</span> <span class="o">=</span> <span class="n">ns_selection_1</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">selection_distance</span><span class="p">)</span><span class="o">.</span><span class="n">ix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Size of selection 1: </span><span class="si">{0}</span><span class="s2"> atoms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Selection 1 &quot;</span><span class="si">{0}</span><span class="s1">&quot; did not select any atoms.&#39;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">)[:</span><span class="mi">80</span><span class="p">]))</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_first</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s1">&#39;Size of selection 2 before filtering:&#39;</span>
                              <span class="s1">&#39; </span><span class="si">{}</span><span class="s1"> atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)))</span>
            <span class="n">ns_selection_2</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">],</span>
                                                <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2</span> <span class="o">=</span> <span class="n">ns_selection_2</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">selection_distance</span><span class="p">)</span><span class="o">.</span><span class="n">ix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s1">&#39;Size of selection 2: </span><span class="si">{0}</span><span class="s1"> atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Selection 2 &quot;</span><span class="si">{0}</span><span class="s1">&quot; did not select any atoms.&#39;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">)[:</span><span class="mi">80</span><span class="p">]))</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">]</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="k">for</span> <span class="n">atom_ix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_donor_h</span><span class="p">(</span><span class="n">atom_ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_h_donors</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 donors: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 donor hydrogens: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_h_donors</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">]</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 acceptors: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">]</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 acceptors: </span><span class="si">{0:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">]</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="k">for</span> <span class="n">atom_ix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_donor_h</span><span class="p">(</span><span class="n">atom_ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_h_donors</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 donors: </span><span class="si">{0:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 donor hydrogens: </span><span class="si">{0:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_h_donors</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_update_water_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_water_donors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_water_h_donors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_water_donors_h</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_water_acceptors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_water</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">water_selection</span><span class="p">)</span><span class="o">.</span><span class="n">ix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s1">&#39;Size of water selection before filtering:&#39;</span>
                          <span class="s1">&#39; </span><span class="si">{}</span><span class="s1"> atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_first</span><span class="p">:</span>
            <span class="n">filtered_s1</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">],</span>
                                             <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection_distance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">filtered_s1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_water</span> <span class="o">=</span> <span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="n">filtered_s1</span><span class="p">,</span>
                                                 <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection_distance</span><span class="p">)</span><span class="o">.</span><span class="n">ix</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Size of water selection: </span><span class="si">{0}</span><span class="s2"> atoms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Water selection &#39;</span><span class="si">{0}</span><span class="s2">&#39; did not select any atoms.&quot;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">water_selection</span><span class="p">)[:</span><span class="mi">80</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_water_donors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">]</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="k">for</span> <span class="n">atom_ix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_donors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_donor_h</span><span class="p">(</span><span class="n">atom_ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_h_donors</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_water_donors_h</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Water donors: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water_donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Water donor hydrogens: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water_h_donors</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_water_acceptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_water</span><span class="p">]</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s1">&#39;name </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)))</span><span class="o">.</span><span class="n">ix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Water acceptors: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water_acceptors</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_get_bonded_hydrogens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find hydrogens bonded within cutoff to `atom`.</span>

<span class="sd">        Hydrogens are detected by either name (&quot;H*&quot;, &quot;[123]H*&quot;) or type (&quot;H&quot;);</span>
<span class="sd">        this is not fool-proof as the atom type is not always a character but</span>
<span class="sd">        the name pattern should catch most typical occurrences.</span>

<span class="sd">        The distance from `atom` is calculated for all hydrogens in the residue</span>
<span class="sd">        and only those within a cutoff are kept. The cutoff depends on the</span>
<span class="sd">        heavy atom (more precisely, on its element, which is taken as the first</span>
<span class="sd">        letter of its name ``atom.name[0]``) and is parameterized in</span>
<span class="sd">        :attr:`WaterBridgeAnalysis.r_cov`. If no match is found then the</span>
<span class="sd">        default of 1.5 Å is used.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : groups.Atom</span>
<span class="sd">             heavy atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hydrogen_atoms : AtomGroup or []</span>
<span class="sd">            list of hydrogens (can be a</span>
<span class="sd">            :class:`~MDAnalysis.core.groups.AtomGroup`)</span>
<span class="sd">            or empty list ``[]`` if none were found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                <span class="s2">&quot;(name H* 1H* 2H* 3H* or type H) and around </span><span class="si">{0:f}</span><span class="s2"> name </span><span class="si">{1!s}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r_cov</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">NoDataError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">logger_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The distance for selection is defined as twice the maximum bond</span>
        <span class="c1"># length of an O-H bond (2A) plus order of water bridge times the</span>
        <span class="c1"># length of OH bond plus hydrogne bond distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_distance</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_residue_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_residue_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_residue_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_residue_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">water_selection</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_selection</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_water_selection</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: &quot;</span>
                        <span class="s2">&quot;no atoms found in the selection.&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: initial checks passed.&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: starting&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: donors    </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">donors</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: acceptors </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptors</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: water bridge </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">water_selection</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Toggling debug to </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;WaterBridgeAnalysis: For full step-by-step &quot;</span>
                         <span class="s2">&quot;debugging output use debug=True&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting analysis &quot;</span>
                    <span class="s2">&quot;(frame index start=</span><span class="si">%d</span><span class="s2"> stop=</span><span class="si">%d</span><span class="s2">, step=</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_donor2acceptor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">donors</span><span class="p">,</span> <span class="n">h_donors</span><span class="p">,</span> <span class="n">acceptor</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">donors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">acceptor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span> <span class="o">!=</span> <span class="s1">&#39;heavy&#39;</span><span class="p">:</span>
            <span class="n">donors_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">h_donors</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">donors_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">donors</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Code modified from p-j-smith</span>
        <span class="n">pairs</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="n">capped_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">donors_idx</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">acceptor</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                           <span class="n">max_cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span>
                                           <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">,</span>
                                           <span class="n">return_distances</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_type</span> <span class="o">==</span> <span class="s1">&#39;hydrogen&#39;</span><span class="p">:</span>
            <span class="n">tmp_distances</span> <span class="o">=</span> <span class="n">distances</span>
            <span class="n">tmp_donors</span> <span class="o">=</span> <span class="p">[</span><span class="n">h_donors</span><span class="p">[</span><span class="n">donors_idx</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="n">tmp_hydrogens</span> <span class="o">=</span> <span class="p">[</span><span class="n">donors_idx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="n">tmp_acceptors</span> <span class="o">=</span> <span class="p">[</span><span class="n">acceptor</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># To make sure that for the same index i, the donor (tmp_donors[i]),</span>
            <span class="c1"># hydrogen (tmp_hydrogens[i]), acceptor (tmp_acceptors[i]) matches the</span>
            <span class="c1"># distance (tmp_distances[i]).</span>
            <span class="n">tmp_donors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">tmp_hydrogens</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">tmp_acceptors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">tmp_distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distances</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">donors</span><span class="p">[</span><span class="n">donors_idx</span><span class="p">[</span><span class="n">pairs</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]]:</span>
                    <span class="n">tmp_donors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">donors_idx</span><span class="p">[</span><span class="n">pairs</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
                    <span class="n">tmp_hydrogens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                    <span class="n">tmp_acceptors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">acceptor</span><span class="p">[</span><span class="n">pairs</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
                    <span class="n">tmp_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span>
            <span class="n">calc_angles</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">tmp_donors</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">tmp_hydrogens</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">tmp_acceptors</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">hbond_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">angles</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">hbond_indices</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">tmp_hydrogens</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">tmp_donors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">tmp_acceptors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_index</span><span class="p">(</span><span class="n">h</span><span class="p">),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_expand_index</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
                           <span class="n">tmp_distances</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">angles</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_single_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ts</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_selection</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_water_selection</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_water_selection</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="n">selection_1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">water_pool</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">next_round_water</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="n">selection_2</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="c1"># check for direct hbond from s1 to s2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 Donors &lt;-&gt; Selection 2 Acceptors&quot;</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_h_donors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> \
                    <span class="p">(</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                <span class="n">water_pool</span><span class="p">[(</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">selection_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                <span class="n">selection_2</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 Donors &lt;-&gt; Water Acceptors&quot;</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_s1_donors_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s1_h_donors</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_water_acceptors</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                    <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> <span class="p">(</span>
                        <span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="n">selection_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Water Donors &lt;-&gt; Selection 2 Acceptors&quot;</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_water_donors_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_h_donors</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_s2_acceptors</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                    <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> <span class="p">(</span>
                        <span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="n">water_pool</span><span class="p">[(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                    <span class="n">selection_2</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 Donors &lt;-&gt; Selection 1 Acceptors&quot;</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_s2_h_donors</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> \
                    <span class="p">(</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                <span class="n">water_pool</span><span class="p">[(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">selection_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                <span class="n">selection_2</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 2 Donors &lt;-&gt; Water Acceptors&quot;</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_s2_donors_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s2_h_donors</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_water_acceptors</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                    <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> <span class="p">(</span>
                        <span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="n">water_pool</span><span class="p">[(</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                    <span class="n">selection_2</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">))</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Selection 1 Acceptors &lt;-&gt; Water Donors&quot;</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_water_donors_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_water_h_donors</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_s1_acceptors</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                    <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> <span class="p">(</span>
                        <span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="n">selection_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger_debug</span><span class="p">(</span><span class="s2">&quot;Water donor &lt;-&gt; Water Acceptors&quot;</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_donor2acceptor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_water_donors_h</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_water_h_donors</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_water_acceptors</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="p">(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">,</span> <span class="n">h_name</span><span class="p">),</span> <span class="p">(</span>
                    <span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">,</span> <span class="n">a_name</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">line</span>
                <span class="n">water_pool</span><span class="p">[(</span><span class="n">a_resname</span><span class="p">,</span> <span class="n">a_resid</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
                <span class="n">water_pool</span><span class="p">[(</span><span class="n">h_resname</span><span class="p">,</span> <span class="n">h_resid</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">h_index</span><span class="p">,</span> <span class="n">d_index</span><span class="p">,</span> <span class="n">a_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>

        <span class="c1"># solve the connectivity network</span>
        <span class="c1"># The following code attempt to generate a water network which is</span>
        <span class="c1"># formed by the class dict.</span>
        <span class="c1"># Suppose we have a water bridge connection ARG1 to ASP3 via the two</span>
        <span class="c1"># hydrogen bonds.</span>
        <span class="c1">#     [0,1,(&#39;ARG&#39;,1,&#39;O&#39;),  (&#39;SOL&#39;,2,&#39;HW1&#39;),  3.0,180],</span>
        <span class="c1">#     [2,3,(&#39;SOL&#39;,2,&#39;HW2&#39;),(&#39;ASP&#39;,3,&#39;OD1&#39;),  3.0,180],</span>
        <span class="c1"># The resulting network will be</span>
        <span class="c1"># {(0,1,(&#39;ARG&#39;,1,&#39;O&#39;),  (&#39;SOL&#39;,2,&#39;HW1&#39;),  3.0,180):</span>
        <span class="c1"># {(2,3,(&#39;SOL&#39;,2,&#39;HW2&#39;),(&#39;ASP&#39;,3,&#39;OD1&#39;),  3.0,180): None}}</span>
        <span class="c1"># Where the key of the a dict will be all the hydrogen bonds starting</span>
        <span class="c1"># from this nodes.</span>
        <span class="c1"># The corresponding value of a certain key will be a dictionary whose</span>
        <span class="c1"># key will be all the hydrogen bonds from</span>
        <span class="c1"># the destination of in the key.</span>
        <span class="c1"># If the value of a certain key is None, which means it is reaching</span>
        <span class="c1"># selection 2.</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;start&#39;</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">),</span> <span class="s1">&#39;water&#39;</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)}</span>

        <span class="k">def</span> <span class="nf">add_route</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">route</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">route</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">][</span><span class="n">route</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># exclude the the selection which goes back to itself</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">route</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">route</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">2</span><span class="p">])):</span>
                    <span class="k">return</span>

                <span class="c1"># selection 2 to water</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;water&#39;</span><span class="p">][</span><span class="n">route</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># water to water</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">route</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;water&#39;</span><span class="p">][</span><span class="n">route</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">route</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> \
                        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;water&#39;</span><span class="p">][</span><span class="n">route</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                <span class="c1"># selection 1 to water</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">][</span><span class="n">route</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">route</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;water&#39;</span><span class="p">][</span><span class="n">route</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">def</span> <span class="nf">traverse_water_network</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">route</span><span class="p">,</span> <span class="n">maxdepth</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">route</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">end</span><span class="p">:</span>
                    <span class="c1"># check if any duplication happens</span>
                    <span class="n">heavy_atom</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="ow">or</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">route</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heavy_atom</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">heavy_atom</span><span class="p">)):</span>
                        <span class="n">add_route</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">new_node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                        <span class="n">new_route</span> <span class="o">=</span> <span class="n">route</span><span class="p">[:]</span>
                        <span class="n">new_route</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
                        <span class="n">new_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span>
                            <span class="n">new_node</span><span class="p">,</span> <span class="s1">&#39;sele1_sele2&#39;</span><span class="p">)[</span><span class="mi">3</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">traverse_water_network</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">new_node</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">new_route</span><span class="p">,</span>
                                               <span class="n">maxdepth</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">selection_1</span><span class="p">:</span>
            <span class="n">route</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="p">]</span>
            <span class="n">next_mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="s1">&#39;sele1_sele2&#39;</span><span class="p">)[</span><span class="mi">3</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">traverse_water_network</span><span class="p">(</span><span class="n">water_pool</span><span class="p">,</span> <span class="n">next_mol</span><span class="p">,</span> <span class="n">selection_2</span><span class="p">,</span> <span class="n">route</span><span class="p">[:],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_traverse_water_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">analysis_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">link_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function recursively traverses the water network</span>
<span class="sd">        self.results.network and finds the hydrogen bonds which connect the</span>
<span class="sd">        current atom to the next atom. The newly found hydrogen bond will be</span>
<span class="sd">        appended to the hydrogen bonds connecting the selection 1 to the</span>
<span class="sd">        current atom via link_func. When selection 2 is reached, the full list</span>
<span class="sd">        of hydrogen bonds connecting the selection 1 to selection 2 will be</span>
<span class="sd">        fed into analysis_func, which will then modify the output in place.</span>

<span class="sd">        :param graph: The connection network describes the connection between</span>
<span class="sd">        the atoms in the water network.</span>
<span class="sd">        :param current: The hydrogen bonds from selection 1 until now.</span>
<span class="sd">        :param analysis_func: The analysis function which is called to analysis</span>
<span class="sd">        the hydrogen bonds.</span>
<span class="sd">        :param output: where the result is stored.</span>
<span class="sd">        :param link_func: The new hydrogen bonds will be appended to current.</span>
<span class="sd">        :param kwargs: the keywords which are passed into the analysis_func.</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">link_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If no link_func is provided, the default link_func will be used</span>
            <span class="n">link_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_link</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if selection 2 is reached</span>
            <span class="k">if</span> <span class="n">analysis_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># the result is analysed by analysis_func which will change the</span>
                <span class="c1"># output</span>
                <span class="n">analysis_func</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># make sure no loop can occur</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
                    <span class="c1"># the new hydrogen bond will be added to the existing bonds</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">link_func</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_water_network</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">new</span><span class="p">,</span>
                                                 <span class="n">analysis_func</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span>
                                                 <span class="n">link_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Expand the index into (resname, resid, name).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Expand the compact data format into the old timeseries form.</span>
<span class="sd">        The old is defined as the format for release up to 0.19.2.</span>
<span class="sd">        As is discussed in Issue #2177, the internal storage of the hydrogen</span>
<span class="sd">        bond information has been changed to the compact format.</span>
<span class="sd">        The function takes in the argument `output_format` to see which output</span>
<span class="sd">        format will be chosen.</span>
<span class="sd">        if `output_format` is not specified, the value will be taken from</span>
<span class="sd">        :attr:`output_format`.</span>
<span class="sd">        If `output_format` is &#39;sele1_sele2&#39;, the output will be the old water</span>
<span class="sd">        bridge analysis format::</span>

<span class="sd">          # donor from selection 1 to acceptor in selection 2</span>
<span class="sd">          [sele1_index, sele2_index,</span>
<span class="sd">           (sele1_resname, sele1_resid, sele1_name),</span>
<span class="sd">           (sele2_resname, sele2_resid, sele2_name), dist, angle]</span>

<span class="sd">        If `output_format` is &#39;donor_acceptor&#39;, the output will be the old</span>
<span class="sd">        hydrogen bond analysis format::</span>

<span class="sd">          # From donor to acceptor</span>
<span class="sd">          [donor_index, acceptor_index,</span>
<span class="sd">           (donor_resname, donor_resid, donor_name),</span>
<span class="sd">           (acceptor_resname, acceptor_resid, acceptor_name), dist, angle]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">output_format</span> <span class="o">=</span> <span class="n">output_format</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_format</span>
        <span class="c1"># Expand the compact entry into atom1, which is the first index in the</span>
        <span class="c1"># output and atom2, which is the second</span>
        <span class="c1"># entry.</span>
        <span class="n">atom1</span><span class="p">,</span> <span class="n">heavy_atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">heavy_atom2</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">entry</span>
        <span class="k">if</span> <span class="n">output_format</span> <span class="o">==</span> <span class="s1">&#39;sele1_sele2&#39;</span><span class="p">:</span>
            <span class="c1"># If the output format is the sele1_sele2, no change will be</span>
            <span class="c1"># executed</span>
            <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span> <span class="o">=</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span>
        <span class="k">elif</span> <span class="n">output_format</span> <span class="o">==</span> <span class="s1">&#39;donor_acceptor&#39;</span><span class="p">:</span>
            <span class="c1"># If the output format is donor_acceptor, use heavy atom position</span>
            <span class="c1"># to check which is donor and which is</span>
            <span class="c1"># acceptor</span>
            <span class="k">if</span> <span class="n">heavy_atom1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># atom1 is hydrogen bond acceptor and thus, the position of</span>
                <span class="c1"># atom1 and atom2 are swapped.</span>
                <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span> <span class="o">=</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># atom1 is hydrogen bond donor, position not swapped.</span>
                <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span> <span class="o">=</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;Only &#39;sele1_sele2&#39; or &#39;donor_acceptor&#39; are allowed as output &quot;</span>
                <span class="s2">&quot;format&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_index</span><span class="p">(</span><span class="n">atom1</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_expand_index</span><span class="p">(</span><span class="n">atom2</span><span class="p">),</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generate_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&#39;&#39;&#39;Time series of water bridges.</span>

<span class="sd">        The output is generated per frame as is explained in</span>
<span class="sd">        :ref:`wb_Analysis_Timeseries`. The format of output can be changed via</span>
<span class="sd">        the output_format selection. If ``output_format=&quot;sele1_sele2&quot;``, the</span>
<span class="sd">        hydrogen bond forms a directional link from selection 1 to selection 2.</span>
<span class="sd">        If ``output_format=&quot;donor_acceptor&quot;``, for each hydrogen bond, the</span>
<span class="sd">        donor is always written before the acceptor.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        To find an acceptor atom in :attr:`Universe.atoms` by</span>
<span class="sd">        *index* one would use ``u.atoms[acceptor_index]``.</span>

<span class="sd">        .. versionchanged 0.20.0</span>
<span class="sd">           The :attr:`WaterBridgeAnalysis.timeseries` has been updated where</span>
<span class="sd">           the donor and acceptor string has been changed to tuple</span>
<span class="sd">           (resname string, resid, name_string).</span>


<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">output_format</span> <span class="o">=</span> <span class="n">output_format</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_format</span>

        <span class="k">def</span> <span class="nf">analysis</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">current</span>

        <span class="n">timeseries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span><span class="p">:</span>
            <span class="n">new_frame</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_water_network</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">new_frame</span><span class="p">,</span>
                                         <span class="n">analysis_func</span><span class="o">=</span><span class="n">analysis</span><span class="p">,</span>
                                         <span class="n">output</span><span class="o">=</span><span class="n">new_frame</span><span class="p">,</span>
                                         <span class="n">link_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compact_link</span><span class="p">)</span>
            <span class="n">timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">output_format</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">new_frame</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">timeseries</span>


    <span class="k">def</span> <span class="nf">set_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">):</span>
        <span class="n">wmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The `set_network` method was deprecated in MDAnalysis 2.0.0 &quot;</span>
                <span class="s2">&quot;and will be removed in MDAnalysis 3.0.0. Please use &quot;</span>
                <span class="s2">&quot;`results.network` instead&quot;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">wmsg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_full_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A function used in _traverse_water_network to add the new hydrogen</span>
<span class="sd">        bond to the existing bonds.</span>
<span class="sd">        :param output: The existing hydrogen bonds from selection 1</span>
<span class="sd">        :param node: The new hydrogen bond</span>
<span class="sd">        :return: The hydrogen bonds from selection 1 with the new hydrogen</span>
<span class="sd">        bond added</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">output</span><span class="p">[:]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_compact_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A function used in _traverse_water_network to add the new hydrogen</span>
<span class="sd">        bond to the existing bonds. In this form no new list is created and</span>
<span class="sd">        thus, one bridge will only appear once.</span>
<span class="sd">        :param output: The existing hydrogen bonds from selection 1</span>
<span class="sd">        :param node: The new hydrogen bond</span>
<span class="sd">        :return: The hydrogen bonds from selection 1 with the new hydrogen</span>
<span class="sd">        bond added</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_count_by_type_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generates the key for count_by_type analysis.</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">s1_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">to_residue</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">s1_resname</span><span class="p">,</span> <span class="n">s1_resid</span><span class="p">,</span> <span class="n">s1_name</span> <span class="o">=</span> <span class="n">s1</span>
        <span class="n">from_index</span><span class="p">,</span> <span class="n">s2_index</span><span class="p">,</span> <span class="n">from_residue</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">s2_resname</span><span class="p">,</span> <span class="n">s2_resid</span><span class="p">,</span> <span class="n">s2_name</span> <span class="o">=</span> <span class="n">s2</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1_index</span><span class="p">,</span> <span class="n">s2_index</span><span class="p">,</span>
               <span class="n">s1_resname</span><span class="p">,</span> <span class="n">s1_resid</span><span class="p">,</span> <span class="n">s1_name</span><span class="p">,</span> <span class="n">s2_resname</span><span class="p">,</span> <span class="n">s2_resid</span><span class="p">,</span> <span class="n">s2_name</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<div class="viewcode-block" id="WaterBridgeAnalysis.count_by_type">
<a class="viewcode-back" href="../../../../documentation_pages/analysis/wbridge_analysis.html#MDAnalysis.analysis.hydrogenbonds.wbridge_analysis.WaterBridgeAnalysis.count_by_type">[docs]</a>
    <span class="k">def</span> <span class="nf">count_by_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Counts the frequency of water bridge of a specific type.</span>

<span class="sd">        If one atom *A* from *selection 1* is linked to atom *B* from</span>
<span class="sd">        *selection 2* through one or more bridging waters, an entity will be</span>
<span class="sd">        created and the proportion of time that this linkage exists in the</span>
<span class="sd">        whole simulation will be calculated.</span>

<span class="sd">        The identification of a specific type of water bridge can be modified</span>
<span class="sd">        by supplying the analysis_func function. See :ref:`wb_count_by_type`</span>
<span class="sd">        for detail.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        counts : list</span>
<span class="sd">            Returns a :class:`list` containing atom indices for *A* and</span>
<span class="sd">            *B*, residue names, residue numbers, atom names (for both A and B)</span>
<span class="sd">            and the fraction of the total time during which the water bridge</span>
<span class="sd">            was detected. This method returns None if method</span>
<span class="sd">            :meth:`WaterBridgeAnalysis.run` was not executed first.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">analysis_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">analysis_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_by_type_analysis</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;combined&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span><span class="p">)</span>
            <span class="n">result_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span><span class="p">:</span>
                <span class="n">frame_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_water_network</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="p">[],</span>
                                             <span class="n">analysis_func</span><span class="o">=</span><span class="n">analysis_func</span><span class="p">,</span>
                                             <span class="n">output</span><span class="o">=</span><span class="n">frame_dict</span><span class="p">,</span>
                                             <span class="n">link_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_full_link</span><span class="p">,</span>
                                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">frame_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">result_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frame_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;combined&#39;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result_dict</span><span class="p">]</span>
                <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">/</span><span class="n">length</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result_dict</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span>
                           <span class="n">result_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">/</span><span class="n">length</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result_dict</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


    <span class="k">def</span> <span class="nf">_count_by_time_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">s1_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">to_residue</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">s1_resname</span><span class="p">,</span> <span class="n">s1_resid</span><span class="p">,</span> <span class="n">s1_name</span> <span class="o">=</span> <span class="n">s1</span>
        <span class="n">from_index</span><span class="p">,</span> <span class="n">s2_index</span><span class="p">,</span> <span class="n">from_residue</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">s2_resname</span><span class="p">,</span> <span class="n">s2_resid</span><span class="p">,</span> <span class="n">s2_name</span> <span class="o">=</span> <span class="n">s2</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1_index</span><span class="p">,</span> <span class="n">s2_index</span><span class="p">,</span>
               <span class="n">s1_resname</span><span class="p">,</span> <span class="n">s1_resid</span><span class="p">,</span> <span class="n">s1_name</span><span class="p">,</span> <span class="n">s2_resname</span><span class="p">,</span> <span class="n">s2_resid</span><span class="p">,</span> <span class="n">s2_name</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<div class="viewcode-block" id="WaterBridgeAnalysis.count_by_time">
<a class="viewcode-back" href="../../../../documentation_pages/analysis/wbridge_analysis.html#MDAnalysis.analysis.hydrogenbonds.wbridge_analysis.WaterBridgeAnalysis.count_by_time">[docs]</a>
    <span class="k">def</span> <span class="nf">count_by_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Counts the number of water bridges per timestep.</span>

<span class="sd">        The counting behaviour can be adjusted by supplying analysis_func.</span>
<span class="sd">        See :ref:`wb_count_by_time` for details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        counts : list</span>
<span class="sd">             Returns a time series ``N(t)`` where ``N`` is the total</span>
<span class="sd">             number of observed water bridges at time ``t``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">analysis_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">analysis_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_by_time_analysis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span><span class="p">):</span>
                <span class="n">result_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_water_network</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="p">[],</span>
                                             <span class="n">analysis_func</span><span class="o">=</span><span class="n">analysis_func</span><span class="p">,</span>
                                             <span class="n">output</span><span class="o">=</span><span class="n">result_dict</span><span class="p">,</span>
                                             <span class="n">link_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_full_link</span><span class="p">,</span>
                                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">time</span><span class="p">,</span>
                               <span class="nb">sum</span><span class="p">([</span><span class="n">result_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result_dict</span><span class="p">])))</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


    <span class="k">def</span> <span class="nf">_timesteps_by_type_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">s1_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">to_residue</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">s1_resname</span><span class="p">,</span> <span class="n">s1_resid</span><span class="p">,</span> <span class="n">s1_name</span> <span class="o">=</span> <span class="n">s1</span>
        <span class="n">from_index</span><span class="p">,</span> <span class="n">s2_index</span><span class="p">,</span> <span class="n">from_residue</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_expand_timeseries</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">s2_resname</span><span class="p">,</span> <span class="n">s2_resid</span><span class="p">,</span> <span class="n">s2_name</span> <span class="o">=</span> <span class="n">s2</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1_index</span><span class="p">,</span> <span class="n">s2_index</span><span class="p">,</span> <span class="n">s1_resname</span><span class="p">,</span> <span class="n">s1_resid</span><span class="p">,</span> <span class="n">s1_name</span><span class="p">,</span> <span class="n">s2_resname</span><span class="p">,</span>
               <span class="n">s2_resid</span><span class="p">,</span> <span class="n">s2_name</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">))</span>

<div class="viewcode-block" id="WaterBridgeAnalysis.timesteps_by_type">
<a class="viewcode-back" href="../../../../documentation_pages/analysis/wbridge_analysis.html#MDAnalysis.analysis.hydrogenbonds.wbridge_analysis.WaterBridgeAnalysis.timesteps_by_type">[docs]</a>
    <span class="k">def</span> <span class="nf">timesteps_by_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Frames during which each water bridges existed, sorted by each water</span>
<span class="sd">        bridges.</span>

<span class="sd">        Processes :attr:`WaterBridgeAnalysis.results.network` and returns a</span>
<span class="sd">        :class:`list` containing atom indices, residue names, residue</span>
<span class="sd">        numbers (from selection 1 and selection 2) and each timestep at which</span>
<span class="sd">        the water bridge was detected.</span>

<span class="sd">        Similar to :meth:`~WaterBridgeAnalysis.count_by_type` and</span>
<span class="sd">        :meth:`~WaterBridgeAnalysis.count_by_time`, the behavior can be</span>
<span class="sd">        adjusted by supplying an analysis_func.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">analysis_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">analysis_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timesteps_by_type_analysis</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;combined&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">timesteps</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">timesteps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span>
            <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">timesteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_water_network</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="p">[],</span>
                                             <span class="n">analysis_func</span><span class="o">=</span><span class="n">analysis_func</span><span class="p">,</span>
                                             <span class="n">output</span><span class="o">=</span><span class="n">result</span><span class="p">,</span>
                                             <span class="n">link_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_full_link</span><span class="p">,</span>
                                             <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">result_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">time_list</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">time_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;combined&#39;</span><span class="p">:</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                        <span class="n">key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
                        <span class="n">result_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">time</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">result_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="WaterBridgeAnalysis.generate_table">
<a class="viewcode-back" href="../../../../documentation_pages/analysis/wbridge_analysis.html#MDAnalysis.analysis.hydrogenbonds.wbridge_analysis.WaterBridgeAnalysis.generate_table">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a normalised table of the results.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_format : {&#39;sele1_sele2&#39;, &#39;donor_acceptor&#39;}</span>
<span class="sd">            The output format of the `table` can be changed a fashion similar</span>
<span class="sd">            to :attr:`WaterBridgeAnalysis.results.timeseries` by changing the</span>
<span class="sd">            labels of the columns of the participating atoms.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        table : numpy.rec.recarray</span>
<span class="sd">            A &quot;tidy&quot; table with one hydrogen bond per row, labeled according to</span>
<span class="sd">            `output_format` and containing information of atom_1, atom_2,</span>
<span class="sd">            distance, and angle.</span>

<span class="sd">        .. versionchanged:: 2.0.0</span>
<span class="sd">           Return the generated table (as well as storing it as :attr:`table`).</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">           In release 3.0.0, :meth:`generate_table()` will _only_ return the</span>
<span class="sd">           table and no longer store it in :attr:`table`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output_format</span> <span class="o">=</span> <span class="n">output_format</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_format</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No data computed, do run() first.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">MissingDataWarning</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">timeseries</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
          <span class="ow">and</span> <span class="n">output_format</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_format</span><span class="p">:</span>
            <span class="n">timeseries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">timeseries</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Recompute timeseries with correct output format</span>
            <span class="n">timeseries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_timeseries</span><span class="p">(</span><span class="n">output_format</span><span class="p">)</span>

        <span class="n">num_records</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">hframe</span><span class="p">)</span> <span class="k">for</span> <span class="n">hframe</span> <span class="ow">in</span> <span class="n">timeseries</span><span class="p">])</span>
        <span class="c1"># build empty output table</span>
        <span class="k">if</span> <span class="n">output_format</span> <span class="o">==</span> <span class="s1">&#39;sele1_sele2&#39;</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;sele1_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sele2_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;sele1_resnm&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sele1_resid&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;sele1_atom&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;sele2_resnm&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sele2_resid&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;sele2_atom&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;angle&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">output_format</span> <span class="o">==</span> <span class="s1">&#39;donor_acceptor&#39;</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;donor_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;acceptor_index&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;donor_resnm&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;donor_resid&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;donor_atom&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;acceptor_resnm&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;acceptor_resid&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;acceptor_atom&quot;</span><span class="p">,</span> <span class="s2">&quot;|U4&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;angle&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)]</span>

        <span class="c1"># according to Lukas&#39; notes below, using a recarray at this stage is</span>
        <span class="c1"># ineffective and speedups of ~x10 can be achieved by filling a</span>
        <span class="c1"># standard array, like this:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_records</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># current row</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">hframe</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timesteps</span><span class="p">,</span> <span class="n">timeseries</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">donor_index</span><span class="p">,</span> <span class="n">acceptor_index</span><span class="p">,</span> <span class="n">donor</span><span class="p">,</span>
                 <span class="n">acceptor</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span> <span class="ow">in</span> <span class="n">hframe</span><span class="p">:</span>
                <span class="c1"># donor|acceptor = (resname, resid, atomid)</span>
                <span class="n">out</span><span class="p">[</span><span class="n">cursor</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">donor_index</span><span class="p">,</span> <span class="n">acceptor_index</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="n">donor</span> <span class="o">+</span> <span class="n">acceptor</span> <span class="o">+</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
                <span class="n">cursor</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">cursor</span> <span class="o">==</span> <span class="n">num_records</span><span class="p">,</span> \
            <span class="s2">&quot;Internal Error: Not all wb records stored&quot;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;WBridge: Stored results as table with </span><span class="si">%(num_records)d</span><span class="s2"> entries.&quot;</span><span class="p">,</span>
            <span class="nb">vars</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span>

        <span class="k">return</span> <span class="n">table</span></div>


    <span class="k">def</span> <span class="nf">_conclude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_timeseries</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">network</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">wmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The `network` attribute was deprecated in MDAnalysis 2.0.0 &quot;</span>
                <span class="s2">&quot;and will be removed in MDAnalysis 3.0.0. Please use &quot;</span>
                <span class="s2">&quot;`results.network` instead&quot;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">wmsg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">network</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">wmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The `timeseries` attribute was deprecated in MDAnalysis &quot;</span>
                <span class="s2">&quot;2.0.0 and will be removed in MDAnalysis 3.0.0. Please use &quot;</span>
                <span class="s2">&quot;`results.timeseries` instead&quot;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">wmsg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">timeseries</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2024, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Henok Ademtew, Shobhit Agarwal, Aya M. Alaa, Irfan Alibay, Kazi Shudipto Amin, Anshul Angaria, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Patricio Barletta, Leonardo Barneschi, Jonathan Barnoud, Estefania Barreto-Ojeda, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Kavya Bisht, Wouter Boomsma, Jose Borreguero, Cédric Bouysset, Kevin Boyd, Meet Brijwani, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, Yantong Cai, David Caplan, Yuanyu Chang, Pratham Chauhan, Matthieu Chavent, Haochuan Chen, Xu Hong Chen, Kathleen Clark, Jennifer A Clark, Orion Cohen, Charlie Cook, Ruggero Cortini, Nicholas Craven, Ramon Crehuet, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Bradley Dice, Jan Domanski, David L. Dotson, Mark D. Driver, Ali Ehlen, Daniel J. Evans, Shujie Fan, Bjarne Feddersen, Lennard van der Feltz, Jake Fennick, Philip Fowler, Guillaume Fraux, Anirvinya G, Michael Gecht, Ahmed Salah Ghoneim, Mikhail Glagolev, William Glass, Jenna M. Swarthout Goddard, Joseph Goose, Alexander Gorfer, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Pratik Gupta, Sumit Gupta, Benjamin Hall, Ameya Harmalkar, Ivan Hristov, Eugen Hruska, Kyle J. Huston, Siddharth Jain, Edis Jakupovic, Joe Jordan, Henrik Jäger, Uma D Kadam, Aditya Kamath, Jon Kapla, Ian M. Kenney, Aditya Keshari, Haleema Khan, Navya Khare, Utsav Khatu, Andrew William King, Henry Kobin, Abhishek A. Kognole, Kosuke Kudo, Atharva Kulkarni, Manish Kumar, Mohit Kumar, Shubham Kumar, Alia Lescoulie, Zhenbo Li, Max Linke, Philip Loche, Jinju Lu, Hugo MacDermott-Opeskin, Shaivi Malik, Egor Marin, Domenico Marson, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Rocco Meli, Manuel Nuno Melo, Marcelo C. R. Melo, Dominik &#39;Rathann&#39; Mierzejewski, David Minh, Geongi Moon, Sampurna Mukherjee, Henry Mull, Morgan L. Nance, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Meghan Osato, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Dimitrios Papageorgiou, Rafael R. Pappalardo, Vishal Parmar, Danny Parton, Shakul Pathak, Christian Pfaendner, Joshua L. Phillips, Marcelo D. Poleto, Hannah Pollak, Kashish Punjani, Michael Quevillon, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Andrea Rizzi, Xiaoxu Ruan, Carlos Yanez S., Utkarsh Saxena, Moritz Schaeffler, Alexander Schlaich, Marcello Sega, Ricky Sexton, Sean L. Seyler, Faraaz Shah, Sulay Shah, Abhishek Shandilya, Shubham Sharma, Rishabh Shukla, Karthikeyan Singaravelan, Tamandeep Singh, Brigitta Sipőcz, Paul Smith, Andy Somogyi, Caio S. Souza, David van der Spoel, Shantanu Srivastava, Lukas Stelzl, Jan Stevens, Gorman Stock, Philipp Stärk, Johannes Stöckelmaier, Fenil Suchak, Ayush Suhane, Filip T. Szczypiński, Sukeerti T, Matthijs Tadema, Joao Miguel Correia Teixeira, Paarth Thadani, Matthew W. Thompson, Hao Tian, Matteo Tiberti, Zaheer Timol, Wiep van der Toorn, Mieczyslaw Torchala, Aditi Tripathi, Heet Vekariya, Mark Verma, Josh Vermaas, Isaac Virshup, Lily Wang, Leon Wehrhan, Nestor Wendt, Lawson Woods, Zhiyi Wu, Tengyu Xie, Zhuyi Xue, Mingyi Xue, Alexander Yang, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, Raymond Zhao, Yuxuan Zhuang, and Oliver Beckstein.</p>
  </div>

  

<div class="footer"><p>Please see
    our <a href="https://www.mdanalysis.org/pages/privacy/">Privacy Policy</a>
    to learn how <a href="https://www.mdanalysis.org">MDAnalysis</a> collects data.</p>
    <script data-goatcounter="https://mdanalysis.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</div>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
    var versions_json_url = 'https://docs.mdanalysis.org/versions.json'
</script>

<div class="rst-versions" data-toggle="rst-versions" role="note"
     aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
        2.8.0-dev0
      <span class="fa fa-caret-down"></span>
    </span>

    <div class="rst-other-versions">
        <dl id="versionselector">
            <dt>Other Versions</dt>
        </dl>

    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>