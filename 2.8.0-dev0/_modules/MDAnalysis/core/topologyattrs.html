


  
    
  




<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="shortcut icon" href="../../../_static/logo/mda_favicon.ico">
</head>

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MDAnalysis.core.topologyattrs &mdash; MDAnalysis 2.8.0-dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/site.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=a9b57af3"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/js/versions.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 2.8.0-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >




  




<a href="../../../index.html">
  
    <img src="../../../_static/logo/mda_logo.png" class="logo" alt="Logo"/>
</a>


  
  
  
    <div class="version">
      2.8.0-dev0
    </div>
  



<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>
<div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
    <!-- <p class="caption" role="heading"></p> -->
    <ul>
        
        <li class="toctree-l1"><a class="reference internal" href="http://mdanalysis.org">MDAnalysis</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="http://userguide.mdanalysis.org">User guide</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="https://mdakits.mdanalysis.org/">MDAKits</a></li>
        
    </ul>
    
        <p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/converters.html">7. Converter modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/trajectory_transformations.html">8. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections_modules.html">9. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/auxiliary_modules.html">10. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/core_modules.html">11. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/visualization_modules.html">12. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/lib_modules.html">13. Library functions — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/version.html">14. Version information for MDAnalysis - <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/units.html">15. Constants and unit conversion — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/exceptions.html">16. Custom exceptions and warnings — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/references.html">17. References</a></li>
</ul>

</div>

      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MDAnalysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">MDAnalysis.core.topologyattrs</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MDAnalysis.core.topologyattrs</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1"># doi: 10.25080/majora-629e541a-00e</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Topology attribute objects --- :mod:`MDAnalysis.core.topologyattrs`</span>
<span class="sd">===================================================================</span>

<span class="sd">Common :class:`TopologyAttr` instances that are used by most topology</span>
<span class="sd">parsers.</span>

<span class="sd">TopologyAttrs are used to contain attributes such as atom names or resids.</span>
<span class="sd">These are usually read by the TopologyParser.</span>

<span class="sd">References</span>
<span class="sd">----------</span>

<span class="sd">.. footbibliography::</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span> <span class="k">as</span> <span class="n">inspect_signature</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">MethodType</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">Bio.Seq</span>
    <span class="kn">import</span> <span class="nn">Bio.SeqRecord</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">HAS_BIOPYTHON</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">HAS_BIOPYTHON</span> <span class="o">=</span> <span class="kc">True</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">..lib.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">cached</span><span class="p">,</span> <span class="n">convert_aa_code</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">warn_if_not_unique</span><span class="p">,</span>
                        <span class="n">unique_int_1d</span><span class="p">,</span> <span class="n">check_atomgroup_not_empty</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">transformations</span><span class="p">,</span> <span class="n">mdamath</span>
<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="kn">import</span> <span class="n">NoDataError</span><span class="p">,</span> <span class="n">SelectionError</span>
<span class="kn">from</span> <span class="nn">.topologyobjects</span> <span class="kn">import</span> <span class="n">TopologyGroup</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">selection</span>
<span class="kn">from</span> <span class="nn">.groups</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ComponentBase</span><span class="p">,</span> <span class="n">GroupBase</span><span class="p">,</span>
                     <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">,</span>
                     <span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span>
                     <span class="n">check_wrap_and_unwrap</span><span class="p">,</span> <span class="n">_pbc_to_wrap</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">_TOPOLOGY_ATTRS</span><span class="p">,</span> <span class="n">_TOPOLOGY_TRANSPLANTS</span><span class="p">,</span> <span class="n">_TOPOLOGY_ATTRNAMES</span>


<span class="k">def</span> <span class="nf">_check_length</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper which checks the length of inputs to set_X</span>

<span class="sd">    Eg:</span>

<span class="sd">    @_check_length</span>
<span class="sd">    def set_X(self, group, values):</span>

<span class="sd">    Will check the length of *values* compared to *group* before proceeding with</span>
<span class="sd">    anything in the *set_X* method.</span>

<span class="sd">    Pseudo code for the check:</span>

<span class="sd">    if group in (Atom, Residue, Segment):</span>
<span class="sd">        values must be single values, ie int, float or string</span>
<span class="sd">    else:</span>
<span class="sd">        values must be single value OR same length as group</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_SINGLE_VALUE_ERROR</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Setting </span><span class="si">{cls}</span><span class="s2"> </span><span class="si">{attrname}</span><span class="s2"> with wrong sized input. &quot;</span>
                           <span class="s2">&quot;Must use single value, length of supplied values: </span><span class="si">{lenvalues}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="c1"># Eg &quot;Setting Residue resid with wrong sized input. Must use single value, length of supplied</span>
    <span class="c1"># values: 2.&quot;</span>

    <span class="n">_GROUP_VALUE_ERROR</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Setting </span><span class="si">{group}</span><span class="s2"> </span><span class="si">{attrname}</span><span class="s2"> with wrong sized array. &quot;</span>
                          <span class="s2">&quot;Length </span><span class="si">{group}</span><span class="s2">: </span><span class="si">{lengroup}</span><span class="s2">, length of supplied values: </span><span class="si">{lenvalues}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="c1"># Eg &quot;Setting AtomGroup masses with wrong sized array. Length AtomGroup: 100, length of</span>
    <span class="c1"># supplied values: 50.&quot;</span>

    <span class="k">def</span> <span class="nf">_attr_len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="c1"># quasi len measurement</span>
        <span class="c1"># strings, floats, ints are len 0, ie not iterable</span>
        <span class="c1"># other iterables are just len&#39;d</span>
        <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>  <span class="c1"># special case</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">val_len</span> <span class="o">=</span> <span class="n">_attr_len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">ComponentBase</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">val_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_SINGLE_VALUE_ERROR</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">cls</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attrname</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">singular</span><span class="p">,</span>
                    <span class="n">lenvalues</span><span class="o">=</span><span class="n">val_len</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">val_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">val_len</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_GROUP_VALUE_ERROR</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attrname</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">attrname</span><span class="p">,</span>
                    <span class="n">lengroup</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="n">lenvalues</span><span class="o">=</span><span class="n">val_len</span><span class="p">))</span>
        <span class="c1"># if everything went OK, continue with the function</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_wronglevel_error</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate an error for setting attr at wrong level</span>

<span class="sd">    attr : TopologyAttr that was accessed</span>
<span class="sd">    group : Offending Component/Group</span>

<span class="sd">    Eg:</span>
<span class="sd">    setting mass of residue, gets called with attr=Masses, group=residue</span>

<span class="sd">    raises a NotImplementedError with:</span>
<span class="sd">    &#39;Cannot set masses from Residue.  Use &#39;Residue.atoms.masses&#39;</span>

<span class="sd">    Mainly used to ensure consistent and helpful error messages</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
        <span class="n">group_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Residue</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">)):</span>
        <span class="n">group_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)):</span>
        <span class="n">group_level</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="c1"># What level to go to before trying to set this attr</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">AtomAttr</span><span class="p">):</span>
        <span class="n">corr_classes</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;atoms&#39;</span><span class="p">,</span> <span class="s1">&#39;atom&#39;</span><span class="p">)</span>
        <span class="n">attr_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">ResidueAttr</span><span class="p">):</span>
        <span class="n">corr_classes</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;residues&#39;</span><span class="p">,</span> <span class="s1">&#39;residue&#39;</span><span class="p">)</span>
        <span class="n">attr_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">SegmentAttr</span><span class="p">):</span>
        <span class="n">corr_classes</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;segments&#39;</span><span class="p">,</span> <span class="s1">&#39;segment&#39;</span><span class="p">)</span>
        <span class="n">attr_level</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">ComponentBase</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">attr_level</span> <span class="o">&gt;</span> <span class="n">group_level</span><span class="p">):</span>
        <span class="c1"># ie going downards use plurals, going upwards use singulars</span>
        <span class="c1"># Residue.atom!s!.mass!es! but Atom.segment!!.segid!!</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="n">corr_classes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">attrname</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">singular</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="n">corr_classes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">attrname</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">attrname</span>

    <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot set </span><span class="si">{attr}</span><span class="s2"> from </span><span class="si">{cls}</span><span class="s2">. Use &#39;</span><span class="si">{cls}</span><span class="s2">.</span><span class="si">{correct}</span><span class="s2">.</span><span class="si">{attr}</span><span class="s2"> = &#39;&quot;</span>
    <span class="c1"># eg &quot;Cannot set masses from Residue.  &#39;Use Residue.atoms.masses = &#39;&quot;</span>

    <span class="k">return</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">attr</span><span class="o">=</span><span class="n">attrname</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">correct</span><span class="o">=</span><span class="n">correct</span><span class="p">,</span>
    <span class="p">))</span>


<span class="k">def</span> <span class="nf">_build_stub</span><span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a stub for a transplanted method.</span>

<span class="sd">    A transplanted stub is a dummy method that gets attached to a core class</span>
<span class="sd">    (usually from :mod:`MDAnalysis.core.groups`) and raises a</span>
<span class="sd">    :exc:`NoDataError`.</span>
<span class="sd">    The stub mimics the original method for everything that has traits with the</span>
<span class="sd">    documentation (docstring, name, signature). It gets overwritten by the</span>
<span class="sd">    actual method when the latter is transplanted at universe creation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    method_name: str</span>
<span class="sd">        The name of the attribute in the destination class.</span>
<span class="sd">    method: Callable</span>
<span class="sd">        The method to be mimicked.</span>
<span class="sd">    attribute_name: str</span>
<span class="sd">        The name topology attribute that is required for the method to be</span>
<span class="sd">        relevant (e.g. masses, charges, ...)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The stub.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">stub_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">{class_name}</span><span class="s1">.</span><span class="si">{method_name}</span><span class="s1">() &#39;</span>
            <span class="s1">&#39;not available; this requires </span><span class="si">{attribute_name}</span><span class="s1">&#39;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">class_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">method_name</span><span class="o">=</span><span class="n">method_name</span><span class="p">,</span>
            <span class="n">attribute_name</span><span class="o">=</span><span class="n">attribute_name</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="n">annotation</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">        .. note::</span>

<span class="s2">          This requires the underlying topology to have </span><span class="si">{}</span><span class="s2">. Otherwise, a</span>
<span class="s2">          :exc:`~MDAnalysis.exceptions.NoDataError` is raised.</span>


<span class="s2">    &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attribute_name</span><span class="p">))</span>
    <span class="c1"># The first line of the original docstring is not indented, but the</span>
    <span class="c1"># subsequent lines are. We want to dedent the whole docstring.</span>
    <span class="n">first_line</span><span class="p">,</span> <span class="n">other_lines</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">stub_method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">first_line</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="o">+</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="n">other_lines</span><span class="p">)</span>
        <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">annotation</span>
    <span class="p">)</span>
    <span class="n">stub_method</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">method_name</span>
    <span class="n">stub_method</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">inspect_signature</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stub_method</span>


<span class="k">def</span> <span class="nf">_attach_transplant_stubs</span><span class="p">(</span><span class="n">attribute_name</span><span class="p">,</span> <span class="n">topology_attribute_class</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transplant a stub for every method that will be transplanted from a</span>
<span class="sd">    topology attribute.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    attribute_name: str</span>
<span class="sd">        User-facing name of the topology attribute (e.g. masses, charges, ...)</span>
<span class="sd">    topology_attribute_class:</span>
<span class="sd">        Topology attribute class to inspect for transplant methods.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">topology_attribute_class</span><span class="o">.</span><span class="n">transplants</span>
    <span class="k">for</span> <span class="n">dest_class</span><span class="p">,</span> <span class="n">methods</span> <span class="ow">in</span> <span class="n">transplants</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">dest_class</span> <span class="o">==</span> <span class="s1">&#39;Universe&#39;</span><span class="p">:</span>
            <span class="c1"># Cannot be imported at the top level, it creates issues with</span>
            <span class="c1"># circular imports.</span>
            <span class="kn">from</span> <span class="nn">.universe</span> <span class="kn">import</span> <span class="n">Universe</span>
            <span class="n">dest_class</span> <span class="o">=</span> <span class="n">Universe</span>
        <span class="k">for</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">method_callback</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>
            <span class="c1"># Methods the name of which is prefixed by _ should not be accessed</span>
            <span class="c1"># directly by a user, we do not transplant a stub as the stubs are</span>
            <span class="c1"># only relevant for user-facing method and properties. Also,</span>
            <span class="c1"># methods _-prefixed can be operator methods, and we do not want</span>
            <span class="c1"># to overwrite these with a stub.</span>
            <span class="k">if</span> <span class="n">method_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">is_property</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">method_callback</span> <span class="o">=</span> <span class="n">method_callback</span><span class="o">.</span><span class="n">fget</span>
                <span class="n">is_property</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">stub</span> <span class="o">=</span> <span class="n">_build_stub</span><span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="n">method_callback</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_property</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">dest_class</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">stub</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">dest_class</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">stub</span><span class="p">)</span>


<span class="c1"># TODO: remove bfactors in 3.0</span>
<span class="n">BFACTOR_WARNING</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The bfactor topology attribute is only &quot;</span>
                   <span class="s2">&quot;provided as an alias to the tempfactor &quot;</span>
                   <span class="s2">&quot;attribute. It will be removed in &quot;</span>
                   <span class="s2">&quot;3.0. Please use the tempfactor attribute &quot;</span>
                   <span class="s2">&quot;instead.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">deprecate_bfactor_warning</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bfactor alias with warning</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">BFACTOR_WARNING</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">class</span> <span class="nc">_TopologyAttrMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Register TopologyAttrs on class creation</span>

<span class="sd">    Each topology attribute is added to the top-level dictionaries</span>
<span class="sd">    for various record purposes. The class itself is added to</span>
<span class="sd">    :data:`_TOPOLOGY_ATTRS` and :data:`_TOPOLOGY_ATTRNAMES`. Transplanted</span>
<span class="sd">    methods are also added to :data:`_TOPOLOGY_TRANSPLANTS.`</span>

<span class="sd">    We also attempt to make the topology attribute selectable with</span>
<span class="sd">    atom selection language by automatically generating a relevant</span>
<span class="sd">    selection class with the singular name (``singular``) as the</span>
<span class="sd">    selection token. Only certain ``dtype``\ s are supported; if a</span>
<span class="sd">    selection class cannot be generated, a warning will be raised</span>
<span class="sd">    but no error.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`MDAnalysis.core.selection.gen_selection_class`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">classdict</span><span class="p">):</span>
        <span class="nb">type</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">classdict</span><span class="p">)</span>
        <span class="n">attrname</span> <span class="o">=</span> <span class="n">classdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;attrname&#39;</span><span class="p">)</span>
        <span class="n">singular</span> <span class="o">=</span> <span class="n">classdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;singular&#39;</span><span class="p">,</span> <span class="n">attrname</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">attrname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attrname</span> <span class="o">=</span> <span class="n">singular</span>

        <span class="k">if</span> <span class="n">singular</span><span class="p">:</span>
            <span class="n">_TOPOLOGY_ATTRS</span><span class="p">[</span><span class="n">singular</span><span class="p">]</span> <span class="o">=</span> <span class="n">_TOPOLOGY_ATTRS</span><span class="p">[</span><span class="n">attrname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>
            <span class="n">_singular</span> <span class="o">=</span> <span class="n">singular</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">_attrname</span> <span class="o">=</span> <span class="n">attrname</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">_TOPOLOGY_ATTRNAMES</span><span class="p">[</span><span class="n">_singular</span><span class="p">]</span> <span class="o">=</span> <span class="n">singular</span>
            <span class="n">_TOPOLOGY_ATTRNAMES</span><span class="p">[</span><span class="n">_attrname</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrname</span>

            <span class="k">for</span> <span class="n">clstype</span><span class="p">,</span> <span class="n">transplants</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">transplants</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">transplants</span><span class="p">:</span>
                    <span class="n">_TOPOLOGY_TRANSPLANTS</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">attrname</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">clstype</span><span class="p">]</span>
                    <span class="n">clean</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="n">_TOPOLOGY_ATTRNAMES</span><span class="p">[</span><span class="n">clean</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;singular&#39;</span><span class="p">,</span> <span class="s1">&#39;attrname&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">attrname</span> <span class="o">=</span> <span class="n">classdict</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_attach_transplant_stubs</span><span class="p">(</span><span class="n">attrname</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
            <span class="c1"># add each to &quot;same attr as&quot; class</span>

        <span class="k">if</span> <span class="n">singular</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">selection</span><span class="o">.</span><span class="n">SameSelection</span><span class="o">.</span><span class="n">prop_trans</span><span class="p">:</span>
            <span class="n">selection</span><span class="o">.</span><span class="n">SameSelection</span><span class="o">.</span><span class="n">prop_trans</span><span class="p">[</span><span class="n">singular</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrname</span>

        <span class="c1"># add each to the property selection class</span>
        <span class="k">if</span> <span class="n">singular</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">selection</span><span class="o">.</span><span class="n">PropertySelection</span><span class="o">.</span><span class="n">props</span><span class="p">:</span>
            <span class="n">selection</span><span class="o">.</span><span class="n">PropertySelection</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="n">singular</span><span class="p">]</span> <span class="o">=</span> <span class="n">attrname</span>

        <span class="c1"># add token to selectiondict</span>
        <span class="k">if</span> <span class="n">singular</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">selection</span><span class="o">.</span><span class="n">_SELECTIONDICT</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">classdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">per_obj</span> <span class="o">=</span> <span class="n">classdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;per_object&quot;</span><span class="p">,</span> <span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">per_object</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">selection</span><span class="o">.</span><span class="n">gen_selection_class</span><span class="p">(</span><span class="n">singular</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span>
                                                  <span class="n">dtype</span><span class="p">,</span> <span class="n">per_obj</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;A selection keyword could not be &quot;</span>
                           <span class="s2">&quot;automatically generated for the &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">singular</span><span class="si">}</span><span class="s2"> attribute. If you need a &quot;</span>
                           <span class="s2">&quot;selection keyword, define it manually &quot;</span>
                           <span class="s2">&quot;by subclassing core.selection.Selection&quot;</span><span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># TODO: remove in 3.0</span>
        <span class="k">if</span> <span class="n">attrname</span> <span class="o">==</span> <span class="s2">&quot;tempfactors&quot;</span><span class="p">:</span>
            <span class="n">_TOPOLOGY_ATTRS</span><span class="p">[</span><span class="s2">&quot;bfactor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_TOPOLOGY_ATTRS</span><span class="p">[</span><span class="s2">&quot;bfactors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>
            <span class="n">selcls</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="n">gen_selection_class</span><span class="p">(</span><span class="s2">&quot;bfactor&quot;</span><span class="p">,</span> <span class="s2">&quot;bfactors&quot;</span><span class="p">,</span>
                                                   <span class="n">classdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">),</span>
                                                   <span class="n">per_object</span><span class="o">=</span><span class="s2">&quot;atom&quot;</span><span class="p">)</span>
            <span class="n">selcls</span><span class="o">.</span><span class="n">apply</span> <span class="o">=</span> <span class="n">deprecate_bfactor_warning</span><span class="p">(</span><span class="n">selcls</span><span class="o">.</span><span class="n">apply</span><span class="p">)</span>


<div class="viewcode-block" id="TopologyAttr">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr">[docs]</a>
<span class="k">class</span> <span class="nc">TopologyAttr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_TopologyAttrMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for Topology attributes.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This class is intended to be subclassed, and mostly amounts to</span>
<span class="sd">    a skeleton. The methods here should be present in all</span>
<span class="sd">    :class:`TopologyAttr` child classes, but by default they raise</span>
<span class="sd">    appropriate exceptions.</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    attrname : str</span>
<span class="sd">        the name used for the attribute when attached to a ``Topology`` object</span>
<span class="sd">    singular : str</span>
<span class="sd">        name for the attribute on a singular object (Atom/Residue/Segment)</span>
<span class="sd">    per_object : str</span>
<span class="sd">        If there is a strict mapping between Component and Attribute</span>
<span class="sd">    dtype : int/float/object</span>
<span class="sd">        Type to coerce this attribute to be.  For string use &#39;object&#39;</span>
<span class="sd">    top : Topology</span>
<span class="sd">        handle for the Topology object TopologyAttr is associated with</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;topologyattrs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;topologyattr&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># ie Resids per_object = &#39;residue&#39;</span>
    <span class="n">top</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># pointer to Topology object</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">groupdoc</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">singledoc</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">guessed</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">n_residues</span><span class="p">,</span> <span class="n">n_segments</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Populate an initial empty data structure for this Attribute</span>

<span class="sd">        The only provided parameters are the &quot;shape&quot; of the Universe</span>

<span class="sd">        Eg for charges, provide np.zeros(n_atoms)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;No default values&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyAttr.from_blank">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.from_blank">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_blank</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_residues</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a blank version of this TopologyAttribute</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_atoms : int, optional</span>
<span class="sd">          Size of the TopologyAttribute atoms</span>
<span class="sd">        n_residues: int, optional</span>
<span class="sd">          Size of the TopologyAttribute residues</span>
<span class="sd">        n_segments : int, optional</span>
<span class="sd">          Size of the TopologyAttribute segments</span>
<span class="sd">        values : optional</span>
<span class="sd">          Initial values for the TopologyAttribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_gen_initial_values</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">n_residues</span><span class="p">,</span> <span class="n">n_segments</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">cls</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if supplied starting values and statically typed</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>


<div class="viewcode-block" id="TopologyAttr.copy">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a deepcopy of this attribute&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">guessed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Length of the TopologyAttr at its intrinsic level.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Accepts an AtomGroup, ResidueGroup or SegmentGroup&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Residue</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_residues</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segments</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_atoms</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Residue</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_residues</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_guessed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bool of if the source of this information is a guess&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span>

    <span class="k">def</span> <span class="nf">_add_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newval</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resize TopologyAttr to one larger, with *newval* as the new value</span>

<span class="sd">        .. versionadded:: 2.1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">newval</span><span class="p">])])</span>

<div class="viewcode-block" id="TopologyAttr.get_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.get_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get atom attributes for a given AtomGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">NoDataError</span></div>


<div class="viewcode-block" id="TopologyAttr.set_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.set_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set atom attributes for a given AtomGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="TopologyAttr.get_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.get_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get residue attributes for a given ResidueGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">NoDataError</span></div>


<div class="viewcode-block" id="TopologyAttr.set_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.set_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set residue attributes for a given ResidueGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="TopologyAttr.get_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.get_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get segment attributes for a given SegmentGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">NoDataError</span></div>


<div class="viewcode-block" id="TopologyAttr.set_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.set_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set segmentattributes for a given SegmentGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>
</div>



<span class="c1"># core attributes</span>


<div class="viewcode-block" id="Atomindices">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomindices">[docs]</a>
<span class="k">class</span> <span class="nc">Atomindices</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Globally unique indices for each atom in the group.</span>

<span class="sd">    If the group is an AtomGroup, then this gives the index for each atom in</span>
<span class="sd">    the group. This is the unambiguous identifier for each atom in the</span>
<span class="sd">    topology, and it is not alterable.</span>

<span class="sd">    If the group is a ResidueGroup or SegmentGroup, then this gives the indices</span>
<span class="sd">    of each atom represented in the group in a 1-D array, in the order of the</span>
<span class="sd">    elements in that group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;indices&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;index&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Atomindices.set_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomindices.set_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Atom indices are fixed; they cannot be reset&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Atomindices.get_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomindices.get_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ag</span><span class="o">.</span><span class="n">ix</span></div>


<div class="viewcode-block" id="Atomindices.get_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomindices.get_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_2d</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">))</span></div>


<div class="viewcode-block" id="Atomindices.get_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomindices.get_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="Resindices">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resindices">[docs]</a>
<span class="k">class</span> <span class="nc">Resindices</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Globally unique resindices for each residue in the group.</span>

<span class="sd">    If the group is an AtomGroup, then this gives the resindex for each atom in</span>
<span class="sd">    the group. This unambiguously determines each atom&#39;s residue membership.</span>
<span class="sd">    Resetting these values changes the residue membership of the atoms.</span>

<span class="sd">    If the group is a ResidueGroup or SegmentGroup, then this gives the</span>
<span class="sd">    resindices of each residue represented in the group in a 1-D array, in the</span>
<span class="sd">    order of the elements in that group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;resindices&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;resindex&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Resindices.get_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resindices.get_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">atoms2residues</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span></div>


<div class="viewcode-block" id="Resindices.get_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resindices.get_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">rg</span><span class="o">.</span><span class="n">ix</span></div>


<div class="viewcode-block" id="Resindices.set_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resindices.set_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Residue indices are fixed; they cannot be reset&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Resindices.get_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resindices.get_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2residues_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="Segindices">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segindices">[docs]</a>
<span class="k">class</span> <span class="nc">Segindices</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Globally unique segindices for each segment in the group.</span>

<span class="sd">    If the group is an AtomGroup, then this gives the segindex for each atom in</span>
<span class="sd">    the group. This unambiguously determines each atom&#39;s segment membership.</span>
<span class="sd">    It is not possible to set these, since membership in a segment is an</span>
<span class="sd">    attribute of each atom&#39;s residue.</span>

<span class="sd">    If the group is a ResidueGroup or SegmentGroup, then this gives the</span>
<span class="sd">    segindices of each segment represented in the group in a 1-D array, in the</span>
<span class="sd">    order of the elements in that group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;segindices&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;segindex&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span>
                      <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Segindices.get_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segindices.get_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">atoms2segments</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span></div>


<div class="viewcode-block" id="Segindices.get_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segindices.get_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2segments</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span></div>


<div class="viewcode-block" id="Segindices.get_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segindices.get_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sg</span><span class="o">.</span><span class="n">ix</span></div>


<div class="viewcode-block" id="Segindices.set_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segindices.set_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Segment indices are fixed; they cannot be reset&quot;</span><span class="p">)</span></div>
</div>



<span class="c1"># atom attributes</span>


<div class="viewcode-block" id="AtomAttr">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr">[docs]</a>
<span class="k">class</span> <span class="nc">AtomAttr</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for atom attributes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;atomattrs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;atomattr&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">]</span>

<div class="viewcode-block" id="AtomAttr.get_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.get_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span></div>


<div class="viewcode-block" id="AtomAttr.set_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.set_atoms">[docs]</a>
    <span class="nd">@_check_length</span>
    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span></div>


<div class="viewcode-block" id="AtomAttr.get_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.get_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;By default, the values for each atom present in the set of residues</span>
<span class="sd">        are returned in a single array. This behavior can be overriden in child</span>
<span class="sd">        attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aixs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_2d</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">aix</span><span class="p">]</span> <span class="k">for</span> <span class="n">aix</span> <span class="ow">in</span> <span class="n">aixs</span><span class="p">]</span></div>


<div class="viewcode-block" id="AtomAttr.set_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.set_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">)</span></div>


<div class="viewcode-block" id="AtomAttr.get_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.get_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;By default, the values for each atom present in the set of residues</span>
<span class="sd">        are returned in a single array. This behavior can be overriden in child</span>
<span class="sd">        attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aixs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">aix</span><span class="p">]</span> <span class="k">for</span> <span class="n">aix</span> <span class="ow">in</span> <span class="n">aixs</span><span class="p">]</span></div>


<div class="viewcode-block" id="AtomAttr.set_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.set_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">)</span></div>
</div>



<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Atomids">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomids">[docs]</a>
<span class="k">class</span> <span class="nc">Atomids</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ID for each atom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;ids&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;id&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">na</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>



<span class="k">class</span> <span class="nc">_StringInternerMixin</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;String interning pattern</span>

<span class="sd">    Used for faster matching of strings (see _ProtoStringSelection)</span>

<span class="sd">     self.namedict (dict)</span>
<span class="sd">     - maps actual string to string index (str-&gt;int)</span>
<span class="sd">     self.namelookup (array dtype object)</span>
<span class="sd">     - maps string index to actual string (int-&gt;str)</span>
<span class="sd">     self.nmidx (array dtype int)</span>
<span class="sd">     - maps atom index to string index (int-&gt;int)</span>
<span class="sd">     self.values (array dtype object)</span>
<span class="sd">     - the premade per-object string values</span>

<span class="sd">    .. versionadded:: 2.1.0</span>
<span class="sd">       Mashed together the different implementations to keep it DRY.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">guessed</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">namedict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># maps str to nmidx</span>
        <span class="n">name_lookup</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># maps idx to str</span>
        <span class="c1"># eg namedict[&#39;O&#39;] = 5 &amp; name_lookup[5] = &#39;O&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nmidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># the lookup for each atom</span>
        <span class="c1"># eg Atom 5 is &#39;C&#39;, so nmidx[5] = 7, where name_lookup[7] = &#39;C&#39;</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nmidx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namedict</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">nextidx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namedict</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">namedict</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextidx</span>
                <span class="n">name_lookup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">nmidx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextidx</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name_lookup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">name_lookup</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_lookup</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nmidx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_add_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newval</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Append new value to the TopologyAttr</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newval : str</span>
<span class="sd">          value to append</span>

<span class="sd">        resizes this attr to size+1 and adds newval as the value of the new entry</span>
<span class="sd">        for string interning this is slightly different hence the override</span>

<span class="sd">        .. versionadded:: 2.1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">newidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namedict</span><span class="p">[</span><span class="n">newval</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">newidx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namedict</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">namedict</span><span class="p">[</span><span class="n">newval</span><span class="p">]</span> <span class="o">=</span> <span class="n">newidx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_lookup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">name_lookup</span><span class="p">,</span> <span class="p">[</span><span class="n">newval</span><span class="p">]])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nmidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nmidx</span><span class="p">,</span> <span class="p">[</span><span class="n">newidx</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="p">[</span><span class="n">newval</span><span class="p">]])</span>

    <span class="k">def</span> <span class="nf">_set_X</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">newnames</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># two possibilities, either single value given, or one per Atom</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">newidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namedict</span><span class="p">[</span><span class="n">values</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">newidx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namedict</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">namedict</span><span class="p">[</span><span class="n">values</span><span class="p">]</span> <span class="o">=</span> <span class="n">newidx</span>
                <span class="n">newnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">newidx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namedict</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">nextidx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namedict</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">namedict</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextidx</span>
                    <span class="n">newnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="n">newidx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextidx</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nmidx</span><span class="p">[</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">newidx</span>  <span class="c1"># newidx either single value or same size array</span>
        <span class="k">if</span> <span class="n">newnames</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_lookup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">name_lookup</span><span class="p">,</span> <span class="n">newnames</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_lookup</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nmidx</span><span class="p">]</span>


<span class="c1"># woe betide anyone who switches this inheritance order</span>
<span class="c1"># Mixin needs to be first (L to R) to get correct __init__ and set_atoms</span>
<div class="viewcode-block" id="AtomStringAttr">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomStringAttr">[docs]</a>
<span class="k">class</span> <span class="nc">AtomStringAttr</span><span class="p">(</span><span class="n">_StringInternerMixin</span><span class="p">,</span> <span class="n">AtomAttr</span><span class="p">):</span>

<div class="viewcode-block" id="AtomStringAttr.set_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomStringAttr.set_atoms">[docs]</a>
    <span class="nd">@_check_length</span>
    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_X</span><span class="p">(</span><span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>



<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Atomnames">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames">[docs]</a>
<span class="k">class</span> <span class="nc">Atomnames</span><span class="p">(</span><span class="n">AtomStringAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name for each atom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;names&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;name&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<div class="viewcode-block" id="Atomnames.phi_selection">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.phi_selection">[docs]</a>
    <span class="k">def</span> <span class="nf">phi_selection</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">c_name</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">n_name</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="n">ca_name</span><span class="o">=</span><span class="s1">&#39;CA&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select AtomGroup corresponding to the phi protein backbone dihedral</span>
<span class="sd">        C&#39;-N-CA-C.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c_name: str (optional)</span>
<span class="sd">            name for the backbone C atom</span>
<span class="sd">        n_name: str (optional)</span>
<span class="sd">            name for the backbone N atom</span>
<span class="sd">        ca_name: str (optional)</span>
<span class="sd">            name for the alpha-carbon atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomGroup</span>
<span class="sd">            4-atom selection in the correct order. If no C&#39; found in the</span>
<span class="sd">            previous residue (by resid) then this method returns ``None``.</span>

<span class="sd">        .. versionchanged:: 1.0.0</span>
<span class="sd">            Added arguments for flexible atom names and refactored code for</span>
<span class="sd">            faster atom matching with boolean arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># fnmatch is expensive. try the obv candidate first</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">ix</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sid</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">segid</span>
        <span class="n">rid</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">resid</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">segid</span> <span class="o">==</span> <span class="n">sid</span> <span class="ow">and</span> <span class="n">prev</span><span class="o">.</span><span class="n">resid</span> <span class="o">==</span> <span class="n">rid</span><span class="p">):</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="s1">&#39;segid </span><span class="si">{}</span><span class="s1"> and resid </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">rid</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="n">c_</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">prev</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">c_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">atnames</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span>
        <span class="n">ncac_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_name</span><span class="p">,</span> <span class="n">ca_name</span><span class="p">,</span> <span class="n">c_name</span><span class="p">]</span>
        <span class="n">ncac</span> <span class="o">=</span> <span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atnames</span> <span class="o">==</span> <span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ncac_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="n">ncac</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">sel</span> <span class="o">=</span> <span class="n">c_</span><span class="o">+</span><span class="nb">sum</span><span class="p">(</span><span class="n">ncac</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sel</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;phi_selection&#39;</span><span class="p">,</span> <span class="n">phi_selection</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.phi_selections">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.phi_selections">[docs]</a>
    <span class="k">def</span> <span class="nf">phi_selections</span><span class="p">(</span><span class="n">residues</span><span class="p">,</span> <span class="n">c_name</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">n_name</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="n">ca_name</span><span class="o">=</span><span class="s1">&#39;CA&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select list of AtomGroups corresponding to the phi protein</span>
<span class="sd">        backbone dihedral C&#39;-N-CA-C.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c_name: str (optional)</span>
<span class="sd">            name for the backbone C atom</span>
<span class="sd">        n_name: str (optional)</span>
<span class="sd">            name for the backbone N atom</span>
<span class="sd">        ca_name: str (optional)</span>
<span class="sd">            name for the alpha-carbon atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of AtomGroups</span>
<span class="sd">            4-atom selections in the correct order. If no C&#39; found in the</span>
<span class="sd">            previous residue (by resid) then corresponding item in the list</span>
<span class="sd">            is ``None``.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">universe</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">residues</span><span class="o">.</span><span class="n">ix</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># obv candidates first</span>
        <span class="n">rsid</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">segids</span>
        <span class="n">prid</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">resids</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">ncac_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_name</span><span class="p">,</span> <span class="n">ca_name</span><span class="p">,</span> <span class="n">c_name</span><span class="p">]</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="s1">&#39;segid </span><span class="si">{}</span><span class="s1"> and resid </span><span class="si">{}</span><span class="s1">&#39;</span>

        <span class="c1"># replace wrong residues</span>
        <span class="n">wix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">prev</span><span class="o">.</span><span class="n">segids</span> <span class="o">!=</span> <span class="n">rsid</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">resids</span> <span class="o">!=</span> <span class="n">prid</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wix</span><span class="p">):</span>
            <span class="n">prevls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rsid</span><span class="p">[</span><span class="n">wix</span><span class="p">],</span> <span class="n">prid</span><span class="p">[</span><span class="n">wix</span><span class="p">],</span> <span class="n">wix</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">prevls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="n">invalid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">prevls</span><span class="p">)</span>

        <span class="n">keep_prev</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">c_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">prev</span><span class="p">]</span>
        <span class="n">keep_res</span> <span class="o">=</span> <span class="p">[</span><span class="nb">all</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ncac_names</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">]</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">keep_prev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">keep_res</span><span class="p">)</span>
        <span class="n">keep</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">residues</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="o">~</span><span class="n">keep</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">keepix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keep</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">c_</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">prev</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">c_name</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">n_name</span><span class="p">]</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">ca_name</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">c_name</span><span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="n">keepix</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">c_</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ca</span><span class="p">,</span> <span class="n">c</span><span class="p">)]</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;phi_selections&#39;</span><span class="p">,</span> <span class="n">phi_selections</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.psi_selection">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.psi_selection">[docs]</a>
    <span class="k">def</span> <span class="nf">psi_selection</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">c_name</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">n_name</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="n">ca_name</span><span class="o">=</span><span class="s1">&#39;CA&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select AtomGroup corresponding to the psi protein backbone dihedral</span>
<span class="sd">        N-CA-C-N&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c_name: str (optional)</span>
<span class="sd">            name for the backbone C atom</span>
<span class="sd">        n_name: str (optional)</span>
<span class="sd">            name for the backbone N atom</span>
<span class="sd">        ca_name: str (optional)</span>
<span class="sd">            name for the alpha-carbon atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomGroup</span>
<span class="sd">            4-atom selection in the correct order. If no N&#39; found in the</span>
<span class="sd">            following residue (by resid) then this method returns ``None``.</span>

<span class="sd">        .. versionchanged:: 1.0.0</span>
<span class="sd">            Added arguments for flexible atom names and refactored code for</span>
<span class="sd">            faster atom matching with boolean arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># fnmatch is expensive. try the obv candidate first</span>
        <span class="n">_manual_sel</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">sid</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">segid</span>
        <span class="n">rid</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">resid</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nxt</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">ix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">_manual_sel</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nxt</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">segid</span> <span class="o">==</span> <span class="n">sid</span> <span class="ow">and</span> <span class="n">nxt</span><span class="o">.</span><span class="n">resid</span> <span class="o">==</span> <span class="n">rid</span><span class="p">):</span>
                <span class="n">_manual_sel</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">_manual_sel</span><span class="p">:</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="s1">&#39;segid </span><span class="si">{}</span><span class="s1"> and resid </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">rid</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nxt</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="n">n_</span> <span class="o">=</span> <span class="n">nxt</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">nxt</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">n_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">atnames</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span>
        <span class="n">ncac_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_name</span><span class="p">,</span> <span class="n">ca_name</span><span class="p">,</span> <span class="n">c_name</span><span class="p">]</span>
        <span class="n">ncac</span> <span class="o">=</span> <span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atnames</span> <span class="o">==</span> <span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ncac_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="n">ncac</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">sel</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ncac</span><span class="p">)</span> <span class="o">+</span> <span class="n">n_</span>
        <span class="k">return</span> <span class="n">sel</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;psi_selection&#39;</span><span class="p">,</span> <span class="n">psi_selection</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_next_residues_by_resid</span><span class="p">(</span><span class="n">residues</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select list of Residues corresponding to the next resid for each</span>
<span class="sd">        residue in `residues`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List of Residues</span>
<span class="sd">            List of the next residues in the Universe, by resid and segid.</span>
<span class="sd">            If not found, the corresponding item in the list is ``None``.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">universe</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">residues</span>
        <span class="n">nxres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">))</span>
        <span class="c1"># no guarantee residues is ordered or unique</span>
        <span class="n">last</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">residues</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">last</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">notlast</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">ix</span> <span class="o">!=</span> <span class="n">last</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="n">notlast</span><span class="p">]</span>
            <span class="n">residues</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="n">notlast</span><span class="p">]</span>

        <span class="n">nxres</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">nxt</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">residues</span><span class="o">.</span><span class="n">ix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rsid</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">segids</span>
        <span class="n">nrid</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">resids</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="s1">&#39;segid </span><span class="si">{}</span><span class="s1"> and resid </span><span class="si">{}</span><span class="s1">&#39;</span>

        <span class="c1"># replace wrong residues</span>
        <span class="n">wix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">nxt</span><span class="o">.</span><span class="n">segids</span> <span class="o">!=</span> <span class="n">rsid</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">nxt</span><span class="o">.</span><span class="n">resids</span> <span class="o">!=</span> <span class="n">nrid</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wix</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rsid</span><span class="p">[</span><span class="n">wix</span><span class="p">],</span> <span class="n">nrid</span><span class="p">[</span><span class="n">wix</span><span class="p">],</span> <span class="n">wix</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">nxres</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="n">nxres</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">nxres</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;_get_next_residues_by_resid&#39;</span><span class="p">,</span>
                                      <span class="n">_get_next_residues_by_resid</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_prev_residues_by_resid</span><span class="p">(</span><span class="n">residues</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select list of Residues corresponding to the previous resid for each</span>
<span class="sd">        residue in `residues`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List of Residues</span>
<span class="sd">            List of the previous residues in the Universe, by resid and segid.</span>
<span class="sd">            If not found, the corresponding item in the list is ``None``.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">universe</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">residues</span>
        <span class="n">pvres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">))</span>
        <span class="n">pvres</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">residues</span><span class="o">.</span><span class="n">ix</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rsid</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">segids</span>
        <span class="n">prid</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">resids</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="s1">&#39;segid </span><span class="si">{}</span><span class="s1"> and resid </span><span class="si">{}</span><span class="s1">&#39;</span>

        <span class="c1"># replace wrong residues</span>
        <span class="n">wix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">prev</span><span class="o">.</span><span class="n">segids</span> <span class="o">!=</span> <span class="n">rsid</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">resids</span> <span class="o">!=</span> <span class="n">prid</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wix</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rsid</span><span class="p">[</span><span class="n">wix</span><span class="p">],</span> <span class="n">prid</span><span class="p">[</span><span class="n">wix</span><span class="p">],</span> <span class="n">wix</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">pvres</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="n">pvres</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">pvres</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;_get_prev_residues_by_resid&#39;</span><span class="p">,</span>
                                      <span class="n">_get_prev_residues_by_resid</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.psi_selections">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.psi_selections">[docs]</a>
    <span class="k">def</span> <span class="nf">psi_selections</span><span class="p">(</span><span class="n">residues</span><span class="p">,</span> <span class="n">c_name</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">n_name</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="n">ca_name</span><span class="o">=</span><span class="s1">&#39;CA&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select list of AtomGroups corresponding to the psi protein</span>
<span class="sd">        backbone dihedral N-CA-C-N&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c_name: str (optional)</span>
<span class="sd">            name for the backbone C atom</span>
<span class="sd">        n_name: str (optional)</span>
<span class="sd">            name for the backbone N atom</span>
<span class="sd">        ca_name: str (optional)</span>
<span class="sd">            name for the alpha-carbon atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List of AtomGroups</span>
<span class="sd">            4-atom selections in the correct order. If no N&#39; found in the</span>
<span class="sd">            following residue (by resid) then the corresponding item in the</span>
<span class="sd">            list is ``None``.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">nxtres</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">_get_next_residues_by_resid</span><span class="p">()</span>
        <span class="n">rix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nxtres</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nxt</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nxtres</span><span class="p">[</span><span class="n">rix</span><span class="p">])</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="n">rix</span><span class="p">]</span>
        <span class="n">ncac_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_name</span><span class="p">,</span> <span class="n">ca_name</span><span class="p">,</span> <span class="n">c_name</span><span class="p">]</span>

        <span class="n">keep_nxt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">n_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">nxt</span><span class="p">]</span>
        <span class="n">keep_res</span> <span class="o">=</span> <span class="p">[</span><span class="nb">all</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ncac_names</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">]</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">keep_nxt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">keep_res</span><span class="p">)</span>
        <span class="n">nxt</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">keepix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keep</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">n_name</span><span class="p">]</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">ca_name</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">c_name</span><span class="p">]</span>
        <span class="n">n_</span> <span class="o">=</span> <span class="n">nxt</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">nxt</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">n_name</span><span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="n">rix</span><span class="p">[</span><span class="n">keepix</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ca</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_</span><span class="p">)]</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;psi_selections&#39;</span><span class="p">,</span> <span class="n">psi_selections</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.omega_selection">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.omega_selection">[docs]</a>
    <span class="k">def</span> <span class="nf">omega_selection</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">c_name</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">n_name</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="n">ca_name</span><span class="o">=</span><span class="s1">&#39;CA&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select AtomGroup corresponding to the omega protein backbone dihedral</span>
<span class="sd">        CA-C-N&#39;-CA&#39;.</span>

<span class="sd">        omega describes the -C-N- peptide bond. Typically, it is trans (180</span>
<span class="sd">        degrees) although cis-bonds (0 degrees) are also occasionally observed</span>
<span class="sd">        (especially near Proline).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c_name: str (optional)</span>
<span class="sd">            name for the backbone C atom</span>
<span class="sd">        n_name: str (optional)</span>
<span class="sd">            name for the backbone N atom</span>
<span class="sd">        ca_name: str (optional)</span>
<span class="sd">            name for the alpha-carbon atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomGroup</span>
<span class="sd">            4-atom selection in the correct order. If no C&#39; found in the</span>
<span class="sd">            previous residue (by resid) then this method returns ``None``.</span>

<span class="sd">        .. versionchanged:: 1.0.0</span>
<span class="sd">            Added arguments for flexible atom names and refactored code for</span>
<span class="sd">            faster atom matching with boolean arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># fnmatch is expensive. try the obv candidate first</span>
        <span class="n">_manual_sel</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">sid</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">segid</span>
        <span class="n">rid</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">resid</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nxt</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">ix</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">_manual_sel</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nxt</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">segid</span> <span class="o">==</span> <span class="n">sid</span> <span class="ow">and</span> <span class="n">nxt</span><span class="o">.</span><span class="n">resid</span> <span class="o">==</span> <span class="n">rid</span><span class="p">):</span>
                <span class="n">_manual_sel</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">_manual_sel</span><span class="p">:</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="s1">&#39;segid </span><span class="si">{}</span><span class="s1"> and resid </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">rid</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nxt</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="n">ca</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">ca_name</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">c_name</span><span class="p">]</span>
        <span class="n">n_</span> <span class="o">=</span> <span class="n">nxt</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">nxt</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">n_name</span><span class="p">]</span>
        <span class="n">ca_</span> <span class="o">=</span> <span class="n">nxt</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">nxt</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">ca_name</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ca_</span><span class="p">,</span> <span class="n">n_</span><span class="p">,</span> <span class="n">ca</span><span class="p">,</span> <span class="n">c</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">ca</span><span class="o">+</span><span class="n">c</span><span class="o">+</span><span class="n">n_</span><span class="o">+</span><span class="n">ca_</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;omega_selection&#39;</span><span class="p">,</span> <span class="n">omega_selection</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.omega_selections">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.omega_selections">[docs]</a>
    <span class="k">def</span> <span class="nf">omega_selections</span><span class="p">(</span><span class="n">residues</span><span class="p">,</span> <span class="n">c_name</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">n_name</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="n">ca_name</span><span class="o">=</span><span class="s1">&#39;CA&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select list of AtomGroups corresponding to the omega protein</span>
<span class="sd">        backbone dihedral CA-C-N&#39;-CA&#39;.</span>

<span class="sd">        omega describes the -C-N- peptide bond. Typically, it is trans (180</span>
<span class="sd">        degrees) although cis-bonds (0 degrees) are also occasionally observed</span>
<span class="sd">        (especially near Proline).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c_name: str (optional)</span>
<span class="sd">            name for the backbone C atom</span>
<span class="sd">        n_name: str (optional)</span>
<span class="sd">            name for the backbone N atom</span>
<span class="sd">        ca_name: str (optional)</span>
<span class="sd">            name for the alpha-carbon atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List of AtomGroups</span>
<span class="sd">            4-atom selections in the correct order. If no C&#39; found in the</span>
<span class="sd">            previous residue (by resid) then the corresponding item in the</span>
<span class="sd">            list is ``None``.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">nxtres</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">_get_next_residues_by_resid</span><span class="p">()</span>
        <span class="n">rix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nxtres</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nxt</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nxtres</span><span class="p">[</span><span class="n">rix</span><span class="p">])</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="n">rix</span><span class="p">]</span>

        <span class="n">nxtatoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">ca_name</span><span class="p">,</span> <span class="n">n_name</span><span class="p">]</span>
        <span class="n">resatoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">ca_name</span><span class="p">,</span> <span class="n">c_name</span><span class="p">]</span>
        <span class="n">keep_nxt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">all</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nxtatoms</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">nxt</span><span class="p">]</span>
        <span class="n">keep_res</span> <span class="o">=</span> <span class="p">[</span><span class="nb">all</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">resatoms</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">]</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">keep_nxt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">keep_res</span><span class="p">)</span>
        <span class="n">nxt</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">keepix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keep</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">c_name</span><span class="p">]</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">ca_name</span><span class="p">]</span>
        <span class="n">n_</span> <span class="o">=</span> <span class="n">nxt</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">nxt</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">n_name</span><span class="p">]</span>
        <span class="n">ca_</span> <span class="o">=</span> <span class="n">nxt</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">nxt</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">ca_name</span><span class="p">]</span>

        <span class="n">results</span><span class="p">[</span><span class="n">rix</span><span class="p">[</span><span class="n">keepix</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n_</span><span class="p">,</span> <span class="n">ca_</span><span class="p">)]</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;omega_selections&#39;</span><span class="p">,</span> <span class="n">omega_selections</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.chi1_selection">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.chi1_selection">[docs]</a>
    <span class="k">def</span> <span class="nf">chi1_selection</span><span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">n_name</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="n">ca_name</span><span class="o">=</span><span class="s1">&#39;CA&#39;</span><span class="p">,</span> <span class="n">cb_name</span><span class="o">=</span><span class="s1">&#39;CB&#39;</span><span class="p">,</span>
                       <span class="n">cg_name</span><span class="o">=</span><span class="s1">&#39;CG CG1 OG OG1 SG&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Select AtomGroup corresponding to the chi1 sidechain dihedral ``N-CA-CB-*G.``</span>
<span class="sd">        The gamma atom is taken to be the heavy atom in the gamma position. If more than one</span>
<span class="sd">        heavy atom is present (e.g. CG1 and CG2), the one with the lower number is used (CG1).</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This numbering of chi1 atoms here in following with the IUPAC 1970 rules.</span>
<span class="sd">            However, it should be noted that analyses which use dihedral angles may have</span>
<span class="sd">            different definitions. For example, the</span>
<span class="sd">            :class:`MDAnalysis.analysis.dihedrals.Janin` class does not incorporate</span>
<span class="sd">            amino acids where the gamma atom is not carbon, into its chi1 selections.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c_name: str (optional)</span>
<span class="sd">            name for the backbone C atom</span>
<span class="sd">        ca_name: str (optional)</span>
<span class="sd">            name for the alpha-carbon atom</span>
<span class="sd">        cb_name: str (optional)</span>
<span class="sd">            name for the beta-carbon atom</span>
<span class="sd">        cg_name: str (optional)</span>
<span class="sd">            name for the gamma-carbon atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomGroup</span>
<span class="sd">            4-atom selection in the correct order. If no CB and/or CG is found</span>
<span class="sd">            then this method returns ``None``.</span>


<span class="sd">        .. versionadded:: 0.7.5</span>
<span class="sd">        .. versionchanged:: 1.0.0</span>
<span class="sd">           Added arguments for flexible atom names and refactored code for</span>
<span class="sd">           faster atom matching with boolean arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_name</span><span class="p">,</span> <span class="n">ca_name</span><span class="p">,</span> <span class="n">cb_name</span><span class="p">,</span> <span class="n">cg_name</span><span class="p">]</span>
        <span class="n">atnames</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span>
        <span class="n">ags</span> <span class="o">=</span> <span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">atnames</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">split</span><span class="p">())]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="n">ags</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ags</span><span class="p">)</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;chi1_selection&#39;</span><span class="p">,</span> <span class="n">chi1_selection</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.chi1_selections">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.chi1_selections">[docs]</a>
    <span class="k">def</span> <span class="nf">chi1_selections</span><span class="p">(</span><span class="n">residues</span><span class="p">,</span> <span class="n">n_name</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="n">ca_name</span><span class="o">=</span><span class="s1">&#39;CA&#39;</span><span class="p">,</span> <span class="n">cb_name</span><span class="o">=</span><span class="s1">&#39;CB&#39;</span><span class="p">,</span>
                        <span class="n">cg_name</span><span class="o">=</span><span class="s1">&#39;CG CG1 OG OG1 SG&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select list of AtomGroups corresponding to the chi1 sidechain dihedral</span>
<span class="sd">        N-CA-CB-CG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c_name: str (optional)</span>
<span class="sd">            name for the backbone C atom</span>
<span class="sd">        ca_name: str (optional)</span>
<span class="sd">            name for the alpha-carbon atom</span>
<span class="sd">        cb_name: str (optional)</span>
<span class="sd">            name for the beta-carbon atom</span>
<span class="sd">        cg_name: str (optional)</span>
<span class="sd">            name for the gamma-carbon atom</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List of AtomGroups</span>
<span class="sd">            4-atom selections in the correct order. If no CB and/or CG is found</span>
<span class="sd">            then the corresponding item in the list is ``None``.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">))</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_name</span><span class="p">,</span> <span class="n">ca_name</span><span class="p">,</span> <span class="n">cb_name</span><span class="p">,</span> <span class="n">cg_name</span><span class="p">]</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="p">[</span><span class="nb">all</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">]</span>
        <span class="n">keepix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keep</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

        <span class="n">atnames</span> <span class="o">=</span> <span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">names</span>
        <span class="n">ags</span> <span class="o">=</span> <span class="p">[</span><span class="n">residues</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">atnames</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">split</span><span class="p">())]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="n">keepix</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">ags</span><span class="p">)]</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;chi1_selections&#39;</span><span class="p">,</span> <span class="n">chi1_selections</span><span class="p">))</span></div>



<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Atomtypes">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomtypes">[docs]</a>
<span class="k">class</span> <span class="nc">Atomtypes</span><span class="p">(</span><span class="n">AtomStringAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Type for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;types&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;type&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span></div>



<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Elements">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Elements">[docs]</a>
<span class="k">class</span> <span class="nc">Elements</span><span class="p">(</span><span class="n">AtomStringAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Element for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;elements&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;element&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>



<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Radii">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Radii">[docs]</a>
<span class="k">class</span> <span class="nc">Radii</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Radii for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;radii&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;radius&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>



<div class="viewcode-block" id="RecordTypes">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.RecordTypes">[docs]</a>
<span class="k">class</span> <span class="nc">RecordTypes</span><span class="p">(</span><span class="n">AtomStringAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For PDB-like formats, indicates if ATOM or HETATM</span>

<span class="sd">    Defaults to &#39;ATOM&#39;</span>

<span class="sd">    .. versionchanged:: 0.20.0</span>
<span class="sd">       Now stores array of dtype object rather than boolean mapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;record_types&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;record_type&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ATOM&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>



<div class="viewcode-block" id="ChainIDs">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ChainIDs">[docs]</a>
<span class="k">class</span> <span class="nc">ChainIDs</span><span class="p">(</span><span class="n">AtomStringAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ChainID per atom</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This is an attribute of the Atom, not Residue or Segment</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;chainIDs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;chainID&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span></div>



<div class="viewcode-block" id="Tempfactors">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Tempfactors">[docs]</a>
<span class="k">class</span> <span class="nc">Tempfactors</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tempfactor for atoms&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;tempfactors&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;tempfactor&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span>

    <span class="c1"># TODO: remove bfactors in 3.0</span>
<div class="viewcode-block" id="Tempfactors.bfactor">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Tempfactors.bfactor">[docs]</a>
    <span class="nd">@deprecate_bfactor_warning</span>
    <span class="k">def</span> <span class="nf">bfactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias for tempfactor</span>

<span class="sd">        The bfactor topology attribute is only</span>
<span class="sd">        provided as an alias to the tempfactor</span>
<span class="sd">        attribute. It will be removed in</span>
<span class="sd">        3.0. Please use the tempfactor attribute</span>
<span class="sd">        instead.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            Will be removed in 3.0.0. Use the</span>
<span class="sd">            ``tempfactor`` attribute instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">tempfactor</span></div>


<div class="viewcode-block" id="Tempfactors.bfactor_setter">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Tempfactors.bfactor_setter">[docs]</a>
    <span class="nd">@deprecate_bfactor_warning</span>
    <span class="k">def</span> <span class="nf">bfactor_setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tempfactor alias property for atom</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">tempfactor</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="Tempfactors.bfactors">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Tempfactors.bfactors">[docs]</a>
    <span class="nd">@deprecate_bfactor_warning</span>
    <span class="k">def</span> <span class="nf">bfactors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias for tempfactors</span>

<span class="sd">        The bfactor topology attribute is only</span>
<span class="sd">        provided as an alias to the tempfactor</span>
<span class="sd">        attribute. It will be removed in</span>
<span class="sd">        3.0. Please use the tempfactor attribute</span>
<span class="sd">        instead.</span>

<span class="sd">        .. versionadded:: 2.0.0</span>

<span class="sd">        .. deprecated:: 2.0.0</span>
<span class="sd">            Will be removed in 3.0.0. Use the</span>
<span class="sd">            ``tempfactor`` attribute instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">tempfactors</span></div>


<div class="viewcode-block" id="Tempfactors.bfactors_setter">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Tempfactors.bfactors_setter">[docs]</a>
    <span class="nd">@deprecate_bfactor_warning</span>
    <span class="k">def</span> <span class="nf">bfactors_setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tempfactor alias property for groups of atoms</span>

<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">tempfactors</span> <span class="o">=</span> <span class="n">value</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;bfactor&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">bfactor</span><span class="p">,</span> <span class="n">bfactor_setter</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">bfactor</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="p">(</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">):</span>
        <span class="n">transplants</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;bfactors&quot;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">bfactors</span><span class="p">,</span> <span class="n">bfactors_setter</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">bfactors</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span></div>



<div class="viewcode-block" id="Masses">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses">[docs]</a>
<span class="k">class</span> <span class="nc">Masses</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;masses&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;mass&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span>
                      <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="n">groupdoc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Mass of each component in the Group.</span>

<span class="s2">    If the Group is an AtomGroup, then the masses are for each atom. If the</span>
<span class="s2">    Group is a ResidueGroup or SegmentGroup, the masses are for each residue or</span>
<span class="s2">    segment, respectively. These are obtained by summation of the member atoms</span>
<span class="s2">    for each component.</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="n">singledoc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Mass of the component.&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span>

<div class="viewcode-block" id="Masses.get_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.get_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="n">resatoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_2d</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># for a single residue</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">resatoms</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for a residuegroup</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rg</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">resatoms</span><span class="p">):</span>
                <span class="n">masses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">masses</span></div>


<div class="viewcode-block" id="Masses.get_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.get_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="n">segatoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># for a single segment</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">segatoms</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for a segmentgroup</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">segatoms</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">masses</span></div>


<div class="viewcode-block" id="Masses.center_of_mass">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.center_of_mass">[docs]</a>
    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@_pbc_to_wrap</span>
    <span class="nd">@check_wrap_and_unwrap</span>
    <span class="nd">@check_atomgroup_not_empty</span>
    <span class="k">def</span> <span class="nf">center_of_mass</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Center of mass of (compounds of) the group</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol R = \frac{\sum_i m_i \boldsymbol r_i}{\sum m_i}</span>

<span class="sd">        where :math:`m_i` is the mass and :math:`\boldsymbol r_i` the</span>
<span class="sd">        position of atom :math:`i` in the given</span>
<span class="sd">        :class:`MDAnalysis.core.groups.AtomGroup`.</span>
<span class="sd">        Centers of mass per :class:`Residue`, :class:`Segment`, molecule, or</span>
<span class="sd">        fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly. If the masses of a compound sum up to zero, the</span>
<span class="sd">        center of mass coordinates of that compound will be ``nan`` (not a</span>
<span class="sd">        number).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True`` and `compound` is ``&#39;group&#39;``, move all atoms to the</span>
<span class="sd">            primary unit cell before calculation.</span>
<span class="sd">            If ``True`` and `compound` is not ``group``, the</span>
<span class="sd">            centers of mass of each compound will be calculated without moving</span>
<span class="sd">            any atoms to keep the compounds intact. Instead, the resulting</span>
<span class="sd">            center-of-mass position vectors will be moved to the primary unit</span>
<span class="sd">            cell after calculation.</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their</span>
<span class="sd">            centers.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;},\</span>
<span class="sd">                   optional</span>
<span class="sd">            If ``&#39;group&#39;``, the center of mass of all atoms in the group will</span>
<span class="sd">            be returned as a single position vector. Otherwise, the centers of</span>
<span class="sd">            mass of each :class:`Segment`, :class:`Residue`, molecule, or</span>
<span class="sd">            fragment will be returned as an array of position vectors, i.e. a 2d</span>
<span class="sd">            array.</span>
<span class="sd">            Note that, in any case, *only* the positions of :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">            *belonging to the group* will be taken into account.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        center : numpy.ndarray</span>
<span class="sd">            Position vector(s) of the center(s) of mass of the group.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            position vector.</span>
<span class="sd">            If `compound` was set to ``&#39;segments&#39;`` or ``&#39;residues&#39;``, the</span>
<span class="sd">            output will be a 2d coordinate array of shape ``(n, 3)`` where ``n``</span>
<span class="sd">            is the number of compounds.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method can only be accessed if the underlying topology has</span>
<span class="sd">        information about atomic masses.</span>


<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Added `pbc` parameter</span>
<span class="sd">        .. versionchanged:: 0.19.0</span>
<span class="sd">           Added `compound` parameter</span>
<span class="sd">        .. versionchanged:: 0.20.0</span>
<span class="sd">           Added ``&#39;molecules&#39;`` and ``&#39;fragments&#39;`` compounds;</span>
<span class="sd">           added `unwrap` parameter</span>
<span class="sd">        .. versionchanged:: 2.1.0</span>
<span class="sd">           Renamed `pbc` kwarg to `wrap`. `pbc` is still accepted but</span>
<span class="sd">           is deprecated and will be removed in version 3.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">return</span> <span class="n">atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">masses</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">,</span>
                            <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">)</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;center_of_mass&#39;</span><span class="p">,</span> <span class="n">center_of_mass</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.total_mass">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.total_mass">[docs]</a>
    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@check_atomgroup_not_empty</span>
    <span class="k">def</span> <span class="nf">total_mass</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Total mass of (compounds of) the group.</span>

<span class="sd">        Computes the total mass of :class:`Atoms&lt;Atom&gt;` in the group.</span>
<span class="sd">        Total masses per :class:`Residue`, :class:`Segment`, molecule, or</span>
<span class="sd">        fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;},\</span>
<span class="sd">                   optional</span>
<span class="sd">            If ``&#39;group&#39;``, the total mass of all atoms in the group will be</span>
<span class="sd">            returned as a single value. Otherwise, the total masses per</span>
<span class="sd">            :class:`Segment`, :class:`Residue`, molecule, or fragment will be</span>
<span class="sd">            returned as a 1d array.</span>
<span class="sd">            Note that, in any case, *only* the masses of :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">            *belonging to the group* will be taken into account.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or numpy.ndarray</span>
<span class="sd">            Total mass of (compounds of) the group.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            value. Otherwise, the output will be a 1d array of shape ``(n,)``</span>
<span class="sd">            where ``n`` is the number of compounds.</span>


<span class="sd">        .. versionchanged:: 0.20.0 Added `compound` parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="s2">&quot;masses&quot;</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;total_mass&#39;</span><span class="p">,</span> <span class="n">total_mass</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.moment_of_inertia">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.moment_of_inertia">[docs]</a>
    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@_pbc_to_wrap</span>
    <span class="nd">@check_wrap_and_unwrap</span>
    <span class="nd">@check_atomgroup_not_empty</span>
    <span class="k">def</span> <span class="nf">moment_of_inertia</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s2">&quot;group&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Moment of inertia tensor relative to center of mass.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True`` and `compound` is ``&#39;group&#39;``, move all atoms to the</span>
<span class="sd">            primary unit cell before calculation.</span>
<span class="sd">            If ``True`` and `compound` is not ``group``, the</span>
<span class="sd">            centers of mass of each compound will be calculated without moving</span>
<span class="sd">            any atoms to keep the compounds intact. Instead, the resulting</span>
<span class="sd">            center-of-mass position vectors will be moved to the primary unit</span>
<span class="sd">            cell after calculation.</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their</span>
<span class="sd">            centers and tensor of inertia.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;},\</span>
<span class="sd">                   optional</span>
<span class="sd">            `compound` determines the behavior of `wrap`.</span>
<span class="sd">            Note that, in any case, *only* the positions of :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">            *belonging to the group* will be taken into account.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moment_of_inertia : numpy.ndarray</span>
<span class="sd">            Moment of inertia tensor as a 3 x 3 numpy array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The moment of inertia tensor :math:`\mathsf{I}` is calculated for a group of</span>
<span class="sd">        :math:`N` atoms with coordinates :math:`\mathbf{r}_i,\ 1 \le i \le N`</span>
<span class="sd">        relative to its center of mass from the relative coordinates</span>

<span class="sd">        .. math::</span>
<span class="sd">           \mathbf{r}&#39;_i = \mathbf{r}_i - \frac{1}{\sum_{i=1}^{N} m_i} \sum_{i=1}^{N} m_i \mathbf{r}_i</span>

<span class="sd">        as</span>

<span class="sd">        .. math::</span>
<span class="sd">           \mathsf{I} = \sum_{i=1}^{N} m_i \Big[(\mathbf{r}&#39;_i\cdot\mathbf{r}&#39;_i) \sum_{\alpha=1}^{3}</span>
<span class="sd">                 \hat{\mathbf{e}}_\alpha \otimes \hat{\mathbf{e}}_\alpha - \mathbf{r}&#39;_i \otimes \mathbf{r}&#39;_i\Big]</span>

<span class="sd">        where :math:`\hat{\mathbf{e}}_\alpha` are Cartesian unit vectors, or in Cartesian coordinates</span>

<span class="sd">        .. math::</span>
<span class="sd">           I_{\alpha,\beta} = \sum_{k=1}^{N} m_k</span>
<span class="sd">                 \Big(\big(\sum_{\gamma=1}^3 (x&#39;^{(k)}_{\gamma})^2 \big)\delta_{\alpha,\beta}</span>
<span class="sd">                 - x&#39;^{(k)}_{\alpha} x&#39;^{(k)}_{\beta} \Big).</span>

<span class="sd">        where :math:`x&#39;^{(k)}_{\alpha}` are the Cartesian coordinates of the</span>
<span class="sd">        relative coordinates :math:`\mathbf{r}&#39;_k`.</span>


<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Added `pbc` keyword</span>
<span class="sd">        .. versionchanged:: 0.20.0</span>
<span class="sd">           Added `unwrap` parameter</span>
<span class="sd">        .. versionchanged:: 2.1.0</span>
<span class="sd">           Renamed `pbc` kwarg to `wrap`. `pbc` is still accepted but</span>
<span class="sd">           is deprecated and will be removed in version 3.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>

        <span class="n">com</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span>
            <span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compound</span> <span class="o">!=</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
            <span class="n">com</span> <span class="o">=</span> <span class="p">(</span><span class="n">com</span> <span class="o">*</span> <span class="n">group</span><span class="o">.</span><span class="n">masses</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                   <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">group</span><span class="o">.</span><span class="n">masses</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span>
        <span class="k">elif</span> <span class="n">unwrap</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">com</span>

        <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>
        <span class="c1"># Create the inertia tensor</span>
        <span class="c1"># m_i = mass of atom i</span>
        <span class="c1"># (x_i, y_i, z_i) = pos of atom i</span>
        <span class="c1"># Ixx = sum(m_i*(y_i^2+z_i^2));</span>
        <span class="c1"># Iyy = sum(m_i*(x_i^2+z_i^2));</span>
        <span class="c1"># Izz = sum(m_i*(x_i^2+y_i^2))</span>
        <span class="c1"># Ixy = Iyx = -1*sum(m_i*x_i*y_i)</span>
        <span class="c1"># Ixz = Izx = -1*sum(m_i*x_i*z_i)</span>
        <span class="c1"># Iyz = Izy = -1*sum(m_i*y_i*z_i)</span>
        <span class="n">tens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># xx</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># xy &amp; yx</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># xz &amp; zx</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># yy</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># yz + zy</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># zz</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">tens</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;moment_of_inertia&#39;</span><span class="p">,</span> <span class="n">moment_of_inertia</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.radius_of_gyration">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.radius_of_gyration">[docs]</a>
    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@_pbc_to_wrap</span>
    <span class="nd">@check_atomgroup_not_empty</span>
    <span class="k">def</span> <span class="nf">radius_of_gyration</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Radius of gyration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>


<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Added `pbc` keyword</span>
<span class="sd">        .. versionchanged:: 2.1.0</span>
<span class="sd">           Renamed `pbc` kwarg to `wrap`. `pbc` is still accepted but</span>
<span class="sd">           is deprecated and will be removed in version 3.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>

        <span class="n">com</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">com</span>

        <span class="n">rog_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i-&gt;&#39;</span><span class="p">,</span><span class="n">masses</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span>
                                     <span class="n">recenteredpos</span><span class="p">,</span><span class="n">recenteredpos</span><span class="p">))</span><span class="o">/</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">total_mass</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rog_sq</span><span class="p">)</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;radius_of_gyration&#39;</span><span class="p">,</span> <span class="n">radius_of_gyration</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.gyration_moments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.gyration_moments">[docs]</a>
    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@_pbc_to_wrap</span>
    <span class="nd">@check_atomgroup_not_empty</span>
    <span class="k">def</span> <span class="nf">gyration_moments</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Moments of the gyration tensor.</span>

<span class="sd">        The moments are defined as the eigenvalues of the gyration</span>
<span class="sd">        tensor.</span>

<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            \mathsf{T} = \frac{1}{N} \sum_{i=1}^{N} (\mathbf{r}_\mathrm{i} - </span>
<span class="sd">                \mathbf{r}_\mathrm{COM})(\mathbf{r}_\mathrm{i} - \mathbf{r}_\mathrm{COM})</span>

<span class="sd">        Where :math:`\mathbf{r}_\mathrm{COM}` is the center of mass.</span>

<span class="sd">        See [Dima2004a]_ for background information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their centers.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;}, optional</span>
<span class="sd">            Which type of component to keep together during unwrapping.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        principle_moments_of_gyration : numpy.ndarray</span>
<span class="sd">            Gyration vector(s) of (compounds of) the group in :math:`Å^2`.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            vector of length 3. Otherwise, the output will be a 2D array of shape</span>
<span class="sd">            ``(n,3)`` where ``n`` is the number of compounds.</span>


<span class="sd">        .. versionadded:: 2.5.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_gyration</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">,</span> <span class="n">masses</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">masses</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">masses</span><span class="p">)</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span> <span class="s2">&quot;ki,kj-&gt;ij&quot;</span><span class="p">,</span>
                                <span class="n">recenteredpos</span><span class="p">,</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,i-&gt;ij&quot;</span><span class="p">,</span> <span class="n">recenteredpos</span><span class="p">,</span> <span class="n">masses</span><span class="p">),</span>
                              <span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">tensor</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masses</span><span class="p">))</span>

        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>

        <span class="n">com</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span>
            <span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">compound</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
             <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
                 <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span><span class="p">)</span>
             <span class="k">elif</span> <span class="n">unwrap</span><span class="p">:</span>
                 <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">,</span> 
                                                   <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                                  <span class="p">)</span> <span class="o">-</span> <span class="n">com</span><span class="p">)</span>
             <span class="k">else</span><span class="p">:</span>
                 <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">com</span><span class="p">)</span>
             <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">_gyration</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">,</span> <span class="n">masses</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
             <span class="p">(</span><span class="n">atom_masks</span><span class="p">,</span> 
              <span class="n">compound_masks</span><span class="p">,</span> 
              <span class="n">n_compounds</span><span class="p">)</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">_split_by_compound_indices</span><span class="p">(</span><span class="n">compound</span><span class="p">)</span>

             <span class="k">if</span> <span class="n">unwrap</span><span class="p">:</span>
                 <span class="n">coords</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span>
                     <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">,</span> 
                     <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                     <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span>
                 <span class="p">)</span>
             <span class="k">else</span><span class="p">:</span>
                 <span class="n">coords</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span>

             <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_compounds</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">compound_mask</span><span class="p">,</span> <span class="n">atom_mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">compound_masks</span><span class="p">,</span> <span class="n">atom_masks</span><span class="p">):</span>
                 <span class="n">eig_vals</span><span class="p">[</span><span class="n">compound_mask</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">_gyration</span><span class="p">(</span>
                      <span class="n">coords</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">com</span><span class="p">[</span><span class="n">compound_mask</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                      <span class="n">masses</span><span class="p">[</span><span class="n">mask</span><span class="p">][:,</span> <span class="kc">None</span><span class="p">]</span>
                     <span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_mask</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">eig_vals</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;gyration_moments&#39;</span><span class="p">,</span> <span class="n">gyration_moments</span><span class="p">))</span>


<div class="viewcode-block" id="Masses.shape_parameter">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.shape_parameter">[docs]</a>
    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@_pbc_to_wrap</span>
    <span class="nd">@check_atomgroup_not_empty</span>
    <span class="k">def</span> <span class="nf">shape_parameter</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shape parameter.</span>

<span class="sd">        See [Dima2004a]_ for background information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their centers.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;}, optional</span>
<span class="sd">            Which type of component to keep together during unwrapping.</span>


<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Added `pbc` keyword</span>
<span class="sd">        .. versionchanged:: 2.1.0</span>
<span class="sd">           Renamed `pbc` kwarg to `wrap`. `pbc` is still accepted but</span>
<span class="sd">           is deprecated and will be removed in version 3.0.</span>
<span class="sd">           Superfluous kwargs were removed.</span>
<span class="sd">        .. versionchanged:: 2.5.0</span>
<span class="sd">           Added calculation for any `compound` type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">gyration_moments</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eig_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="mf">27.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">eig_vals</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                                   <span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="mf">27.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">eig_vals</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)</span>
                                   <span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">shape</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;shape_parameter&#39;</span><span class="p">,</span> <span class="n">shape_parameter</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.asphericity">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.asphericity">[docs]</a>
    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@_pbc_to_wrap</span>
    <span class="nd">@check_wrap_and_unwrap</span>
    <span class="nd">@check_atomgroup_not_empty</span>
    <span class="k">def</span> <span class="nf">asphericity</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Asphericity.</span>

<span class="sd">        See [Dima2004b]_ for background information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their centers.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;}, optional</span>
<span class="sd">            Which type of component to keep together during unwrapping.</span>


<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Added `pbc` keyword</span>
<span class="sd">        .. versionchanged:: 0.20.0</span>
<span class="sd">           Added *unwrap* and *compound* parameter</span>
<span class="sd">        .. versionchanged:: 2.1.0</span>
<span class="sd">           Renamed `pbc` kwarg to `wrap`. `pbc` is still accepted but</span>
<span class="sd">           is deprecated and will be removed in version 3.0.</span>
<span class="sd">        .. versionchanged:: 2.5.0</span>
<span class="sd">           Added calculation for any `compound` type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">gyration_moments</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eig_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">eig_vals</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">eig_vals</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">shape</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;asphericity&#39;</span><span class="p">,</span> <span class="n">asphericity</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.principal_axes">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.principal_axes">[docs]</a>
    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@_pbc_to_wrap</span>
    <span class="nd">@check_atomgroup_not_empty</span>
    <span class="k">def</span> <span class="nf">principal_axes</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the principal axes from the moment of inertia.</span>

<span class="sd">        e1,e2,e3 = AtomGroup.principal_axes()</span>

<span class="sd">        The eigenvectors are sorted by eigenvalue, i.e. the first one</span>
<span class="sd">        corresponds to the highest eigenvalue and is thus the first principal</span>
<span class="sd">        axes.</span>

<span class="sd">        The eigenvectors form a right-handed coordinate system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        axis_vectors : array</span>
<span class="sd">            3 x 3 array with ``v[0]`` as first, ``v[1]`` as second, and</span>
<span class="sd">            ``v[2]`` as third eigenvector.</span>


<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           Added `pbc` keyword</span>
<span class="sd">        .. versionchanged:: 1.0.0</span>
<span class="sd">           Always return principal axes in right-hand convention.</span>
<span class="sd">        .. versionchanged:: 2.1.0</span>
<span class="sd">           Renamed `pbc` kwarg to `wrap`. `pbc` is still accepted but</span>
<span class="sd">           is deprecated and will be removed in version 3.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">e_val</span><span class="p">,</span> <span class="n">e_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">moment_of_inertia</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">))</span>

        <span class="c1"># Sort</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">e_val</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Make transposed in more logical form. See Issue 33.</span>
        <span class="n">e_vec</span> <span class="o">=</span> <span class="n">e_vec</span><span class="p">[:,</span> <span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Make sure the right hand convention is followed</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">e_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">e_vec</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">e_vec</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">e_vec</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;principal_axes&#39;</span><span class="p">,</span> <span class="n">principal_axes</span><span class="p">))</span>

<div class="viewcode-block" id="Masses.align_principal_axis">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Masses.align_principal_axis">[docs]</a>
    <span class="k">def</span> <span class="nf">align_principal_axis</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Align principal axis with index `axis` with `vector`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0, 1, 2}</span>
<span class="sd">            Index of the principal axis (0, 1, or 2), as produced by</span>
<span class="sd">            :meth:`~principal_axes`.</span>
<span class="sd">        vector : array_like</span>
<span class="sd">            Vector to align principal axis with.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To align the long axis of a channel (the first principal axis, i.e.</span>
<span class="sd">        *axis* = 0) with the z-axis::</span>

<span class="sd">          u.atoms.align_principal_axis(0, [0,0,1])</span>
<span class="sd">          u.atoms.write(&quot;aligned.pdb&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">principal_axes</span><span class="p">()[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">mdamath</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">vector</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">transformations</span><span class="o">.</span><span class="n">rotaxis</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
        <span class="c1"># print &quot;principal[%d] = %r&quot; % (axis, p)</span>
        <span class="c1"># print &quot;axis = %r, angle = %f deg&quot; % (ax, angle)</span>
        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">rotateby</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;align_principal_axis&#39;</span><span class="p">,</span> <span class="n">align_principal_axis</span><span class="p">))</span></div>



<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Charges">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges">[docs]</a>
<span class="k">class</span> <span class="nc">Charges</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;charges&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;charge&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span>
                      <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span>

<div class="viewcode-block" id="Charges.get_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges.get_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="n">resatoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_2d</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">resatoms</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rg</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">resatoms</span><span class="p">):</span>
                <span class="n">charges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">charges</span></div>


<div class="viewcode-block" id="Charges.get_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges.get_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="n">segatoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># for a single segment</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">segatoms</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for a segmentgroup</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">segatoms</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">charges</span></div>


<div class="viewcode-block" id="Charges.center_of_charge">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges.center_of_charge">[docs]</a>
    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@_pbc_to_wrap</span>
    <span class="nd">@check_wrap_and_unwrap</span>
    <span class="nd">@check_atomgroup_not_empty</span>
    <span class="k">def</span> <span class="nf">center_of_charge</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Center of (absolute) charge of (compounds of) the group</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol R = \frac{\sum_i \vert q_i \vert \boldsymbol r_i}</span>
<span class="sd">                                 {\sum_i \vert q_i \vert}</span>

<span class="sd">        where :math:`q_i` is the charge and :math:`\boldsymbol r_i` the</span>
<span class="sd">        position of atom :math:`i` in the given</span>
<span class="sd">        :class:`MDAnalysis.core.groups.AtomGroup`.</span>
<span class="sd">        Centers of charge per :class:`Residue`, :class:`Segment`, molecule, or</span>
<span class="sd">        fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly. If the charges of a compound sum up to zero, the</span>
<span class="sd">        center of mass coordinates of that compound will be ``nan`` (not a</span>
<span class="sd">        number).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True`` and `compound` is ``&#39;group&#39;``, move all atoms to the</span>
<span class="sd">            primary unit cell before calculation.</span>
<span class="sd">            If ``True`` and `compound` is not ``group``, the</span>
<span class="sd">            centers of mass of each compound will be calculated without moving</span>
<span class="sd">            any atoms to keep the compounds intact. Instead, the resulting</span>
<span class="sd">            center-of-mass position vectors will be moved to the primary unit</span>
<span class="sd">            cell after calculation.</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their</span>
<span class="sd">            centers.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, \</span>
<span class="sd">                    &#39;fragments&#39;}, optional</span>
<span class="sd">            If ``&#39;group&#39;``, the center of mass of all atoms in the group will</span>
<span class="sd">            be returned as a single position vector. Otherwise, the centers of</span>
<span class="sd">            mass of each :class:`Segment`, :class:`Residue`, molecule, or</span>
<span class="sd">            fragment will be returned as an array of position vectors, i.e.</span>
<span class="sd">            a 2d array.</span>
<span class="sd">            Note that, in any case, *only* the positions of</span>
<span class="sd">            :class:`Atoms&lt;Atom&gt;` *belonging to the group* will be taken into</span>
<span class="sd">            account.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        center : numpy.ndarray</span>
<span class="sd">            Position vector(s) of the center(s) of charge of the group.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            position vector.</span>
<span class="sd">            If `compound` was set to ``&#39;segments&#39;`` or ``&#39;residues&#39;``, the</span>
<span class="sd">            output will be a 2d coordinate array of shape ``(n, 3)`` where</span>
<span class="sd">            ``n`` is the number of compounds.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method can only be accessed if the underlying topology has</span>
<span class="sd">        information about atomic charges.</span>

<span class="sd">        .. versionadded:: 2.2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">return</span> <span class="n">atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">charges</span><span class="o">.</span><span class="fm">__abs__</span><span class="p">(),</span>
                            <span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">,</span>
                            <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">,</span>
                            <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">)</span></div>



    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;center_of_charge&#39;</span><span class="p">,</span> <span class="n">center_of_charge</span><span class="p">))</span>

<div class="viewcode-block" id="Charges.total_charge">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges.total_charge">[docs]</a>
    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@check_atomgroup_not_empty</span>
    <span class="k">def</span> <span class="nf">total_charge</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Total charge of (compounds of) the group.</span>

<span class="sd">        Computes the total charge of :class:`Atoms&lt;Atom&gt;` in the group.</span>
<span class="sd">        Total charges per :class:`Residue`, :class:`Segment`, molecule, or</span>
<span class="sd">        fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;},\</span>
<span class="sd">                   optional</span>
<span class="sd">            If &#39;group&#39;, the total charge of all atoms in the group will</span>
<span class="sd">            be returned as a single value. Otherwise, the total charges per</span>
<span class="sd">            :class:`Segment`, :class:`Residue`, molecule, or fragment</span>
<span class="sd">            will be returned as a 1d array.</span>
<span class="sd">            Note that, in any case, *only* the charges of :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">            *belonging to the group* will be taken into account.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or numpy.ndarray</span>
<span class="sd">            Total charge of (compounds of) the group.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            value. Otherwise, the output will be a 1d array of shape ``(n,)``</span>
<span class="sd">            where ``n`` is the number of compounds.</span>


<span class="sd">        .. versionchanged:: 0.20.0 Added `compound` parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="s2">&quot;charges&quot;</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;total_charge&#39;</span><span class="p">,</span> <span class="n">total_charge</span><span class="p">))</span>

<div class="viewcode-block" id="Charges.dipole_vector">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges.dipole_vector">[docs]</a>
    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@_pbc_to_wrap</span>
    <span class="nd">@check_wrap_and_unwrap</span>
    <span class="k">def</span> <span class="nf">dipole_vector</span><span class="p">(</span><span class="n">group</span><span class="p">,</span>
                      <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">unwrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">,</span>
                      <span class="n">center</span><span class="o">=</span><span class="s2">&quot;mass&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Dipole vector of the group.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol{\mu} = \sum_{i=1}^{N} q_{i} ( \mathbf{r}_{i} - </span>
<span class="sd">            \mathbf{r}_{COM} )</span>

<span class="sd">        Computes the dipole vector of :class:`Atoms&lt;Atom&gt;` in the group.</span>
<span class="sd">        Dipole vector per :class:`Residue`, :class:`Segment`, molecule, or</span>
<span class="sd">        fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly.</span>

<span class="sd">        Note that the magnitude of the dipole moment is independent of the</span>
<span class="sd">        ``center`` chosen unless the species has a net charge. In the case of</span>
<span class="sd">        a charged group the dipole moment can be later adjusted  with:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol{\mu}_{COC} = \boldsymbol{\mu}_{COM} + </span>
<span class="sd">            q_{ag}\mathbf{r}_{COM} - q_{ag}\boldsymbol{r}_{COC}</span>

<span class="sd">        Where :math:`\mathbf{r}_{COM}` is the center of mass and </span>
<span class="sd">        :math:`\mathbf{r}_{COC}` is the center of charge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True`` and `compound` is ``&#39;group&#39;``, move all atoms to the</span>
<span class="sd">            primary unit cell before calculation.</span>
<span class="sd">            If ``True`` and `compound` is not ``group``, the</span>
<span class="sd">            centers of mass of each compound will be calculated without moving</span>
<span class="sd">            any atoms to keep the compounds intact.</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their</span>
<span class="sd">            centers.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, \</span>
<span class="sd">                    &#39;fragments&#39;}, optional</span>
<span class="sd">            If ``&#39;group&#39;``, a single dipole vector returns. Otherwise, an</span>
<span class="sd">            array of each :class:`Segment`, :class:`Residue`, molecule, or</span>
<span class="sd">            fragment will be returned as an array of position vectors, i.e.</span>
<span class="sd">            a 2d array.</span>
<span class="sd">            Note that, in any case, *only* the positions of</span>
<span class="sd">            :class:`Atoms&lt;Atom&gt;` *belonging to the group* will be taken into</span>
<span class="sd">            account.</span>
<span class="sd">        center : {&#39;mass&#39;, &#39;charge&#39;}, optional</span>
<span class="sd">            Choose whether the dipole vector is calculated at the center of </span>
<span class="sd">            &quot;mass&quot; or the center of &quot;charge&quot;, default is &quot;mass&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Dipole vector(s) of (compounds of) the group in :math:`eÅ`.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            value. Otherwise, the output will be a 1d array of shape ``(n,3)``</span>
<span class="sd">            where ``n`` is the number of compounds.</span>


<span class="sd">        .. versionadded:: 2.4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">compound</span> <span class="o">=</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">charges</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">charges</span>

        <span class="k">if</span> <span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;mass&quot;</span><span class="p">:</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">,</span>
                                           <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">,</span>
                                           <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;charge&quot;</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_charge</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">,</span>
                                             <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">,</span>
                                             <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">,</span> <span class="s2">&quot;charge&quot;</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The dipole center, </span><span class="si">{</span><span class="n">center</span><span class="si">}</span><span class="s2">, is not supported. Choose&quot;</span>
                <span class="s2">&quot; one of: </span><span class="si">{choices}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">compound</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
                <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">ref</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">unwrap</span><span class="p">:</span>
                <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span>
                    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">,</span>
                    <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">-</span> <span class="n">ref</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">ref</span><span class="p">)</span>
            <span class="n">dipole_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;j&#39;</span><span class="p">,</span><span class="n">recenteredpos</span><span class="p">,</span> 
                                       <span class="n">charges</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">atom_masks</span><span class="p">,</span> <span class="n">compound_masks</span><span class="p">,</span>
             <span class="n">n_compounds</span><span class="p">)</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">_split_by_compound_indices</span><span class="p">(</span><span class="n">compound</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">unwrap</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">,</span>
                                          <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span>
            <span class="n">chgs</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">charges</span>

            <span class="n">dipole_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_compounds</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">compound_mask</span><span class="p">,</span> <span class="n">atom_mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">compound_masks</span><span class="p">,</span> <span class="n">atom_masks</span><span class="p">):</span>
                <span class="n">dipole_vector</span><span class="p">[</span><span class="n">compound_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ijk-&gt;ik&#39;</span><span class="p">,</span>
                                                          <span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">atom_mask</span><span class="p">]</span><span class="o">-</span>
                                                           <span class="n">ref</span><span class="p">[</span><span class="n">compound_mask</span><span class="p">][:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]),</span>
                                                          <span class="n">chgs</span><span class="p">[</span><span class="n">atom_mask</span><span class="p">][:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">dipole_vector</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;dipole_vector&#39;</span><span class="p">,</span> <span class="n">dipole_vector</span><span class="p">))</span>

<div class="viewcode-block" id="Charges.dipole_moment">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges.dipole_moment">[docs]</a>
    <span class="k">def</span> <span class="nf">dipole_moment</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Dipole moment of the group or compounds in a group.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mu = |\boldsymbol{\mu}| = \sqrt{ \sum_{i=1}^{D} \mu^2 }</span>

<span class="sd">        Where :math:`D` is the number of dimensions, in this case 3.</span>

<span class="sd">        Computes the dipole moment of :class:`Atoms&lt;Atom&gt;` in the group.</span>
<span class="sd">        Dipole per :class:`Residue`, :class:`Segment`, molecule, or</span>
<span class="sd">        fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly.</span>

<span class="sd">        Note that when there is a net charge, the magnitude of the dipole </span>
<span class="sd">        moment is dependent on the `center` chosen. </span>
<span class="sd">        See :meth:`~dipole_vector`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True`` and `compound` is ``&#39;group&#39;``, move all atoms to the</span>
<span class="sd">            primary unit cell before calculation.</span>
<span class="sd">            If ``True`` and `compound` is not ``group``, the</span>
<span class="sd">            centers of mass of each compound will be calculated without moving</span>
<span class="sd">            any atoms to keep the compounds intact.</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their</span>
<span class="sd">            centers.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, \</span>
<span class="sd">                    &#39;fragments&#39;}, optional</span>
<span class="sd">            If ``&#39;group&#39;``, a single dipole vector returns. Otherwise, an</span>
<span class="sd">            array of each :class:`Segment`, :class:`Residue`, molecule, or</span>
<span class="sd">            fragment will be returned as an array of position vectors, i.e.</span>
<span class="sd">            a 2d array.</span>
<span class="sd">            Note that, in any case, *only* the positions of</span>
<span class="sd">            :class:`Atoms&lt;Atom&gt;` *belonging to the group* will be taken into</span>
<span class="sd">            account.</span>
<span class="sd">        center : {&#39;mass&#39;, &#39;charge&#39;}, optional</span>
<span class="sd">            Choose whether the dipole vector is calculated at the center of </span>
<span class="sd">            &quot;mass&quot; or the center of &quot;charge&quot;, default is &quot;mass&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Dipole moment(s) of (compounds of) the group in :math:`eÅ`.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            value. Otherwise, the output will be a 1d array of shape ``(n,)``</span>
<span class="sd">            where ``n`` is the number of compounds.</span>


<span class="sd">        .. versionadded:: 2.4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>

        <span class="n">dipole_vector</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">dipole_vector</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dipole_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dipole_moment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span><span class="n">dipole_vector</span><span class="p">,</span><span class="n">dipole_vector</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dipole_moment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i-&gt;&#39;</span><span class="p">,</span><span class="n">dipole_vector</span><span class="p">,</span><span class="n">dipole_vector</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">dipole_moment</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;dipole_moment&#39;</span><span class="p">,</span> <span class="n">dipole_moment</span><span class="p">))</span>

<div class="viewcode-block" id="Charges.quadrupole_tensor">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges.quadrupole_tensor">[docs]</a>
    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@_pbc_to_wrap</span>
    <span class="nd">@check_wrap_and_unwrap</span>
    <span class="k">def</span> <span class="nf">quadrupole_tensor</span><span class="p">(</span><span class="n">group</span><span class="p">,</span>
                          <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">unwrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">,</span>
                          <span class="n">center</span><span class="o">=</span><span class="s2">&quot;mass&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Traceless quadrupole tensor of the group or compounds.</span>

<span class="sd">        This tensor is first computed as the outer product of vectors from</span>
<span class="sd">        a reference point to some atom, and multiplied by the atomic charge.</span>
<span class="sd">        The tensor of each atom is then summed to produce the quadrupole</span>
<span class="sd">        tensor of the group:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathsf{Q} = \sum_{i=1}^{N} q_{i} ( \mathbf{r}_{i} - </span>
<span class="sd">            \mathbf{r}_{COM} ) \otimes ( \mathbf{r}_{i} - \mathbf{r}_{COM} )</span>

<span class="sd">        The traceless quadrupole tensor, :math:`\hat{\mathsf{Q}}`, is then</span>
<span class="sd">        taken from:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \hat{\mathsf{Q}} = \frac{3}{2} \mathsf{Q} - \frac{1}{2} </span>
<span class="sd">            tr(\mathsf{Q})</span>

<span class="sd">        Computes the quadrupole tensor of :class:`Atoms&lt;Atom&gt;` in the group.</span>
<span class="sd">        Tensor per :class:`Residue`, :class:`Segment`, molecule, or</span>
<span class="sd">        fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly.</span>

<span class="sd">        Note that when there is an unsymmetrical plane in the molecule or </span>
<span class="sd">        group, the magnitude of the quadrupole tensor is dependent on the </span>
<span class="sd">        ``center`` (e.g., :math:`\mathbf{r}_{COM}`) chosen and cannot be translated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True`` and `compound` is ``&#39;group&#39;``, move all atoms to the</span>
<span class="sd">            primary unit cell before calculation.</span>
<span class="sd">            If ``True`` and `compound` is not ``group``, the</span>
<span class="sd">            centers of mass of each compound will be calculated without moving</span>
<span class="sd">            any atoms to keep the compounds intact.</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their</span>
<span class="sd">            centers.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, \</span>
<span class="sd">                    &#39;fragments&#39;}, optional</span>
<span class="sd">            If ``&#39;group&#39;``, a single quadrupole value returns. Otherwise, an</span>
<span class="sd">            array of each :class:`Segment`, :class:`Residue`, molecule, or</span>
<span class="sd">            fragment will be returned as an array of position vectors, i.e.</span>
<span class="sd">            a 1d array.</span>
<span class="sd">            Note that, in any case, *only* the positions of</span>
<span class="sd">            :class:`Atoms&lt;Atom&gt;` *belonging to the group* will be taken into</span>
<span class="sd">            account.</span>
<span class="sd">        center : {&#39;mass&#39;, &#39;charge&#39;}, optional</span>
<span class="sd">            Choose whether the dipole vector is calculated at the center of </span>
<span class="sd">            &quot;mass&quot; or the center of &quot;charge&quot;, default is &quot;mass&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Quadrupole tensor(s) of (compounds of) the group in :math:`eÅ^2`.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            tensor of shape ``(3,3)``. Otherwise, the output will be a 1d array </span>
<span class="sd">            of shape ``(n,3,3)`` where ``n`` is the number of compounds.</span>


<span class="sd">        .. versionadded:: 2.4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__quadrupole_tensor</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">,</span> <span class="n">charges</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Calculate the traceless quadrupole tensor</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">charges</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">charges</span><span class="p">)</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s2">&quot;ki,kj-&gt;ij&quot;</span><span class="p">,</span>
                <span class="n">recenteredpos</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,i-&gt;ij&quot;</span><span class="p">,</span> <span class="n">recenteredpos</span><span class="p">,</span> <span class="n">charges</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">tensor</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">compound</span> <span class="o">=</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">charges</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">charges</span>

        <span class="k">if</span> <span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;mass&quot;</span><span class="p">:</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">,</span>
                                           <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">,</span>
                                           <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;charge&quot;</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_charge</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">,</span>
                                             <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">,</span>
                                             <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">,</span> <span class="s2">&quot;charge&quot;</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The quadrupole center, </span><span class="si">{</span><span class="n">center</span><span class="si">}</span><span class="s2">, is not supported. Choose&quot;</span>
                <span class="s2">&quot; one of: </span><span class="si">{choices}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">compound</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
                <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">ref</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">unwrap</span><span class="p">:</span>
                <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span>
                    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">,</span>
                    <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">-</span> <span class="n">ref</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">ref</span><span class="p">)</span>
            <span class="n">quad_tensor</span> <span class="o">=</span> <span class="n">__quadrupole_tensor</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">,</span> <span class="n">charges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">atom_masks</span><span class="p">,</span> <span class="n">compound_masks</span><span class="p">,</span>
             <span class="n">n_compounds</span><span class="p">)</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">_split_by_compound_indices</span><span class="p">(</span><span class="n">compound</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">unwrap</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">,</span>
                                          <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span>
            <span class="n">chgs</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">charges</span>

            <span class="n">quad_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_compounds</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">compound_mask</span><span class="p">,</span> <span class="n">atom_mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">compound_masks</span><span class="p">,</span> <span class="n">atom_masks</span><span class="p">):</span>
                <span class="n">quad_tensor</span><span class="p">[</span><span class="n">compound_mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">__quadrupole_tensor</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">ref</span><span class="p">[</span><span class="n">compound_mask</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                                 <span class="n">chgs</span><span class="p">[</span><span class="n">mask</span><span class="p">][:,</span> <span class="kc">None</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_mask</span><span class="p">)</span>
                <span class="p">]</span>

        <span class="k">return</span> <span class="n">quad_tensor</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;quadrupole_tensor&#39;</span><span class="p">,</span> <span class="n">quadrupole_tensor</span><span class="p">))</span>

<div class="viewcode-block" id="Charges.quadrupole_moment">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Charges.quadrupole_moment">[docs]</a>
    <span class="k">def</span> <span class="nf">quadrupole_moment</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Quadrupole moment of the group according to :footcite:p:`Gray1984`.</span>
<span class="sd">         </span>
<span class="sd">        .. math::</span>
<span class="sd">            Q = \sqrt{\frac{2}{3}{\hat{\mathsf{Q}}}:{\hat{\mathsf{Q}}}}</span>

<span class="sd">        where the quadrupole moment is calculated from the tensor double </span>
<span class="sd">        contraction of the traceless quadropole tensor :math:`\hat{\mathsf{Q}}`</span>

<span class="sd">        Computes the quadrupole moment of :class:`Atoms&lt;Atom&gt;` in the group.</span>
<span class="sd">        Quadrupole per :class:`Residue`, :class:`Segment`, molecule, or</span>
<span class="sd">        fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly.</span>

<span class="sd">        Note that when there is an unsymmetrical plane in the molecule or </span>
<span class="sd">        group, the magnitude of the quadrupole moment is dependant on the </span>
<span class="sd">        ``center`` chosen and cannot be translated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True`` and `compound` is ``&#39;group&#39;``, move all atoms to the</span>
<span class="sd">            primary unit cell before calculation.</span>
<span class="sd">            If ``True`` and `compound` is not ``group``, the</span>
<span class="sd">            centers of mass of each compound will be calculated without moving</span>
<span class="sd">            any atoms to keep the compounds intact.</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their</span>
<span class="sd">            centers.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, \</span>
<span class="sd">                    &#39;fragments&#39;}, optional</span>
<span class="sd">            If ``&#39;group&#39;``, a single quadrupole value returns. Otherwise, an</span>
<span class="sd">            array of each :class:`Segment`, :class:`Residue`, molecule, or</span>
<span class="sd">            fragment will be returned as an array of position vectors, i.e.</span>
<span class="sd">            a 1d array.</span>
<span class="sd">            Note that, in any case, *only* the positions of</span>
<span class="sd">            :class:`Atoms&lt;Atom&gt;` *belonging to the group* will be taken into</span>
<span class="sd">            account.</span>
<span class="sd">        center : {&#39;mass&#39;, &#39;charge&#39;}, optional</span>
<span class="sd">            Choose whether the dipole vector is calculated at the center of </span>
<span class="sd">            &quot;mass&quot; or the center of &quot;charge&quot;, default is &quot;mass&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Quadrupole moment(s) of (compounds of) the group in :math:`eÅ^2`.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            value. Otherwise, the output will be a 1d array of shape ``(n,)``</span>
<span class="sd">            where ``n`` is the number of compounds.</span>


<span class="sd">        .. versionadded:: 2.4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>

        <span class="k">def</span> <span class="nf">__quadrupole_moment</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">tensor</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

        <span class="n">quad_tensor</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">quadrupole_tensor</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">quad_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">quad_moment</span> <span class="o">=</span> <span class="n">__quadrupole_moment</span><span class="p">(</span><span class="n">quad_tensor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">quad_moment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">__quadrupole_moment</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">quad_tensor</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">quad_moment</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;quadrupole_moment&#39;</span><span class="p">,</span> <span class="n">quadrupole_moment</span><span class="p">))</span></div>



<div class="viewcode-block" id="FormalCharges">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.FormalCharges">[docs]</a>
<span class="k">class</span> <span class="nc">FormalCharges</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Formal charge on each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;formalcharges&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;formalcharge&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>



<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Occupancies">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Occupancies">[docs]</a>
<span class="k">class</span> <span class="nc">Occupancies</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;occupancies&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;occupancy&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>



<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="AltLocs">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AltLocs">[docs]</a>
<span class="k">class</span> <span class="nc">AltLocs</span><span class="p">(</span><span class="n">AtomStringAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;AltLocs for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;altLocs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;altLoc&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>



<div class="viewcode-block" id="GBScreens">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.GBScreens">[docs]</a>
<span class="k">class</span> <span class="nc">GBScreens</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generalized Born screening factor&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;gbscreens&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;gbscreen&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>



<div class="viewcode-block" id="SolventRadii">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SolventRadii">[docs]</a>
<span class="k">class</span> <span class="nc">SolventRadii</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Intrinsic solvation radius&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;solventradii&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;solventradius&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>



<div class="viewcode-block" id="NonbondedIndices">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.NonbondedIndices">[docs]</a>
<span class="k">class</span> <span class="nc">NonbondedIndices</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Nonbonded index (AMBER)&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;nbindices&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;nbindex&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>



<div class="viewcode-block" id="RMins">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.RMins">[docs]</a>
<span class="k">class</span> <span class="nc">RMins</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The Rmin/2 LJ parameter&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;rmins&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;rmin&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>



<div class="viewcode-block" id="Epsilons">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Epsilons">[docs]</a>
<span class="k">class</span> <span class="nc">Epsilons</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The epsilon LJ parameter&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;epsilons&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;epsilon&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>



<div class="viewcode-block" id="RMin14s">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.RMin14s">[docs]</a>
<span class="k">class</span> <span class="nc">RMin14s</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The Rmin/2 LJ parameter for 1-4 interactions&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;rmin14s&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;rmin14&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>



<div class="viewcode-block" id="Epsilon14s">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Epsilon14s">[docs]</a>
<span class="k">class</span> <span class="nc">Epsilon14s</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The epsilon LJ parameter for 1-4 interactions&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;epsilon14s&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;epsilon14&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">)</span></div>



<div class="viewcode-block" id="Aromaticities">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Aromaticities">[docs]</a>
<span class="k">class</span> <span class="nc">Aromaticities</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Aromaticity&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s2">&quot;aromaticities&quot;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s2">&quot;aromaticity&quot;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s2">&quot;atom&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span></div>



<div class="viewcode-block" id="RSChirality">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.RSChirality">[docs]</a>
<span class="k">class</span> <span class="nc">RSChirality</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;R/S chirality&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;chiralities&#39;</span>
    <span class="n">singular</span><span class="o">=</span> <span class="s1">&#39;chirality&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;U1&#39;</span></div>



<div class="viewcode-block" id="ResidueAttr">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr">[docs]</a>
<span class="k">class</span> <span class="nc">ResidueAttr</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;residueattrs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;residueattr&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;residue&#39;</span>

<div class="viewcode-block" id="ResidueAttr.get_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.get_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="n">rix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">atoms2residues</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">rix</span><span class="p">]</span></div>


<div class="viewcode-block" id="ResidueAttr.set_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.set_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span></div>


<div class="viewcode-block" id="ResidueAttr.get_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.get_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span></div>


<div class="viewcode-block" id="ResidueAttr.set_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.set_residues">[docs]</a>
    <span class="nd">@_check_length</span>
    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span></div>


<div class="viewcode-block" id="ResidueAttr.get_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.get_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;By default, the values for each residue present in the set of</span>
<span class="sd">        segments are returned in a single array. This behavior can be overriden</span>
<span class="sd">        in child attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rixs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2residues_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">rix</span><span class="p">]</span> <span class="k">for</span> <span class="n">rix</span> <span class="ow">in</span> <span class="n">rixs</span><span class="p">]</span></div>


<div class="viewcode-block" id="ResidueAttr.set_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.set_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">)</span></div>
</div>



<span class="c1"># woe betide anyone who switches this inheritance order</span>
<span class="c1"># Mixin needs to be first (L to R) to get correct __init__ and set_atoms</span>
<div class="viewcode-block" id="ResidueStringAttr">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueStringAttr">[docs]</a>
<span class="k">class</span> <span class="nc">ResidueStringAttr</span><span class="p">(</span><span class="n">_StringInternerMixin</span><span class="p">,</span> <span class="n">ResidueAttr</span><span class="p">):</span>

<div class="viewcode-block" id="ResidueStringAttr.set_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueStringAttr.set_residues">[docs]</a>
    <span class="nd">@_check_length</span>
    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_X</span><span class="p">(</span><span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>



<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Resids">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resids">[docs]</a>
<span class="k">class</span> <span class="nc">Resids</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Residue ID&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;resids&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;resid&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>



<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Resnames">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resnames">[docs]</a>
<span class="k">class</span> <span class="nc">Resnames</span><span class="p">(</span><span class="n">ResidueStringAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;resnames&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;resname&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

<div class="viewcode-block" id="Resnames.sequence">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resnames.sequence">[docs]</a>
    <span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the amino acid sequence.</span>

<span class="sd">        The format of the sequence is selected with the keyword *format*:</span>

<span class="sd">        ============== ============================================</span>
<span class="sd">        *format*       description</span>
<span class="sd">        ============== ============================================</span>
<span class="sd">        &#39;SeqRecord&#39;    :class:`Bio.SeqRecord.SeqRecord` (default)</span>
<span class="sd">        &#39;Seq&#39;          :class:`Bio.Seq.Seq`</span>
<span class="sd">        &#39;string&#39;       string</span>
<span class="sd">        ============== ============================================</span>

<span class="sd">        The sequence is returned by default (keyword ``format = &#39;SeqRecord&#39;``)</span>
<span class="sd">        as a :class:`Bio.SeqRecord.SeqRecord` instance, which can then be</span>
<span class="sd">        further processed. In this case, all keyword arguments (such as the</span>
<span class="sd">        *id* string or the *name* or the *description*) are directly passed to</span>
<span class="sd">        :class:`Bio.SeqRecord.SeqRecord`.</span>

<span class="sd">        If the keyword *format* is set to ``&#39;Seq&#39;``, all *kwargs* are ignored</span>
<span class="sd">        and a :class:`Bio.Seq.Seq` instance is returned. The difference to the</span>
<span class="sd">        record is that the record also contains metadata and can be directly</span>
<span class="sd">        used as an input for other functions in :mod:`Bio`.</span>

<span class="sd">        If the keyword *format* is set to ``&#39;string&#39;``, all *kwargs* are</span>
<span class="sd">        ignored and a Python string is returned.</span>

<span class="sd">        .. rubric:: Example: Write FASTA file</span>

<span class="sd">        Use :func:`Bio.SeqIO.write`, which takes sequence records::</span>

<span class="sd">           import Bio.SeqIO</span>

<span class="sd">           # get the sequence record of a protein component of a Universe</span>
<span class="sd">           protein = u.select_atoms(&quot;protein&quot;)</span>
<span class="sd">           record = protein.sequence(id=&quot;myseq1&quot;, name=&quot;myprotein&quot;)</span>

<span class="sd">           Bio.SeqIO.write(record, &quot;single.fasta&quot;, &quot;fasta&quot;)</span>

<span class="sd">        A FASTA file with multiple entries can be written with ::</span>

<span class="sd">           Bio.SeqIO.write([record1, record2, ...], &quot;multi.fasta&quot;, &quot;fasta&quot;)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        format : string, optional</span>
<span class="sd">           - ``&quot;string&quot;``: return sequence as a string of 1-letter codes</span>
<span class="sd">           - ``&quot;Seq&quot;``: return a :class:`Bio.Seq.Seq` instance</span>
<span class="sd">           - ``&quot;SeqRecord&quot;``: return a :class:`Bio.SeqRecord.SeqRecord`</span>
<span class="sd">             instance</span>

<span class="sd">            Default is ``&quot;SeqRecord&quot;``</span>
<span class="sd">        id : optional</span>
<span class="sd">           Sequence ID for SeqRecord (should be different for different</span>
<span class="sd">           sequences)</span>
<span class="sd">        name : optional</span>
<span class="sd">           Name of the protein.</span>
<span class="sd">        description : optional</span>
<span class="sd">           Short description of the sequence.</span>
<span class="sd">        kwargs : optional</span>
<span class="sd">           Any other keyword arguments that are understood by</span>
<span class="sd">           class:`Bio.SeqRecord.SeqRecord`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        :exc:`ValueError` if a residue name cannot be converted to a</span>
<span class="sd">        1-letter IUPAC protein amino acid code; make sure to only</span>
<span class="sd">        select protein residues.</span>

<span class="sd">        :exc:`TypeError` if an unknown *format* is selected.</span>

<span class="sd">        :exc:`ImportError` is the Biopython package is not available.</span>


<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 2.7.0</span>
<span class="sd">           Biopython is now an optional dependency</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">HAS_BIOPYTHON</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The `sequence_alignment` method requires an &quot;</span>
                      <span class="s2">&quot;installation of `Biopython`. Please install &quot;</span>
                      <span class="s2">&quot;`Biopython` to use this method: &quot;</span>
                      <span class="s2">&quot;https://biopython.org/wiki/Download&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

        <span class="n">formats</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="s1">&#39;Seq&#39;</span><span class="p">,</span> <span class="s1">&#39;SeqRecord&#39;</span><span class="p">)</span>

        <span class="nb">format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;SeqRecord&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">formats</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown format=&#39;</span><span class="si">{0}</span><span class="s2">&#39;: must be one of: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">format</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formats</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">convert_aa_code</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">resnames</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AtomGroup contains a residue name &#39;</span><span class="si">{</span><span class="n">err</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&#39; that&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot; does not have a IUPAC protein 1-letter character&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sequence</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">Seq</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;Seq&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">seq</span>
        <span class="k">return</span> <span class="n">Bio</span><span class="o">.</span><span class="n">SeqRecord</span><span class="o">.</span><span class="n">SeqRecord</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;sequence&#39;</span><span class="p">,</span> <span class="n">sequence</span><span class="p">))</span></div>



<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Resnums">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resnums">[docs]</a>
<span class="k">class</span> <span class="nc">Resnums</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;resnums&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;resnum&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="ICodes">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ICodes">[docs]</a>
<span class="k">class</span> <span class="nc">ICodes</span><span class="p">(</span><span class="n">ResidueStringAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Insertion code for Atoms&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;icodes&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;icode&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span></div>



<div class="viewcode-block" id="Moltypes">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Moltypes">[docs]</a>
<span class="k">class</span> <span class="nc">Moltypes</span><span class="p">(</span><span class="n">ResidueStringAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Name of the molecule type</span>

<span class="sd">    Two molecules that share a molecule type share a common template topology.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;moltypes&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;moltype&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span></div>



<div class="viewcode-block" id="Molnums">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Molnums">[docs]</a>
<span class="k">class</span> <span class="nc">Molnums</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Index of molecule from 0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;molnums&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;molnum&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span></div>



<span class="c1"># segment attributes</span>


<div class="viewcode-block" id="SegmentAttr">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr">[docs]</a>
<span class="k">class</span> <span class="nc">SegmentAttr</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for segment attributes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;segmentattrs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;segmentattr&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span>
                      <span class="n">SegmentGroup</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;segment&#39;</span>

<div class="viewcode-block" id="SegmentAttr.get_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr.get_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="n">six</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">atoms2segments</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">six</span><span class="p">]</span></div>


<div class="viewcode-block" id="SegmentAttr.set_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr.set_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span></div>


<div class="viewcode-block" id="SegmentAttr.get_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr.get_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="n">six</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2segments</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">six</span><span class="p">]</span></div>


<div class="viewcode-block" id="SegmentAttr.set_residues">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr.set_residues">[docs]</a>
    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">)</span></div>


<div class="viewcode-block" id="SegmentAttr.get_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr.get_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span></div>


<div class="viewcode-block" id="SegmentAttr.set_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr.set_segments">[docs]</a>
    <span class="nd">@_check_length</span>
    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span></div>
</div>



<span class="c1"># woe betide anyone who switches this inheritance order</span>
<span class="c1"># Mixin needs to be first (L to R) to get correct __init__ and set_atoms</span>
<div class="viewcode-block" id="SegmentStringAttr">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentStringAttr">[docs]</a>
<span class="k">class</span> <span class="nc">SegmentStringAttr</span><span class="p">(</span><span class="n">_StringInternerMixin</span><span class="p">,</span> <span class="n">SegmentAttr</span><span class="p">):</span>

<div class="viewcode-block" id="SegmentStringAttr.set_segments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentStringAttr.set_segments">[docs]</a>
    <span class="nd">@_check_length</span>
    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_X</span><span class="p">(</span><span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>



<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Segids">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segids">[docs]</a>
<span class="k">class</span> <span class="nc">Segids</span><span class="p">(</span><span class="n">SegmentStringAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;segids&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;segid&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_initial_values</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_check_connection_values</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks values passed to _Connection methods for:</span>
<span class="sd">     - appropriate number of atom indices</span>
<span class="sd">     - coerces them to tuples of ints (for hashing)</span>
<span class="sd">     - ensures that first value is less than last (reversibility &amp; hashing)</span>

<span class="sd">    .. versionadded:: 1.0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_atoms</span>
                   <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> must be an iterable of tuples with </span><span class="si">{}</span><span class="s2">&quot;</span>
                              <span class="s2">&quot; atom indices&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attrname</span><span class="p">,</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">_n_atoms</span><span class="p">))</span>
        <span class="n">clean</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">clean</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clean</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">class</span> <span class="nc">_ConnectionTopologyAttrMeta</span><span class="p">(</span><span class="n">_TopologyAttrMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specific metaclass for atom-connectivity topology attributes.</span>

<span class="sd">    This class adds an ``intra_{attrname}`` property to groups</span>
<span class="sd">    to return only the connections within the atoms in the group.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">classdict</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">classdict</span><span class="p">)</span>

        <span class="n">attrname</span> <span class="o">=</span> <span class="n">classdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;attrname&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">attrname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">intra_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Get connections only within this AtomGroup</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="n">ag</span><span class="o">.</span><span class="n">get_connections</span><span class="p">(</span><span class="n">attrname</span><span class="p">,</span> <span class="n">outside</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">method</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">intra_connection</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
            <span class="n">prop</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">transplants</span><span class="p">[</span><span class="n">AtomGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">f</span><span class="s2">&quot;intra_</span><span class="si">{</span><span class="n">attrname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prop</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_Connection</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_ConnectionTopologyAttrMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for connectivity between atoms</span>

<span class="sd">    .. versionchanged:: 1.0.0</span>
<span class="sd">        Added type checking to atom index values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@_check_connection_values</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">if</span> <span class="n">types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">types</span>
        <span class="k">if</span> <span class="n">guessed</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># if single value passed, multiply this across</span>
            <span class="c1"># all bonds</span>
            <span class="n">guessed</span> <span class="o">=</span> <span class="p">[</span><span class="n">guessed</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">guessed</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a deepcopy of this attribute&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                              <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">),</span>
                              <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">),</span>
                              <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondDict</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;bd&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_bondDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lazily built mapping of atoms:bonds&quot;&quot;&quot;</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">bd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">bd</span>

    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot set bond information&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get connection values where the atom indices are in</span>
<span class="sd">        the given atomgroup.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ag : AtomGroup</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">unique_bonds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondDict</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># maybe we got passed an Atom</span>
            <span class="n">unique_bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondDict</span><span class="p">[</span><span class="n">ag</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span>
        <span class="n">unique_bonds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">unique_bonds</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">bond_idx</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">guessed</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">unique_bonds</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">bond_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bond_idx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">types</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">guessed</span> <span class="o">=</span> <span class="n">guessed</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">bond_idx</span><span class="p">,</span> <span class="n">ag</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">singular</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">types</span><span class="p">,</span>
                             <span class="n">guessed</span><span class="p">,</span>
                             <span class="n">order</span><span class="p">)</span>

    <span class="nd">@_check_connection_values</span>
    <span class="k">def</span> <span class="nf">_add_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="kc">None</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">guessed</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">guessed</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="n">guessed</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="kc">None</span><span class="p">,))</span>

        <span class="n">existing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">guessed</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="c1"># kill the old cache of bond Dict</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;bd&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="nd">@_check_connection_values</span>
    <span class="k">def</span> <span class="nf">_delete_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 1.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">to_check</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">self_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_check</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">self_values</span><span class="p">):</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">to_check</span><span class="o">-</span><span class="n">self_values</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">missing</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Cannot delete nonexistent &#39;</span>
                              <span class="s1">&#39;</span><span class="si">{attrname}</span><span class="s1"> with atom indices:&#39;</span>
                              <span class="s1">&#39;</span><span class="si">{indices}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attrname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attrname</span><span class="p">,</span>
                                                  <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">to_check</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;types&#39;</span><span class="p">,</span> <span class="s1">&#39;_guessed&#39;</span><span class="p">,</span> <span class="s1">&#39;order&#39;</span><span class="p">):</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;object&#39;</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">new</span><span class="p">))</span>
        <span class="c1"># kill the old cache of bond Dict</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;bd&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>


<div class="viewcode-block" id="Bonds">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds">[docs]</a>
<span class="k">class</span> <span class="nc">Bonds</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bonds between two atoms</span>

<span class="sd">    Must be initialised by a list of zero based tuples.</span>
<span class="sd">    These indices refer to the atom indices.</span>
<span class="sd">    E.g., ` [(0, 1), (1, 2), (2, 3)]`</span>

<span class="sd">    Also adds the `bonded_atoms`, `fragment` and `fragments`</span>
<span class="sd">    attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;bonds&#39;</span>
    <span class="c1"># Singular is the same because one Atom might have</span>
    <span class="c1"># many bonds, so still asks for &quot;bonds&quot; in the plural</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;bonds&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">_n_atoms</span> <span class="o">=</span> <span class="mi">2</span>

<div class="viewcode-block" id="Bonds.bonded_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.bonded_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">bonded_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An :class:`~MDAnalysis.core.groups.AtomGroup` of all</span>
<span class="sd">        :class:`Atoms&lt;MDAnalysis.core.groups.Atom&gt;` bonded to this</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.Atom`.&quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;bonded_atoms&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">bonded_atoms</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">bonded_atoms</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

<div class="viewcode-block" id="Bonds.fragindex">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.fragindex">[docs]</a>
    <span class="k">def</span> <span class="nf">fragindex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The index (ID) of the</span>
<span class="sd">        :class:`~MDAnalysis.core.topologyattrs.Bonds.fragment` this</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.Atom` is part of.</span>


<span class="sd">        .. versionadded:: 0.20.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_fragdict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">ix</span></div>


<div class="viewcode-block" id="Bonds.fragindices">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.fragindices">[docs]</a>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;fragindices&#39;</span><span class="p">,</span> <span class="n">universe_validation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fragindices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The</span>
<span class="sd">        :class:`fragment indices&lt;MDAnalysis.core.topologyattrs.Bonds.fragindex&gt;`</span>
<span class="sd">        of all :class:`Atoms&lt;MDAnalysis.core.groups.Atom&gt;` in this</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.AtomGroup`.</span>

<span class="sd">        A :class:`numpy.ndarray` with</span>
<span class="sd">        :attr:`~numpy.ndarray.shape`\ ``=(``\ :attr:`~AtomGroup.n_atoms`\ ``,)``</span>
<span class="sd">        and :attr:`~numpy.ndarray.dtype`\ ``=numpy.int64``.</span>


<span class="sd">        .. versionadded:: 0.20.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fragdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_fragdict</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fragdict</span><span class="p">[</span><span class="n">aix</span><span class="p">]</span><span class="o">.</span><span class="n">ix</span> <span class="k">for</span> <span class="n">aix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span></div>


<div class="viewcode-block" id="Bonds.fragment">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.fragment">[docs]</a>
    <span class="k">def</span> <span class="nf">fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An :class:`~MDAnalysis.core.groups.AtomGroup` representing the</span>
<span class="sd">        fragment this :class:`~MDAnalysis.core.groups.Atom` is part of.</span>

<span class="sd">        A fragment is a</span>
<span class="sd">        :class:`group of atoms&lt;MDAnalysis.core.groups.AtomGroup&gt;` which are</span>
<span class="sd">        interconnected by :class:`~MDAnalysis.core.topologyattrs.Bonds`, i.e.,</span>
<span class="sd">        there exists a path along one</span>
<span class="sd">        or more :class:`~MDAnalysis.core.topologyattrs.Bonds` between any pair</span>
<span class="sd">        of :class:`Atoms&lt;MDAnalysis.core.groups.Atom&gt;`</span>
<span class="sd">        within a fragment. Thus, a fragment typically corresponds to a molecule.</span>


<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_fragdict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">fragment</span></div>


<div class="viewcode-block" id="Bonds.fragments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.fragments">[docs]</a>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;fragments&#39;</span><span class="p">,</span> <span class="n">universe_validation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read-only :class:`tuple` of</span>
<span class="sd">        :class:`fragments&lt;MDAnalysis.core.topologyattrs.Bonds.fragment&gt;`.</span>

<span class="sd">        Contains all fragments that</span>
<span class="sd">        any :class:`~MDAnalysis.core.groups.Atom` in this</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.AtomGroup` is part of.</span>

<span class="sd">        A fragment is a</span>
<span class="sd">        :class:`group of atoms&lt;MDAnalysis.core.groups.AtomGroup&gt;` which are</span>
<span class="sd">        interconnected by :class:`~MDAnalysis.core.topologyattrs.Bonds`, i.e.,</span>
<span class="sd">        there exists a path along one</span>
<span class="sd">        or more :class:`~MDAnalysis.core.topologyattrs.Bonds` between any pair</span>
<span class="sd">        of :class:`Atoms&lt;MDAnalysis.core.groups.Atom&gt;`</span>
<span class="sd">        within a fragment. Thus, a fragment typically corresponds to a molecule.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        * The contents of the fragments may extend beyond the contents of this</span>
<span class="sd">          :class:`~MDAnalysis.core.groups.AtomGroup`.</span>


<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fragdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_fragdict</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">fragdict</span><span class="p">[</span><span class="n">aix</span><span class="p">]</span><span class="o">.</span><span class="n">fragment</span> <span class="k">for</span> <span class="n">aix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">),</span>
                            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ix</span><span class="p">))</span></div>


<div class="viewcode-block" id="Bonds.n_fragments">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.n_fragments">[docs]</a>
    <span class="k">def</span> <span class="nf">n_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of unique</span>
<span class="sd">        :class:`~MDAnalysis.core.topologyattrs.Bonds.fragments` the</span>
<span class="sd">        :class:`Atoms&lt;MDAnalysis.core.groups.Atom&gt;` of this</span>
<span class="sd">        :class:`~MDAnalysis.core.groups.AtomGroup` are part of.</span>


<span class="sd">        .. versionadded:: 0.20.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_int_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragindices</span><span class="p">))</span></div>


    <span class="n">transplants</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;fragment&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">fragment</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;fragindex&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">fragindex</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">fragindex</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">AtomGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;fragments&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">fragments</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">fragments</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">AtomGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;fragindices&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">fragindices</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">fragindices</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">AtomGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;n_fragments&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">n_fragments</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">n_fragments</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span></div>



<div class="viewcode-block" id="UreyBradleys">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.UreyBradleys">[docs]</a>
<span class="k">class</span> <span class="nc">UreyBradleys</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Angles between two atoms</span>

<span class="sd">    Initialise with a list of 2 long tuples</span>

<span class="sd">    These indices refer to the atom indices.</span>

<span class="sd">    .. versionadded:: 1.0.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;ureybradleys&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;ureybradleys&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">_n_atoms</span> <span class="o">=</span> <span class="mi">2</span></div>



<div class="viewcode-block" id="Angles">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Angles">[docs]</a>
<span class="k">class</span> <span class="nc">Angles</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Angles between three atoms</span>

<span class="sd">    Initialise with a list of 3 long tuples</span>
<span class="sd">    E.g.,  `[(0, 1, 2), (1, 2, 3), (2, 3, 4)]`</span>

<span class="sd">    These indices refer to the atom indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;angles&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;angles&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">_n_atoms</span> <span class="o">=</span> <span class="mi">3</span></div>



<div class="viewcode-block" id="Dihedrals">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Dihedrals">[docs]</a>
<span class="k">class</span> <span class="nc">Dihedrals</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A connection between four sequential atoms&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;dihedrals&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;dihedrals&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">_n_atoms</span> <span class="o">=</span> <span class="mi">4</span></div>



<div class="viewcode-block" id="Impropers">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Impropers">[docs]</a>
<span class="k">class</span> <span class="nc">Impropers</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An imaginary dihedral between four atoms&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;impropers&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;impropers&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">_n_atoms</span> <span class="o">=</span> <span class="mi">4</span></div>



<div class="viewcode-block" id="CMaps">
<a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.CMaps">[docs]</a>
<span class="k">class</span> <span class="nc">CMaps</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A connection between five atoms</span>
<span class="sd">    .. versionadded:: 1.0.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;cmaps&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;cmaps&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">_n_atoms</span> <span class="o">=</span> <span class="mi">5</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2024, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Henok Ademtew, Shobhit Agarwal, Aya M. Alaa, Irfan Alibay, Kazi Shudipto Amin, Anshul Angaria, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Patricio Barletta, Leonardo Barneschi, Jonathan Barnoud, Estefania Barreto-Ojeda, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Kavya Bisht, Wouter Boomsma, Jose Borreguero, Cédric Bouysset, Kevin Boyd, Meet Brijwani, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, Yantong Cai, David Caplan, Yuanyu Chang, Pratham Chauhan, Matthieu Chavent, Haochuan Chen, Xu Hong Chen, Kathleen Clark, Jennifer A Clark, Orion Cohen, Charlie Cook, Ruggero Cortini, Nicholas Craven, Ramon Crehuet, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Bradley Dice, Jan Domanski, David L. Dotson, Mark D. Driver, Ali Ehlen, Daniel J. Evans, Shujie Fan, Bjarne Feddersen, Lennard van der Feltz, Jake Fennick, Philip Fowler, Guillaume Fraux, Anirvinya G, Michael Gecht, Ahmed Salah Ghoneim, Mikhail Glagolev, William Glass, Jenna M. Swarthout Goddard, Joseph Goose, Alexander Gorfer, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Pratik Gupta, Sumit Gupta, Benjamin Hall, Ameya Harmalkar, Ivan Hristov, Eugen Hruska, Kyle J. Huston, Siddharth Jain, Edis Jakupovic, Joe Jordan, Henrik Jäger, Uma D Kadam, Aditya Kamath, Jon Kapla, Ian M. Kenney, Aditya Keshari, Haleema Khan, Navya Khare, Utsav Khatu, Andrew William King, Henry Kobin, Abhishek A. Kognole, Kosuke Kudo, Atharva Kulkarni, Manish Kumar, Mohit Kumar, Shubham Kumar, Alia Lescoulie, Zhenbo Li, Max Linke, Philip Loche, Jinju Lu, Hugo MacDermott-Opeskin, Shaivi Malik, Egor Marin, Domenico Marson, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Rocco Meli, Manuel Nuno Melo, Marcelo C. R. Melo, Dominik &#39;Rathann&#39; Mierzejewski, David Minh, Geongi Moon, Sampurna Mukherjee, Henry Mull, Morgan L. Nance, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Meghan Osato, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Dimitrios Papageorgiou, Rafael R. Pappalardo, Vishal Parmar, Danny Parton, Shakul Pathak, Christian Pfaendner, Joshua L. Phillips, Marcelo D. Poleto, Hannah Pollak, Kashish Punjani, Michael Quevillon, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Andrea Rizzi, Xiaoxu Ruan, Carlos Yanez S., Utkarsh Saxena, Moritz Schaeffler, Alexander Schlaich, Marcello Sega, Ricky Sexton, Sean L. Seyler, Faraaz Shah, Sulay Shah, Abhishek Shandilya, Shubham Sharma, Rishabh Shukla, Karthikeyan Singaravelan, Tamandeep Singh, Brigitta Sipőcz, Paul Smith, Andy Somogyi, Caio S. Souza, David van der Spoel, Shantanu Srivastava, Lukas Stelzl, Jan Stevens, Gorman Stock, Philipp Stärk, Johannes Stöckelmaier, Fenil Suchak, Ayush Suhane, Filip T. Szczypiński, Sukeerti T, Matthijs Tadema, Valerij Talagayev, Joao Miguel Correia Teixeira, Paarth Thadani, Matthew W. Thompson, Hao Tian, Matteo Tiberti, Zaheer Timol, Wiep van der Toorn, Mieczyslaw Torchala, Aditi Tripathi, Heet Vekariya, Mark Verma, Josh Vermaas, Isaac Virshup, Lily Wang, Leon Wehrhan, Nestor Wendt, Lawson Woods, Zhiyi Wu, Tengyu Xie, Zhuyi Xue, Mingyi Xue, Alexander Yang, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, Raymond Zhao, Yuxuan Zhuang, and Oliver Beckstein.</p>
  </div>

  

<div class="footer"><p>Please see
    our <a href="https://www.mdanalysis.org/pages/privacy/">Privacy Policy</a>
    to learn how <a href="https://www.mdanalysis.org">MDAnalysis</a> collects data.</p>
    <script data-goatcounter="https://mdanalysis.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</div>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
    var versions_json_url = 'https://docs.mdanalysis.org/versions.json'
</script>

<div class="rst-versions" data-toggle="rst-versions" role="note"
     aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
        2.8.0-dev0
      <span class="fa fa-caret-down"></span>
    </span>

    <div class="rst-other-versions">
        <dl id="versionselector">
            <dt>Other Versions</dt>
        </dl>

    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>