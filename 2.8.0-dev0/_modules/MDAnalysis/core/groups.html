


  
    
  




<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="shortcut icon" href="../../../_static/logo/mda_favicon.ico">
</head>

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MDAnalysis.core.groups &mdash; MDAnalysis 2.8.0-dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/site.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=a9b57af3"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/js/versions.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 2.8.0-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >




  




<a href="../../../index.html">
  
    <img src="../../../_static/logo/mda_logo.png" class="logo" alt="Logo"/>
</a>


  
  
  
    <div class="version">
      2.8.0-dev0
    </div>
  



<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>
<div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
    <!-- <p class="caption" role="heading"></p> -->
    <ul>
        
        <li class="toctree-l1"><a class="reference internal" href="http://mdanalysis.org">MDAnalysis</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="http://userguide.mdanalysis.org">User guide</a></li>
        
        <li class="toctree-l1"><a class="reference internal" href="https://mdakits.mdanalysis.org/">MDAKits</a></li>
        
    </ul>
    
        <p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/converters.html">7. Converter modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/trajectory_transformations.html">8. Trajectory transformations (“on-the-fly” transformations)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections_modules.html">9. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/auxiliary_modules.html">10. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/core_modules.html">11. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/visualization_modules.html">12. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/lib_modules.html">13. Library functions — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/version.html">14. Version information for MDAnalysis - <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/units.html">15. Constants and unit conversion — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/exceptions.html">16. Custom exceptions and warnings — <code class="xref py py-mod docutils literal notranslate"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/references.html">17. References</a></li>
</ul>

</div>

      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MDAnalysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">MDAnalysis.core.groups</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MDAnalysis.core.groups</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- https://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1"># doi: 10.25080/majora-629e541a-00e</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">==========================================================</span>
<span class="sd">Core objects: Containers --- :mod:`MDAnalysis.core.groups`</span>
<span class="sd">==========================================================</span>

<span class="sd">The :class:`~MDAnalysis.core.universe.Universe` instance contains all the</span>
<span class="sd">particles in the system (which MDAnalysis calls :class:`Atom`). Groups of</span>
<span class="sd">:class:`atoms&lt;Atom&gt;` are handled as :class:`AtomGroup` instances. The</span>
<span class="sd">:class:`AtomGroup` is probably the most important object in MDAnalysis because</span>
<span class="sd">virtually everything can be accessed through it. :class:`AtomGroup` instances</span>
<span class="sd">can be easily created (e.g., from an :meth:`AtomGroup.select_atoms` selection or</span>
<span class="sd">simply by slicing).</span>

<span class="sd">For convenience, chemically meaningful groups of :class:`Atoms&lt;Atom&gt;` such as a</span>
<span class="sd">:class:`Residue` or a :class:`Segment` (typically a whole molecule or all of the</span>
<span class="sd">solvent) also exist as containers, as well as groups of these units</span>
<span class="sd">(:class:`ResidueGroup`, :class:`SegmentGroup`).</span>


<span class="sd">Classes</span>
<span class="sd">=======</span>

<span class="sd">Collections</span>
<span class="sd">-----------</span>

<span class="sd">.. autoclass:: AtomGroup</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>
<span class="sd">.. autoclass:: ResidueGroup</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>
<span class="sd">.. autoclass:: SegmentGroup</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>
<span class="sd">.. autoclass:: UpdatingAtomGroup</span>
<span class="sd">   :members:</span>

<span class="sd">Chemical units</span>
<span class="sd">--------------</span>

<span class="sd">.. autoclass:: Atom</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>
<span class="sd">.. autoclass:: Residue</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>
<span class="sd">.. autoclass:: Segment</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>

<span class="sd">Levels</span>
<span class="sd">------</span>

<span class="sd">Each of the above classes has a *level* attribute.  This can be used to verify</span>
<span class="sd">that two objects are of the same level, or to access a particular class</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    u = mda.Universe()</span>

<span class="sd">    ag = u.atoms[:10]</span>
<span class="sd">    at = u.atoms[11]</span>

<span class="sd">    ag.level == at.level  # Returns True</span>

<span class="sd">    ag.level.singular  # Returns Atom class</span>
<span class="sd">    at.level.plural  # Returns AtomGroup class</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_CONVERTERS</span><span class="p">,</span>
                <span class="n">_TOPOLOGY_ATTRS</span><span class="p">,</span> <span class="n">_TOPOLOGY_TRANSPLANTS</span><span class="p">,</span> <span class="n">_TOPOLOGY_ATTRNAMES</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..lib.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">cached</span><span class="p">,</span> <span class="n">warn_if_not_unique</span><span class="p">,</span>
                        <span class="n">unique_int_1d</span><span class="p">,</span> <span class="n">unique_int_1d_unsorted</span><span class="p">,</span>
                        <span class="n">int_array_is_sorted</span>
                        <span class="p">)</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">distances</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">transformations</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">mdamath</span>
<span class="kn">from</span> <span class="nn">.accessors</span> <span class="kn">import</span> <span class="n">Accessor</span><span class="p">,</span> <span class="n">ConverterWrapper</span>
<span class="kn">from</span> <span class="nn">..selections</span> <span class="kn">import</span> <span class="n">get_writer</span> <span class="k">as</span> <span class="n">get_selection_writer_for</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">selection</span>
<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="kn">import</span> <span class="n">NoDataError</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">topologyobjects</span>
<span class="kn">from</span> <span class="nn">._get_readers</span> <span class="kn">import</span> <span class="n">get_writer_for</span><span class="p">,</span> <span class="n">get_converter_for</span>


<span class="k">def</span> <span class="nf">_unpickle</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ix</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>


<span class="c1"># TODO 3.0: deprecate _unpickle in favor of _unpickle2.</span>
<span class="k">def</span> <span class="nf">_unpickle2</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_unpickle_uag</span><span class="p">(</span><span class="n">basepickle</span><span class="p">,</span> <span class="n">selections</span><span class="p">,</span> <span class="n">selstrs</span><span class="p">):</span>
    <span class="n">bfunc</span><span class="p">,</span> <span class="n">bargs</span> <span class="o">=</span> <span class="n">basepickle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">basepickle</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">basegroup</span> <span class="o">=</span> <span class="n">bfunc</span><span class="p">(</span><span class="o">*</span><span class="n">bargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">UpdatingAtomGroup</span><span class="p">(</span><span class="n">basegroup</span><span class="p">,</span> <span class="n">selections</span><span class="p">,</span> <span class="n">selstrs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">make_classes</span><span class="p">():</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Make a fresh copy of all classes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Two dictionaries. One with a set of :class:`_TopologyAttrContainer` classes</span>
<span class="sd">    to serve as bases for :class:`~MDAnalysis.core.universe.Universe`\ -specific</span>
<span class="sd">    MDA container classes. Another with the final merged versions of those</span>
<span class="sd">    classes. The classes themselves are used as hashing keys.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bases</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">classes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="p">(</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)</span>
    <span class="n">components</span> <span class="o">=</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">)</span>

    <span class="c1"># The &#39;GBase&#39; middle man is needed so that a single topologyattr</span>
    <span class="c1">#  patching applies automatically to all groups.</span>
    <span class="n">GBase</span> <span class="o">=</span> <span class="n">bases</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span> <span class="o">=</span> <span class="n">_TopologyAttrContainer</span><span class="o">.</span><span class="n">_subclass</span><span class="p">(</span><span class="n">is_group</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
        <span class="n">bases</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">GBase</span><span class="o">.</span><span class="n">_subclass</span><span class="p">(</span><span class="n">is_group</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># CBase for patching all components</span>
    <span class="n">CBase</span> <span class="o">=</span> <span class="n">bases</span><span class="p">[</span><span class="n">ComponentBase</span><span class="p">]</span> <span class="o">=</span> <span class="n">_TopologyAttrContainer</span><span class="o">.</span><span class="n">_subclass</span><span class="p">(</span>
        <span class="n">is_group</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
        <span class="n">bases</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">CBase</span><span class="o">.</span><span class="n">_subclass</span><span class="p">(</span><span class="n">is_group</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Initializes the class cache.</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">groups</span> <span class="o">+</span> <span class="n">components</span><span class="p">:</span>
        <span class="n">classes</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">bases</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span><span class="o">.</span><span class="n">_mix</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bases</span><span class="p">,</span> <span class="n">classes</span>


<span class="k">class</span> <span class="nc">_TopologyAttrContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class factory for receiving sets of :class:`TopologyAttr` objects.</span>

<span class="sd">    :class:`_TopologyAttrContainer` is a convenience class to encapsulate the</span>
<span class="sd">    functions that deal with:</span>
<span class="sd">    * the import and namespace transplant of</span>
<span class="sd">      :class:`~MDAnalysis.core.topologyattrs.TopologyAttr` objects;</span>
<span class="sd">    * the copying (subclassing) of itself to create distinct bases for the</span>
<span class="sd">      different container classes (:class:`AtomGroup`, :class:`ResidueGroup`,</span>
<span class="sd">      :class:`SegmentGroup`, :class:`Atom`, :class:`Residue`, :class:`Segment`,</span>
<span class="sd">      and subclasses thereof);</span>
<span class="sd">    * the mixing (subclassing and co-inheritance) with the container classes.</span>
<span class="sd">      The mixed subclasses become the final container classes specific to each</span>
<span class="sd">      :class:`~MDAnalysis.core.universe.Universe`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_subclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">is_group</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Factory method returning :class:`_TopologyAttrContainer` subclasses.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        is_group : bool</span>
<span class="sd">            The :attr:`_is_group` of the returned class will be set to</span>
<span class="sd">            `is_group`. This is used to distinguish between Groups</span>
<span class="sd">            (:class:`AtomGroup` etc.) and Components (:class:`Atom` etc.) in</span>
<span class="sd">            internal methods when considering actions such as addition of</span>
<span class="sd">            objects or adding</span>
<span class="sd">            :class:`TopologyAttributes&lt;MDAnalysis.core.topologyattrs.TopologyAttr&gt;`</span>
<span class="sd">            to them.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            A subclass of :class:`_TopologyAttrContainer`, with the same name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newcls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="bp">cls</span><span class="p">,),</span> <span class="p">{</span><span class="s1">&#39;_is_group&#39;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">is_group</span><span class="p">)})</span>
        <span class="k">if</span> <span class="n">is_group</span><span class="p">:</span>
            <span class="n">newcls</span><span class="o">.</span><span class="n">_SETATTR_WHITELIST</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;positions&#39;</span><span class="p">,</span> <span class="s1">&#39;velocities&#39;</span><span class="p">,</span> <span class="s1">&#39;forces&#39;</span><span class="p">,</span> <span class="s1">&#39;dimensions&#39;</span><span class="p">,</span>
                <span class="s1">&#39;atoms&#39;</span><span class="p">,</span> <span class="s1">&#39;residue&#39;</span><span class="p">,</span> <span class="s1">&#39;residues&#39;</span><span class="p">,</span> <span class="s1">&#39;segment&#39;</span><span class="p">,</span> <span class="s1">&#39;segments&#39;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newcls</span><span class="o">.</span><span class="n">_SETATTR_WHITELIST</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="s1">&#39;velocity&#39;</span><span class="p">,</span> <span class="s1">&#39;force&#39;</span><span class="p">,</span> <span class="s1">&#39;dimensions&#39;</span><span class="p">,</span>
                <span class="s1">&#39;atoms&#39;</span><span class="p">,</span> <span class="s1">&#39;residue&#39;</span><span class="p">,</span> <span class="s1">&#39;residues&#39;</span><span class="p">,</span> <span class="s1">&#39;segment&#39;</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="n">newcls</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_mix</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a subclass with ourselves and another class as parents.</span>

<span class="sd">        Classes mixed at this point override :meth:`__new__`, causing further</span>
<span class="sd">        instantiations to shortcut to :meth:`~object.__new__` (skipping the</span>
<span class="sd">        cache-fetch process for :class:`_MutableBase` subclasses).</span>

<span class="sd">        The new class will have an attribute `_derived_class` added, pointing</span>
<span class="sd">        to itself. This pointer instructs which class to use when</span>
<span class="sd">        slicing/adding instances of the new class. At initialization time, the</span>
<span class="sd">        new class may choose to point `_derived_class` to another class (as is</span>
<span class="sd">        done in the initialization of :class:`UpdatingAtomGroup`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : type</span>
<span class="sd">            The class to mix with ourselves.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            A class of parents :class:`_ImmutableBase`, *other* and this class.</span>
<span class="sd">            Its name is the same as *other*&#39;s.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newcls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="n">_ImmutableBase</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span> <span class="p">{})</span>
        <span class="n">newcls</span><span class="o">.</span><span class="n">_derived_class</span> <span class="o">=</span> <span class="n">newcls</span>
        <span class="k">return</span> <span class="n">newcls</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_prop</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add `attr` into the namespace for this class</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attr : A :class:`TopologyAttr` object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">getter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_group</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">attrname</span><span class="p">,</span>
                    <span class="nb">property</span><span class="p">(</span><span class="n">getter</span><span class="p">,</span> <span class="n">setter</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">groupdoc</span><span class="p">))</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_SETATTR_WHITELIST</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">attrname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">singular</span><span class="p">,</span>
                    <span class="nb">property</span><span class="p">(</span><span class="n">getter</span><span class="p">,</span> <span class="n">setter</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">singledoc</span><span class="p">))</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_SETATTR_WHITELIST</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">singular</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_del_prop</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove `attr` from the namespace for this class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attr : A :class:`TopologyAttr` object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">suppress</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">):</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">attrname</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">suppress</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">):</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">singular</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_SETATTR_WHITELIST</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">attrname</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_SETATTR_WHITELIST</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">singular</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># `ag.this = 42` calls setattr(ag, &#39;this&#39;, 42)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span>  <span class="c1"># &#39;private&#39; allowed</span>
                <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SETATTR_WHITELIST</span> <span class="ow">or</span>  <span class="c1"># known attributes allowed</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)):</span>  <span class="c1"># preexisting (eg properties) allowed</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot set arbitrary attributes to a </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s1">&#39;Group&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_group</span> <span class="k">else</span> <span class="s1">&#39;Component&#39;</span><span class="p">))</span>
        <span class="c1"># if it is, we allow the setattr to proceed by deferring to the super</span>
        <span class="c1"># behaviour (ie do it)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_TopologyAttrContainer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_MutableBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class that merges appropriate :class:`_TopologyAttrContainer` classes.</span>

<span class="sd">    Implements :meth:`__new__`. In it the instantiating class is fetched from</span>
<span class="sd">    :attr:`~MDAnalysis.core.universe.Universe._classes`. If there is a cache</span>
<span class="sd">    miss, a merged class is made</span>
<span class="sd">    with a base from :attr:`~MDAnalysis.core.universe.Universe._class_bases`</span>
<span class="sd">    and cached.</span>

<span class="sd">    The classes themselves are used as the cache dictionary keys for simplcity</span>
<span class="sd">    in cache retrieval.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># This pre-initialization wrapper must be pretty generic to</span>
        <span class="c1"># allow for different initialization schemes of the possible classes.</span>
        <span class="c1"># All we really need here is to fish a universe out of the arg list.</span>
        <span class="c1"># The AtomGroup cases get priority and are fished out first.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">universe</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># older AtomGroup init method..</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">universe</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">.universe</span> <span class="kn">import</span> <span class="n">Universe</span>
                <span class="c1"># Let&#39;s be generic and get the first argument that&#39;s either a</span>
                <span class="c1"># Universe, a Group, or a Component, and go from there.</span>
                <span class="c1"># This is where the UpdatingAtomGroup args get matched.</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="o">+</span><span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">Universe</span><span class="p">,</span> <span class="n">GroupBase</span><span class="p">,</span>
                                        <span class="n">ComponentBase</span><span class="p">)):</span>
                        <span class="n">u</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">universe</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No universe, or universe-containing object &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;passed to the initialization of </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_classes</span><span class="p">[</span><span class="bp">cls</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Cache miss. Let&#39;s find which kind of class this is and merge.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">parent_cls</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_class_bases</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>
                                  <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mro</span><span class="p">()</span>
                                  <span class="k">if</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">_class_bases</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attempted to instantiate class &#39;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;but none of its parents are known to the universe.&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot; Currently possible parent classes are: &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_class_bases</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
            <span class="n">newcls</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">_classes</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent_cls</span><span class="o">.</span><span class="n">_mix</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">newcls</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="n">selfcls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">_TOPOLOGY_TRANSPLANTS</span><span class="p">:</span>
            <span class="n">topattr</span><span class="p">,</span> <span class="n">meth</span><span class="p">,</span> <span class="n">clstype</span> <span class="o">=</span> <span class="n">_TOPOLOGY_TRANSPLANTS</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
                <span class="n">attrname</span> <span class="o">=</span> <span class="n">attr</span>
                <span class="n">attrtype</span> <span class="o">=</span> <span class="s1">&#39;property&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attrname</span> <span class="o">=</span> <span class="n">attr</span> <span class="o">+</span> <span class="s1">&#39;()&#39;</span>
                <span class="n">attrtype</span> <span class="o">=</span> <span class="s1">&#39;method&#39;</span>

            <span class="c1"># property of wrong group/component</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clstype</span><span class="p">):</span>
                <span class="n">mname</span> <span class="o">=</span> <span class="s1">&#39;property&#39;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="nb">property</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;method&#39;</span>
                <span class="n">err</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{attr}</span><span class="s1"> is a </span><span class="si">{method}</span><span class="s1"> of </span><span class="si">{clstype}</span><span class="s1">, not </span><span class="si">{selfcls}</span><span class="s1">&#39;</span>
                <span class="n">clsname</span> <span class="o">=</span> <span class="n">clstype</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">if</span> <span class="n">clsname</span> <span class="o">==</span> <span class="s1">&#39;GroupBase&#39;</span><span class="p">:</span>
                    <span class="n">clsname</span> <span class="o">=</span> <span class="n">selfcls</span> <span class="o">+</span> <span class="s1">&#39;Group&#39;</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="n">attrname</span><span class="p">,</span>
                                                <span class="n">method</span><span class="o">=</span><span class="n">attrtype</span><span class="p">,</span>
                                                <span class="n">clstype</span><span class="o">=</span><span class="n">clsname</span><span class="p">,</span>
                                                <span class="n">selfcls</span><span class="o">=</span><span class="n">selfcls</span><span class="p">))</span>
            <span class="c1"># missing required topologyattr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{selfcls}</span><span class="s1">.</span><span class="si">{attrname}</span><span class="s1"> not available; &#39;</span>
                       <span class="s1">&#39;this requires </span><span class="si">{topattr}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">selfcls</span><span class="o">=</span><span class="n">selfcls</span><span class="p">,</span>
                                             <span class="n">attrname</span><span class="o">=</span><span class="n">attrname</span><span class="p">,</span>
                                             <span class="n">topattr</span><span class="o">=</span><span class="n">topattr</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">clean</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">err</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{selfcls}</span><span class="s1"> has no attribute </span><span class="si">{attr}</span><span class="s1">. &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">selfcls</span><span class="o">=</span><span class="n">selfcls</span><span class="p">,</span>
                                                               <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">clean</span> <span class="ow">in</span> <span class="n">_TOPOLOGY_ATTRNAMES</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">_TOPOLOGY_ATTRNAMES</span><span class="p">[</span><span class="n">clean</span><span class="p">]</span>
                <span class="n">err</span> <span class="o">+=</span> <span class="s1">&#39;Did you mean </span><span class="si">{match}</span><span class="s1">?&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typename</span><span class="p">,</span> <span class="n">outside</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get bonded connections between atoms as a</span>
<span class="sd">        :class:`~MDAnalysis.core.topologyobjects.TopologyGroup`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typename : str</span>
<span class="sd">            group name. One of {&quot;bonds&quot;, &quot;angles&quot;, &quot;dihedrals&quot;,</span>
<span class="sd">            &quot;impropers&quot;, &quot;ureybradleys&quot;, &quot;cmaps&quot;}</span>
<span class="sd">        outside : bool (optional)</span>
<span class="sd">            Whether to include connections involving atoms outside</span>
<span class="sd">            this group.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TopologyGroup</span>
<span class="sd">            containing the bonded group of choice, i.e. bonds, angles,</span>
<span class="sd">            dihedrals, impropers, ureybradleys or cmaps.</span>

<span class="sd">        .. versionadded:: 1.1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># AtomGroup has handy error messages for missing attributes</span>
        <span class="n">ugroup</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">typename</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ugroup</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ugroup</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span> <span class="k">if</span> <span class="n">outside</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># if self is an Atom</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">ugroup</span><span class="o">.</span><span class="n">_bix</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">seen</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ugroup</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_ImmutableBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class used to shortcut :meth:`__new__` to :meth:`object.__new__`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># When mixed via _TopologyAttrContainer._mix this class has MRO priority.</span>
    <span class="c1">#  Setting __new__ like this will avoid having to go through the</span>
    <span class="c1">#  cache lookup if the class is reused (as in ag._derived_class(...)).</span>
    <span class="fm">__new__</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span>


<span class="k">def</span> <span class="nf">_pbc_to_wrap</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raises deprecation warning if &#39;pbc&#39; is set and assigns value to &#39;wrap&#39;&quot;&quot;&quot;</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pbc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The &#39;pbc&#39; kwarg has been deprecated and will be &quot;</span>
                          <span class="s2">&quot;removed in version 3.0., &quot;</span>
                          <span class="s2">&quot;please use &#39;wrap&#39; instead&quot;</span><span class="p">,</span>
                          <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;wrap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pbc&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapped</span>


<span class="k">def</span> <span class="nf">check_wrap_and_unwrap</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raises ValueError when both &#39;wrap&#39; and &#39;unwrap&#39; are set to True&quot;&quot;&quot;</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;unwrap&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;both &#39;wrap&#39; and &#39;unwrap&#39; can not be set to true&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapped</span>


<span class="k">def</span> <span class="nf">_only_same_level</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">ComponentBase</span><span class="p">,</span> <span class="n">GroupBase</span><span class="p">)):</span>  <span class="c1"># sanity check</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t perform &#39;</span><span class="si">{}</span><span class="s2">&#39; between objects:&quot;</span>
                            <span class="s2">&quot; &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t perform &#39;</span><span class="si">{}</span><span class="s2">&#39; on different level objects&quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">universe</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t operate on objects from different Universes&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapped</span>


<span class="k">class</span> <span class="nc">GroupBase</span><span class="p">(</span><span class="n">_MutableBase</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Base class from which a :class:`&lt;~MDAnalysis.core.universe.Universe`\ &#39;s</span>
<span class="sd">    Group class is built.</span>

<span class="sd">    Instances of :class:`GroupBase` provide the following operations that</span>
<span class="sd">    conserve element repetitions and order:</span>

<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | Operation                     | Equivalent | Result                     |</span>
<span class="sd">    +===============================+============+============================+</span>
<span class="sd">    | ``len(s)``                    |            | number of elements (atoms, |</span>
<span class="sd">    |                               |            | residues or segment) in    |</span>
<span class="sd">    |                               |            | the group                  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s == t``                    |            | test if ``s`` and ``t``    |</span>
<span class="sd">    |                               |            | contain the same elements  |</span>
<span class="sd">    |                               |            | in the same order          |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``x in s``                    |            | test if component ``x`` is |</span>
<span class="sd">    |                               |            | part of group ``s``        |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.concatenate(t)``          | ``s + t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | from ``s`` and from ``t``  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.subtract(t)``             |            | new Group with elements    |</span>
<span class="sd">    |                               |            | from ``s`` that are not    |</span>
<span class="sd">    |                               |            | in ``t``                   |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>

<span class="sd">    The following operations treat the Group as set. Any result will have any</span>
<span class="sd">    duplicate entries removed and the Group will be sorted.</span>

<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | Operation                     | Equivalent | Result                     |</span>
<span class="sd">    +===============================+============+============================+</span>
<span class="sd">    | ``s.isdisjoint(t)``           |            | ``True`` if ``s`` and      |</span>
<span class="sd">    |                               |            | ``t`` do not share         |</span>
<span class="sd">    |                               |            | elements                   |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.issubset(t)``             |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``s`` are part of ``t``    |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.is_strict_subset(t)``     |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``s`` are part of ``t``,   |</span>
<span class="sd">    |                               |            | and ``s != t``             |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.issuperset(t)``           |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``t`` are part of ``s``    |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.is_strict_superset(t)``   |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``t`` are part of ``s``,   |</span>
<span class="sd">    |                               |            | and ``s != t``             |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.union(t)``                | ``s | t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | from both ``s`` and ``t``  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.intersection(t)``         | ``s &amp; t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | common to ``s`` and ``t``  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.difference(t)``           | ``s - t``  | new Group with elements of |</span>
<span class="sd">    |                               |            | ``s`` that are not in ``t``|</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.symmetric_difference(t)`` | ``s ^ t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | that are part of ``s`` or  |</span>
<span class="sd">    |                               |            | ``t`` but not both         |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># list of atoms/res/segs, old init method</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="p">[</span><span class="n">at</span><span class="o">.</span><span class="n">ix</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">universe</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># current/new init method</span>
                <span class="n">ix</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span>  <span class="c1"># couldn&#39;t find ix/universe</span>
                <span class="ne">TypeError</span><span class="p">):</span>  <span class="c1"># couldn&#39;t iterate the object we got</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Can only initialise a Group from an iterable of Atom/Residue/&quot;</span>
                <span class="s2">&quot;Segment objects eg: AtomGroup([Atom1, Atom2, Atom3]) &quot;</span>
                <span class="s2">&quot;or an iterable of indices and a Universe reference &quot;</span>
                <span class="s2">&quot;eg: AtomGroup([0, 5, 7, 8], u).&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

        <span class="c1"># indices for the objects I hold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">u</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="o">.</span><span class="n">tolist</span><span class="p">())))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="c1"># supports</span>
        <span class="c1"># - integer access</span>
        <span class="c1"># - boolean slicing</span>
        <span class="c1"># - fancy indexing</span>
        <span class="c1"># because our _ix attribute is a numpy array</span>
        <span class="c1"># it can be sliced by all of these already,</span>
        <span class="c1"># so just return ourselves sliced by the item</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;None cannot be used to index a group.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">singular</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">item</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="p">:</span>  <span class="c1"># check for empty list</span>
                <span class="c1"># hack to make lists into numpy arrays</span>
                <span class="c1"># important for boolean slicing</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="c1"># We specify _derived_class instead of self.__class__ to allow</span>
            <span class="c1"># subclasses, such as UpdatingAtomGroup, to control the class</span>
            <span class="c1"># resulting from slicing.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">item</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="n">selfcls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">_TOPOLOGY_ATTRS</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">_TOPOLOGY_ATTRS</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">singular</span> <span class="ow">and</span> <span class="n">attr</span> <span class="o">!=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">attrname</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{selfcls}</span><span class="s1"> has no attribute </span><span class="si">{attr}</span><span class="s1">. &#39;</span>
                       <span class="s1">&#39;Do you mean </span><span class="si">{plural}</span><span class="s1">?&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">selfcls</span><span class="o">=</span><span class="n">selfcls</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span>
                                                <span class="n">plural</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">attrname</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="s1">&#39;This Universe does not contain </span><span class="si">{singular}</span><span class="s1"> information&#39;</span>
                <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">singular</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">singular</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">GroupBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">Group with </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}{}</span><span class="s2">&gt;&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span>
                          <span class="s2">&quot;s&quot;</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:]))</span>  <span class="c1"># Shorthand for a conditional plural &#39;s&#39;.</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{}</span><span class="s1">Group </span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">(),</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{}</span><span class="s1">Group </span><span class="si">{}</span><span class="s1">, ..., </span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">(),</span>
                                                  <span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)[:</span><span class="mi">3</span><span class="p">])[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                  <span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Concatenate the Group with another Group or Component of the same</span>
<span class="sd">        level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with elements of `self` and `other` concatenated</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Using built-in sum requires supporting 0 + self. If other is</span>
<span class="sd">        anything other 0, an exception will be raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : int</span>
<span class="sd">            Other should be 0, or else an exception will be raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>
<span class="sd">            Group with elements of `self` reproduced</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unsupported operand type(s) for +:&quot;</span>
                            <span class="s2">&quot; &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test group equality.</span>

<span class="sd">        Two groups are equal if they contain the same indices in</span>
<span class="sd">        the same order. Groups that are not at the same level or that belong</span>
<span class="sd">        to different :class:`Universes&lt;MDAnalysis.core.universe.Universe&gt;`</span>
<span class="sd">        cannot be compared.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
            <span class="c1"># maybe raise TypeError instead?</span>
            <span class="c1"># eq method raises Error for wrong comparisons</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">ix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The underlying :class:`~MDAnalysis.core.universe.Universe` the group</span>
<span class="sd">        belongs to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unique indices of the components in the Group.</span>

<span class="sd">        - If this Group is an :class:`AtomGroup`, these are the</span>
<span class="sd">          indices of the :class:`Atom` instances.</span>
<span class="sd">        - If it is a :class:`ResidueGroup`, these are the indices of</span>
<span class="sd">          the :class:`Residue` instances.</span>
<span class="sd">        - If it is a :class:`SegmentGroup`, these are the indices of</span>
<span class="sd">          the :class:`Segment` instances.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ix_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unique indices of the components in the Group.</span>

<span class="sd">        For a Group, :attr:`ix_array` is the same as :attr:`ix`. This method</span>
<span class="sd">        gives a consistent API between components and groups.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :attr:`ix`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Obtain a copy of the dimensions of the currently loaded Timestep&quot;&quot;&quot;</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dims</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dims</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@dimensions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">dimensions</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sorted_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">asunique</span><span class="p">(</span><span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">unsorted_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">asunique</span><span class="p">(</span><span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;issorted&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">issorted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">int_array_is_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;isunique&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">isunique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Boolean indicating whether all components of the group are unique,</span>
<span class="sd">        i.e., the group contains no duplicates.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. testsetup:: GroupBase.isunique</span>

<span class="sd">            from MDAnalysis.tests.datafiles import PDB, XTC</span>
<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            u = mda.Universe(PDB, XTC)</span>

<span class="sd">        .. doctest:: GroupBase.isunique</span>

<span class="sd">            &gt;&gt;&gt; ag = u.atoms[[2, 1, 2, 2, 1, 0]]</span>
<span class="sd">            &gt;&gt;&gt; ag</span>
<span class="sd">            &lt;AtomGroup with 6 atoms&gt;</span>
<span class="sd">            &gt;&gt;&gt; ag.isunique</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; ag2 = ag.unique</span>
<span class="sd">            &gt;&gt;&gt; ag2</span>
<span class="sd">            &lt;AtomGroup with 3 atoms&gt;</span>
<span class="sd">            &gt;&gt;&gt; ag2.isunique</span>
<span class="sd">            True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asunique</span>


<span class="sd">        .. versionadded:: 0.19.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">unique_int_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_asunique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">set_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;sorted_unique&#39;</span> <span class="k">if</span> <span class="nb">sorted</span> <span class="k">else</span> <span class="s1">&#39;unsorted_unique&#39;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isunique</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">sorted</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">issorted</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="nb">sorted</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">set_mask</span><span class="p">:</span>
                <span class="n">unique_ix</span><span class="p">,</span> <span class="n">restore_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unique_restore_mask</span> <span class="o">=</span> <span class="n">restore_mask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_ix</span> <span class="o">=</span> <span class="n">unique_int_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

            <span class="n">_unique</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">unique_ix</span><span class="p">]</span>
            <span class="n">_unique</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">_unique</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">_unique</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unique</span>
            <span class="n">_unique</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unique</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unique</span>
            <span class="k">return</span> <span class="n">_unique</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">unique_int_1d_unsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">set_mask</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span> <span class="o">==</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">values</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unique_restore_mask</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="n">issorted</span> <span class="o">=</span> <span class="n">int_array_is_sorted</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">issorted</span> <span class="ow">and</span> <span class="s1">&#39;sorted_unique&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_unique</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_unique</span>

        <span class="n">_unique</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">_unique</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">_unique</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">issorted</span>
        <span class="n">_unique</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unique</span>
        <span class="k">if</span> <span class="n">issorted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unique</span>
            <span class="n">_unique</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unique</span>
        <span class="k">return</span> <span class="n">_unique</span>

    <span class="k">def</span> <span class="nf">_get_compound_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compound</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">compound</span> <span class="o">==</span> <span class="s1">&#39;residues&#39;</span><span class="p">:</span>
            <span class="n">compound_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">resindices</span>
        <span class="k">elif</span> <span class="n">compound</span> <span class="o">==</span> <span class="s1">&#39;segments&#39;</span><span class="p">:</span>
            <span class="n">compound_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">segindices</span>
        <span class="k">elif</span> <span class="n">compound</span> <span class="o">==</span> <span class="s1">&#39;molecules&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">compound_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">molnums</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Cannot use compound=&#39;molecules&#39;: No molecule &quot;</span>
                          <span class="s2">&quot;information in topology.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">compound</span> <span class="o">==</span> <span class="s1">&#39;fragments&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">compound_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">fragindices</span>
            <span class="k">except</span> <span class="n">NoDataError</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Cannot use compound=&#39;fragments&#39;: No bond &quot;</span>
                          <span class="s2">&quot;information in topology.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">compound</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This method does not accept compound=&#39;group&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized compound definition: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">Please use&quot;</span>
                             <span class="s2">&quot; one of &#39;residues&#39;, &#39;segments&#39;, &#39;molecules&#39;,&quot;</span>
                             <span class="s2">&quot; or &#39;fragments&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">compound</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">compound_indices</span>

    <span class="k">def</span> <span class="nf">_split_by_compound_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compound</span><span class="p">,</span> <span class="n">stable_sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Splits a group&#39;s compounds into groups of equal compound size.</span>

<span class="sd">        Grouping equal sizes together facilitates subsequent vectorization.</span>

<span class="sd">        For a 10-atom molecule with atoms organized into compounds C0 through</span>
<span class="sd">        C2::</span>

<span class="sd">           at.id:  0  1  2  3  4  5  6  7  8  9</span>
<span class="sd">        compound: C0 C0 C0 C0 C1 C1 C2 C2 C2 C2</span>

<span class="sd">        this function will yield an `atom_masks` list with two submasks: one</span>
<span class="sd">        for compounds of size 2 and one for compounds of size 4:</span>
<span class="sd">        [array([[4, 5]]),</span>
<span class="sd">         array([[1, 2, 3, 0],</span>
<span class="sd">                [8, 7, 6, 9]])]</span>

<span class="sd">        (Note that atom order within component submasks may be lost unless a</span>
<span class="sd">        `stable_sort` is requested)</span>
<span class="sd">        These submasks can be used directly to fancy-index arrays of the same</span>
<span class="sd">        length as self (including :class:`AtomGroups&lt;AtomGroup&gt;`).</span>

<span class="sd">        This function also returns `compound_masks`, the boolean mapping of</span>
<span class="sd">        each of the `atom_masks` submask into the original compound order::</span>
<span class="sd">        [array([False,  True, False]),</span>
<span class="sd">         array([ True, False,  True])]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compound : {&#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;}</span>
<span class="sd">            The compound type to base splitting on.</span>
<span class="sd">        stable_sort : bool, optional</span>
<span class="sd">            Whether to ensure that, when needed, sorting does not affect an</span>
<span class="sd">            atom&#39;s order within a compound (at a cost to performance). E.g.,</span>
<span class="sd">            for an unwrap operation it is important that the first atom of a</span>
<span class="sd">            compound is always the same, whereas a center-of-geometry</span>
<span class="sd">            computation wouldn&#39;t care.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        atom_masks : list of numpy.ndarray</span>
<span class="sd">            Integer masks for fancy-indexing atoms/weights lists; masks are</span>
<span class="sd">            already shaped as ``(number of compounds of a given size,</span>
<span class="sd">            compound_size)``.</span>
<span class="sd">        compound_masks : list of numpy.ndarray</span>
<span class="sd">            1D boolean masks for fancy-indexing lists of compounds. Translate</span>
<span class="sd">            the distribution of the compounds in each mask of `atom_masks` into</span>
<span class="sd">            their original order.</span>
<span class="sd">        n_compounds : int</span>
<span class="sd">            The number of individual compounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Caching would help here, especially when repeating the operation</span>
        <span class="c1"># over different frames, since these masks are coordinate-independent.</span>
        <span class="c1"># However, cache must be invalidated whenever new compound indices are</span>
        <span class="c1"># modified, which is not yet implemented.</span>
        <span class="c1"># Also, should we include here the grouping for &#39;group&#39;, which is</span>
        <span class="c1"># essentially a non-split?</span>

        <span class="n">compound_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_compound_indices</span><span class="p">(</span><span class="n">compound</span><span class="p">)</span>
        <span class="n">compound_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">compound_indices</span><span class="p">)</span>
        <span class="n">size_per_atom</span> <span class="o">=</span> <span class="n">compound_sizes</span><span class="p">[</span><span class="n">compound_indices</span><span class="p">]</span>
        <span class="n">compound_sizes</span> <span class="o">=</span> <span class="n">compound_sizes</span><span class="p">[</span><span class="n">compound_sizes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">unique_compound_sizes</span> <span class="o">=</span> <span class="n">unique_int_1d</span><span class="p">(</span><span class="n">compound_sizes</span><span class="p">)</span>

        <span class="c1"># Are we already sorted? argsorting and fancy-indexing can be expensive</span>
        <span class="c1"># so we do a quick pre-check.</span>
        <span class="n">needs_sorting</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">compound_indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">needs_sorting</span><span class="p">:</span>
            <span class="c1"># stable sort ensures reproducibility, especially concerning who</span>
            <span class="c1"># gets to be a compound&#39;s atom[0] and be a reference for unwrap.</span>
            <span class="k">if</span> <span class="n">stable_sort</span><span class="p">:</span>
                <span class="n">sort_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">compound_indices</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Quicksort</span>
                <span class="n">sort_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">compound_indices</span><span class="p">)</span>
            <span class="c1"># We must sort size_per_atom accordingly (Issue #3352).</span>
            <span class="n">size_per_atom</span> <span class="o">=</span> <span class="n">size_per_atom</span><span class="p">[</span><span class="n">sort_indices</span><span class="p">]</span>

        <span class="n">compound_masks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">atom_masks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">compound_size</span> <span class="ow">in</span> <span class="n">unique_compound_sizes</span><span class="p">:</span>
            <span class="n">compound_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compound_sizes</span> <span class="o">==</span> <span class="n">compound_size</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">needs_sorting</span><span class="p">:</span>
                <span class="n">atom_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_indices</span><span class="p">[</span><span class="n">size_per_atom</span> <span class="o">==</span> <span class="n">compound_size</span><span class="p">]</span>
                                   <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">compound_size</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">atom_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">size_per_atom</span> <span class="o">==</span> <span class="n">compound_size</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                                   <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">compound_size</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">atom_masks</span><span class="p">,</span> <span class="n">compound_masks</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">compound_sizes</span><span class="p">)</span>

    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@_pbc_to_wrap</span>
    <span class="nd">@check_wrap_and_unwrap</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Weighted center of (compounds of) the group</span>

<span class="sd">        Computes the weighted center of :class:`Atoms&lt;Atom&gt;` in the group.</span>
<span class="sd">        Weighted centers per :class:`Residue`, :class:`Segment`, molecule, or</span>
<span class="sd">        fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly. If the weights of a compound sum up to zero, the</span>
<span class="sd">        coordinates of that compound&#39;s weighted center will be ``nan`` (not a</span>
<span class="sd">        number).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weights : array_like or None</span>
<span class="sd">            Weights to be used. Setting `weights=None` is equivalent to passing</span>
<span class="sd">            identical weights for all atoms of the group.</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True`` and `compound` is ``&#39;group&#39;``, move all atoms to the</span>
<span class="sd">            primary unit cell before calculation.</span>
<span class="sd">            If ``True`` and `compound` is not ``&#39;group&#39;`` the center of each</span>
<span class="sd">            compound will be calculated without moving any</span>
<span class="sd">            :class:`Atoms&lt;Atom&gt;` to keep the compounds intact. Instead, the</span>
<span class="sd">            resulting position vectors will be moved to the primary unit cell</span>
<span class="sd">            after calculation. Default [``False``].</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their</span>
<span class="sd">             centers.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;}, optional</span>
<span class="sd">            If ``&#39;group&#39;``, the weighted center of all atoms in the group will</span>
<span class="sd">            be returned as a single position vector. Else, the weighted centers</span>
<span class="sd">            of each :class:`Segment`, :class:`Residue`, molecule, or fragment</span>
<span class="sd">            will be returned as an array of position vectors, i.e. a 2d array.</span>
<span class="sd">            Note that, in any case, *only* the positions of :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">            *belonging to the group* will be taken into account.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        center : numpy.ndarray</span>
<span class="sd">            Position vector(s) of the weighted center(s) of the group.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            position vector.</span>
<span class="sd">            If `compound` was set to ``&#39;segments&#39;``, ``&#39;residues&#39;``,</span>
<span class="sd">            ``&#39;molecules&#39;``, or ``&#39;fragments&#39;``, the output will be a 2d array</span>
<span class="sd">            of shape ``(n, 3)`` where ``n`` is the number of compounds.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `compound` is not one of ``&#39;group&#39;``, ``&#39;segments&#39;``,</span>
<span class="sd">            ``&#39;residues&#39;``, ``&#39;molecules&#39;``, or ``&#39;fragments&#39;``.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If both &#39;wrap&#39; and &#39;unwrap&#39; set to true.</span>
<span class="sd">        ~MDAnalysis.exceptions.NoDataError</span>
<span class="sd">            If `compound` is ``&#39;molecule&#39;`` but the topology doesn&#39;t</span>
<span class="sd">            contain molecule information (molnums) or if `compound` is</span>
<span class="sd">            ``&#39;fragments&#39;`` but the topology doesn&#39;t contain bonds.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        To find the center of charge of a given :class:`AtomGroup`:</span>

<span class="sd">        .. testsetup:: GroupBase.center</span>

<span class="sd">            from MDAnalysis.tests.datafiles import PDB, XTC</span>
<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            u = mda.Universe(PSF, DCD)</span>

<span class="sd">        .. doctest:: GroupBase.center</span>

<span class="sd">            &gt;&gt;&gt; sel = u.select_atoms(&#39;prop mass &gt; 4.0&#39;)</span>
<span class="sd">            &gt;&gt;&gt; sel.center(sel.charges)</span>
<span class="sd">            array([-0.22925091, -0.04771193, -0.16728489])</span>

<span class="sd">        To find the centers of mass per residue of all CA :class:`Atoms&lt;Atom&gt;`:</span>

<span class="sd">        .. doctest:: GroupBase.center</span>
<span class="sd">           :options: +NORMALIZE_WHITESPACE</span>

<span class="sd">            &gt;&gt;&gt; sel = u.select_atoms(&#39;name CA&#39;)</span>
<span class="sd">            &gt;&gt;&gt; sel.center(sel.masses, compound=&#39;residues&#39;)</span>
<span class="sd">            array([[ 11.66462231,   8.39347267,  -8.98323059],</span>
<span class="sd">                  [ 11.41483879,   5.43442154,  -6.51348448],</span>
<span class="sd">                  [  8.95975494,   5.61292315,  -3.61323047],</span>
<span class="sd">                  [  8.29006767,   3.07599092,  -0.79665166],</span>
<span class="sd">                  [  5.01112604,   3.76389837,   1.130355  ],</span>
<span class="sd">                  ...</span>


<span class="sd">        .. versionchanged:: 0.19.0 Added `compound` parameter</span>
<span class="sd">        .. versionchanged:: 0.20.0 Added ``&#39;molecules&#39;`` and ``&#39;fragments&#39;``</span>
<span class="sd">            compounds</span>
<span class="sd">        .. versionchanged:: 0.20.0 Added `unwrap` parameter</span>
<span class="sd">        .. versionchanged:: 1.0.0 Removed flags affecting default behaviour</span>
<span class="sd">        .. versionchanged::</span>
<span class="sd">           2.1.0 Renamed `pbc` kwarg to `wrap`. `pbc` is still accepted but</span>
<span class="sd">           is deprecated and will be removed in version 3.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>

        <span class="c1"># enforce calculations in double precision:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

        <span class="n">comp</span> <span class="o">=</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">unwrap</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span>
                    <span class="n">compound</span><span class="o">=</span><span class="n">comp</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span>
            <span class="c1"># If there&#39;s no atom, return its (empty) coordinates unchanged.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">coords</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># promote coords to dtype if required:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">coords</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># promote weights to dtype if required:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;j&#39;</span><span class="p">,</span><span class="n">coords</span><span class="p">,</span><span class="n">weights</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">/</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># When compound split caching gets implemented it will be clever to</span>
        <span class="c1"># preempt at this point whether or not stable sorting will be needed</span>
        <span class="c1"># later for unwrap (so that we don&#39;t split now with non-stable sort,</span>
        <span class="c1"># only to have to re-split with stable sort if unwrap is requested).</span>
        <span class="p">(</span><span class="n">atom_masks</span><span class="p">,</span>
         <span class="n">compound_masks</span><span class="p">,</span>
         <span class="n">n_compounds</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_by_compound_indices</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>

        <span class="c1"># Unwrap Atoms</span>
        <span class="k">if</span> <span class="n">unwrap</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">compound</span><span class="o">=</span><span class="n">comp</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Allocate output array:</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_compounds</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Compute centers per compound for each compound size:</span>
        <span class="k">for</span> <span class="n">compound_mask</span><span class="p">,</span> <span class="n">atom_mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">compound_masks</span><span class="p">,</span> <span class="n">atom_masks</span><span class="p">):</span>
            <span class="n">_coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">atom_mask</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_centers</span> <span class="o">=</span> <span class="n">_coords</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">atom_mask</span><span class="p">]</span>
                <span class="n">_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ijk-&gt;ik&#39;</span><span class="p">,</span><span class="n">_coords</span><span class="p">,</span><span class="n">_weights</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">])</span>
                <span class="n">_centers</span> <span class="o">/=</span> <span class="n">_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">centers</span><span class="p">[</span><span class="n">compound_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">_centers</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">apply_PBC</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">atoms</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">centers</span>

    <span class="nd">@warn_if_not_unique</span>
    <span class="nd">@_pbc_to_wrap</span>
    <span class="nd">@check_wrap_and_unwrap</span>
    <span class="k">def</span> <span class="nf">center_of_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Center of geometry of (compounds of) the group</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol R = \frac{\sum_i \boldsymbol r_i}{\sum_i 1}</span>

<span class="sd">        where :math:`\boldsymbol r_i` of :class:`Atoms&lt;Atom&gt;` :math:`i`.</span>
<span class="sd">        Centers of geometry per :class:`Residue` or per :class:`Segment` can</span>
<span class="sd">        be obtained by setting the `compound` parameter accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True`` and `compound` is ``&#39;group&#39;``, move all atoms to the</span>
<span class="sd">            primary unit cell before calculation. If ``True`` and `compound` is</span>
<span class="sd">            ``&#39;segments&#39;`` or ``&#39;residues&#39;``, the center of each compound will</span>
<span class="sd">            be calculated without moving any :class:`Atoms&lt;Atom&gt;` to keep the</span>
<span class="sd">            compounds intact. Instead, the resulting position vectors will be</span>
<span class="sd">            moved to the primary unit cell after calculation. Default False.</span>
<span class="sd">        unwrap : bool, optional</span>
<span class="sd">            If ``True``, compounds will be unwrapped before computing their</span>
<span class="sd">            centers.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;}, optional</span>
<span class="sd">            If ``&#39;group&#39;``, the center of geometry of all :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">            in the group will be returned as a single position vector. Else,</span>
<span class="sd">            the centers of geometry of each :class:`Segment` or</span>
<span class="sd">            :class:`Residue` will be returned as an array of position vectors,</span>
<span class="sd">            i.e. a 2d array. Note that, in any case, *only* the positions of</span>
<span class="sd">            :class:`Atoms&lt;Atom&gt;` *belonging to the group* will be taken into</span>
<span class="sd">            account.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        center : numpy.ndarray</span>
<span class="sd">            Position vector(s) of the geometric center(s) of the group.</span>
<span class="sd">            If `compound` was set to ``&#39;group&#39;``, the output will be a single</span>
<span class="sd">            position vector.</span>
<span class="sd">            If `compound` was set to ``&#39;segments&#39;`` or ``&#39;residues&#39;``, the</span>
<span class="sd">            output will be a 2d array of shape ``(n, 3)`` where ``n`` is the</span>
<span class="sd">            number of compounds.</span>


<span class="sd">        .. versionchanged:: 0.8 Added `pbc` keyword</span>
<span class="sd">        .. versionchanged:: 0.19.0 Added `compound` parameter</span>
<span class="sd">        .. versionchanged:: 0.20.0 Added ``&#39;molecules&#39;`` and ``&#39;fragments&#39;``</span>
<span class="sd">            compounds</span>
<span class="sd">        .. versionchanged:: 0.20.0 Added `unwrap` parameter</span>
<span class="sd">        .. versionchanged:: 1.0.0 Removed flags affecting default behaviour</span>
<span class="sd">        .. versionchanged::</span>
<span class="sd">           2.1.0 Renamed `pbc` kwarg to `wrap`. `pbc` is still accepted but</span>
<span class="sd">           is deprecated and will be removed in version 3.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">compound</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">)</span>

    <span class="n">centroid</span> <span class="o">=</span> <span class="n">center_of_geometry</span>

    <span class="nd">@warn_if_not_unique</span>
    <span class="k">def</span> <span class="nf">accumulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Accumulates the attribute associated with (compounds of) the group.</span>

<span class="sd">        Accumulates the attribute of :class:`Atoms&lt;Atom&gt;` in the group.</span>
<span class="sd">        The accumulation per :class:`Residue`, :class:`Segment`, molecule,</span>
<span class="sd">        or fragment can be obtained by setting the `compound` parameter</span>
<span class="sd">        accordingly. By default, the method sums up all attributes per compound,</span>
<span class="sd">        but any function that takes an array and returns an acuumulation over a</span>
<span class="sd">        given axis can be used. For multi-dimensional input arrays, the</span>
<span class="sd">        accumulation is performed along the first axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute : str or array_like</span>
<span class="sd">            Attribute or array of values to accumulate.</span>
<span class="sd">            If a :class:`numpy.ndarray` (or compatible) is provided, its first</span>
<span class="sd">            dimension must have the same length as the total number of atoms in</span>
<span class="sd">            the group.</span>
<span class="sd">        function : callable, optional</span>
<span class="sd">            The function performing the accumulation. It must take the array of</span>
<span class="sd">            attribute values to accumulate as its only positional argument and</span>
<span class="sd">            accept an (optional) keyword argument ``axis`` allowing to specify</span>
<span class="sd">            the axis along which the accumulation is performed.</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, &#39;fragments&#39;},\</span>
<span class="sd">                   optional</span>
<span class="sd">            If ``&#39;group&#39;``, the accumulation of all attributes associated with</span>
<span class="sd">            atoms in the group will be returned as a single value. Otherwise,</span>
<span class="sd">            the accumulation of the attributes per :class:`Segment`,</span>
<span class="sd">            :class:`Residue`, molecule, or fragment will be returned as a 1d</span>
<span class="sd">            array. Note that, in any case, *only* the :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">            *belonging to the group* will be taken into account.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or numpy.ndarray</span>
<span class="sd">            Acuumulation of the `attribute`.</span>
<span class="sd">            If `compound` is set to ``&#39;group&#39;``, the first dimension of the</span>
<span class="sd">            `attribute` array will be contracted to a single value.</span>
<span class="sd">            If `compound` is set to ``&#39;segments&#39;``, ``&#39;residues&#39;``,</span>
<span class="sd">            ``&#39;molecules&#39;``, or ``&#39;fragments&#39;``, the length of the first</span>
<span class="sd">            dimension will correspond to the number of compounds. In all cases,</span>
<span class="sd">            the other dimensions of the returned array will be of the original</span>
<span class="sd">            shape (without the first dimension).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the length of a provided `attribute` array does not correspond to</span>
<span class="sd">            the number of atoms in the group.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `compound` is not one of ``&#39;group&#39;``, ``&#39;segments&#39;``,</span>
<span class="sd">            ``&#39;residues&#39;``, ``&#39;molecules&#39;``, or ``&#39;fragments&#39;``.</span>
<span class="sd">        ~MDAnalysis.exceptions.NoDataError</span>
<span class="sd">            If `compound` is ``&#39;molecule&#39;`` but the topology doesn&#39;t</span>
<span class="sd">            contain molecule information (molnums), or if `compound` is</span>
<span class="sd">            ``&#39;fragments&#39;`` but the topology doesn&#39;t contain bonds.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        To find the total charge of a given :class:`AtomGroup`:</span>

<span class="sd">        .. testsetup:: GroupBase.center</span>

<span class="sd">            from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            u = mda.Universe(PSF, DCD)</span>

<span class="sd">        .. doctest:: GroupBase.center</span>

<span class="sd">            &gt;&gt;&gt; sel = u.select_atoms(&#39;prop mass &gt; 4.0&#39;)</span>
<span class="sd">            &gt;&gt;&gt; sel.accumulate(&#39;charges&#39;)</span>
<span class="sd">            -251.68500316143036</span>

<span class="sd">        To find the total mass per residue of all CA :class:`Atoms&lt;Atom&gt;`:</span>

<span class="sd">        .. doctest:: GroupBase.center</span>
<span class="sd">           :options: +NORMALIZE_WHITESPACE</span>

<span class="sd">            &gt;&gt;&gt; sel = u.select_atoms(&#39;name CA&#39;)</span>
<span class="sd">            &gt;&gt;&gt; sel.accumulate(&#39;masses&#39;, compound=&#39;residues&#39;)</span>
<span class="sd">            array([12.011, 12.011, 12.011, 12.011, 12.011, 12.011, 12.011, 12.011,</span>
<span class="sd">                   12.011, 12.011, 12.011, 12.011, 12.011, 12.011, 12.011, 12.011,</span>
<span class="sd">                   12.011, 12.011, 12.011, 12.011, 12.011, 12.011, 12.011, 12.011,</span>
<span class="sd">                   12.011, 12.011, 12.011, 12.011, 12.011, 12.011, 12.011, 12.011,</span>
<span class="sd">                   12.011, 12.011, 12.011, 12.011, 12.011, 12.011, 12.011, 12.011,</span>
<span class="sd">                   ...</span>

<span class="sd">        To find the maximum atomic charge per fragment of a given</span>
<span class="sd">        :class:`AtomGroup`:</span>

<span class="sd">        .. doctest:: GroupBase.center</span>

<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; sel.accumulate(&#39;charges&#39;, compound=&quot;fragments&quot;, function=np.max)</span>
<span class="sd">            array([0.20999999])</span>


<span class="sd">        .. versionadded:: 0.20.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">attribute_values</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attribute_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribute_values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input array length (</span><span class="si">{}</span><span class="s2">) does not match &quot;</span>
                                 <span class="s2">&quot;the number of atoms (</span><span class="si">{}</span><span class="s2">) in the group.&quot;</span>
                                 <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">attribute_values</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)))</span>

        <span class="n">comp</span> <span class="o">=</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="n">attribute_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="p">(</span><span class="n">atom_masks</span><span class="p">,</span>
         <span class="n">compound_masks</span><span class="p">,</span>
         <span class="n">n_compounds</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_by_compound_indices</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>

        <span class="n">higher_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">attribute_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># Allocate output array:</span>
        <span class="c1"># (what dtype should this be?)</span>
        <span class="n">accumulation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">n_compounds</span><span class="p">]</span> <span class="o">+</span> <span class="n">higher_dims</span><span class="p">)</span>
        <span class="c1"># Apply the accumulation function per compound for each compound size:</span>
        <span class="k">for</span> <span class="n">compound_mask</span><span class="p">,</span> <span class="n">atom_mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">compound_masks</span><span class="p">,</span> <span class="n">atom_masks</span><span class="p">):</span>
            <span class="n">_elements</span> <span class="o">=</span> <span class="n">attribute_values</span><span class="p">[</span><span class="n">atom_mask</span><span class="p">]</span>
            <span class="n">_accumulation</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">_elements</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">accumulation</span><span class="p">[</span><span class="n">compound_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">_accumulation</span>
        <span class="k">return</span> <span class="n">accumulation</span>

    <span class="nd">@_pbc_to_wrap</span>
    <span class="k">def</span> <span class="nf">bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the bounding box of the selection.</span>

<span class="sd">        The lengths A,B,C of the orthorhombic enclosing box are ::</span>

<span class="sd">          L = AtomGroup.bbox()</span>
<span class="sd">          A,B,C = L[1] - L[0]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True``, move all :class:`Atoms&lt;Atom&gt;` to the primary unit cell</span>
<span class="sd">            before calculation. [``False``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">         corners : numpy.ndarray</span>
<span class="sd">            2x3 array giving corners of bounding box as</span>
<span class="sd">            ``[[xmin, ymin, zmin], [xmax, ymax, zmax]]``.</span>


<span class="sd">        .. versionadded:: 0.7.2</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        .. versionchanged:: 1.0.0 Removed flags affecting default behaviour</span>
<span class="sd">        .. versionchanged::</span>
<span class="sd">           2.1.0 Renamed `pbc` kwarg to `wrap`. `pbc` is still accepted but</span>
<span class="sd">           is deprecated and will be removed in version 3.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add unwrap/compounds treatment</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>

        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>

    <span class="nd">@_pbc_to_wrap</span>
    <span class="k">def</span> <span class="nf">bsphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the bounding sphere of the selection.</span>

<span class="sd">        The sphere is calculated relative to the</span>
<span class="sd">        :meth:`center of geometry&lt;center_of_geometry&gt;`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wrap : bool, optional</span>
<span class="sd">            If ``True``, move all atoms to the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R : float</span>
<span class="sd">            Radius of the bounding sphere.</span>
<span class="sd">        center : numpy.ndarray</span>
<span class="sd">            Coordinates of the sphere center as ``[xcen, ycen, zcen]``.</span>


<span class="sd">        .. versionadded:: 0.7.3</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        .. versionchanged::</span>
<span class="sd">           2.1.0 Renamed `pbc` kwarg to `wrap`. `pbc` is still accepted but</span>
<span class="sd">           is deprecated and will be removed in version 3.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">unsorted_unique</span>

        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_geometry</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_geometry</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">centroid</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply homogenous transformation matrix `M` to the coordinates.</span>

<span class="sd">        :class:`Atom` coordinates are rotated and translated in-place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        M : array_like</span>
<span class="sd">            4x4 matrix with the rotation in ``R = M[:3, :3]`` and the</span>
<span class="sd">            translation in ``t = M[:3, 3]``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        MDAnalysis.lib.transformations : module of all coordinate transforms</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The rotation :math:`\mathsf{R}` is about the origin and is applied</span>
<span class="sd">        before the translation :math:`\mathbf{t}`:</span>

<span class="sd">        .. math::</span>

<span class="sd">           \mathbf{x}&#39; = \mathsf{R}\mathbf{x} + \mathbf{t}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply translation vector `t` to the selection&#39;s coordinates.</span>

<span class="sd">        :class:`Atom` coordinates are translated in-place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : array_like</span>
<span class="sd">            vector to translate coordinates with</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        MDAnalysis.lib.transformations : module of all coordinate transforms</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The method applies a translation to the :class:`AtomGroup`</span>
<span class="sd">        from current coordinates :math:`\mathbf{x}` to new coordinates</span>
<span class="sd">        :math:`\mathbf{x}&#39;`:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathbf{x}&#39; = \mathbf{x} + \mathbf{t}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">unsorted_unique</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="c1"># changes the coordinates in place</span>
        <span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">+=</span> <span class="n">vector</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a rotation matrix `R` to the selection&#39;s coordinates.</span>
<span class="sd">        :math:`\mathsf{R}` is a 3x3 orthogonal matrix that transforms a vector</span>
<span class="sd">        :math:`\mathbf{x} \rightarrow \mathbf{x}&#39;`:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathbf{x}&#39; = \mathsf{R}\mathbf{x}</span>

<span class="sd">        :class:`Atom` coordinates are rotated in-place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        R : array_like</span>
<span class="sd">            3x3 rotation matrix</span>
<span class="sd">        point : array_like, optional</span>
<span class="sd">            Center of rotation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        By default, rotates about the origin ``point=(0, 0, 0)``. To rotate</span>
<span class="sd">        a group ``g`` around its center of geometry, use</span>
<span class="sd">        ``g.rotate(R, point=g.center_of_geometry())``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        rotateby : rotate around given axis and angle</span>
<span class="sd">        MDAnalysis.lib.transformations : module of all coordinate transforms</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="c1"># changes the coordinates (in place)</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">unsorted_unique</span>
        <span class="n">require_translation</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">require_translation</span><span class="p">:</span>
            <span class="n">atomgroup</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">point</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">require_translation</span><span class="p">:</span>
            <span class="n">atomgroup</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">rotateby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a rotation to the selection&#39;s coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float</span>
<span class="sd">            Rotation angle in degrees.</span>
<span class="sd">        axis : array_like</span>
<span class="sd">            Rotation axis vector.</span>
<span class="sd">        point : array_like, optional</span>
<span class="sd">            Center of rotation. If ``None`` then the center of geometry of this</span>
<span class="sd">            group is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The transformation from current coordinates :math:`\mathbf{x}`</span>
<span class="sd">        to new coordinates :math:`\mathbf{x}&#39;` is</span>

<span class="sd">        .. math::</span>

<span class="sd">          \mathbf{x}&#39; = \mathsf{R}\,(\mathbf{x}-\mathbf{p}) + \mathbf{p}</span>

<span class="sd">        where :math:`\mathsf{R}` is the rotation by `angle` around the</span>
<span class="sd">        `axis` going through `point` :math:`\mathbf{p}`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        MDAnalysis.lib.transformations.rotation_matrix :</span>
<span class="sd">            calculate :math:`\mathsf{R}`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_of_geometry</span><span class="p">()</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">transformations</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="n">point</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pack_into_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Shift all :class:`Atoms&lt;Atom&gt;` in this group to the primary unit</span>
<span class="sd">        cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        box : array_like</span>
<span class="sd">            Box dimensions, can be either orthogonal or triclinic information.</span>
<span class="sd">            Cell dimensions must be in an identical to format to those returned</span>
<span class="sd">            by :attr:`MDAnalysis.coordinates.timestep.Timestep.dimensions`,</span>
<span class="sd">            ``[lx, ly, lz, alpha, beta, gamma]``. If ``None``, uses these</span>
<span class="sd">            timestep dimensions.</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            ``True`` to change coordinates in place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coords : numpy.ndarray</span>
<span class="sd">            Shifted atom coordinates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All atoms will be moved so that they lie between 0 and boxlength</span>
<span class="sd">        :math:`L_i` in all dimensions, i.e. the lower left corner of the</span>
<span class="sd">        simulation box is taken to be at (0,0,0):</span>

<span class="sd">        .. math::</span>

<span class="sd">           x_i&#39; = x_i - \left\lfloor\frac{x_i}{L_i}\right\rfloor</span>

<span class="sd">        The default is to take unit cell information from the underlying</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.timestep.Timestep` instance. The optional</span>
<span class="sd">        argument `box` can be used to provide alternative unit cell information</span>
<span class="sd">        (in the MDAnalysis standard format</span>
<span class="sd">        ``[Lx, Ly, Lz, alpha, beta, gamma]``).</span>

<span class="sd">        Works with either orthogonal or triclinic box types.</span>

<span class="sd">        .. note::</span>
<span class="sd">           :meth:`pack_into_box` is identical to :meth:`wrap` with all default</span>
<span class="sd">           keywords.</span>

<span class="sd">        .. note::</span>
<span class="sd">            :meth:`AtomGroup.pack_into_box` is currently faster than</span>
<span class="sd">            :meth:`ResidueGroup.pack_into_box` or</span>
<span class="sd">            :meth:`SegmentGroup.pack_into_box`.</span>


<span class="sd">        .. versionadded:: 0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s2">&quot;atoms&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s2">&quot;com&quot;</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Shift the contents of this group back into the primary unit cell</span>
<span class="sd">        according to periodic boundary conditions.</span>

<span class="sd">        Specifying a `compound` will keep the :class:`Atoms&lt;Atom&gt;` in each</span>
<span class="sd">        compound together during the process. If `compound` is different from</span>
<span class="sd">        ``&#39;atoms&#39;``, each compound as a whole will be shifted so that its</span>
<span class="sd">        `center` lies within the primary unit cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compound : {&#39;atoms&#39;, &#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, \</span>
<span class="sd">                    &#39;fragments&#39;}, optional</span>
<span class="sd">            Which type of compound to keep together during wrapping. Note that,</span>
<span class="sd">            in any case, *only* the positions of :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">            *belonging to the group* will be taken into account.</span>
<span class="sd">        center : {&#39;com&#39;, &#39;cog&#39;}</span>
<span class="sd">            How to define the center of a given group of atoms. If `compound` is</span>
<span class="sd">            ``&#39;atoms&#39;``, this parameter is meaningless and therefore ignored.</span>
<span class="sd">        box : array_like, optional</span>
<span class="sd">            The unitcell dimensions of the system, which can be orthogonal or</span>
<span class="sd">            triclinic and must be provided in the same format as returned by</span>
<span class="sd">            :attr:`MDAnalysis.coordinates.timestep.Timestep.dimensions`:</span>
<span class="sd">            ``[lx, ly, lz, alpha, beta, gamma]``.</span>
<span class="sd">            If ``None``, uses the</span>
<span class="sd">            dimensions of the current time step.</span>
<span class="sd">        inplace: bool, optional</span>
<span class="sd">            If ``True``, coordinates will be changed in place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of wrapped atom coordinates of dtype `np.float32` and shape</span>
<span class="sd">            ``(len(self.atoms.n_atoms), 3)``</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `compound` is not one of ``&#39;atoms&#39;``, ``&#39;group&#39;``,</span>
<span class="sd">            ``&#39;segments&#39;``, ``&#39;residues&#39;``, ``&#39;molecules&#39;``, or ``&#39;fragments&#39;``.</span>
<span class="sd">        ~MDAnalysis.exceptions.NoDataError</span>
<span class="sd">            If `compound` is ``&#39;molecule&#39;`` but the topology doesn&#39;t</span>
<span class="sd">            contain molecule information (molnums) or if `compound` is</span>
<span class="sd">            ``&#39;fragments&#39;`` but the topology doesn&#39;t contain bonds or if</span>
<span class="sd">            `center` is ``&#39;com&#39;`` but the topology doesn&#39;t contain masses.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All atoms of the group will be moved so that the centers of its</span>
<span class="sd">        compounds lie within the primary periodic image. For orthorhombic unit</span>
<span class="sd">        cells, the primary periodic image is defined as the half-open interval</span>
<span class="sd">        :math:`[0,L_i)` between :math:`0` and boxlength :math:`L_i` in all</span>
<span class="sd">        dimensions :math:`i\in\{x,y,z\}`, i.e., the origin of the of the</span>
<span class="sd">        simulation box is taken to be at the origin :math:`(0,0,0)` of the</span>
<span class="sd">        euclidian coordinate system. A compound center residing at position</span>
<span class="sd">        :math:`x_i` in dimension :math:`i` will be shifted to :math:`x_i&#39;`</span>
<span class="sd">        according to</span>

<span class="sd">        .. math::</span>

<span class="sd">           x_i&#39; = x_i - \left\lfloor\frac{x_i}{L_i}\right\rfloor\,.</span>

<span class="sd">        When specifying a `compound`, the translation is calculated based on</span>
<span class="sd">        each compound. The same translation is applied to all atoms</span>
<span class="sd">        within this compound, meaning it will not be broken by the shift.</span>
<span class="sd">        This might however mean that not all atoms of a compound will be</span>
<span class="sd">        inside the unit cell after wrapping, but rather will be the center of</span>
<span class="sd">        the compound.</span>
<span class="sd">        Be aware of the fact that only atoms *belonging to the group* will be</span>
<span class="sd">        taken into account!</span>

<span class="sd">        `center` allows to define how the center of each group is computed.</span>
<span class="sd">        This can be either ``&#39;com&#39;`` for center of mass, or ``&#39;cog&#39;`` for</span>
<span class="sd">        center of geometry.</span>


<span class="sd">        `box` allows a unit cell to be given for the transformation. If not</span>
<span class="sd">        specified, the :attr:`~MDAnalysis.coordinates.timestep.Timestep.dimensions`</span>
<span class="sd">        information from the current</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.timestep.Timestep` will be used.</span>

<span class="sd">        .. note::</span>
<span class="sd">            :meth:`AtomGroup.wrap` is currently faster than</span>
<span class="sd">            :meth:`ResidueGroup.wrap` or :meth:`SegmentGroup.wrap`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`pack_into_box`</span>
<span class="sd">        :meth:`unwrap`</span>
<span class="sd">        :meth:`MDAnalysis.lib.distances.apply_PBC`</span>


<span class="sd">        .. versionadded:: 0.9.2</span>
<span class="sd">        .. versionchanged:: 0.20.0</span>
<span class="sd">           The method only acts on atoms *belonging to the group* and returns</span>
<span class="sd">           the wrapped positions as a :class:`numpy.ndarray`.</span>
<span class="sd">           Added optional argument `inplace`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Try and auto detect box dimensions:</span>
        <span class="k">if</span> <span class="n">box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
            <span class="k">if</span> <span class="n">box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No dimensions information in Universe. &quot;</span>
                                 <span class="s2">&quot; Either use the &#39;box&#39; argument or&quot;</span>
                                 <span class="s2">&quot; set the &#39;.dimensions&#39; attribute&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">box</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">box</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid box: Box has invalid shape or not all &quot;</span>
                                 <span class="s2">&quot;box dimensions are positive. You can specify a &quot;</span>
                                 <span class="s2">&quot;valid box using the &#39;box&#39; argument.&quot;</span><span class="p">)</span>

        <span class="c1"># no matter what kind of group we have, we need to work on its (unique)</span>
        <span class="c1"># atoms:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isunique</span><span class="p">:</span>
            <span class="n">_atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">unsorted_unique</span>
            <span class="n">restore_mask</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">_unique_restore_mask</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">_atoms</span>

        <span class="n">comp</span> <span class="o">=</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;atoms&#39;</span><span class="p">,</span> <span class="s1">&#39;group&#39;</span><span class="p">,</span> <span class="s1">&#39;segments&#39;</span><span class="p">,</span> <span class="s1">&#39;residues&#39;</span><span class="p">,</span> <span class="s1">&#39;molecules&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;fragments&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized compound definition &#39;</span><span class="si">{}</span><span class="s2">&#39;. &quot;</span>
                             <span class="s2">&quot;Please use one of &#39;atoms&#39;, &#39;group&#39;, &#39;segments&#39;, &quot;</span>
                             <span class="s2">&quot;&#39;residues&#39;, &#39;molecules&#39;, or &#39;fragments&#39;.&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">compound</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;atoms&quot;</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">apply_PBC</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ctr</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ctr</span> <span class="o">==</span> <span class="s1">&#39;com&#39;</span><span class="p">:</span>
                <span class="c1"># Don&#39;t use hasattr(self, &#39;masses&#39;) because that&#39;s incredibly</span>
                <span class="c1"># slow for ResidueGroups or SegmentGroups</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="o">.</span><span class="n">_topology</span><span class="p">,</span> <span class="s1">&#39;masses&#39;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Cannot perform wrap with center=&#39;com&#39;, &quot;</span>
                                      <span class="s2">&quot;this requires masses.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ctr</span> <span class="o">!=</span> <span class="s1">&#39;cog&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized center definition &#39;</span><span class="si">{}</span><span class="s2">&#39;. Please &quot;</span>
                                 <span class="s2">&quot;use one of &#39;com&#39; or &#39;cog&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">center</span><span class="p">))</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span>

            <span class="c1"># compute and apply required shift:</span>
            <span class="k">if</span> <span class="n">ctr</span> <span class="o">==</span> <span class="s1">&#39;com&#39;</span><span class="p">:</span>
                <span class="n">ctrpos</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">comp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ctrpos</span><span class="p">)):</span>
                    <span class="n">specifier</span> <span class="o">=</span> <span class="s1">&#39;the&#39;</span> <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span> <span class="k">else</span> <span class="s1">&#39;one of the&#39;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use compound=&#39;</span><span class="si">{0}</span><span class="s2">&#39; with &quot;</span>
                                     <span class="s2">&quot;center=&#39;com&#39; because </span><span class="si">{1}</span><span class="s2"> </span><span class="si">{0}</span><span class="se">\&#39;</span><span class="s2">s total &quot;</span>
                                     <span class="s2">&quot;mass is zero.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">specifier</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># ctr == &#39;cog&#39;</span>
                <span class="n">ctrpos</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">center_of_geometry</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="n">comp</span><span class="p">)</span>
            <span class="n">ctrpos</span> <span class="o">=</span> <span class="n">ctrpos</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">apply_PBC</span><span class="p">(</span><span class="n">ctrpos</span><span class="p">,</span> <span class="n">box</span><span class="p">)</span>
            <span class="n">shifts</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">ctrpos</span>

            <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
                <span class="n">positions</span> <span class="o">+=</span> <span class="n">shifts</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">compound_indices</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">_get_compound_indices</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>

                <span class="c1"># apply the shifts:</span>
                <span class="n">unique_compound_indices</span> <span class="o">=</span> <span class="n">unique_int_1d</span><span class="p">(</span><span class="n">compound_indices</span><span class="p">)</span>
                <span class="n">shift_idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unique_compound_indices</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">compound_indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">positions</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span> <span class="n">shifts</span><span class="p">[</span><span class="n">shift_idx</span><span class="p">]</span>
                    <span class="n">shift_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isunique</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">restore_mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">positions</span>

    <span class="k">def</span> <span class="nf">unwrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compound</span><span class="o">=</span><span class="s1">&#39;fragments&#39;</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="s1">&#39;com&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Move atoms of this group so that bonds within the</span>
<span class="sd">        group&#39;s compounds aren&#39;t split across periodic boundaries.</span>

<span class="sd">        This function is most useful when atoms have been packed into the</span>
<span class="sd">        primary unit cell, causing breaks mid-molecule, with the molecule then</span>
<span class="sd">        appearing on either side of the unit cell. This is problematic for</span>
<span class="sd">        operations such as calculating the center of mass of the molecule. ::</span>

<span class="sd">           +-----------+       +-----------+</span>
<span class="sd">           |           |       |           |</span>
<span class="sd">           | 6       3 |       |         3 | 6</span>
<span class="sd">           | !       ! |       |         ! | !</span>
<span class="sd">           |-5-8   1-2-|  ==&gt;  |       1-2-|-5-8</span>
<span class="sd">           | !       ! |       |         ! | !</span>
<span class="sd">           | 7       4 |       |         4 | 7</span>
<span class="sd">           |           |       |           |</span>
<span class="sd">           +-----------+       +-----------+</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compound : {&#39;group&#39;, &#39;segments&#39;, &#39;residues&#39;, &#39;molecules&#39;, \</span>
<span class="sd">                    &#39;fragments&#39;}, optional</span>
<span class="sd">            Which type of compound to unwrap. Note that, in any case, all</span>
<span class="sd">            atoms within each compound must be interconnected by bonds, i.e.,</span>
<span class="sd">            compounds must correspond to (parts of) molecules.</span>
<span class="sd">        reference : {&#39;com&#39;, &#39;cog&#39;, None}, optional</span>
<span class="sd">            If ``&#39;com&#39;`` (center of mass) or ``&#39;cog&#39;`` (center of geometry), the</span>
<span class="sd">            unwrapped compounds will be shifted so that their individual</span>
<span class="sd">            reference point lies within the primary unit cell.</span>
<span class="sd">            If ``None``, no such shift is performed.</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            If ``True``, coordinates are modified in place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coords : numpy.ndarray</span>
<span class="sd">            Unwrapped atom coordinate array of shape ``(n, 3)``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NoDataError</span>
<span class="sd">            If `compound` is ``&#39;molecules&#39;`` but the underlying topology does</span>
<span class="sd">            not contain molecule information, or if `reference` is ``&#39;com&#39;``</span>
<span class="sd">            but the topology does not contain masses.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `reference` is not one of ``&#39;com&#39;``, ``&#39;cog&#39;``, or ``None``, or</span>
<span class="sd">            if `reference` is ``&#39;com&#39;`` and the total mass of any `compound` is</span>
<span class="sd">            zero.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Be aware of the fact that only atoms *belonging to the group* will</span>
<span class="sd">        be unwrapped! If you want entire molecules to be unwrapped, make sure</span>
<span class="sd">        that all atoms of these molecules are part of the group.</span>
<span class="sd">        An AtomGroup containing all atoms of all fragments in the group ``ag``</span>
<span class="sd">        can be created with::</span>

<span class="sd">          all_frag_atoms = sum(ag.fragments)</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`~MDAnalysis.lib.mdamath.make_whole`,</span>
<span class="sd">        :meth:`wrap`,</span>
<span class="sd">        :meth:`pack_into_box`,</span>
<span class="sd">        :func:`~MDanalysis.lib.distances.apply_PBC`</span>


<span class="sd">        .. versionadded:: 0.20.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="c1"># bail out early if no bonds in topology:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="s1">&#39;bonds&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.unwrap() not available; this requires Bonds&quot;</span>
                              <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="n">unique_atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">unsorted_unique</span>

        <span class="c1"># Parameter sanity checking</span>
        <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">reference</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;cog&#39;</span><span class="p">,</span> <span class="s1">&#39;com&#39;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized reference &#39;</span><span class="si">{}</span><span class="s2">&#39;. Please use one &quot;</span>
                                 <span class="s2">&quot;of &#39;com&#39;, &#39;cog&#39;, or None.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>
        <span class="c1"># Don&#39;t use hasattr(self, &#39;masses&#39;) because that&#39;s incredibly slow for</span>
        <span class="c1"># ResidueGroups or SegmentGroups</span>
        <span class="k">if</span> <span class="n">reference</span> <span class="o">==</span> <span class="s1">&#39;com&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">unique_atoms</span><span class="p">,</span> <span class="s1">&#39;masses&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;Cannot perform unwrap with reference=&#39;com&#39;, &quot;</span>
                              <span class="s2">&quot;this requires masses.&quot;</span><span class="p">)</span>

        <span class="c1"># Sanity checking of the compound parameter is done downstream in</span>
        <span class="c1"># _split_by_compound_indices</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">compound</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c1"># The &#39;group&#39; needs no splitting:</span>
        <span class="c1">#  There is a lot of code duplication with the multi-compound split</span>
        <span class="c1">#  case below. Both code paths could be merged, but &#39;group&#39; can be done</span>
        <span class="c1">#  unidimensionally whereas the general multi-compound case involves</span>
        <span class="c1">#  more indexing and is therefore slower. Leaving separate for now.</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">mdamath</span><span class="o">.</span><span class="n">make_whole</span><span class="p">(</span><span class="n">unique_atoms</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Apply reference shift if required:</span>
            <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">reference</span> <span class="o">==</span> <span class="s1">&#39;com&#39;</span><span class="p">:</span>
                    <span class="n">masses</span> <span class="o">=</span> <span class="n">unique_atoms</span><span class="o">.</span><span class="n">masses</span>
                    <span class="n">total_mass</span> <span class="o">=</span> <span class="n">masses</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">total_mass</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot perform unwrap with &quot;</span>
                                         <span class="s2">&quot;reference=&#39;com&#39; because the total &quot;</span>
                                         <span class="s2">&quot;mass of the group is zero.&quot;</span><span class="p">)</span>
                    <span class="n">refpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;j&#39;</span><span class="p">,</span><span class="n">positions</span><span class="p">,</span><span class="n">masses</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
                    <span class="n">refpos</span> <span class="o">/=</span> <span class="n">total_mass</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># reference == &#39;cog&#39;</span>
                    <span class="n">refpos</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">refpos</span> <span class="o">=</span> <span class="n">refpos</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">apply_PBC</span><span class="p">(</span><span class="n">refpos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                <span class="n">positions</span> <span class="o">+=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">refpos</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># We need to split the group into compounds</span>
            <span class="c1"># When unwrapping and not shifting with a cog/com reference we</span>
            <span class="c1"># need to make sure that the first atom of each compound is stable</span>
            <span class="c1"># regarding sorting.</span>
            <span class="n">atom_masks</span> <span class="o">=</span> <span class="n">unique_atoms</span><span class="o">.</span><span class="n">_split_by_compound_indices</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span>
                                              <span class="n">stable_sort</span><span class="o">=</span><span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">unique_atoms</span><span class="o">.</span><span class="n">positions</span>
            <span class="k">for</span> <span class="n">atom_mask</span> <span class="ow">in</span> <span class="n">atom_masks</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">atom_mask</span><span class="p">:</span>
                    <span class="n">positions</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">mdamath</span><span class="o">.</span><span class="n">make_whole</span><span class="p">(</span><span class="n">unique_atoms</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                                                         <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="c1"># Apply reference shift if required:</span>
                <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">reference</span> <span class="o">==</span> <span class="s1">&#39;com&#39;</span><span class="p">:</span>
                        <span class="n">masses</span> <span class="o">=</span> <span class="n">unique_atoms</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">atom_mask</span><span class="p">]</span>
                        <span class="n">total_mass</span> <span class="o">=</span> <span class="n">masses</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">total_mass</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)):</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot perform unwrap with &quot;</span>
                                             <span class="s2">&quot;reference=&#39;com&#39; because the &quot;</span>
                                             <span class="s2">&quot;total mass of at least one of &quot;</span>
                                             <span class="s2">&quot;the </span><span class="si">{}</span><span class="s2"> is zero.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">))</span>
                        <span class="n">refpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ijk-&gt;ik&#39;</span><span class="p">,</span><span class="n">positions</span><span class="p">[</span><span class="n">atom_mask</span><span class="p">],</span>
                                           <span class="n">masses</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">])</span>
                        <span class="n">refpos</span> <span class="o">/=</span> <span class="n">total_mass</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># reference == &#39;cog&#39;</span>
                        <span class="n">refpos</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">atom_mask</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">refpos</span> <span class="o">=</span> <span class="n">refpos</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">apply_PBC</span><span class="p">(</span><span class="n">refpos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                    <span class="n">positions</span><span class="p">[</span><span class="n">atom_mask</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">target</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                                             <span class="o">-</span> <span class="n">refpos</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">unique_atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span><span class="o">.</span><span class="n">isunique</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">atoms</span><span class="o">.</span><span class="n">_unique_restore_mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">positions</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get another group identical to this one.</span>


<span class="sd">        .. versionadded:: 0.19.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:]</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_set_unique_caches_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">group</span>

    <span class="k">def</span> <span class="nf">_set_unique_caches_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Try to fill the copied group&#39;s uniqueness caches:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isunique</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">issorted</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;isunique&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topattrs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group together items in this group according to values of *topattr*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        topattrs: str or list</span>
<span class="sd">           One or more topology attributes to group components by.</span>
<span class="sd">           Single arguments are passed as a string. Multiple arguments</span>
<span class="sd">           are passed as a list.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Unique values of the multiple combinations of topology attributes</span>
<span class="sd">            as keys, Groups as values.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To group atoms with the same mass together:</span>

<span class="sd">        .. testsetup:: GroupBase.groupby</span>

<span class="sd">            from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            u = mda.Universe(PSF, DCD)</span>
<span class="sd">            ag = u.atoms</span>

<span class="sd">        .. doctest:: GroupBase.groupby</span>
<span class="sd">           :options: +NORMALIZE_WHITESPACE</span>

<span class="sd">            &gt;&gt;&gt; ag.groupby(&#39;masses&#39;)</span>
<span class="sd">            {32.06: &lt;AtomGroup with 7 atoms&gt;,</span>
<span class="sd">             1.008: &lt;AtomGroup with 1685 atoms&gt;,</span>
<span class="sd">             12.011: &lt;AtomGroup with 1040 atoms&gt;,</span>
<span class="sd">             14.007: &lt;AtomGroup with 289 atoms&gt;,</span>
<span class="sd">             15.999: &lt;AtomGroup with 320 atoms&gt;}</span>

<span class="sd">        To group atoms with the same residue name and mass together:</span>

<span class="sd">        .. doctest:: GroupBase.groupby</span>
<span class="sd">           :options: +NORMALIZE_WHITESPACE</span>

<span class="sd">            &gt;&gt;&gt; group_dict = ag.groupby([&#39;resnames&#39;, &#39;masses&#39;])</span>
<span class="sd">            &gt;&gt;&gt; dict(sorted(group_dict.items()))</span>
<span class="sd">            {(&#39;ALA&#39;, 1.008): &lt;AtomGroup with 95 atoms&gt;,</span>
<span class="sd">             (&#39;ALA&#39;, 12.011): &lt;AtomGroup with 57 atoms&gt;,</span>
<span class="sd">             (&#39;ALA&#39;, 14.007): &lt;AtomGroup with 19 atoms&gt;,</span>
<span class="sd">             (&#39;ALA&#39;, 15.999): &lt;AtomGroup with 19 atoms&gt;,</span>
<span class="sd">             (&#39;ARG&#39;, 1.008): &lt;AtomGroup with 169 atoms&gt;,</span>
<span class="sd">             ...</span>

<span class="sd">        .. doctest:: GroupBase.groupby</span>

<span class="sd">            &gt;&gt;&gt; ag.groupby([&#39;resnames&#39;, &#39;masses&#39;])[&#39;ALA&#39;, 15.999]</span>
<span class="sd">            &lt;AtomGroup with 19 atoms&gt;</span>


<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        .. versionchanged:: 0.18.0 The function accepts multiple attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">res</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topattrs</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">topattrs</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topattrs</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                <span class="n">attr</span> <span class="o">=</span> <span class="n">topattrs</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
            <span class="n">ta</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">ta</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">ta</span><span class="p">)}</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">topattrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ta</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">ta</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">topattrs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ta</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ta</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">topattrs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

            <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">flatten_dict</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Concatenate with another Group or Component of the same level.</span>

<span class="sd">        Duplicate entries and original order is preserved. It is synomymous to</span>
<span class="sd">        the `+` operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with elements of `self` and `other` concatenated</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        The order of the original contents (including duplicates)</span>
<span class="sd">        are preserved when performing a concatenation.</span>

<span class="sd">        .. testsetup:: GroupBase.concatenate</span>

<span class="sd">            from MDAnalysis.tests.datafiles import PDB, XTC</span>
<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            u = mda.Universe(PDB, XTC)</span>

<span class="sd">        .. doctest:: GroupBase.concatenate</span>

<span class="sd">            &gt;&gt;&gt; ag1 = u.select_atoms(&#39;name O&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ag2 = u.select_atoms(&#39;name N&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ag3 = ag1 + ag2  # or ag1.concatenate(ag2)</span>
<span class="sd">            &gt;&gt;&gt; ag3[:3].names</span>
<span class="sd">            array([&#39;O&#39;, &#39;O&#39;, &#39;O&#39;], dtype=object)</span>
<span class="sd">            &gt;&gt;&gt; ag3[-3:].names</span>
<span class="sd">            array([&#39;N&#39;, &#39;N&#39;, &#39;N&#39;], dtype=object)</span>


<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">]),</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group of elements either in this Group or another</span>

<span class="sd">        On the contrary to concatenation, this method sort the elements and</span>
<span class="sd">        removes duplicate ones. It is synomymous to the `|` operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with the combined elements of `self` and `other`, without</span>
<span class="sd">            duplicate elements</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        In contrast to :meth:`concatenate`, any duplicates are dropped</span>
<span class="sd">        and the result is sorted.</span>

<span class="sd">        .. testsetup:: GroupBase.union</span>

<span class="sd">            from MDAnalysis.tests.datafiles import PDB, XTC</span>
<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            u = mda.Universe(PDB, XTC)</span>

<span class="sd">        .. doctest:: GroupBase.union</span>

<span class="sd">            &gt;&gt;&gt; ag1 = u.select_atoms(&#39;name O&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ag2 = u.select_atoms(&#39;name N&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ag3 = ag1 | ag2  # or ag1.union(ag2)</span>
<span class="sd">            &gt;&gt;&gt; ag3[:3].names</span>
<span class="sd">            array([&#39;N&#39;, &#39;O&#39;, &#39;N&#39;], dtype=object)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        concatenate, intersection</span>


<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group of elements which are in both this Group and another</span>

<span class="sd">        This method removes duplicate elements and sorts the result. It is</span>
<span class="sd">        synomymous to the `&amp;` operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with the common elements of `self` and `other`, without</span>
<span class="sd">            duplicate elements</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        Intersections can be used when the select atoms string would</span>
<span class="sd">        become too complicated.  For example to find the water atoms</span>
<span class="sd">        which are within 4.0A of two segments:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            &gt;&gt;&gt; shell1 = u.select_atoms(&#39;resname SOL and around 4.0 segid 1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; shell2 = u.select_atoms(&#39;resname SOL and around 4.0 segid 2&#39;)</span>
<span class="sd">            &gt;&gt;&gt; common = shell1 &amp; shell2  # or shell1.intersection(shell2)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        union</span>


<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group with elements from this Group that don&#39;t appear in other</span>

<span class="sd">        The original order of this group is kept, as well as any duplicate</span>
<span class="sd">        elements. If an element of this Group is duplicated and appears in</span>
<span class="sd">        the other Group or Component, then all the occurences of that element</span>
<span class="sd">        are removed from the returned Group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with the elements of `self` that are not in  `other`,</span>
<span class="sd">            conserves order and duplicates.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        Unlike :meth:`difference` this method will not sort or remove</span>
<span class="sd">        duplicates.</span>

<span class="sd">        .. testsetup:: GroupBase.subtract</span>

<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">            u = mda.Universe(PSF,DCD)</span>

<span class="sd">        .. doctest:: GroupBase.subtract</span>

<span class="sd">            &gt;&gt;&gt; ag1 = u.atoms[[3, 3, 2, 2, 1, 1]]</span>
<span class="sd">            &gt;&gt;&gt; ag2 = u.atoms[2]</span>
<span class="sd">            &gt;&gt;&gt; ag3 = ag1.subtract(ag2)</span>
<span class="sd">            &gt;&gt;&gt; ag3.indices</span>
<span class="sd">            array([3, 3, 1, 1])</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        concatenate, difference</span>


<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="n">in_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">)</span>  <span class="c1"># mask of in self.ix AND other</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="o">~</span><span class="n">in_other</span><span class="p">]</span>  <span class="c1"># ie inverse of previous mask</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Elements from this Group that do not appear in another</span>

<span class="sd">        This method removes duplicate elements and sorts the result. As such,</span>
<span class="sd">        it is different from :meth:`subtract`. :meth:`difference` is synomymous</span>
<span class="sd">        to the `-` operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with the elements of `self` that are not in  `other`, without</span>
<span class="sd">            duplicate elements</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        subtract, symmetric_difference</span>


<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">symmetric_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group of elements which are only in one of this Group or another</span>

<span class="sd">        This method removes duplicate elements and the result is sorted. It is</span>
<span class="sd">        synomym to the `^` operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with the elements that are in `self` or in `other` but not in</span>
<span class="sd">            both, without duplicate elements</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        .. testsetup:: GroupBase.symmetric_difference</span>

<span class="sd">            from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            u = mda.Universe(PSF, DCD)</span>

<span class="sd">        .. doctest:: GroupBase.symmetric_difference</span>

<span class="sd">            &gt;&gt;&gt; ag1 = u.atoms[[0, 1, 5, 3, 3, 2]]</span>
<span class="sd">            &gt;&gt;&gt; ag2 = u.atoms[[4, 4, 6, 2, 3, 5]]</span>
<span class="sd">            &gt;&gt;&gt; ag3 = ag1 ^ ag2  # or ag1.symmetric_difference(ag2)</span>
<span class="sd">            &gt;&gt;&gt; ag3.indices  # 0 and 1 are only in ag1, 4 and 6 are only in ag2</span>
<span class="sd">            array([0, 1, 4, 6])</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        difference</span>


<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setxor1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isdisjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If the Group has no elements in common with the other Group</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the two Groups do not have common elements</span>


<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">issubset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If all elements of this Group are part of another Group</span>

<span class="sd">        Note that an empty group is a subset of any group of the same level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if this Group is a subset of the other one</span>


<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ix_array</span><span class="p">)</span>
        <span class="n">s_ix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s_ix</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">o_ix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_strict_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If this Group is a subset of another Group but not identical</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if this Group is a strict subset of the other one</span>


<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="nf">issuperset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If all elements of another Group are part of this Group</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if this Group is a subset of the other one</span>


<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ix_array</span><span class="p">)</span>
        <span class="n">s_ix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s_ix</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">o_ix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_strict_superset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If this Group is a superset of another Group but not identical</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Group or Component</span>
<span class="sd">            Group or Component with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if this Group is a strict superset of the other one</span>


<span class="sd">        .. versionadded:: 0.16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>


<div class="viewcode-block" id="AtomGroup">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.AtomGroup">[docs]</a>
<span class="k">class</span> <span class="nc">AtomGroup</span><span class="p">(</span><span class="n">GroupBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An ordered array of atoms.</span>

<span class="sd">    Can be initiated from an iterable of :class:`Atoms&lt;Atom&gt;`::</span>

<span class="sd">        ag = AtomGroup([Atom1, Atom2, Atom3])</span>

<span class="sd">    Or from providing a list of indices and the</span>
<span class="sd">    :class:`~MDAnalysis.core.universe.Universe` it should belong to::</span>

<span class="sd">        ag = AtomGroup([72, 14, 25], u)</span>

<span class="sd">    Alternatively, an :class:`AtomGroup` is generated by indexing/slicing</span>
<span class="sd">    another :class:`AtomGroup`, such as the group of all :class:`Atoms&lt;Atom&gt;` in</span>
<span class="sd">    the :class:`~MDAnalysis.core.universe.Universe` at</span>
<span class="sd">    :attr:`MDAnalysis.core.universe.Universe.atoms`.</span>

<span class="sd">    An :class:`AtomGroup` can be indexed and sliced like a list::</span>

<span class="sd">        ag[0], ag[-1]</span>

<span class="sd">    will return the first and the last :class:`Atom` in the group whereas the</span>
<span class="sd">    slice::</span>

<span class="sd">        ag[0:6:2]</span>

<span class="sd">    returns an :class:`AtomGroup` of every second element, corresponding to</span>
<span class="sd">    indices 0, 2, and 4.</span>

<span class="sd">    It also supports &quot;advanced slicing&quot; when the argument is a</span>
<span class="sd">    :class:`numpy.ndarray` or a :class:`list`::</span>

<span class="sd">        aslice = [0, 3, -1, 10, 3]</span>
<span class="sd">        ag[aslice]</span>

<span class="sd">    will return a new :class:`AtomGroup` of :class:`Atoms&lt;Atom&gt;` with those</span>
<span class="sd">    indices in the old :class:`AtomGroup`.</span>

<span class="sd">    Finally, :class:`AtomGroups&lt;AtomGroup&gt;` can be created from a selection.</span>
<span class="sd">    See :meth:`select_atoms`.</span>

<span class="sd">    .. note::</span>

<span class="sd">        :class:`AtomGroups&lt;AtomGroup&gt;` originating from a selection are sorted</span>
<span class="sd">        and duplicate elements are removed. This is not true for</span>
<span class="sd">        :class:`AtomGroups&lt;AtomGroup&gt;` produced by slicing. Thus, slicing can be</span>
<span class="sd">        used when the order of atoms is crucial (for instance, in order to</span>
<span class="sd">        define angles or dihedrals).</span>

<span class="sd">    :class:`AtomGroups&lt;AtomGroup&gt;` can be compared and combined using group</span>
<span class="sd">    operators. For instance, :class:`AtomGroups&lt;AtomGroup&gt;` can be concatenated</span>
<span class="sd">    using `+` or :meth:`concatenate`::</span>

<span class="sd">        ag_concat = ag1 + ag2  # or ag_concat = ag1.concatenate(ag2)</span>

<span class="sd">    When groups are concatenated, the order of the :class:`Atoms&lt;Atom&gt;` is</span>
<span class="sd">    conserved. If :class:`Atoms&lt;Atom&gt;` appear several times in one of the</span>
<span class="sd">    groups, the duplicates are kept in the resulting group. On the contrary to</span>
<span class="sd">    :meth:`concatenate`, :meth:`union` treats the :class:`AtomGroups&lt;AtomGroup&gt;`</span>
<span class="sd">    as sets so that duplicates are removed from the resulting group, and</span>
<span class="sd">    :class:`Atoms&lt;Atom&gt;` are ordered. The `|` operator is synomymous to</span>
<span class="sd">    :meth:`union`::</span>

<span class="sd">        ag_union = ag1 | ag2  # or ag_union = ag1.union(ag2)</span>

<span class="sd">    The opposite operation to :meth:`concatenate` is :meth:`subtract`. This</span>
<span class="sd">    method creates a new group with all the :class:`Atoms&lt;Atom&gt;` of the group</span>
<span class="sd">    that are not in a given other group; the order of the :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">    is kept, and so are duplicates. :meth:`difference` is the set version of</span>
<span class="sd">    :meth:`subtract`. The resulting group is sorted and deduplicated.</span>

<span class="sd">    All set methods are listed in the table below. These methods treat the</span>
<span class="sd">    groups as sorted and deduplicated sets of :class:`Atoms&lt;Atom&gt;`.</span>

<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | Operation                     | Equivalent | Result                     |</span>
<span class="sd">    +===============================+============+============================+</span>
<span class="sd">    | ``s.isdisjoint(t)``           |            | ``True`` if ``s`` and      |</span>
<span class="sd">    |                               |            | ``t`` do not share         |</span>
<span class="sd">    |                               |            | elements                   |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.issubset(t)``             |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``s`` are part of ``t``    |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.is_strict_subset(t)``     |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``s`` are part of ``t``,   |</span>
<span class="sd">    |                               |            | and ``s != t``             |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.issuperset(t)``           |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``t`` are part of ``s``    |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.is_strict_superset(t)``   |            | test if all elements of    |</span>
<span class="sd">    |                               |            | ``t`` are part of ``s``,   |</span>
<span class="sd">    |                               |            | and ``s != t``             |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.union(t)``                | ``s | t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | from both ``s`` and ``t``  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.intersection(t)``         | ``s &amp; t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | common to ``s`` and ``t``  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.difference(t)``           | ``s - t``  | new Group with elements of |</span>
<span class="sd">    |                               |            | ``s`` that are not in ``t``|</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.symmetric_difference(t)`` | ``s ^ t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | that are part of ``s`` or  |</span>
<span class="sd">    |                               |            | ``t`` but not both         |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>

<span class="sd">    The following methods keep the order of the atoms as well as duplicates.</span>

<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | Operation                     | Equivalent | Result                     |</span>
<span class="sd">    +===============================+============+============================+</span>
<span class="sd">    | ``len(s)``                    |            | number of elements (atoms, |</span>
<span class="sd">    |                               |            | residues or segment) in    |</span>
<span class="sd">    |                               |            | the group                  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s == t``                    |            | test if ``s`` and ``t``    |</span>
<span class="sd">    |                               |            | contain the same elements  |</span>
<span class="sd">    |                               |            | in the same order          |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.concatenate(t)``          | ``s + t``  | new Group with elements    |</span>
<span class="sd">    |                               |            | from ``s`` and from ``t``  |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>
<span class="sd">    | ``s.subtract(t)``             |            | new Group with elements    |</span>
<span class="sd">    |                               |            | from ``s`` that are not    |</span>
<span class="sd">    |                               |            | in ``t``                   |</span>
<span class="sd">    +-------------------------------+------------+----------------------------+</span>

<span class="sd">    The `in` operator allows to test if an :class:`Atom` is in the</span>
<span class="sd">    :class:`AtomGroup`.</span>

<span class="sd">    :class:`AtomGroup` instances are always bound to a</span>
<span class="sd">    :class:`MDAnalysis.core.universe.Universe`. They cannot exist in isolation.</span>

<span class="sd">    During serialization, :class:`AtomGroup` will be pickled with its bound</span>
<span class="sd">    :class:`MDAnalysis.core.universe.Universe` which means after unpickling,</span>
<span class="sd">    a new :class:`MDAnalysis.core.universe.Universe` will be created and</span>
<span class="sd">    be attached by the new :class:`AtomGroup`. If the Universe is serialized</span>
<span class="sd">    with its :class:`AtomGroup`, they will still be bound together afterwards:</span>

<span class="sd">    .. testsetup:: AtomGroup</span>

<span class="sd">        import MDAnalysis as mda</span>
<span class="sd">        from MDAnalysis.tests.datafiles import PSF, DCD</span>

<span class="sd">    .. doctest:: AtomGroup</span>

<span class="sd">        &gt;&gt;&gt; import pickle</span>

<span class="sd">        &gt;&gt;&gt; u = mda.Universe(PSF, DCD)</span>
<span class="sd">        &gt;&gt;&gt; g = u.atoms</span>

<span class="sd">        &gt;&gt;&gt; g_pickled = pickle.loads(pickle.dumps(g))</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;g_pickled.universe is u: &quot;, u is g_pickled.universe)</span>
<span class="sd">        g_pickled.universe is u:  False</span>

<span class="sd">        &gt;&gt;&gt; g_pickled, u_pickled = pickle.loads(pickle.dumps((g, u)))</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;g_pickled.universe is u_pickled: &quot;,</span>
<span class="sd">        ...       u_pickled is g_pickled.universe)</span>
<span class="sd">        g_pickled.universe is u_pickled:  True</span>

<span class="sd">    If multiple :class:`AtomGroup` are bound to the same</span>
<span class="sd">    :class:`MDAnalysis.core.universe.Universe`, they will bound to the same one</span>
<span class="sd">    after serialization:</span>

<span class="sd">    .. doctest:: AtomGroup</span>

<span class="sd">        &gt;&gt;&gt; import pickle</span>

<span class="sd">        &gt;&gt;&gt; u = mda.Universe(PSF, DCD)</span>
<span class="sd">        &gt;&gt;&gt; g = u.atoms</span>
<span class="sd">        &gt;&gt;&gt; h = u.atoms</span>

<span class="sd">        &gt;&gt;&gt; g_pickled = pickle.loads(pickle.dumps(g))</span>
<span class="sd">        &gt;&gt;&gt; h_pickled = pickle.loads(pickle.dumps(h))</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;g_pickled.universe is h_pickled.universe: &quot;,</span>
<span class="sd">        ...       g_pickled.universe is h_pickled.universe)</span>
<span class="sd">        g_pickled.universe is h_pickled.universe:  False</span>

<span class="sd">        &gt;&gt;&gt; g_pickled, h_pickled = pickle.loads(pickle.dumps((g, h)))</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;g_pickled.universe is h_pickled.universe: &quot;,</span>
<span class="sd">        ...       g_pickled.universe is h_pickled.universe)</span>
<span class="sd">        g_pickled.universe is h_pickled.universe:  True</span>

<span class="sd">    The aforementioned two cases are useful for implementation of parallel</span>
<span class="sd">    analysis base classes. First, you always get an independent</span>
<span class="sd">    :class:`MDAnalysis.core.universe.Universe`</span>
<span class="sd">    in the new process; you don&#39;t have to worry about detaching and reattaching</span>
<span class="sd">    Universe with :class:`AtomGroup`. It also means the state of the</span>
<span class="sd">    new pickled AtomGroup will not be changed with the old Universe,</span>
<span class="sd">    So either the Universe has to pickled together with the AtomGroup</span>
<span class="sd">    (e.g. as a tuple, or as attributes of the object to be pickled), or the</span>
<span class="sd">    implicit new Universe (`AtomGroup.Universe`) needs to be used.</span>
<span class="sd">    Second, When multiple AtomGroup need to be pickled, they will recognize if</span>
<span class="sd">    they belong to the same Univese or not.</span>
<span class="sd">    Also keep in mind that they need to be pickled together.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`MDAnalysis.core.universe.Universe`</span>


<span class="sd">    .. deprecated:: 0.16.2</span>
<span class="sd">       *Instant selectors* of :class:`AtomGroup` will be removed in the 1.0</span>
<span class="sd">       release.</span>
<span class="sd">    .. versionchanged:: 1.0.0</span>
<span class="sd">       Removed instant selectors, use select_atoms(&#39;name ...&#39;) to select</span>
<span class="sd">       atoms by name.</span>
<span class="sd">    .. versionchanged:: 2.0.0</span>
<span class="sd">       :class:`AtomGroup` can always be pickled with or without its universe,</span>
<span class="sd">       instead of failing when not finding its anchored universe.</span>
<span class="sd">    .. versionchanged:: 2.1.0</span>
<span class="sd">       Indexing an AtomGroup with ``None`` raises a ``TypeError``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="c1"># special-case timestep info</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;velocities&#39;</span><span class="p">,</span> <span class="s1">&#39;forces&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s1">&#39;This Timestep has no &#39;</span> <span class="o">+</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;positions&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s1">&#39;This Universe has no coordinates&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AtomGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_unpickle</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The :class:`AtomGroup` itself.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        copy : return a true copy of the :class:`AtomGroup`</span>


<span class="sd">        .. versionchanged:: 0.19.0</span>
<span class="sd">           In previous versions, this returned a copy, but now</span>
<span class="sd">           the :class:`AtomGroup` itself is returned. This should</span>
<span class="sd">           not affect any code but only speed up calculations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of atoms in the :class:`AtomGroup`.</span>

<span class="sd">        Equivalent to ``len(self)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A sorted :class:`ResidueGroup` of the unique</span>
<span class="sd">        :class:`Residues&lt;Residue&gt;` present in the :class:`AtomGroup`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">unique_int_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resindices</span><span class="p">)]</span>
        <span class="n">rg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">rg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">rg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rg</span>
        <span class="n">rg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rg</span>
        <span class="k">return</span> <span class="n">rg</span>

    <span class="nd">@residues</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="c1"># Can set with Res, ResGroup or list/tuple of Res</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">Residue</span><span class="p">):</span>
            <span class="n">r_ix</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="n">new</span><span class="o">.</span><span class="n">resindex</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">):</span>
            <span class="n">r_ix</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">resindices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">r_ix</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">resindex</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Can only set AtomGroup residues to Residue &quot;</span>
                          <span class="s2">&quot;or ResidueGroup not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                          <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new</span>
                                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Residue</span><span class="p">))))</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r_ix</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_ix</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incorrect size: </span><span class="si">{}</span><span class="s2"> for AtomGroup of size: </span><span class="si">{}</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="c1"># Optimisation TODO:</span>
        <span class="c1"># This currently rebuilds the tt len(self) times</span>
        <span class="c1"># Ideally all changes would happen and *afterwards* tables are built</span>
        <span class="c1"># Alternatively, if the changes didn&#39;t rebuild table, this list</span>
        <span class="c1"># comprehension isn&#39;t terrible.</span>
        <span class="k">for</span> <span class="n">at</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r_ix</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">move_atom</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of unique :class:`Residues&lt;Residue&gt;` present in the</span>
<span class="sd">        :class:`AtomGroup`.</span>

<span class="sd">        Equivalent to ``len(self.residues)``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A sorted :class:`SegmentGroup` of the unique segments present in the</span>
<span class="sd">        :class:`AtomGroup`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">unique_int_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segindices</span><span class="p">)]</span>
        <span class="n">sg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">sg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">sg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sg</span>
        <span class="n">sg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sg</span>
        <span class="k">return</span> <span class="n">sg</span>

    <span class="nd">@segments</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot assign Segments to AtomGroup. &quot;</span>
                                  <span class="s2">&quot;Segments are assigned to Residues&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of unique segments present in the :class:`AtomGroup`.</span>

<span class="sd">        Equivalent to ``len(self.segments)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;unique_restore_mask&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_unique_restore_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The _unique_restore_mask property&#39;s cache is populated whenever the</span>
        <span class="c1"># AtomGroup.unique property of a *non-unique* AtomGroup is accessed.</span>
        <span class="c1"># If _unique_restore_mask is not cached, it is *definitely* used in the</span>
        <span class="c1"># wrong place, so we raise an exception here. In principle, the</span>
        <span class="c1"># exception should be an AttributeError, but the error message would</span>
        <span class="c1"># then be replaced by the __getattr__() error message. To prevent the</span>
        <span class="c1"># message from being overridden, we raise a RuntimeError instead.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isunique</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">._unique_restore_mask is not available if the </span><span class="si">{0}</span><span class="s2"> is &quot;</span>
                   <span class="s2">&quot;unique. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">._unique_restore_mask is only available after &quot;</span>
                   <span class="s2">&quot;accessing </span><span class="si">{0}</span><span class="s2">.unique. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;If you see this error message in an unmodified release &quot;</span>
                <span class="s2">&quot;version of MDAnalysis, this is almost certainly a bug!&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="nd">@_unique_restore_mask</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_unique_restore_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unique_restore_mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An :class:`AtomGroup` containing sorted and unique</span>
<span class="sd">        :class:`Atoms&lt;Atom&gt;` only.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. doctest:: AtomGroup.unique</span>

<span class="sd">            &gt;&gt;&gt; import MDAnalysis as mda</span>
<span class="sd">            &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">            &gt;&gt;&gt; u = mda.Universe(PSF, DCD)</span>
<span class="sd">            &gt;&gt;&gt; ag = u.atoms[[2, 1, 2, 2, 1, 0]]</span>
<span class="sd">            &gt;&gt;&gt; ag</span>
<span class="sd">            &lt;AtomGroup with 6 atoms&gt;</span>
<span class="sd">            &gt;&gt;&gt; ag.ix</span>
<span class="sd">            array([2, 1, 2, 2, 1, 0])</span>
<span class="sd">            &gt;&gt;&gt; ag2 = ag.unique</span>
<span class="sd">            &gt;&gt;&gt; ag2</span>
<span class="sd">            &lt;AtomGroup with 3 atoms&gt;</span>
<span class="sd">            &gt;&gt;&gt; ag2.ix</span>
<span class="sd">            array([0, 1, 2])</span>
<span class="sd">            &gt;&gt;&gt; ag2.unique is ag2</span>
<span class="sd">            False</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        asunique</span>

<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        .. versionchanged:: 0.19.0 If the :class:`AtomGroup` is already unique,</span>
<span class="sd">            :attr:`AtomGroup.unique` now returns the group itself instead of a</span>
<span class="sd">            copy.</span>
<span class="sd">        .. versionchanged:: 2.0.0</span>
<span class="sd">            This function now always returns a copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_unique</span><span class="p">[:]</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
        <span class="k">return</span> <span class="n">group</span>

<div class="viewcode-block" id="AtomGroup.asunique">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.AtomGroup.asunique">[docs]</a>
    <span class="k">def</span> <span class="nf">asunique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a :class:`AtomGroup` containing unique</span>
<span class="sd">        :class:`Atoms&lt;Atom&gt;` only, with optional sorting.</span>

<span class="sd">        If the :class:`AtomGroup` is unique, this is the group itself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sorted: bool (optional)</span>
<span class="sd">            Whether or not the returned AtomGroup should be sorted</span>
<span class="sd">            by index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`AtomGroup`</span>
<span class="sd">            Unique ``AtomGroup``</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. doctest:: AtomGroup.asunique</span>

<span class="sd">            &gt;&gt;&gt; import MDAnalysis as mda</span>
<span class="sd">            &gt;&gt;&gt; from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">            &gt;&gt;&gt; u = mda.Universe(PSF, DCD)</span>
<span class="sd">            &gt;&gt;&gt; ag = u.atoms[[2, 1, 0]]</span>
<span class="sd">            &gt;&gt;&gt; ag2 = ag.asunique(sorted=False)</span>
<span class="sd">            &gt;&gt;&gt; ag2 is ag</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; ag2.ix</span>
<span class="sd">            array([2, 1, 0])</span>
<span class="sd">            &gt;&gt;&gt; ag3 = ag.asunique(sorted=True)</span>
<span class="sd">            &gt;&gt;&gt; ag3 is ag</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; ag3.ix</span>
<span class="sd">            array([0, 1, 2])</span>
<span class="sd">            &gt;&gt;&gt; u.atoms[[2, 1, 1, 0, 1]].asunique(sorted=False).ix</span>
<span class="sd">            array([2, 1, 0])</span>


<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asunique</span><span class="p">(</span><span class="nb">sorted</span><span class="o">=</span><span class="nb">sorted</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span>
                              <span class="n">set_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Coordinates of the :class:`Atoms&lt;Atom&gt;` in the :class:`AtomGroup`.</span>

<span class="sd">        A :class:`numpy.ndarray` with</span>
<span class="sd">        :attr:`~numpy.ndarray.shape`\ ``=(``\ :attr:`~AtomGroup.n_atoms`\ ``, 3)``</span>
<span class="sd">        and :attr:`~numpy.ndarray.dtype`\ ``=numpy.float32``.</span>

<span class="sd">        The positions can be changed by assigning an array of the appropriate</span>
<span class="sd">        shape, i.e., either ``(``\ :attr:`~AtomGroup.n_atoms`\ ``, 3)`` to</span>
<span class="sd">        assign individual coordinates, or ``(3,)`` to assign the *same*</span>
<span class="sd">        coordinate to all :class:`Atoms&lt;Atom&gt;` (e.g.,</span>
<span class="sd">        ``ag.positions = array([0,0,0])`` will move all :class:`Atoms&lt;Atom&gt;`</span>
<span class="sd">        to the origin).</span>

<span class="sd">        .. note:: Changing positions is not reflected in any files; reading any</span>
<span class="sd">                  frame from the</span>
<span class="sd">                  :attr:`~MDAnalysis.core.universe.Universe.trajectory` will</span>
<span class="sd">                  replace the change with that from the file *except* if the</span>
<span class="sd">                  :attr:`~MDAnalysis.core.universe.Universe.trajectory` is held</span>
<span class="sd">                  in memory, e.g., when the</span>
<span class="sd">                  :meth:`~MDAnalysis.core.universe.Universe.transfer_to_memory`</span>
<span class="sd">                  method was used.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ~MDAnalysis.exceptions.NoDataError</span>
<span class="sd">            If the underlying :class:`~MDAnalysis.coordinates.timestep.Timestep`</span>
<span class="sd">            does not contain</span>
<span class="sd">            :attr:`~MDAnalysis.coordinates.timestep.Timestep.positions`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span>

    <span class="nd">@positions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">velocities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Velocities of the :class:`Atoms&lt;Atom&gt;` in the :class:`AtomGroup`.</span>

<span class="sd">        A :class:`numpy.ndarray` with</span>
<span class="sd">        :attr:`~numpy.ndarray.shape`\ ``=(``\ :attr:`~AtomGroup.n_atoms`\ ``, 3)``</span>
<span class="sd">        and :attr:`~numpy.ndarray.dtype`\ ``=numpy.float32``.</span>

<span class="sd">        The velocities can be changed by assigning an array of the appropriate</span>
<span class="sd">        shape, i.e. either ``(``\ :attr:`~AtomGroup.n_atoms`\ ``, 3)`` to assign</span>
<span class="sd">        individual velocities or ``(3,)`` to assign the *same* velocity to all</span>
<span class="sd">        :class:`Atoms&lt;Atom&gt;` (e.g. ``ag.velocities = array([0,0,0])`` will give</span>
<span class="sd">        all :class:`Atoms&lt;Atom&gt;` zero :attr:`~Atom.velocity`).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ~MDAnalysis.exceptions.NoDataError</span>
<span class="sd">            If the underlying :class:`~MDAnalysis.coordinates.timestep.Timestep`</span>
<span class="sd">            does not contain</span>
<span class="sd">            :attr:`~MDAnalysis.coordinates.timestep.Timestep.velocities`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">])</span>

    <span class="nd">@velocities</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">velocities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">forces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Forces on each :class:`Atom` in the :class:`AtomGroup`.</span>

<span class="sd">        A :class:`numpy.ndarray` with</span>
<span class="sd">        :attr:`~numpy.ndarray.shape`\ ``=(``\ :attr:`~AtomGroup.n_atoms`\ ``, 3)``</span>
<span class="sd">        and :attr:`~numpy.ndarray.dtype`\ ``=numpy.float32``.</span>

<span class="sd">        The forces can be changed by assigning an array of the appropriate</span>
<span class="sd">        shape, i.e. either ``(``\ :attr:`~AtomGroup.n_atoms`\ ``, 3)`` to assign</span>
<span class="sd">        individual forces or ``(3,)`` to assign the *same* force to all</span>
<span class="sd">        :class:`Atoms&lt;Atom&gt;` (e.g. ``ag.forces = array([0,0,0])`` will give all</span>
<span class="sd">        :class:`Atoms&lt;Atom&gt;` a zero :attr:`~Atom.force`).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ~MDAnalysis.exceptions.NoDataError</span>
<span class="sd">            If the :class:`~MDAnalysis.coordinates.timestep.Timestep` does not</span>
<span class="sd">            contain :attr:`~MDAnalysis.coordinates.timestep.Timestep.forces`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">return</span> <span class="n">ts</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span>

    <span class="nd">@forces</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Temporary Timestep that contains the selection coordinates.</span>

<span class="sd">        A :class:`~MDAnalysis.coordinates.timestep.Timestep` instance,</span>
<span class="sd">        which can be passed to a trajectory writer.</span>

<span class="sd">        If :attr:`~AtomGroup.ts` is modified then these modifications</span>
<span class="sd">        will be present until the frame number changes (which</span>
<span class="sd">        typically happens when the underlying</span>
<span class="sd">        :attr:`~MDAnalysis.core.universe.Universe.trajectory` frame changes).</span>

<span class="sd">        It is not possible to assign a new</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.timestep.Timestep` to the</span>
<span class="sd">        :attr:`AtomGroup.ts` attribute; change attributes of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trj_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>  <span class="c1"># original time step</span>

        <span class="k">return</span> <span class="n">trj_ts</span><span class="o">.</span><span class="n">copy_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>

    <span class="c1"># As with universe.select_atoms, needing to fish out specific kwargs</span>
    <span class="c1"># (namely, &#39;updating&#39;) doesn&#39;t allow a very clean signature.</span>

<div class="viewcode-block" id="AtomGroup.select_atoms">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.AtomGroup.select_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="o">*</span><span class="n">othersel</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span>
                     <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">,</span> <span class="n">updating</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">rdkit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">smarts_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">selgroups</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select atoms from within this Group using a selection string.</span>

<span class="sd">        Returns an :class:`AtomGroup` sorted according to their index in the</span>
<span class="sd">        topology (this is to ensure that there are no duplicates, which can</span>
<span class="sd">        happen with complicated selections).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sel : str</span>
<span class="sd">          string of the selection, eg &quot;name Ca&quot;, see below for possibilities.</span>
<span class="sd">        othersel : iterable of str</span>
<span class="sd">          further selections to perform.  The results of these selections</span>
<span class="sd">          will be appended onto the results of the first.</span>
<span class="sd">        periodic : bool (optional)</span>
<span class="sd">          for geometric selections, whether to account for atoms in different</span>
<span class="sd">          periodic images when searching</span>
<span class="sd">        atol : float, optional</span>
<span class="sd">            The absolute tolerance parameter for float comparisons.</span>
<span class="sd">            Passed to :func:``numpy.isclose``.</span>
<span class="sd">        rtol : float, optional</span>
<span class="sd">            The relative tolerance parameter for float comparisons.</span>
<span class="sd">            Passed to :func:``numpy.isclose``.</span>
<span class="sd">        updating : bool (optional)</span>
<span class="sd">          force the selection to be re evaluated each time the Timestep of the</span>
<span class="sd">          trajectory is changed.  See section on **Dynamic selections** below.</span>
<span class="sd">          [``True``]</span>
<span class="sd">        sorted: bool, optional</span>
<span class="sd">          Whether to sort the output AtomGroup by index.</span>
<span class="sd">        rdkit_kwargs : dict (optional)</span>
<span class="sd">          Arguments passed to the</span>
<span class="sd">          :class:`~MDAnalysis.converters.RDKit.RDKitConverter` when using</span>
<span class="sd">          selection based on SMARTS queries</span>
<span class="sd">        smarts_kwargs : dict (optional)</span>
<span class="sd">          Arguments passed internally to RDKit&#39;s `GetSubstructMatches</span>
<span class="sd">          &lt;https://www.rdkit.org/docs/source/rdkit.Chem.rdchem.html#rdkit.Chem.rdchem.Mol.GetSubstructMatches&gt;`_.</span>

<span class="sd">        **selgroups : keyword arguments of str: AtomGroup (optional)</span>
<span class="sd">          when using the &quot;group&quot; keyword in selections, groups are defined by</span>
<span class="sd">          passing them as keyword arguments.  See section on **preexisting</span>
<span class="sd">          selections** below.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the arbitrary groups passed are not of type</span>
<span class="sd">            :class:`MDAnalysis.core.groups.AtomGroup`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        All simple selection listed below support multiple arguments which are</span>
<span class="sd">        implicitly combined with an or operator. For example</span>

<span class="sd">        .. testsetup:: AtomGroup.select_atoms</span>

<span class="sd">            from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            universe = mda.Universe(PSF, DCD)</span>

<span class="sd">        .. doctest:: AtomGroup.select_atoms</span>

<span class="sd">            &gt;&gt;&gt; sel = universe.select_atoms(&#39;resname MET GLY&#39;)</span>
<span class="sd">            &gt;&gt;&gt; sel</span>
<span class="sd">            &lt;AtomGroup with 245 atoms&gt;</span>

<span class="sd">        is equivalent to</span>

<span class="sd">        .. doctest:: AtomGroup.select_atoms</span>

<span class="sd">            &gt;&gt;&gt; sel = universe.select_atoms(&#39;resname MET or resname GLY&#39;)</span>
<span class="sd">            &gt;&gt;&gt; sel</span>
<span class="sd">            &lt;AtomGroup with 245 atoms&gt;</span>

<span class="sd">        Will select all atoms with a residue name of either MET or GLY.</span>

<span class="sd">        Subselections can be grouped with parentheses.</span>

<span class="sd">        .. doctest:: AtomGroup.select_atoms</span>

<span class="sd">            &gt;&gt;&gt; sel = universe.select_atoms(&quot;segid 4AKE and not ( name H* O* )&quot;)</span>
<span class="sd">            &gt;&gt;&gt; sel</span>
<span class="sd">            &lt;AtomGroup with 1336 atoms&gt;</span>

<span class="sd">        Existing :class:`AtomGroup` objects can be passed as named arguments,</span>
<span class="sd">        which will then be available to the selection parser.</span>

<span class="sd">        .. testsetup:: AtomGroup.select_atoms.namedarguments</span>

<span class="sd">            from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            universe = mda.Universe(PSF, DCD)</span>
<span class="sd">            sel = universe.select_atoms(&quot;segid 4AKE and not ( name H* O* )&quot;)</span>

<span class="sd">        .. doctest:: AtomGroup.select_atoms, AtomGroup.select_atoms.namedarguments</span>

<span class="sd">            &gt;&gt;&gt; universe.select_atoms(&quot;around 10 group notHO&quot;, notHO=sel)</span>
<span class="sd">            &lt;AtomGroup with 2005 atoms&gt;</span>

<span class="sd">        Selections can be set to update automatically on frame change, by</span>
<span class="sd">        setting the `updating` keyword argument to `True`.  This will return</span>
<span class="sd">        a :class:`UpdatingAtomGroup` which can represent the solvation shell</span>
<span class="sd">        around another object.</span>

<span class="sd">        .. testsetup:: AtomGroup.select_atoms.updating</span>

<span class="sd">            from MDAnalysis.tests.datafiles import PDB, XTC</span>
<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            universe = mda.Universe(PDB, XTC)</span>

<span class="sd">        .. doctest:: AtomGroup.select_atoms.updating</span>
<span class="sd">           :options: +NORMALIZE_WHITESPACE</span>

<span class="sd">            &gt;&gt;&gt; universe.select_atoms(&quot;resname SOL and around 2.0 protein&quot;,</span>
<span class="sd">            ...       updating=True)</span>
<span class="sd">            &lt;AtomGroup with 454 atoms, with selection</span>
<span class="sd">            &#39;resname SOL and around 2.0 protein&#39; on the entire Universe.&gt;</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        If exact ordering of atoms is required (for instance, for</span>
<span class="sd">        :meth:`~AtomGroup.angle` or :meth:`~AtomGroup.dihedral` calculations)</span>
<span class="sd">        then one supplies selections *separately* in the required order. Also,</span>
<span class="sd">        when multiple :class:`AtomGroup` instances are concatenated with the</span>
<span class="sd">        ``+`` operator, then the order of :class:`Atom` instances is preserved</span>
<span class="sd">        and duplicates are *not* removed.</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :ref:`selection-commands-label` for further details and examples.</span>


<span class="sd">        .. rubric:: Selection syntax</span>


<span class="sd">        The selection parser understands the following CASE SENSITIVE</span>
<span class="sd">        *keywords*:</span>

<span class="sd">        **Simple selections**</span>

<span class="sd">            protein, backbone, nucleic, nucleicbackbone</span>
<span class="sd">                selects all atoms that belong to a standard set of residues;</span>
<span class="sd">                a protein is identfied by a hard-coded set of residue names so</span>
<span class="sd">                it  may not work for esoteric residues.</span>
<span class="sd">            segid *seg-name*</span>
<span class="sd">                select by segid (as given in the topology), e.g. ``segid 4AKE``</span>
<span class="sd">                or ``segid DMPC``</span>
<span class="sd">            resid *residue-number-range*</span>
<span class="sd">                resid can take a single residue number or a range of numbers. A</span>
<span class="sd">                range consists of two numbers separated by a colon (inclusive)</span>
<span class="sd">                such as ``resid 1:5``. A residue number (&quot;resid&quot;) is taken</span>
<span class="sd">                directly from the topology.</span>
<span class="sd">                If icodes are present in the topology, then these will be</span>
<span class="sd">                taken into account.  Ie &#39;resid 163B&#39; will only select resid</span>
<span class="sd">                163 with icode B while &#39;resid 163&#39; will select only residue 163.</span>
<span class="sd">                Range selections will also respect icodes, so &#39;resid 162-163B&#39;</span>
<span class="sd">                will select all residues in 162 and those in 163 up to icode B.</span>
<span class="sd">            resnum *resnum-number-range*</span>
<span class="sd">                resnum is the canonical residue number; typically it is set to</span>
<span class="sd">                the residue id in the original PDB structure.</span>
<span class="sd">            resname *residue-name*</span>
<span class="sd">                select by residue name, e.g. ``resname LYS``</span>
<span class="sd">            name *atom-name*</span>
<span class="sd">                select by atom name (as given in the topology). Often, this is</span>
<span class="sd">                force field dependent. Example: ``name CA`` (for C&amp;alpha; atoms)</span>
<span class="sd">                or ``name OW`` (for SPC water oxygen)</span>
<span class="sd">            type *atom-type*</span>
<span class="sd">                select by atom type; this is either a string or a number and</span>
<span class="sd">                depends on the force field; it is read from the topology file</span>
<span class="sd">                (e.g. the CHARMM PSF file contains numeric atom types). It has</span>
<span class="sd">                non-sensical values when a PDB or GRO file is used as a topology</span>
<span class="sd">            atom *seg-name*  *residue-number*  *atom-name*</span>
<span class="sd">                a selector for a single atom consisting of segid resid atomname,</span>
<span class="sd">                e.g. ``DMPC 1 C2`` selects the C2 carbon of the first residue of</span>
<span class="sd">                the DMPC segment</span>
<span class="sd">            altloc *alternative-location*</span>
<span class="sd">                a selection for atoms where alternative locations are available,</span>
<span class="sd">                which is often the case with high-resolution crystal structures</span>
<span class="sd">                e.g. `resid 4 and resname ALA and altloc B` selects only the</span>
<span class="sd">                atoms of ALA-4 that have an altloc B record.</span>
<span class="sd">            moltype *molecule-type*</span>
<span class="sd">                select by molecule type, e.g. ``moltype Protein_A``. At the</span>
<span class="sd">                moment, only the TPR format defines the molecule type.</span>
<span class="sd">            record_type *record_type*</span>
<span class="sd">                for selecting either ATOM or HETATM from PDB-like files.</span>
<span class="sd">                e.g. ``select_atoms(&#39;name CA and not record_type HETATM&#39;)``</span>
<span class="sd">            smarts *SMARTS-query*</span>
<span class="sd">                select atoms using Daylight&#39;s SMARTS queries, e.g. ``smarts</span>
<span class="sd">                [#7;R]`` to find nitrogen atoms in rings. Requires RDKit.</span>
<span class="sd">                All matches are combined as a single unique match. The `smarts`</span>
<span class="sd">                selection accepts two sets of key word arguments from</span>
<span class="sd">                `select_atoms()`: the ``rdkit_kwargs`` are passed internally to</span>
<span class="sd">                `RDKitConverter.convert()` and the ``smarts_kwargs`` are passed to</span>
<span class="sd">                RDKit&#39;s `GetSubstructMatches</span>
<span class="sd">                &lt;https://www.rdkit.org/docs/source/rdkit.Chem.rdchem.html#rdkit.Chem.rdchem.Mol.GetSubstructMatches&gt;`_.</span>
<span class="sd">                By default, the `useChirality` kwarg in ``rdkit_kwargs`` is set to true</span>
<span class="sd">                and maxMatches in ``smarts_kwargs`` is</span>
<span class="sd">                ``max(1000, 10 * n_atoms)``, where ``n_atoms`` is either</span>
<span class="sd">                ``len(AtomGroup)`` or ``len(Universe.atoms)``, whichever is</span>
<span class="sd">                applicable. Note that the number of matches can occasionally</span>
<span class="sd">                exceed the default value of maxMatches, causing too few atoms</span>
<span class="sd">                to be returned. If this occurs, a warning will be issued. The</span>
<span class="sd">                problem can be fixed by increasing the value of maxMatches.</span>
<span class="sd">                This behavior may be updated in the future.</span>

<span class="sd">                .. testsetup:: AtomGroup.select_atoms.smarts</span>

<span class="sd">                    from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">                    from MDAnalysis.topology.guessers import guess_types</span>
<span class="sd">                    import MDAnalysis as mda</span>
<span class="sd">                    universe = mda.Universe(PSF, DCD)</span>
<span class="sd">                    guessed_elements = guess_types(universe.atoms.names)</span>
<span class="sd">                    universe.add_TopologyAttr(&#39;elements&#39;, guessed_elements)</span>
<span class="sd">                    </span>
<span class="sd">                .. doctest:: AtomGroup.select_atoms.smarts</span>

<span class="sd">                    &gt;&gt;&gt; universe.select_atoms(&quot;smarts C&quot;, smarts_kwargs={&quot;maxMatches&quot;: 100})</span>
<span class="sd">                    &lt;AtomGroup with 100 atoms&gt;</span>

<span class="sd">            chiral *R | S*</span>
<span class="sd">                select a particular stereocenter. e.g. ``name C and chirality</span>
<span class="sd">                S`` to select only S-chiral carbon atoms.  Only ``R`` and</span>
<span class="sd">                ``S`` will be possible options but other values will not raise</span>
<span class="sd">                an error.</span>

<span class="sd">            formalcharge *formal-charge*</span>
<span class="sd">                select atoms based on their formal charge, e.g.</span>
<span class="sd">                ``name O and formalcharge -1`` to select all oxygens with a</span>
<span class="sd">                negative 1 formal charge.</span>

<span class="sd">        **Boolean**</span>

<span class="sd">            not</span>
<span class="sd">                all atoms not in the selection, e.g. ``not protein`` selects</span>
<span class="sd">                all atoms that aren&#39;t part of a protein</span>
<span class="sd">            and, or</span>
<span class="sd">                combine two selections according to the rules of boolean</span>
<span class="sd">                algebra, e.g. ``protein and not resname ALA LYS``</span>
<span class="sd">                selects all atoms that belong to a protein, but are not in a</span>
<span class="sd">                lysine or alanine residue</span>

<span class="sd">        **Geometric**</span>

<span class="sd">            around *distance*  *selection*</span>
<span class="sd">                selects all atoms a certain cutoff away from another selection,</span>
<span class="sd">                e.g. ``around 3.5 protein`` selects all atoms not belonging to</span>
<span class="sd">                protein that are within 3.5 Angstroms from the protein</span>
<span class="sd">            point *x* *y* *z*  *distance*</span>
<span class="sd">                selects all atoms within a cutoff of a point in space, make sure</span>
<span class="sd">                coordinate is separated by spaces,</span>
<span class="sd">                e.g. ``point 5.0 5.0 5.0  3.5`` selects all atoms within 3.5</span>
<span class="sd">                Angstroms of the coordinate (5.0, 5.0, 5.0)</span>
<span class="sd">            prop [abs] *property*  *operator*  *value*</span>
<span class="sd">                selects atoms based on position, using *property*  **x**, **y**,</span>
<span class="sd">                or **z** coordinate. Supports the **abs** keyword (for absolute</span>
<span class="sd">                value) and the following *operators*: **&lt;, &gt;, &lt;=, &gt;=, ==, !=**.</span>
<span class="sd">                For example, ``prop z &gt;= 5.0`` selects all atoms with z</span>
<span class="sd">                coordinate greater than 5.0; ``prop abs z &lt;= 5.0`` selects all</span>
<span class="sd">                atoms within -5.0 &lt;= z &lt;= 5.0.</span>
<span class="sd">            sphzone *radius* *selection*</span>
<span class="sd">                Selects all atoms that are within *radius* of the center of</span>
<span class="sd">                geometry of *selection*</span>
<span class="sd">            sphlayer *inner radius* *outer radius* *selection*</span>
<span class="sd">                Similar to sphzone, but also excludes atoms that are within</span>
<span class="sd">                *inner radius* of the selection COG</span>
<span class="sd">            isolayer *inner radius* *outer radius* *selection*</span>
<span class="sd">                Similar to sphlayer, but will find layer around all reference</span>
<span class="sd">                layer, creating an iso-surface.</span>
<span class="sd">            cyzone *externalRadius* *zMax* *zMin* *selection*</span>
<span class="sd">                selects all atoms within a cylindric zone centered in the</span>
<span class="sd">                center of geometry (COG) of a given selection,</span>
<span class="sd">                e.g. ``cyzone 15 4 -8 protein and resid 42`` selects the</span>
<span class="sd">                center of geometry of protein and resid 42, and creates a</span>
<span class="sd">                cylinder of external radius 15 centered on the COG. In z, the</span>
<span class="sd">                cylinder extends from 4 above the COG to 8 below. Positive</span>
<span class="sd">                values for *zMin*, or negative ones for *zMax*, are allowed.</span>
<span class="sd">            cylayer *innerRadius* *externalRadius* *zMax* *zMin* *selection*</span>
<span class="sd">                selects all atoms within a cylindric layer centered in the</span>
<span class="sd">                center of geometry (COG) of a given selection,</span>
<span class="sd">                e.g. ``cylayer 5 10 10 -8 protein`` selects the center of</span>
<span class="sd">                geometry of protein, and creates a cylindrical layer of inner</span>
<span class="sd">                radius 5, external radius 10 centered on the COG. In z, the</span>
<span class="sd">                cylinder extends from 10 above the COG to 8 below. Positive</span>
<span class="sd">                values for *zMin*, or negative ones for *zMax*, are allowed.</span>

<span class="sd">        **Connectivity**</span>

<span class="sd">            byres *selection*</span>
<span class="sd">                selects all atoms that are in the same segment and residue as</span>
<span class="sd">                selection, e.g. specify the subselection after the byres keyword</span>
<span class="sd">            bonded *selection*</span>
<span class="sd">                selects all atoms that are bonded to selection</span>
<span class="sd">                eg: ``select name H and bonded name O`` selects only hydrogens</span>
<span class="sd">                bonded to oxygens</span>

<span class="sd">        **Index**</span>

<span class="sd">            bynum *index-range*</span>
<span class="sd">                selects all atoms within a range of (1-based) inclusive indices,</span>
<span class="sd">                e.g. ``bynum 1`` selects the first atom in the universe;</span>
<span class="sd">                ``bynum 5:10`` selects atoms 5 through 10 inclusive. All atoms</span>
<span class="sd">                in the :class:`~MDAnalysis.core.universe.Universe` are</span>
<span class="sd">                consecutively numbered, and the index runs from 1 up to the</span>
<span class="sd">                total number of atoms.</span>
<span class="sd">            index *index-range*</span>
<span class="sd">                selects all atoms within a range of (0-based) inclusive indices,</span>
<span class="sd">                e.g. ``index 0`` selects the first atom in the universe;</span>
<span class="sd">                ``index 5:10`` selects atoms 6 through 11 inclusive. All atoms</span>
<span class="sd">                in the :class:`~MDAnalysis.core.universe.Universe` are</span>
<span class="sd">                consecutively numbered, and the index runs from 0 up to the</span>
<span class="sd">                total number of atoms - 1.</span>

<span class="sd">        **Preexisting selections**</span>

<span class="sd">            group `group-name`</span>
<span class="sd">                selects the atoms in the :class:`AtomGroup` passed to the</span>
<span class="sd">                function as a keyword argument named `group-name`. Only the</span>
<span class="sd">                atoms common to `group-name` and the instance</span>
<span class="sd">                :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms`</span>
<span class="sd">                was called from will be considered, unless ``group`` is</span>
<span class="sd">                preceded by the ``global`` keyword. `group-name` will be</span>
<span class="sd">                included in the parsing just by comparison of atom indices.</span>
<span class="sd">                This means that it is up to the user to make sure the</span>
<span class="sd">                `group-name` group was defined in an appropriate</span>
<span class="sd">                :class:`~MDAnalysis.core.universe.Universe`.</span>
<span class="sd">            global *selection*</span>
<span class="sd">                by default, when issuing</span>
<span class="sd">                :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` from an</span>
<span class="sd">                :class:`~MDAnalysis.core.groups.AtomGroup`, selections and</span>
<span class="sd">                subselections are returned intersected with the atoms of that</span>
<span class="sd">                instance. Prefixing a selection term with ``global`` causes its</span>
<span class="sd">                selection to be returned in its entirety.  As an example, the</span>
<span class="sd">                ``global`` keyword allows for</span>
<span class="sd">                ``lipids.select_atoms(&quot;around 10 global protein&quot;)`` --- where</span>
<span class="sd">                ``lipids`` is a group that does not contain any proteins. Were</span>
<span class="sd">                ``global`` absent, the result would be an empty selection since</span>
<span class="sd">                the ``protein`` subselection would itself be empty. When issuing</span>
<span class="sd">                :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` from a</span>
<span class="sd">                :class:`~MDAnalysis.core.universe.Universe`, ``global`` is</span>
<span class="sd">                ignored.</span>

<span class="sd">        **Dynamic selections**</span>
<span class="sd">            If :meth:`~MDAnalysis.core.groups.AtomGroup.select_atoms` is</span>
<span class="sd">            invoked with named argument `updating` set to `True`, an</span>
<span class="sd">            :class:`~MDAnalysis.core.groups.UpdatingAtomGroup` instance will be</span>
<span class="sd">            returned, instead of a regular</span>
<span class="sd">            :class:`~MDAnalysis.core.groups.AtomGroup`. It behaves just like</span>
<span class="sd">            the latter, with the difference that the selection expressions are</span>
<span class="sd">            re-evaluated every time the trajectory frame changes (this happens</span>
<span class="sd">            lazily, only when the</span>
<span class="sd">            :class:`~MDAnalysis.core.groups.UpdatingAtomGroup` is accessed so</span>
<span class="sd">            that there is no redundant updating going on).</span>
<span class="sd">            Issuing an updating selection from an already updating group will</span>
<span class="sd">            cause later updates to also reflect the updating of the base group.</span>
<span class="sd">            A non-updating selection or a slicing operation made on an</span>
<span class="sd">            :class:`~MDAnalysis.core.groups.UpdatingAtomGroup` will return a</span>
<span class="sd">            static :class:`~MDAnalysis.core.groups.AtomGroup`, which will no</span>
<span class="sd">            longer update across frames.</span>


<span class="sd">        .. versionchanged:: 0.7.4 Added *resnum* selection.</span>
<span class="sd">        .. versionchanged:: 0.8.1 Added *group* and *fullgroup* selections.</span>
<span class="sd">        .. versionchanged:: 0.13.0 Added *bonded* selection.</span>
<span class="sd">        .. versionchanged:: 0.16.0 Resid selection now takes icodes into account</span>
<span class="sd">            where present.</span>
<span class="sd">        .. versionchanged:: 0.16.0 Updating selections now possible by setting</span>
<span class="sd">            the `updating` argument.</span>
<span class="sd">        .. versionchanged:: 0.17.0 Added *moltype* and *molnum* selections.</span>
<span class="sd">        .. versionchanged:: 0.19.0</span>
<span class="sd">           Added strict type checking for passed groups.</span>
<span class="sd">           Added periodic kwarg (default True)</span>
<span class="sd">        .. versionchanged:: 0.19.2</span>
<span class="sd">           Empty sel string now returns an empty Atom group.</span>
<span class="sd">        .. versionchanged:: 1.0.0</span>
<span class="sd">           The ``fullgroup`` selection has now been removed in favor of the</span>
<span class="sd">           equivalent ``global group`` selection.</span>
<span class="sd">           Removed flags affecting default behaviour for periodic selections;</span>
<span class="sd">           periodic are now on by default (as with default flags)</span>
<span class="sd">        .. versionchanged:: 2.0.0</span>
<span class="sd">            Added the *smarts* selection. Added `atol` and `rtol` keywords</span>
<span class="sd">            to select float values. Added the ``sort`` keyword. Added</span>
<span class="sd">            `rdkit_kwargs` to pass parameters to the RDKitConverter.</span>
<span class="sd">        .. versionchanged:: 2.2.0</span>
<span class="sd">            Added `smarts_kwargs` to pass parameters to the RDKit</span>
<span class="sd">            GetSubstructMatch for *smarts* selection.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sel</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Empty string to select atoms, empty group returned.&quot;</span><span class="p">,</span>
                          <span class="ne">UserWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[[]]</span>

        <span class="n">sel_strs</span> <span class="o">=</span> <span class="p">(</span><span class="n">sel</span><span class="p">,)</span> <span class="o">+</span> <span class="n">othersel</span>

        <span class="k">for</span> <span class="n">group</span><span class="p">,</span> <span class="n">thing</span> <span class="ow">in</span> <span class="n">selgroups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Passed groups must be AtomGroups. &quot;</span>
                                <span class="s2">&quot;You provided </span><span class="si">{}</span><span class="s2"> for group &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">thing</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">group</span><span class="p">))</span>

        <span class="n">selections</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">selection</span><span class="o">.</span><span class="n">Parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">selgroups</span><span class="p">,</span>
                                                   <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span>
                                                   <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
                                                   <span class="nb">sorted</span><span class="o">=</span><span class="nb">sorted</span><span class="p">,</span>
                                                   <span class="n">rdkit_kwargs</span><span class="o">=</span><span class="n">rdkit_kwargs</span><span class="p">,</span>
                                                   <span class="n">smarts_kwargs</span><span class="o">=</span><span class="n">smarts_kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sel_strs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">updating</span><span class="p">:</span>
            <span class="n">atomgrp</span> <span class="o">=</span> <span class="n">UpdatingAtomGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selections</span><span class="p">,</span> <span class="n">sel_strs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Apply the first selection and sum to it</span>
            <span class="n">atomgrp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">sel</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">sel</span> <span class="ow">in</span> <span class="n">selections</span><span class="p">[</span><span class="mi">1</span><span class="p">:]],</span>
                          <span class="n">selections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">atomgrp</span></div>


<div class="viewcode-block" id="AtomGroup.split">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.AtomGroup.split">[docs]</a>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split :class:`AtomGroup` into a :class:`list` of</span>
<span class="sd">        :class:`AtomGroups&lt;AtomGroup&gt;` by `level`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : {&#39;atom&#39;, &#39;residue&#39;, &#39;molecule&#39;, &#39;segment&#39;}</span>


<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.17.0 Added the &#39;molecule&#39; level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">accessors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;segment&#39;</span><span class="p">:</span> <span class="s1">&#39;segindices&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;residue&#39;</span><span class="p">:</span> <span class="s1">&#39;resindices&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;molecule&#39;</span><span class="p">:</span> <span class="s1">&#39;molnums&#39;</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="s2">&quot;atom&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[[</span><span class="n">a</span><span class="o">.</span><span class="n">ix</span><span class="p">]]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

        <span class="c1"># higher level groupings</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">levelindices</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">accessors</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;This universe does not have </span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s1"> information. Maybe&#39;</span>
                      <span class="sa">f</span><span class="s1">&#39; it is not provided in the topology format in use.&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;level = &#39;</span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2">&#39; not supported, must be one of &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">accessors</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">levelindices</span> <span class="o">==</span> <span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span>
                <span class="n">unique_int_1d</span><span class="p">(</span><span class="n">levelindices</span><span class="p">)]</span></div>


<div class="viewcode-block" id="AtomGroup.guess_bonds">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.AtomGroup.guess_bonds">[docs]</a>
    <span class="k">def</span> <span class="nf">guess_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vdwradii</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fudge_factor</span><span class="o">=</span><span class="mf">0.55</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Guess bonds, angles, and dihedrals between the atoms in this</span>
<span class="sd">        :class:`AtomGroup` and add them to the underlying</span>
<span class="sd">        :attr:`~AtomGroup.universe`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vdwradii : dict, optional</span>
<span class="sd">            Dict relating atom types: vdw radii</span>

<span class="sd">        fudge_factor : float, optional</span>
<span class="sd">            The factor by which atoms must overlap each other to be considered</span>
<span class="sd">            a bond.  Larger values will increase the number of bonds found. [0.55]</span>
<span class="sd">        lower_bound : float, optional</span>
<span class="sd">            The minimum bond length. All bonds found shorter than this length</span>
<span class="sd">            will be ignored. This is useful for parsing PDB with altloc records</span>
<span class="sd">            where atoms with altloc A and B may be very close together and</span>
<span class="sd">            there should be no chemical bond between them. [0.1]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`MDAnalysis.topology.guessers.guess_bonds`</span>
<span class="sd">        :func:`MDAnalysis.topology.guessers.guess_angles`</span>
<span class="sd">        :func:`MDAnalysis.topology.guessers.guess_dihedrals`</span>


<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        .. versionchanged:: 0.20.2</span>
<span class="sd">           Now applies periodic boundary conditions when guessing bonds.</span>
<span class="sd">        .. versionchanged:: 2.5.0</span>
<span class="sd">           Corrected misleading docs, and now allows passing of `fudge_factor`</span>
<span class="sd">           and `lower_bound` arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">guess_bonds</span><span class="p">,</span> <span class="n">guess_angles</span><span class="p">,</span> <span class="n">guess_dihedrals</span>
        <span class="kn">from</span> <span class="nn">.topologyattrs</span> <span class="kn">import</span> <span class="n">Bonds</span><span class="p">,</span> <span class="n">Angles</span><span class="p">,</span> <span class="n">Dihedrals</span>

        <span class="k">def</span> <span class="nf">get_TopAttr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;either get *name* or create one from *cls*&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_topology</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">attr</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">([])</span>
                <span class="n">u</span><span class="o">.</span><span class="n">add_TopologyAttr</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">attr</span>

        <span class="c1"># indices of bonds</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">guess_bonds</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
            <span class="n">vdwradii</span><span class="o">=</span><span class="n">vdwradii</span><span class="p">,</span>
            <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
            <span class="n">fudge_factor</span><span class="o">=</span><span class="n">fudge_factor</span><span class="p">,</span>
            <span class="n">lower_bound</span><span class="o">=</span><span class="n">lower_bound</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">bondattr</span> <span class="o">=</span> <span class="n">get_TopAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="s2">&quot;bonds&quot;</span><span class="p">,</span> <span class="n">Bonds</span><span class="p">)</span>
        <span class="n">bondattr</span><span class="o">.</span><span class="n">_add_bonds</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">guess_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span>
        <span class="n">angleattr</span> <span class="o">=</span> <span class="n">get_TopAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="s1">&#39;angles&#39;</span><span class="p">,</span> <span class="n">Angles</span><span class="p">)</span>
        <span class="n">angleattr</span><span class="o">.</span><span class="n">_add_bonds</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">guess_dihedrals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">diheattr</span> <span class="o">=</span> <span class="n">get_TopAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="s1">&#39;dihedrals&#39;</span><span class="p">,</span> <span class="n">Dihedrals</span><span class="p">)</span>
        <span class="n">diheattr</span><span class="o">.</span><span class="n">_add_bonds</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bond</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This :class:`AtomGroup` represented as a</span>
<span class="sd">        :class:`MDAnalysis.core.topologyobjects.Bond` object</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the :class:`AtomGroup` is not length 2</span>


<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;bond only makes sense for a group with exactly 2 atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">topologyobjects</span><span class="o">.</span><span class="n">Bond</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This :class:`AtomGroup` represented as an</span>
<span class="sd">        :class:`MDAnalysis.core.topologyobjects.Angle` object</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the :class:`AtomGroup` is not length 3</span>


<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;angle only makes sense for a group with exactly 3 atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">topologyobjects</span><span class="o">.</span><span class="n">Angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dihedral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This :class:`AtomGroup` represented as a</span>
<span class="sd">        :class:`~MDAnalysis.core.topologyobjects.Dihedral` object</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the :class:`AtomGroup` is not length 4</span>


<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;dihedral only makes sense for a group with exactly 4 atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">topologyobjects</span><span class="o">.</span><span class="n">Dihedral</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">improper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This :class:`AtomGroup` represented as an</span>
<span class="sd">        :class:`MDAnalysis.core.topologyobjects.ImproperDihedral` object</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the :class:`AtomGroup` is not length 4</span>


<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;improper only makes sense for a group with exactly 4 atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">topologyobjects</span><span class="o">.</span><span class="n">ImproperDihedral</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ureybradley</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This :class:`AtomGroup` represented as an</span>
<span class="sd">        :class:`MDAnalysis.core.topologyobjects.UreyBradley` object</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the :class:`AtomGroup` is not length 2</span>


<span class="sd">        .. versionadded:: 1.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;urey bradley only makes sense for a group with exactly 2 atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">topologyobjects</span><span class="o">.</span><span class="n">UreyBradley</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cmap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This :class:`AtomGroup` represented as an</span>
<span class="sd">        :class:`MDAnalysis.core.topologyobjects.CMap` object</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the :class:`AtomGroup` is not length 5</span>


<span class="sd">        .. versionadded:: 1.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;cmap only makes sense for a group with exactly 5 atoms&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">topologyobjects</span><span class="o">.</span><span class="n">CMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="n">convert_to</span> <span class="o">=</span> <span class="n">Accessor</span><span class="p">(</span><span class="s2">&quot;convert_to&quot;</span><span class="p">,</span> <span class="n">ConverterWrapper</span><span class="p">)</span>

<div class="viewcode-block" id="AtomGroup.write">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.AtomGroup.write">[docs]</a>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">filenamefmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{trjname}</span><span class="s2">_</span><span class="si">{frame}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write `AtomGroup` to a file.</span>

<span class="sd">        The output can either be a coordinate file or a selection, depending on</span>
<span class="sd">        the format.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            &gt;&gt;&gt; ag = u.atoms</span>
<span class="sd">            &gt;&gt;&gt; ag.write(&#39;selection.ndx&#39;)  # Write a gromacs index file</span>
<span class="sd">            &gt;&gt;&gt; ag.write(&#39;coordinates.pdb&#39;)  # Write the current frame as PDB</span>
<span class="sd">            &gt;&gt;&gt; # Write the trajectory in XTC format</span>
<span class="sd">            &gt;&gt;&gt; ag.write(&#39;trajectory.xtc&#39;, frames=&#39;all&#39;)</span>
<span class="sd">            &gt;&gt;&gt; # Write every other frame of the trajectory in PBD format</span>
<span class="sd">            &gt;&gt;&gt; ag.write(&#39;trajectory.pdb&#39;, frames=u.trajectory[::2])</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            ``None``: create TRJNAME_FRAME.FORMAT from filenamefmt [``None``]</span>
<span class="sd">        file_format : str, optional</span>
<span class="sd">            The name or extension of a coordinate, trajectory, or selection</span>
<span class="sd">            file format such as PDB, CRD, GRO, VMD (tcl), PyMol (pml), Gromacs</span>
<span class="sd">            (ndx) CHARMM (str) or Jmol (spt); case-insensitive [PDB]</span>
<span class="sd">        filenamefmt : str, optional</span>
<span class="sd">            format string for default filename; use substitution tokens</span>
<span class="sd">            &#39;trjname&#39; and &#39;frame&#39; [&quot;%(trjname)s_%(frame)d&quot;]</span>
<span class="sd">        bonds : str, optional</span>
<span class="sd">            how to handle bond information, especially relevant for PDBs.</span>
<span class="sd">            ``&quot;conect&quot;``: write only the CONECT records defined in the original</span>
<span class="sd">            file. ``&quot;all&quot;``: write out all bonds, both the original defined and</span>
<span class="sd">            those guessed by MDAnalysis. ``None``: do not write out bonds.</span>
<span class="sd">            Default is ``&quot;conect&quot;``.</span>
<span class="sd">        frames: array-like or slice or FrameIteratorBase or str, optional</span>
<span class="sd">            An ensemble of frames to write. The ensemble can be an list or</span>
<span class="sd">            array of frame indices, a mask of booleans, an instance of</span>
<span class="sd">            :class:`slice`, or the value returned when a trajectory is indexed.</span>
<span class="sd">            By default, `frames` is set to ``None`` and only the current frame</span>
<span class="sd">            is written. If `frames` is set to &quot;all&quot;, then all the frame from</span>
<span class="sd">            trajectory are written.</span>


<span class="sd">        .. versionchanged:: 0.9.0 Merged with write_selection. This method can</span>
<span class="sd">            now write both selections out.</span>
<span class="sd">        .. versionchanged:: 0.19.0</span>
<span class="sd">            Can write multiframe trajectories with the &#39;frames&#39; argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add a &#39;verbose&#39; option alongside &#39;frames&#39;.</span>

        <span class="c1"># check that AtomGroup actually has any atoms (Issue #434)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Cannot write an AtomGroup with 0 atoms&quot;</span><span class="p">)</span>

        <span class="n">trj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span>  <span class="c1"># unified trajectory API</span>
        <span class="k">if</span> <span class="n">frames</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">frames</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">trj_frames</span> <span class="o">=</span> <span class="n">trj</span><span class="p">[::]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># We accept everything that indexes a trajectory and returns a</span>
            <span class="c1"># subset of it. Though, numbers return a Timestep instead.</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The &quot;frames&quot; argument cannot be a number.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">test_trajectory</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">trajectory</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">trj_frames</span> <span class="o">=</span> <span class="n">trj</span><span class="p">[</span><span class="n">frames</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">test_trajectory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">trj</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;The trajectory of </span><span class="si">{}</span><span class="s1"> provided to the frames keyword &#39;</span>
                        <span class="s1">&#39;attribute is different from the trajectory of the &#39;</span>
                        <span class="s1">&#39;AtomGroup.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">trj_frames</span> <span class="o">=</span> <span class="n">frames</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trjname</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">trj</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filenamefmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trjname</span><span class="o">=</span><span class="n">trjname</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">trj</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">filename</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span>
                                 <span class="n">ext</span><span class="o">=</span><span class="n">file_format</span> <span class="k">if</span> <span class="n">file_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;PDB&#39;</span><span class="p">,</span>
                                 <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Some writer behave differently when they are given a &quot;multiframe&quot;</span>
        <span class="c1"># argument. It is the case of the PDB writer tht writes models when</span>
        <span class="c1"># &quot;multiframe&quot; is True.</span>
        <span class="c1"># We want to honor what the user provided with the argument if</span>
        <span class="c1"># provided explicitly. If not, then we need to figure out if we write</span>
        <span class="c1"># multiple frames or not.</span>
        <span class="n">multiframe</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;multiframe&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trj_frames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">multiframe</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Cannot explicitely set &quot;multiframe&quot; to False and request &#39;</span>
                <span class="s1">&#39;more than 1 frame with the &quot;frames&quot; keyword argument.&#39;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">multiframe</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">frames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># By default we only write the current frame.</span>
                <span class="n">multiframe</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">multiframe</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trj_frames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="c1"># From the following blocks, one must pass.</span>
        <span class="c1"># Both can&#39;t pass as the extensions don&#39;t overlap.</span>
        <span class="c1"># Try and select a Class using get_ methods (becomes `writer`)</span>
        <span class="c1"># Once (and if!) class is selected, use it in with block</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">get_writer_for</span><span class="p">(</span>
                <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">file_format</span><span class="p">,</span> <span class="n">multiframe</span><span class="o">=</span><span class="n">multiframe</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">writer</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">frames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">current_frame</span> <span class="o">=</span> <span class="n">trj</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">trj_frames</span><span class="p">:</span>
                            <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="n">trj</span><span class="p">[</span><span class="n">current_frame</span><span class="p">]</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># here `file_format` is only used as default,</span>
            <span class="c1"># anything pulled off `filename` will be used preferentially</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">get_selection_writer_for</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span>
                                              <span class="n">file_format</span> <span class="k">if</span> <span class="n">file_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;PDB&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">writer</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
                <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No writer found for format: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span></div>


<div class="viewcode-block" id="AtomGroup.sort">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.AtomGroup.sort">[docs]</a>
    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ix&#39;</span><span class="p">,</span> <span class="n">keyfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a sorted ``AtomGroup`` using a specified attribute as the key.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key: str, optional</span>
<span class="sd">            The name of the ``AtomGroup`` attribute to sort by (e.g. ``ids``,</span>
<span class="sd">            ``ix``. default= ``ix`` ).</span>
<span class="sd">        keyfunc: callable, optional</span>
<span class="sd">            A function to convert multidimensional arrays to a single</span>
<span class="sd">            dimension. This 1D array will be used as the sort key and</span>
<span class="sd">            is required when sorting with an ``AtomGroup`` attribute</span>
<span class="sd">            key which has multiple dimensions. Note: this argument</span>
<span class="sd">            is ignored when the attribute is one dimensional.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        :class:`AtomGroup`</span>
<span class="sd">            Sorted ``AtomGroup``.</span>

<span class="sd">        Example</span>
<span class="sd">        ----------</span>

<span class="sd">        .. doctest:: AtomGroup.sort</span>

<span class="sd">            &gt;&gt;&gt; import MDAnalysis as mda</span>
<span class="sd">            &gt;&gt;&gt; from MDAnalysisTests.datafiles import PDB_small</span>
<span class="sd">            &gt;&gt;&gt; u = mda.Universe(PDB_small)</span>
<span class="sd">            &gt;&gt;&gt; ag = u.atoms[[3, 2, 1, 0]]</span>
<span class="sd">            &gt;&gt;&gt; ag.ix</span>
<span class="sd">            array([3, 2, 1, 0])</span>
<span class="sd">            &gt;&gt;&gt; ag = ag.sort()</span>
<span class="sd">            &gt;&gt;&gt; ag.ix</span>
<span class="sd">            array([0, 1, 2, 3])</span>
<span class="sd">            &gt;&gt;&gt; ag.positions</span>
<span class="sd">            array([[-11.921,  26.307,  10.41 ],</span>
<span class="sd">                   [-11.447,  26.741,   9.595],</span>
<span class="sd">                   [-12.44 ,  27.042,  10.926],</span>
<span class="sd">                   [-12.632,  25.619,  10.046]], dtype=float32)</span>
<span class="sd">            &gt;&gt;&gt; ag = ag.sort(&quot;positions&quot;, lambda x: x[:, 1])</span>
<span class="sd">            &gt;&gt;&gt; ag.positions</span>
<span class="sd">            array([[-12.632,  25.619,  10.046],</span>
<span class="sd">                   [-11.921,  26.307,  10.41 ],</span>
<span class="sd">                   [-11.447,  26.741,   9.595],</span>
<span class="sd">                   [-12.44 ,  27.042,  10.926]], dtype=float32)</span>

<span class="sd">        Note</span>
<span class="sd">        ----------</span>
<span class="sd">        This uses a stable sort as implemented by</span>
<span class="sd">        `numpy.argsort(kind=&#39;stable&#39;)`.</span>


<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The array returned by the attribute &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                             <span class="s2">&quot;must have the same length as the number of &quot;</span>
                             <span class="s2">&quot;atoms in the input AtomGroup&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">idx</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">keyfunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;The </span><span class="si">{}</span><span class="s2"> attribute returns a multidimensional &quot;</span>
                                <span class="s2">&quot;array. In order to sort it, a function &quot;</span>
                                <span class="s2">&quot;returning a 1D array (to be used as the sort &quot;</span>
                                <span class="s2">&quot;key) must be passed to the keyfunc argument&quot;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="n">sortkeys</span> <span class="o">=</span> <span class="n">keyfunc</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sortkeys</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The function assigned to the argument &quot;</span>
                                 <span class="s2">&quot;&#39;keyfunc&#39;:</span><span class="si">{}</span><span class="s2"> doesn&#39;t return a 1D array.&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keyfunc</span><span class="p">))</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sortkeys</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">order</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="ResidueGroup">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.ResidueGroup">[docs]</a>
<span class="k">class</span> <span class="nc">ResidueGroup</span><span class="p">(</span><span class="n">GroupBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ResidueGroup base class.</span>

<span class="sd">    This class is used by a :class:`~MDAnalysis.core.universe.Universe` for</span>
<span class="sd">    generating its Topology-specific :class:`ResidueGroup` class. All the</span>
<span class="sd">    :class:`~MDAnalysis.core.topologyattrs.TopologyAttr` components are obtained</span>
<span class="sd">    from :class:`GroupBase`, so this class only includes ad-hoc methods</span>
<span class="sd">    specific to :class:`ResidueGroups&lt;ResidueGroup&gt;`.</span>

<span class="sd">    ResidueGroups can be compared and combined using group operators. See the</span>
<span class="sd">    list of these operators on :class:`GroupBase`.</span>

<span class="sd">    .. deprecated:: 0.16.2</span>
<span class="sd">       *Instant selectors* of Segments will be removed in the 1.0 release.</span>
<span class="sd">    .. versionchanged:: 1.0.0</span>
<span class="sd">       Removed instant selectors, use select_atoms instead</span>
<span class="sd">    .. versionchanged:: 2.1.0</span>
<span class="sd">       Indexing an ResidueGroup with ``None`` raises a ``TypeError``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_unpickle2</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An :class:`AtomGroup` of :class:`Atoms&lt;Atom&gt;` present in this</span>
<span class="sd">        :class:`ResidueGroup`.</span>

<span class="sd">        The :class:`Atoms&lt;Atom&gt;` are ordered locally by :class:`Residue` in the</span>
<span class="sd">        :class:`ResidueGroup`.  Duplicates are *not* removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span>
        <span class="n">ag</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">u</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">)]</span>
        <span class="c1"># If the ResidueGroup is known to be unique, this also holds for the</span>
        <span class="c1"># atoms therein, since atoms can only belong to one residue at a time.</span>
        <span class="c1"># On the contrary, if the ResidueGroup is not unique, this does not</span>
        <span class="c1"># imply non-unique atoms, since residues might be empty.</span>
        <span class="n">ag</span><span class="o">.</span><span class="n">_set_unique_caches_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of :class:`Atoms&lt;Atom&gt;` present in this :class:`ResidueGroup`,</span>
<span class="sd">        including duplicate residues (and thus, duplicate atoms).</span>

<span class="sd">        Equivalent to ``len(self.atoms)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The :class:`ResidueGroup` itself.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        copy : return a true copy of the :class:`ResidueGroup`</span>


<span class="sd">        .. versionchanged:: 0.19.0</span>
<span class="sd">           In previous versions, this returned a copy, but now</span>
<span class="sd">           the :class:`ResidueGroup` itself is returned. This should</span>
<span class="sd">           not affect any code but only speed up calculations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of residues in the :class:`ResidueGroup`.</span>

<span class="sd">        Equivalent to ``len(self)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get sorted :class:`SegmentGroup` of the unique segments present in</span>
<span class="sd">        the :class:`ResidueGroup`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">unique_int_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segindices</span><span class="p">)]</span>
        <span class="n">sg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">sg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">sg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sg</span>
        <span class="n">sg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sg</span>
        <span class="k">return</span> <span class="n">sg</span>

    <span class="nd">@segments</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="c1"># Can set with Seg, SegGroup or list/tuple of Seg</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">Segment</span><span class="p">):</span>
            <span class="n">s_ix</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="n">new</span><span class="o">.</span><span class="n">segindex</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">):</span>
            <span class="n">s_ix</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">segindices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">s_ix</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">segindex</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Can only set ResidueGroup segments to Segment &quot;</span>
                          <span class="s2">&quot;or SegmentGroup, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new</span>
                                      <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Segment</span><span class="p">))))</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s_ix</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_ix</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incorrect size: </span><span class="si">{}</span><span class="s2"> for ResidueGroup of size: </span><span class="si">{}</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="c1"># Optimisation TODO:</span>
        <span class="c1"># This currently rebuilds the tt len(self) times</span>
        <span class="c1"># Ideally all changes would happen and *afterwards* tables are built</span>
        <span class="c1"># Alternatively, if the changes didn&#39;t rebuild table, this list</span>
        <span class="c1"># comprehension isn&#39;t terrible.</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_ix</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">move_residue</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of unique segments present in the ResidueGroup.</span>

<span class="sd">        Equivalent to ``len(self.segments)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a :class:`ResidueGroup` containing sorted and unique</span>
<span class="sd">        :class:`Residues&lt;Residue&gt;` only.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. testsetup:: ResidueGroup.unique</span>

<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">            u = mda.Universe(PSF, DCD)</span>

<span class="sd">        .. doctest:: ResidueGroup.unique</span>

<span class="sd">            &gt;&gt;&gt; rg = u.residues[[2, 1, 2, 2, 1, 0]]</span>
<span class="sd">            &gt;&gt;&gt; rg</span>
<span class="sd">            &lt;ResidueGroup with 6 residues&gt;</span>
<span class="sd">            &gt;&gt;&gt; rg.ix</span>
<span class="sd">            array([2, 1, 2, 2, 1, 0])</span>
<span class="sd">            &gt;&gt;&gt; rg2 = rg.unique</span>
<span class="sd">            &gt;&gt;&gt; rg2</span>
<span class="sd">            &lt;ResidueGroup with 3 residues&gt;</span>
<span class="sd">            &gt;&gt;&gt; rg2.ix</span>
<span class="sd">            array([0, 1, 2])</span>
<span class="sd">            &gt;&gt;&gt; rg2.unique is rg2</span>
<span class="sd">            False</span>


<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        .. versionchanged:: 0.19.0 If the :class:`ResidueGroup` is already</span>
<span class="sd">            unique, :attr:`ResidueGroup.unique` now returns the group itself</span>
<span class="sd">            instead of a copy.</span>
<span class="sd">        .. versionchanged:: 2.0.0</span>
<span class="sd">            This function now always returns a copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_unique</span><span class="p">[:]</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
        <span class="k">return</span> <span class="n">group</span>

<div class="viewcode-block" id="ResidueGroup.asunique">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.ResidueGroup.asunique">[docs]</a>
    <span class="k">def</span> <span class="nf">asunique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a :class:`ResidueGroup` containing unique</span>
<span class="sd">        :class:`Residues&lt;Residue&gt;` only, with optional sorting.</span>

<span class="sd">        If the :class:`ResidueGroup` is unique, this is the group itself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sorted: bool (optional)</span>
<span class="sd">            Whether or not the returned ResidueGroup should be sorted</span>
<span class="sd">            by resindex.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`ResidueGroup`</span>
<span class="sd">            Unique ``ResidueGroup``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. testsetup:: ResidueGroup.asunique</span>

<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">            u = mda.Universe(PSF, DCD)</span>

<span class="sd">        .. doctest:: ResidueGroup.asunique</span>

<span class="sd">            &gt;&gt;&gt; rg = u.residues[[2, 1, 2, 2, 1, 0]]</span>
<span class="sd">            &gt;&gt;&gt; rg</span>
<span class="sd">            &lt;ResidueGroup with 6 residues&gt;</span>
<span class="sd">            &gt;&gt;&gt; rg.ix</span>
<span class="sd">            array([2, 1, 2, 2, 1, 0])</span>
<span class="sd">            &gt;&gt;&gt; rg2 = rg.asunique(sorted=True)</span>
<span class="sd">            &gt;&gt;&gt; rg2</span>
<span class="sd">            &lt;ResidueGroup with 3 residues&gt;</span>
<span class="sd">            &gt;&gt;&gt; rg2.ix</span>
<span class="sd">            array([0, 1, 2])</span>
<span class="sd">            &gt;&gt;&gt; rg2.asunique() is rg2</span>
<span class="sd">            True</span>


<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asunique</span><span class="p">(</span><span class="nb">sorted</span><span class="o">=</span><span class="nb">sorted</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SegmentGroup">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.SegmentGroup">[docs]</a>
<span class="k">class</span> <span class="nc">SegmentGroup</span><span class="p">(</span><span class="n">GroupBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;:class:`SegmentGroup` base class.</span>

<span class="sd">    This class is used by a :class:`~MDAnalysis.core.universe.Universe` for</span>
<span class="sd">    generating its Topology-specific :class:`SegmentGroup` class. All the</span>
<span class="sd">    :class:`~MDAnalysis.core.topologyattrs.TopologyAttr` components are obtained</span>
<span class="sd">    from :class:`GroupBase`, so this class only includes ad-hoc methods specific</span>
<span class="sd">    to :class:`SegmentGroups&lt;SegmentGroup&gt;`.</span>

<span class="sd">    :class:`SegmentGroups&lt;SegmentGroup&gt;` can be compared and combined using</span>
<span class="sd">    group operators. See the list of these operators on :class:`GroupBase`.</span>

<span class="sd">    .. deprecated:: 0.16.2</span>
<span class="sd">       *Instant selectors* of Segments will be removed in the 1.0 release.</span>
<span class="sd">    .. versionchanged:: 1.0.0</span>
<span class="sd">       Removed instant selectors, use select_atoms instead</span>
<span class="sd">    .. versionchanged:: 2.1.0</span>
<span class="sd">       Indexing an SegmentGroup with ``None`` raises a ``TypeError``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_unpickle2</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An :class:`AtomGroup` of :class:`Atoms&lt;Atom&gt;` present in this</span>
<span class="sd">        :class:`SegmentGroup`.</span>

<span class="sd">        The :class:`Atoms&lt;Atom&gt;` are ordered locally by :class:`Residue`, which</span>
<span class="sd">        are further ordered by :class:`Segment` in the :class:`SegmentGroup`.</span>
<span class="sd">        Duplicates are *not* removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span>
        <span class="n">ag</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">u</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">)]</span>
        <span class="c1"># If the SegmentGroup is known to be unique, this also holds for the</span>
        <span class="c1"># residues therein, and thus, also for the atoms in those residues.</span>
        <span class="c1"># On the contrary, if the SegmentGroup is not unique, this does not</span>
        <span class="c1"># imply non-unique atoms, since segments or residues might be empty.</span>
        <span class="n">ag</span><span class="o">.</span><span class="n">_set_unique_caches_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of atoms present in the :class:`SegmentGroup`, including</span>
<span class="sd">        duplicate segments (and thus, duplicate atoms).</span>

<span class="sd">        Equivalent to ``len(self.atoms)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A :class:`ResidueGroup` of :class:`Residues&lt;Residue&gt;` present in this</span>
<span class="sd">        :class:`SegmentGroup`.</span>

<span class="sd">        The :class:`Residues&lt;Residue&gt;` are ordered locally by</span>
<span class="sd">        :class:`Segment` in the :class:`SegmentGroup`. Duplicates are *not*</span>
<span class="sd">        removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resindices</span><span class="p">)]</span>
        <span class="c1"># If the SegmentGroup is known to be unique, this also holds for the</span>
        <span class="c1"># residues therein. On the contrary, if the SegmentGroup is not unique,</span>
        <span class="c1"># this does not imply non-unique residues, since segments might be</span>
        <span class="c1"># empty.</span>
        <span class="n">rg</span><span class="o">.</span><span class="n">_set_unique_caches_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rg</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of residues present in this :class:`SegmentGroup`, including</span>
<span class="sd">        duplicate segments (and thus, residues).</span>

<span class="sd">        Equivalent to ``len(self.residues)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The :class:`SegmentGroup` itself.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        copy : return a true copy of the :class:`SegmentGroup`</span>


<span class="sd">        .. versionchanged:: 0.19.0</span>
<span class="sd">           In previous versions, this returned a copy, but now</span>
<span class="sd">           the :class:`SegmentGroup` itself is returned. This should</span>
<span class="sd">           not affect any code but only speed up calculations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of segments in the :class:`SegmentGroup`.</span>

<span class="sd">        Equivalent to ``len(self)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a :class:`SegmentGroup` containing sorted and unique</span>
<span class="sd">        :class:`Segments&lt;Segment&gt;` only.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. testsetup:: SegmentGroup.unique</span>

<span class="sd">            from MDAnalysis.tests.datafiles import CONECT</span>
<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            u = mda.Universe(CONECT)</span>

<span class="sd">        .. doctest:: SegmentGroup.unique</span>

<span class="sd">            &gt;&gt;&gt; sg = u.segments[[2, 1, 2, 2, 1, 0]]</span>
<span class="sd">            &gt;&gt;&gt; sg</span>
<span class="sd">            &lt;SegmentGroup with 6 segments&gt;</span>
<span class="sd">            &gt;&gt;&gt; sg.ix</span>
<span class="sd">            array([2, 1, 2, 2, 1, 0])</span>
<span class="sd">            &gt;&gt;&gt; sg2 = sg.unique</span>
<span class="sd">            &gt;&gt;&gt; sg2</span>
<span class="sd">            &lt;SegmentGroup with 3 segments&gt;</span>
<span class="sd">            &gt;&gt;&gt; sg2.ix</span>
<span class="sd">            array([0, 1, 2])</span>
<span class="sd">            &gt;&gt;&gt; sg2.unique is sg2</span>
<span class="sd">            False</span>


<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        .. versionchanged:: 0.19.0 If the :class:`SegmentGroup` is already</span>
<span class="sd">            unique, :attr:`SegmentGroup.unique` now returns the group itself</span>
<span class="sd">            instead of a copy.</span>
<span class="sd">        .. versionchanged:: 2.0.0</span>
<span class="sd">            This function now always returns a copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_unique</span><span class="p">[:]</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
        <span class="n">group</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
        <span class="k">return</span> <span class="n">group</span>

<div class="viewcode-block" id="SegmentGroup.asunique">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.SegmentGroup.asunique">[docs]</a>
    <span class="k">def</span> <span class="nf">asunique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a :class:`SegmentGroup` containing unique</span>
<span class="sd">        :class:`Segments&lt;Segment&gt;` only, with optional sorting.</span>

<span class="sd">        If the :class:`SegmentGroup` is unique, this is the group itself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sorted: bool (optional)</span>
<span class="sd">            Whether or not the returned SegmentGroup should be sorted</span>
<span class="sd">            by segindex.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`SegmentGroup`</span>
<span class="sd">            Unique ``SegmentGroup``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. testsetup:: SegmentGroup.asunique</span>

<span class="sd">            from MDAnalysis.tests.datafiles import CONECT</span>
<span class="sd">            import MDAnalysis as mda</span>
<span class="sd">            u = mda.Universe(CONECT)</span>

<span class="sd">        .. doctest:: SegmentGroup.asunique</span>

<span class="sd">            &gt;&gt;&gt; sg = u.segments[[2, 1, 2, 2, 1, 0]]</span>
<span class="sd">            &gt;&gt;&gt; sg</span>
<span class="sd">            &lt;SegmentGroup with 6 segments&gt;</span>
<span class="sd">            &gt;&gt;&gt; sg.ix</span>
<span class="sd">            array([2, 1, 2, 2, 1, 0])</span>
<span class="sd">            &gt;&gt;&gt; sg2 = sg.asunique(sorted=True)</span>
<span class="sd">            &gt;&gt;&gt; sg2</span>
<span class="sd">            &lt;SegmentGroup with 3 segments&gt;</span>
<span class="sd">            &gt;&gt;&gt; sg2.ix</span>
<span class="sd">            array([0, 1, 2])</span>
<span class="sd">            &gt;&gt;&gt; sg2.asunique() is sg2</span>
<span class="sd">            True</span>


<span class="sd">        .. versionadded:: 2.0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asunique</span><span class="p">(</span><span class="nb">sorted</span><span class="o">=</span><span class="nb">sorted</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span></div>
</div>



<span class="nd">@functools</span><span class="o">.</span><span class="n">total_ordering</span>
<span class="k">class</span> <span class="nc">ComponentBase</span><span class="p">(</span><span class="n">_MutableBase</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Base class from which a :class:`~MDAnalysis.core.universe.Universe`\ &#39;s</span>
<span class="sd">    Component class is built.</span>

<span class="sd">    Components are the individual objects that are found in Groups.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># index of component</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span> <span class="o">=</span> <span class="n">ix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">u</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="n">selfcls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">_TOPOLOGY_ATTRS</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">_TOPOLOGY_ATTRS</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">attrname</span> <span class="ow">and</span> <span class="n">attr</span> <span class="o">!=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">singular</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{selfcls}</span><span class="s1"> has no attribute </span><span class="si">{attr}</span><span class="s1">. &#39;</span>
                       <span class="s1">&#39;Do you mean </span><span class="si">{singular}</span><span class="s1">?&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">selfcls</span><span class="o">=</span><span class="n">selfcls</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span>
                                                <span class="n">singular</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">singular</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="s1">&#39;This Universe does not contain </span><span class="si">{singular}</span><span class="s1"> information&#39;</span>
                <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">singular</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">singular</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ComponentBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t compare different level objects&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">ix</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t compare different level objects&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">ix</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">)</span>

    <span class="nd">@_only_same_level</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Concatenate the Component with another Component or Group of the</span>
<span class="sd">        same level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Component or Group</span>
<span class="sd">            Component or Group with `other.level` same as `self.level`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Group</span>
<span class="sd">            Group with elements of `self` and `other` concatenated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o_ix</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ix_array</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">plural</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ix_array</span><span class="p">,</span> <span class="n">o_ix</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Using built-in sum requires supporting 0 + self. If other is</span>
<span class="sd">        anything other 0, an exception will be raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : int</span>
<span class="sd">            Other should be 0, or else an exception will be raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>
<span class="sd">            Group with elements of `self` reproduced</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">plural</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unsupported operand type(s) for +:&quot;</span>
                            <span class="s2">&quot; &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unique index of this component.</span>

<span class="sd">        If this component is an :class:`Atom`, this is the index of the</span>
<span class="sd">        :class:`Atom`.</span>
<span class="sd">        If it is a :class:`Residue`, this is the index of the :class:`Residue`.</span>
<span class="sd">        If it is a :class:`Segment`, this is the index of the :class:`Segment`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ix_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unique index of this component as an array.</span>

<span class="sd">        This method gives a consistent API between components and groups.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>


<div class="viewcode-block" id="Atom">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.Atom">[docs]</a>
<span class="k">class</span> <span class="nc">Atom</span><span class="p">(</span><span class="n">ComponentBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;:class:`Atom` base class.</span>

<span class="sd">    This class is used by a :class:`~MDAnalysis.core.universe.Universe` for</span>
<span class="sd">    generating its Topology-specific :class:`Atom` class. All the</span>
<span class="sd">    :class:`~MDAnalysis.core.topologyattrs.TopologyAttr` components are obtained</span>
<span class="sd">    from :class:`ComponentBase`, so this class only includes ad-hoc methods</span>
<span class="sd">    specific to :class:`Atoms&lt;Atom&gt;`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">me</span> <span class="o">=</span> <span class="s1">&#39;&lt;Atom </span><span class="si">{}</span><span class="s1">:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; of type </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;resname&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; of resname </span><span class="si">{}</span><span class="s1">,&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;resid&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; resid </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;segid&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; and segid </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segid</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;altLoc&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; and altLoc </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">altLoc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">me</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_unpickle2</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">Atom</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="c1"># special-case timestep info</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;velocity&#39;</span><span class="p">:</span> <span class="s1">&#39;velocities&#39;</span><span class="p">,</span> <span class="s1">&#39;force&#39;</span><span class="p">:</span> <span class="s1">&#39;forces&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s1">&#39;This Timestep has no &#39;</span> <span class="o">+</span> <span class="n">ts</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;position&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s1">&#39;This Universe has no coordinates&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">residue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">resindices</span><span class="p">[</span><span class="bp">self</span><span class="p">]]</span>

    <span class="nd">@residue</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">residue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">Residue</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only set Atom residue to Residue, not </span><span class="si">{}</span><span class="s2">&quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">new</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">move_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">new</span><span class="o">.</span><span class="n">resindex</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">segindices</span><span class="p">[</span><span class="bp">self</span><span class="p">]]</span>

    <span class="nd">@segment</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot set atom segment.  &quot;</span>
                                  <span class="s2">&quot;Segments are assigned to Residues&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Coordinates of the atom.</span>

<span class="sd">        The position can be changed by assigning an array of length (3,).</span>

<span class="sd">        .. note:: changing the position is not reflected in any files; reading</span>
<span class="sd">                  any frame from the trajectory will replace the change with</span>
<span class="sd">                  that from the file</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ~MDAnalysis.exceptions.NoDataError</span>
<span class="sd">            If the underlying :class:`~MDAnalysis.coordinates.timestep.Timestep`</span>
<span class="sd">            does not contain</span>
<span class="sd">            :attr:`~MDAnalysis.coordinates.timestep.Timestep.positions`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@position</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Velocity of the atom.</span>

<span class="sd">        The velocity can be changed by assigning an array of shape ``(3,)``.</span>

<span class="sd">        .. note:: changing the velocity is not reflected in any files; reading</span>
<span class="sd">                  any frame from the trajectory will replace the change with</span>
<span class="sd">                  that from the file</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ~MDAnalysis.exceptions.NoDataError</span>
<span class="sd">            If the underlying :class:`~MDAnalysis.coordinates.timestep.Timestep`</span>
<span class="sd">            does not contain</span>
<span class="sd">            :attr:`~MDAnalysis.coordinates.timestep.Timestep.velocities`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">return</span> <span class="n">ts</span><span class="o">.</span><span class="n">velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@velocity</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">velocities</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">force</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Force on the atom.</span>

<span class="sd">        The force can be changed by assigning an array of shape ``(3,)``.</span>

<span class="sd">        .. note:: changing the force is not reflected in any files; reading any</span>
<span class="sd">                  frame from the trajectory will replace the change with that</span>
<span class="sd">                  from the file</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ~MDAnalysis.exceptions.NoDataError</span>
<span class="sd">            If the underlying :class:`~MDAnalysis.coordinates.timestep.Timestep`</span>
<span class="sd">            does not contain</span>
<span class="sd">            :attr:`~MDAnalysis.coordinates.timestep.Timestep.forces`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="k">return</span> <span class="n">ts</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@force</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">values</span></div>



<div class="viewcode-block" id="Residue">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.Residue">[docs]</a>
<span class="k">class</span> <span class="nc">Residue</span><span class="p">(</span><span class="n">ComponentBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;:class:`Residue` base class.</span>

<span class="sd">    This class is used by a :class:`~MDAnalysis.core.universe.Universe` for</span>
<span class="sd">    generating its Topology-specific :class:`Residue` class. All the</span>
<span class="sd">    :class:`~MDAnalysis.core.topologyattrs.TopologyAttr` components are obtained</span>
<span class="sd">    from :class:`ComponentBase`, so this class only includes ad-hoc methods</span>
<span class="sd">    specific to :class:`Residues&lt;Residue&gt;`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">me</span> <span class="o">=</span> <span class="s1">&#39;&lt;Residue&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;resname&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">,&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resname</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;resid&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">me</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_unpickle2</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">Residue</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An :class:`AtomGroup` of :class:`Atoms&lt;Atom&gt;` present in this</span>
<span class="sd">        :class:`Residue`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">self</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">ag</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ag</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ag</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ag</span>
        <span class="n">ag</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ag</span>
        <span class="k">return</span> <span class="n">ag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The :class:`Segment` this :class:`Residue` belongs to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">segindices</span><span class="p">[</span><span class="bp">self</span><span class="p">]]</span>

    <span class="nd">@segment</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">Segment</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only set Residue segment to Segment, not </span><span class="si">{}</span><span class="s2">&quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">new</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">move_residue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">new</span><span class="o">.</span><span class="n">segindex</span><span class="p">)</span></div>



<div class="viewcode-block" id="Segment">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.Segment">[docs]</a>
<span class="k">class</span> <span class="nc">Segment</span><span class="p">(</span><span class="n">ComponentBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;:class:`Segment` base class.</span>

<span class="sd">    This class is used by a :class:`~MDAnalysis.core.universe.Universe` for</span>
<span class="sd">    generating its Topology-specific :class:`Segment` class. All the</span>
<span class="sd">    :class:`~MDAnalysis.core.topologyattrs.TopologyAttr` components are obtained</span>
<span class="sd">    from :class:`ComponentBase`, so this class only includes ad-hoc methods</span>
<span class="sd">    specific to :class:`Segments&lt;Segment&gt;`.</span>

<span class="sd">    .. deprecated:: 0.16.2</span>
<span class="sd">       *Instant selectors* of :class:`Segments&lt;Segment&gt;` will be removed in the</span>
<span class="sd">       1.0 release.</span>
<span class="sd">    .. versionchanged:: 1.0.0</span>
<span class="sd">       Removed instant selectors, use either segment.residues[...] to select</span>
<span class="sd">       residue by number, or segment.residues[segment.residue.resnames = ...]</span>
<span class="sd">       to select by resname.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">me</span> <span class="o">=</span> <span class="s1">&#39;&lt;Segment&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;segid&#39;</span><span class="p">):</span>
            <span class="n">me</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">me</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_unpickle2</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">,</span> <span class="n">Segment</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An :class:`AtomGroup` of :class:`Atoms&lt;Atom&gt;` present in this</span>
<span class="sd">        :class:`Segment`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">self</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">ag</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ag</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ag</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ag</span>
        <span class="n">ag</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ag</span>
        <span class="k">return</span> <span class="n">ag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A :class:`ResidueGroup` of :class:`Residues&lt;Residue&gt;` present in this</span>
<span class="sd">        :class:`Segment`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">resindices</span><span class="p">[</span><span class="bp">self</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">rg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;isunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">rg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;issorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">rg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;sorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rg</span>
        <span class="n">rg</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;unsorted_unique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rg</span>
        <span class="k">return</span> <span class="n">rg</span></div>



<span class="c1"># Accessing these attrs doesn&#39;t trigger an update. The class and instance</span>
<span class="c1"># methods of UpdatingAtomGroup that are used during __init__ must all be</span>
<span class="c1"># here, otherwise we get __getattribute__ infinite loops.</span>
<span class="n">_UAG_SHORTCUT_ATTRS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># Class information of the UAG</span>
    <span class="s2">&quot;__class__&quot;</span><span class="p">,</span> <span class="s2">&quot;_derived_class&quot;</span><span class="p">,</span>
    <span class="c1"># Metadata of the UAG</span>
    <span class="s2">&quot;_base_group&quot;</span><span class="p">,</span> <span class="s2">&quot;_selections&quot;</span><span class="p">,</span> <span class="s2">&quot;_lastupdate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="s2">&quot;_u&quot;</span><span class="p">,</span> <span class="s2">&quot;universe&quot;</span><span class="p">,</span>
    <span class="c1"># Methods of the UAG</span>
    <span class="s2">&quot;_ensure_updated&quot;</span><span class="p">,</span>
    <span class="s2">&quot;is_uptodate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;update_selection&quot;</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="UpdatingAtomGroup">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.UpdatingAtomGroup">[docs]</a>
<span class="k">class</span> <span class="nc">UpdatingAtomGroup</span><span class="p">(</span><span class="n">AtomGroup</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;:class:`AtomGroup` subclass that dynamically updates its selected atoms.</span>

<span class="sd">    Accessing any attribute/method of an :class:`UpdatingAtomGroup` instance</span>
<span class="sd">    triggers a check for the last frame the group was updated. If the last</span>
<span class="sd">    frame matches the current trajectory frame, the attribute is returned</span>
<span class="sd">    normally; otherwise the group is updated (the stored selections are</span>
<span class="sd">    re-applied), and only then is the attribute returned.</span>


<span class="sd">    .. versionadded:: 0.16.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># WARNING: This class has __getattribute__ and __getattr__ methods (the</span>
    <span class="c1"># latter inherited from AtomGroup). Because of this bugs introduced in the</span>
    <span class="c1"># class that cause an AttributeError may be very hard to diagnose and</span>
    <span class="c1"># debug: the most obvious symptom is an infinite loop going through both</span>
    <span class="c1"># __getattribute__ and __getattr__, and a solution might be to add said</span>
    <span class="c1"># attribute to _UAG_SHORTCUT_ATTRS.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_group</span><span class="p">,</span> <span class="n">selections</span><span class="p">,</span> <span class="n">strings</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base_group : :class:`AtomGroup`</span>
<span class="sd">            group on which *selections* are to be applied.</span>
<span class="sd">        selections : a tuple of :class:`~MDAnalysis.core.selection.Selection`</span>
<span class="sd">            instances selections ready to be applied to *base_group*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Because we&#39;re implementing __getattribute__, which needs _u for</span>
        <span class="c1"># its check, no self.attribute access can be made before this line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">base_group</span><span class="o">.</span><span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selections</span> <span class="o">=</span> <span class="n">selections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selection_strings</span> <span class="o">=</span> <span class="n">strings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_group</span> <span class="o">=</span> <span class="n">base_group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lastupdate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_derived_class</span> <span class="o">=</span> <span class="n">base_group</span><span class="o">.</span><span class="n">_derived_class</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selections</span><span class="p">:</span>
            <span class="c1"># Allows the creation of a cheap placeholder UpdatingAtomGroup</span>
            <span class="c1"># by passing an empty selection tuple.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_updated</span><span class="p">()</span>

<div class="viewcode-block" id="UpdatingAtomGroup.update_selection">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.UpdatingAtomGroup.update_selection">[docs]</a>
    <span class="k">def</span> <span class="nf">update_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forces the reevaluation and application of the group&#39;s selection(s).</span>

<span class="sd">        This method is triggered automatically when accessing attributes, if</span>
<span class="sd">        the last update occurred under a different trajectory frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_group</span>
        <span class="n">sels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selections</span>
        <span class="k">if</span> <span class="n">sels</span><span class="p">:</span>
            <span class="c1"># As with select_atoms, we select the first sel and then sum to it.</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">sel</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">bg</span><span class="p">)</span> <span class="k">for</span> <span class="n">sel</span> <span class="ow">in</span> <span class="n">sels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]],</span>
                     <span class="n">sels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">bg</span><span class="p">))</span><span class="o">.</span><span class="n">ix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="c1"># Run back through AtomGroup init with this information to remake</span>
        <span class="c1"># ourselves</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UpdatingAtomGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_uptodate</span> <span class="o">=</span> <span class="kc">True</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_uptodate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the selection needs updating based on frame number only.</span>

<span class="sd">        Modifications to the coordinate data that render selections stale are</span>
<span class="sd">        not caught, and in those cases :attr:`is_uptodate` may return an</span>
<span class="sd">        erroneous value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the group&#39;s selection is up-to-date, ``False``</span>
<span class="sd">            otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">frame</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lastupdate</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># self.universe has no trajectory</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lastupdate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@is_uptodate</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">is_uptodate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lastupdate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">frame</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># self.universe has no trajectory</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lastupdate</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This always marks the selection as outdated</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lastupdate</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_ensure_updated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the selection needs updating and updates it if needed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the group was already up-to-date, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uptodate</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">status</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">status</span>

    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># ALL attribute access goes through here</span>
        <span class="c1"># If the requested attribute is public (not starting with &#39;_&#39;) and</span>
        <span class="c1"># isn&#39;t in the shortcut list, update ourselves</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_UAG_SHORTCUT_ATTRS</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_updated</span><span class="p">()</span>
        <span class="c1"># Going via object.__getattribute__ then bypasses this check stage</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># strategy for unpickling is:</span>
        <span class="c1"># - unpickle base group</span>
        <span class="c1"># - recreate UAG as created through select_atoms (basegroup and selstrs)</span>
        <span class="c1"># even if base_group is a UAG this will work through recursion</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_unpickle_uag</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_group</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selections</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_selection_strings</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">basestr</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">UpdatingAtomGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection_strings</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">basestr</span>
        <span class="n">sels</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;&#39; + &#39;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_selection_strings</span><span class="p">))</span>
        <span class="c1"># Cheap comparison. Might fail for corner cases but this is</span>
        <span class="c1"># mostly cosmetic.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_group</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">basegrp</span> <span class="o">=</span> <span class="s2">&quot;the entire Universe.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">basegrp</span> <span class="o">=</span> <span class="s2">&quot;another AtomGroup.&quot;</span>
        <span class="c1"># With a shorthand to conditionally append the &#39;s&#39; in &#39;selections&#39;.</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">, with selection</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> on </span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">basestr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;s&quot;</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_selection_strings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">sels</span><span class="p">,</span> <span class="n">basegrp</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a *static* :class:`AtomGroup` identical to the group of currently</span>
<span class="sd">        selected :class:`Atoms&lt;Atom&gt;` in the :class:`UpdatingAtomGroup`.</span>


<span class="sd">        By returning a *static* :class:`AtomGroup` it becomes possible to</span>
<span class="sd">        compare the contents of the group *between* trajectory frames. See the</span>
<span class="sd">        Example below.</span>


<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The :attr:`atoms` attribute of an :class:`UpdatingAtomGroup` behaves</span>
<span class="sd">        differently from :attr:`AtomGroup.atoms`: the latter returns the</span>
<span class="sd">        :class:`AtomGroup` itself whereas the former returns a</span>
<span class="sd">        :class:`AtomGroup` and not an :class:`UpdatingAtomGroup` (for this, use</span>
<span class="sd">        :meth:`UpdatingAtomGroup.copy`).</span>


<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        The static :attr:`atoms` allows comparison of groups of atoms between</span>
<span class="sd">        frames. For example, track water molecules that move in and out of a</span>
<span class="sd">        solvation shell of a protein</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            u = mda.Universe(TPR, XTC)</span>
<span class="sd">            water_shell = u.select_atoms(&quot;name OW and around 3.5 protein&quot;,</span>
<span class="sd">                                         updating=True)</span>
<span class="sd">            water_shell_prev = water_shell.atoms</span>

<span class="sd">            for ts in u.trajectory:</span>
<span class="sd">                exchanged = water_shell - water_shell_prev</span>

<span class="sd">            print(ts.time, &quot;waters in shell =&quot;, water_shell.n_residues)</span>
<span class="sd">            print(ts.time, &quot;waters that exchanged = &quot;, exchanged.n_residues)</span>
<span class="sd">            print(ts.time, &quot;waters that remained bound = &quot;,</span>
<span class="sd">                  water_shell.n_residues - exchanged.n_residues)</span>

<span class="sd">            water_shell_prev = water_shell.atoms</span>

<span class="sd">        By remembering the atoms of the current time step in</span>
<span class="sd">        `water_shell_prev`, it becomes possible to use the :meth:`subtraction</span>
<span class="sd">        of AtomGroups&lt;AtomGroup.subtract&gt;` to find the water molecules that</span>
<span class="sd">        changed.</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        copy : return a true copy of the :class:`UpdatingAtomGroup`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[:]</span>

<div class="viewcode-block" id="UpdatingAtomGroup.copy">
<a class="viewcode-back" href="../../../documentation_pages/core/groups.html#MDAnalysis.core.groups.UpdatingAtomGroup.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get another :class:`UpdatingAtomGroup` identical to this one.</span>


<span class="sd">        .. versionadded:: 0.19.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">UpdatingAtomGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selections</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_selection_strings</span><span class="p">)</span></div>
</div>



<span class="c1"># Define relationships between these classes</span>
<span class="c1"># with Level objects</span>
<span class="n">_Level</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Level&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;singular&#39;</span><span class="p">,</span> <span class="s1">&#39;plural&#39;</span><span class="p">])</span>
<span class="n">ATOMLEVEL</span> <span class="o">=</span> <span class="n">_Level</span><span class="p">(</span><span class="s1">&#39;atom&#39;</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)</span>
<span class="n">RESIDUELEVEL</span> <span class="o">=</span> <span class="n">_Level</span><span class="p">(</span><span class="s1">&#39;residue&#39;</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">)</span>
<span class="n">SEGMENTLEVEL</span> <span class="o">=</span> <span class="n">_Level</span><span class="p">(</span><span class="s1">&#39;segment&#39;</span><span class="p">,</span> <span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)</span>

<span class="n">Atom</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">ATOMLEVEL</span>
<span class="n">AtomGroup</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">ATOMLEVEL</span>
<span class="n">Residue</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">RESIDUELEVEL</span>
<span class="n">ResidueGroup</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">RESIDUELEVEL</span>
<span class="n">Segment</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">SEGMENTLEVEL</span>
<span class="n">SegmentGroup</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">SEGMENTLEVEL</span>


<span class="k">def</span> <span class="nf">requires</span><span class="p">(</span><span class="o">*</span><span class="n">attrs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to check if all :class:`AtomGroup` arguments have certain</span>
<span class="sd">    attributes</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    When used to wrap a function, will check all :class:`AtomGroup` arguments</span>
<span class="sd">    for the listed requirements</span>

<span class="sd">    @requires(&#39;masses&#39;, &#39;charges&#39;)</span>
<span class="sd">    def mass_times_charge(atomgroup):</span>
<span class="sd">        return atomgroup.masses * atomgroup.charges</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">require_dec</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">check_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>  <span class="c1"># for each argument</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">):</span>
                    <span class="c1"># Make list of missing attributes</span>
                    <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span>
                               <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">attr</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{funcname}</span><span class="s2"> failed. &quot;</span>
                            <span class="s2">&quot;AtomGroup is missing the following required &quot;</span>
                            <span class="s2">&quot;attributes: </span><span class="si">{attrs}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">funcname</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                <span class="n">attrs</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">check_args</span>
    <span class="k">return</span> <span class="n">require_dec</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2024, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Henok Ademtew, Shobhit Agarwal, Aya M. Alaa, Irfan Alibay, Kazi Shudipto Amin, Anshul Angaria, Luís Pedro Borges Araújo, Balasubramanian, Utkarsh Bansal, Patricio Barletta, Leonardo Barneschi, Jonathan Barnoud, Estefania Barreto-Ojeda, Tone Bengtsen, Alejandro Bernardin, Ninad Bhat, Mateusz Bieniek, Kavya Bisht, Wouter Boomsma, Jose Borreguero, Cédric Bouysset, Kevin Boyd, Meet Brijwani, Bart Bruininks, Sébastien Buchoux, Sören von Bülow, Yantong Cai, David Caplan, Yuanyu Chang, Pratham Chauhan, Matthieu Chavent, Haochuan Chen, Xu Hong Chen, Kathleen Clark, Jennifer A Clark, Orion Cohen, Charlie Cook, Ruggero Cortini, Nicholas Craven, Ramon Crehuet, Davide Cruz, Robert Delgado, John Detlefs, Xavier Deupi, Bradley Dice, Jan Domanski, David L. Dotson, Mark D. Driver, Ali Ehlen, Daniel J. Evans, Shujie Fan, Bjarne Feddersen, Lennard van der Feltz, Jake Fennick, Philip Fowler, Guillaume Fraux, Anirvinya G, Michael Gecht, Ahmed Salah Ghoneim, Mikhail Glagolev, William Glass, Jenna M. Swarthout Goddard, Joseph Goose, Alexander Gorfer, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Pratik Gupta, Sumit Gupta, Benjamin Hall, Ameya Harmalkar, Ivan Hristov, Eugen Hruska, Kyle J. Huston, Siddharth Jain, Edis Jakupovic, Joe Jordan, Henrik Jäger, Uma D Kadam, Aditya Kamath, Jon Kapla, Ian M. Kenney, Aditya Keshari, Haleema Khan, Navya Khare, Utsav Khatu, Andrew William King, Henry Kobin, Abhishek A. Kognole, Kosuke Kudo, Atharva Kulkarni, Manish Kumar, Mohit Kumar, Shubham Kumar, Alia Lescoulie, Zhenbo Li, Max Linke, Philip Loche, Jinju Lu, Hugo MacDermott-Opeskin, Shaivi Malik, Egor Marin, Domenico Marson, Micaela Matta, Andrew R. McCluskey, Robert McGibbon, Kurt McKee, Rocco Meli, Manuel Nuno Melo, Marcelo C. R. Melo, Dominik &#39;Rathann&#39; Mierzejewski, David Minh, Geongi Moon, Sampurna Mukherjee, Henry Mull, Morgan L. Nance, Fiona B. Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Meghan Osato, Daniele Padula, Nabarun Pal, Mattia F. Palermo, Dimitrios Papageorgiou, Rafael R. Pappalardo, Vishal Parmar, Danny Parton, Shakul Pathak, Christian Pfaendner, Joshua L. Phillips, Marcelo D. Poleto, Hannah Pollak, Kashish Punjani, Michael Quevillon, Vedant Rathore, Tyler Reddy, Pedro Reis, Paul Rigor, Andrea Rizzi, Xiaoxu Ruan, Carlos Yanez S., Utkarsh Saxena, Moritz Schaeffler, Alexander Schlaich, Marcello Sega, Ricky Sexton, Sean L. Seyler, Faraaz Shah, Sulay Shah, Abhishek Shandilya, Shubham Sharma, Rishabh Shukla, Karthikeyan Singaravelan, Tamandeep Singh, Brigitta Sipőcz, Paul Smith, Andy Somogyi, Caio S. Souza, Kai Niklas Spauszus, David van der Spoel, Shantanu Srivastava, Lukas Stelzl, Jan Stevens, Gorman Stock, Philipp Stärk, Johannes Stöckelmaier, Fenil Suchak, Ayush Suhane, Filip T. Szczypiński, Sukeerti T, Matthijs Tadema, Valerij Talagayev, Joao Miguel Correia Teixeira, Paarth Thadani, Matthew W. Thompson, Hao Tian, Matteo Tiberti, Zaheer Timol, Wiep van der Toorn, Mieczyslaw Torchala, Aditi Tripathi, Heet Vekariya, Mark Verma, Josh Vermaas, Isaac Virshup, Lily Wang, Leon Wehrhan, Nestor Wendt, Lawson Woods, Zhiyi Wu, Tengyu Xie, Zhuyi Xue, Mingyi Xue, Alexander Yang, Juan Eiros Zamora, Johannes Zeman, Yibo Zhang, Raymond Zhao, Yuxuan Zhuang, and Oliver Beckstein.</p>
  </div>

  

<div class="footer"><p>Please see
    our <a href="https://www.mdanalysis.org/pages/privacy/">Privacy Policy</a>
    to learn how <a href="https://www.mdanalysis.org">MDAnalysis</a> collects data.</p>
    <script data-goatcounter="https://mdanalysis.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</div>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
    var versions_json_url = 'https://docs.mdanalysis.org/versions.json'
</script>

<div class="rst-versions" data-toggle="rst-versions" role="note"
     aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
        2.8.0-dev0
      <span class="fa fa-caret-down"></span>
    </span>

    <div class="rst-other-versions">
        <dl id="versionselector">
            <dt>Other Versions</dt>
        </dl>

    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>